{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Let us consider two process P, Q running in parallel. P =\n    loop { x=c; x=x+c; c=x;} and Q = loop { y=c; y=y+c; c=y;}. Initial value\n    of c is 1. The claim is that c can possibly contain any natural value. With\n    model checker we cannot prove this, but for any value, we can try to find\n    it.\n\nParameters:\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "int c=1;\nint x1=0;\nint x2=0;\n\n\nactive proctype a1() { \n\nQ: if\n::  d_step {c<20;x1 = c;}  goto R; \n\nfi;\nR: if\n:: x1 = x1+c; goto S; \n\nfi;\nS: if\n:: c = x1; goto Q; \n\nfi;\n}\n\nactive proctype a2() { \n\nQ: if\n::  d_step {c<20;x2 = c;}  goto R; \n\nfi;\nR: if\n:: x2 = x2+c; goto S; \n\nfi;\nS: if\n:: c = x2; goto Q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Let us consider two process P, Q running in parallel. P =\n    loop { x=c; x=x+c; c=x;} and Q = loop { y=c; y=y+c; c=y;}. Initial value\n    of c is 1. The claim is that c can possibly contain any natural value. With\n    model checker we cannot prove this, but for any value, we can try to find\n    it.\n\nParameters:\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "int c=1;\nint x1=0;\nint x2=0;\n\n\nactive proctype a1() { \n\nQ: if\n::  d_step {c<200;x1 = c;}  goto R; \n\nfi;\nR: if\n:: x1 = x1+c; goto S; \n\nfi;\nS: if\n:: c = x1; goto Q; \n\nfi;\n}\n\nactive proctype a2() { \n\nQ: if\n::  d_step {c<200;x2 = c;}  goto R; \n\nfi;\nR: if\n:: x2 = x2+c; goto S; \n\nfi;\nS: if\n:: c = x2; goto Q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Let us consider two process P, Q running in parallel. P =\n    loop { x=c; x=x+c; c=x;} and Q = loop { y=c; y=y+c; c=y;}. Initial value\n    of c is 1. The claim is that c can possibly contain any natural value. With\n    model checker we cannot prove this, but for any value, we can try to find\n    it.\n\nParameters:\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "int c=1;\nint x1=0;\nint x2=0;\n\n\nactive proctype a1() { \n\nQ: if\n::  d_step {c<300;x1 = c;}  goto R; \n\nfi;\nR: if\n:: x1 = x1+c; goto S; \n\nfi;\nS: if\n:: c = x1; goto Q; \n\nfi;\n}\n\nactive proctype a2() { \n\nQ: if\n::  d_step {c<300;x2 = c;}  goto R; \n\nfi;\nR: if\n:: x2 = x2+c; goto S; \n\nfi;\nS: if\n:: c = x2; goto Q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Let us consider two process P, Q running in parallel. P =\n    loop { x=c; x=x+c; c=x;} and Q = loop { y=c; y=y+c; c=y;}. Initial value\n    of c is 1. The claim is that c can possibly contain any natural value. With\n    model checker we cannot prove this, but for any value, we can try to find\n    it.\n\nParameters:\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "int c=1;\nint x1=0;\nint x2=0;\n\n\nactive proctype a1() { \n\nQ: if\n::  d_step {c<400;x1 = c;}  goto R; \n\nfi;\nR: if\n:: x1 = x1+c; goto S; \n\nfi;\nS: if\n:: c = x1; goto Q; \n\nfi;\n}\n\nactive proctype a2() { \n\nQ: if\n::  d_step {c<400;x2 = c;}  goto R; \n\nfi;\nR: if\n:: x2 = x2+c; goto S; \n\nfi;\nS: if\n:: c = x2; goto Q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Let us consider two process P, Q running in parallel. P =\n    loop { x=c; x=x+c; c=x;} and Q = loop { y=c; y=y+c; c=y;}. Initial value\n    of c is 1. The claim is that c can possibly contain any natural value. With\n    model checker we cannot prove this, but for any value, we can try to find\n    it.\n\nParameters:\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "int c=1;\nint x1=0;\nint x2=0;\n\n\nactive proctype a1() { \n\nQ: if\n::  d_step {c<500;x1 = c;}  goto R; \n\nfi;\nR: if\n:: x1 = x1+c; goto S; \n\nfi;\nS: if\n:: c = x1; goto Q; \n\nfi;\n}\n\nactive proctype a2() { \n\nQ: if\n::  d_step {c<500;x2 = c;}  goto R; \n\nfi;\nR: if\n:: x2 = x2+c; goto S; \n\nfi;\nS: if\n:: c = x2; goto Q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Let us consider two process P, Q running in parallel. P =\n    loop { x=c; x=x+c; c=x;} and Q = loop { y=c; y=y+c; c=y;}. Initial value\n    of c is 1. The claim is that c can possibly contain any natural value. With\n    model checker we cannot prove this, but for any value, we can try to find\n    it.\n\nParameters:\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "int c=1;\nint x1=0;\nint x2=0;\n\n\nactive proctype a1() { \n\nQ: if\n::  d_step {c<600;x1 = c;}  goto R; \n\nfi;\nR: if\n:: x1 = x1+c; goto S; \n\nfi;\nS: if\n:: c = x1; goto Q; \n\nfi;\n}\n\nactive proctype a2() { \n\nQ: if\n::  d_step {c<600;x2 = c;}  goto R; \n\nfi;\nR: if\n:: x2 = x2+c; goto S; \n\nfi;\nS: if\n:: c = x2; goto Q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually.\n\nSee also other mutex examples.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte Slot[2];\nbyte next=0;\n\n\ninit { \n d_step { \nSlot[0] =1; Slot[1] =0; }\natomic { \nrun P_0();\nrun P_1();\n} }\n\nproctype P_0() { \nbyte my_place=0;\n\nNCS: if\n::  d_step {my_place = next;next = next+1;}  goto p1; \n\nfi;\np1: if\n::  d_step {my_place==2-1;next = next-2;}  goto p2; \n\n::  d_step {my_place!=2-1;my_place = my_place%2;}  goto p2; \n\nfi;\np2: if\n:: Slot[my_place]==1; goto p3; \n\nfi;\np3: if\n:: Slot[(my_place+2-1)%2] = 0; goto CS; \n\nfi;\nCS: if\n:: Slot[(my_place+1)%2] = 1; goto NCS; \n\nfi;\n}\n\nproctype P_1() { \nbyte my_place=0;\n\nNCS: if\n::  d_step {my_place = next;next = next+1;}  goto p1; \n\nfi;\np1: if\n::  d_step {my_place==2-1;next = next-2;}  goto p2; \n\n::  d_step {my_place!=2-1;my_place = my_place%2;}  goto p2; \n\nfi;\np2: if\n:: Slot[my_place]==1; goto p3; \n\nfi;\np3: if\n:: Slot[(my_place+2-1)%2] = 0; goto CS; \n\nfi;\nCS: if\n:: Slot[(my_place+1)%2] = 1; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually.\n\nSee also other mutex examples.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte Slot[3];\nbyte next=0;\n\n\ninit { \n d_step { \nSlot[0] =1; Slot[1] =0; Slot[2] =0; }\natomic { \nrun P_0();\nrun P_1();\nrun P_2();\n} }\n\nproctype P_0() { \nbyte my_place=0;\n\nNCS: if\n::  d_step {my_place = next;next = next+1;}  goto p1; \n\nfi;\np1: if\n::  d_step {my_place==3-1;next = next-3;}  goto p2; \n\n::  d_step {my_place!=3-1;my_place = my_place%3;}  goto p2; \n\nfi;\np2: if\n:: Slot[my_place]==1; goto p3; \n\nfi;\np3: if\n:: Slot[my_place] = 0; goto CS; \n\nfi;\nCS: if\n:: Slot[(my_place+1)%3] = 1; goto NCS; \n\nfi;\n}\n\nproctype P_1() { \nbyte my_place=0;\n\nNCS: if\n::  d_step {my_place = next;next = next+1;}  goto p1; \n\nfi;\np1: if\n::  d_step {my_place==3-1;next = next-3;}  goto p2; \n\n::  d_step {my_place!=3-1;my_place = my_place%3;}  goto p2; \n\nfi;\np2: if\n:: Slot[my_place]==1; goto p3; \n\nfi;\np3: if\n:: Slot[my_place] = 0; goto CS; \n\nfi;\nCS: if\n:: Slot[(my_place+1)%3] = 1; goto NCS; \n\nfi;\n}\n\nproctype P_2() { \nbyte my_place=0;\n\nNCS: if\n::  d_step {my_place = next;next = next+1;}  goto p1; \n\nfi;\np1: if\n::  d_step {my_place==3-1;next = next-3;}  goto p2; \n\n::  d_step {my_place!=3-1;my_place = my_place%3;}  goto p2; \n\nfi;\np2: if\n:: Slot[my_place]==1; goto p3; \n\nfi;\np3: if\n:: Slot[my_place] = 0; goto CS; \n\nfi;\nCS: if\n:: Slot[(my_place+1)%3] = 1; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually.\n\nSee also other mutex examples.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte Slot[3];\nbyte next=0;\n\n\ninit { \n d_step { \nSlot[0] =1; Slot[1] =0; Slot[2] =0; }\natomic { \nrun P_0();\nrun P_1();\nrun P_2();\n} }\n\nproctype P_0() { \nbyte my_place=0;\n\nNCS: if\n::  d_step {my_place = next;next = next+1;}  goto p1; \n\nfi;\np1: if\n::  d_step {my_place==3-1;next = next-3;}  goto p2; \n\n::  d_step {my_place!=3-1;my_place = my_place%3;}  goto p2; \n\nfi;\np2: if\n:: Slot[my_place]==1; goto p3; \n\nfi;\np3: if\n:: Slot[(my_place+3-1)%3] = 0; goto CS; \n\nfi;\nCS: if\n:: Slot[(my_place+1)%3] = 1; goto NCS; \n\nfi;\n}\n\nproctype P_1() { \nbyte my_place=0;\n\nNCS: if\n::  d_step {my_place = next;next = next+1;}  goto p1; \n\nfi;\np1: if\n::  d_step {my_place==3-1;next = next-3;}  goto p2; \n\n::  d_step {my_place!=3-1;my_place = my_place%3;}  goto p2; \n\nfi;\np2: if\n:: Slot[my_place]==1; goto p3; \n\nfi;\np3: if\n:: Slot[(my_place+3-1)%3] = 0; goto CS; \n\nfi;\nCS: if\n:: Slot[(my_place+1)%3] = 1; goto NCS; \n\nfi;\n}\n\nproctype P_2() { \nbyte my_place=0;\n\nNCS: if\n::  d_step {my_place = next;next = next+1;}  goto p1; \n\nfi;\np1: if\n::  d_step {my_place==3-1;next = next-3;}  goto p2; \n\n::  d_step {my_place!=3-1;my_place = my_place%3;}  goto p2; \n\nfi;\np2: if\n:: Slot[my_place]==1; goto p3; \n\nfi;\np3: if\n:: Slot[(my_place+3-1)%3] = 0; goto CS; \n\nfi;\nCS: if\n:: Slot[(my_place+1)%3] = 1; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually.\n\nSee also other mutex examples.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte Slot[4];\nbyte next=0;\n\n\ninit { \n d_step { \nSlot[0] =1; Slot[1] =0; Slot[2] =0; Slot[3] =0; }\natomic { \nrun P_0();\nrun P_1();\nrun P_2();\nrun P_3();\n} }\n\nproctype P_0() { \nbyte my_place=0;\n\nNCS: if\n::  d_step {my_place = next;next = next+1;}  goto p1; \n\nfi;\np1: if\n::  d_step {my_place==4-1;next = next-4;}  goto p2; \n\n::  d_step {my_place!=4-1;my_place = my_place%4;}  goto p2; \n\nfi;\np2: if\n:: Slot[my_place]==1; goto p3; \n\nfi;\np3: if\n:: Slot[my_place] = 0; goto CS; \n\nfi;\nCS: if\n:: Slot[(my_place+1)%4] = 1; goto NCS; \n\nfi;\n}\n\nproctype P_1() { \nbyte my_place=0;\n\nNCS: if\n::  d_step {my_place = next;next = next+1;}  goto p1; \n\nfi;\np1: if\n::  d_step {my_place==4-1;next = next-4;}  goto p2; \n\n::  d_step {my_place!=4-1;my_place = my_place%4;}  goto p2; \n\nfi;\np2: if\n:: Slot[my_place]==1; goto p3; \n\nfi;\np3: if\n:: Slot[my_place] = 0; goto CS; \n\nfi;\nCS: if\n:: Slot[(my_place+1)%4] = 1; goto NCS; \n\nfi;\n}\n\nproctype P_2() { \nbyte my_place=0;\n\nNCS: if\n::  d_step {my_place = next;next = next+1;}  goto p1; \n\nfi;\np1: if\n::  d_step {my_place==4-1;next = next-4;}  goto p2; \n\n::  d_step {my_place!=4-1;my_place = my_place%4;}  goto p2; \n\nfi;\np2: if\n:: Slot[my_place]==1; goto p3; \n\nfi;\np3: if\n:: Slot[my_place] = 0; goto CS; \n\nfi;\nCS: if\n:: Slot[(my_place+1)%4] = 1; goto NCS; \n\nfi;\n}\n\nproctype P_3() { \nbyte my_place=0;\n\nNCS: if\n::  d_step {my_place = next;next = next+1;}  goto p1; \n\nfi;\np1: if\n::  d_step {my_place==4-1;next = next-4;}  goto p2; \n\n::  d_step {my_place!=4-1;my_place = my_place%4;}  goto p2; \n\nfi;\np2: if\n:: Slot[my_place]==1; goto p3; \n\nfi;\np3: if\n:: Slot[my_place] = 0; goto CS; \n\nfi;\nCS: if\n:: Slot[(my_place+1)%4] = 1; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually.\n\nSee also other mutex examples.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte Slot[5];\nbyte next=0;\n\n\ninit { \n d_step { \nSlot[0] =1; Slot[1] =0; Slot[2] =0; Slot[3] =0; Slot[4] =0; }\natomic { \nrun P_0();\nrun P_1();\nrun P_2();\nrun P_3();\nrun P_4();\n} }\n\nproctype P_0() { \nbyte my_place=0;\n\nNCS: if\n::  d_step {my_place = next;next = next+1;}  goto p1; \n\nfi;\np1: if\n::  d_step {my_place==5-1;next = next-5;}  goto p2; \n\n::  d_step {my_place!=5-1;my_place = my_place%5;}  goto p2; \n\nfi;\np2: if\n:: Slot[my_place]==1; goto p3; \n\nfi;\np3: if\n:: Slot[(my_place+5-1)%5] = 0; goto CS; \n\nfi;\nCS: if\n:: Slot[(my_place+1)%5] = 1; goto NCS; \n\nfi;\n}\n\nproctype P_1() { \nbyte my_place=0;\n\nNCS: if\n::  d_step {my_place = next;next = next+1;}  goto p1; \n\nfi;\np1: if\n::  d_step {my_place==5-1;next = next-5;}  goto p2; \n\n::  d_step {my_place!=5-1;my_place = my_place%5;}  goto p2; \n\nfi;\np2: if\n:: Slot[my_place]==1; goto p3; \n\nfi;\np3: if\n:: Slot[(my_place+5-1)%5] = 0; goto CS; \n\nfi;\nCS: if\n:: Slot[(my_place+1)%5] = 1; goto NCS; \n\nfi;\n}\n\nproctype P_2() { \nbyte my_place=0;\n\nNCS: if\n::  d_step {my_place = next;next = next+1;}  goto p1; \n\nfi;\np1: if\n::  d_step {my_place==5-1;next = next-5;}  goto p2; \n\n::  d_step {my_place!=5-1;my_place = my_place%5;}  goto p2; \n\nfi;\np2: if\n:: Slot[my_place]==1; goto p3; \n\nfi;\np3: if\n:: Slot[(my_place+5-1)%5] = 0; goto CS; \n\nfi;\nCS: if\n:: Slot[(my_place+1)%5] = 1; goto NCS; \n\nfi;\n}\n\nproctype P_3() { \nbyte my_place=0;\n\nNCS: if\n::  d_step {my_place = next;next = next+1;}  goto p1; \n\nfi;\np1: if\n::  d_step {my_place==5-1;next = next-5;}  goto p2; \n\n::  d_step {my_place!=5-1;my_place = my_place%5;}  goto p2; \n\nfi;\np2: if\n:: Slot[my_place]==1; goto p3; \n\nfi;\np3: if\n:: Slot[(my_place+5-1)%5] = 0; goto CS; \n\nfi;\nCS: if\n:: Slot[(my_place+1)%5] = 1; goto NCS; \n\nfi;\n}\n\nproctype P_4() { \nbyte my_place=0;\n\nNCS: if\n::  d_step {my_place = next;next = next+1;}  goto p1; \n\nfi;\np1: if\n::  d_step {my_place==5-1;next = next-5;}  goto p2; \n\n::  d_step {my_place!=5-1;my_place = my_place%5;}  goto p2; \n\nfi;\np2: if\n:: Slot[my_place]==1; goto p3; \n\nfi;\np3: if\n:: Slot[(my_place+5-1)%5] = 0; goto CS; \n\nfi;\nCS: if\n:: Slot[(my_place+1)%5] = 1; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually.\n\nSee also other mutex examples.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte Slot[6];\nbyte next=0;\n\n\ninit { \n d_step { \nSlot[0] =1; Slot[1] =0; Slot[2] =0; Slot[3] =0; Slot[4] =0; Slot[5] =0; }\natomic { \nrun P_0();\nrun P_1();\nrun P_2();\nrun P_3();\nrun P_4();\nrun P_5();\n} }\n\nproctype P_0() { \nbyte my_place=0;\n\nNCS: if\n::  d_step {my_place = next;next = next+1;}  goto p1; \n\nfi;\np1: if\n::  d_step {my_place==6-1;next = next-6;}  goto p2; \n\n::  d_step {my_place!=6-1;my_place = my_place%6;}  goto p2; \n\nfi;\np2: if\n:: Slot[my_place]==1; goto p3; \n\nfi;\np3: if\n:: Slot[my_place] = 0; goto CS; \n\nfi;\nCS: if\n:: Slot[(my_place+1)%6] = 1; goto NCS; \n\nfi;\n}\n\nproctype P_1() { \nbyte my_place=0;\n\nNCS: if\n::  d_step {my_place = next;next = next+1;}  goto p1; \n\nfi;\np1: if\n::  d_step {my_place==6-1;next = next-6;}  goto p2; \n\n::  d_step {my_place!=6-1;my_place = my_place%6;}  goto p2; \n\nfi;\np2: if\n:: Slot[my_place]==1; goto p3; \n\nfi;\np3: if\n:: Slot[my_place] = 0; goto CS; \n\nfi;\nCS: if\n:: Slot[(my_place+1)%6] = 1; goto NCS; \n\nfi;\n}\n\nproctype P_2() { \nbyte my_place=0;\n\nNCS: if\n::  d_step {my_place = next;next = next+1;}  goto p1; \n\nfi;\np1: if\n::  d_step {my_place==6-1;next = next-6;}  goto p2; \n\n::  d_step {my_place!=6-1;my_place = my_place%6;}  goto p2; \n\nfi;\np2: if\n:: Slot[my_place]==1; goto p3; \n\nfi;\np3: if\n:: Slot[my_place] = 0; goto CS; \n\nfi;\nCS: if\n:: Slot[(my_place+1)%6] = 1; goto NCS; \n\nfi;\n}\n\nproctype P_3() { \nbyte my_place=0;\n\nNCS: if\n::  d_step {my_place = next;next = next+1;}  goto p1; \n\nfi;\np1: if\n::  d_step {my_place==6-1;next = next-6;}  goto p2; \n\n::  d_step {my_place!=6-1;my_place = my_place%6;}  goto p2; \n\nfi;\np2: if\n:: Slot[my_place]==1; goto p3; \n\nfi;\np3: if\n:: Slot[my_place] = 0; goto CS; \n\nfi;\nCS: if\n:: Slot[(my_place+1)%6] = 1; goto NCS; \n\nfi;\n}\n\nproctype P_4() { \nbyte my_place=0;\n\nNCS: if\n::  d_step {my_place = next;next = next+1;}  goto p1; \n\nfi;\np1: if\n::  d_step {my_place==6-1;next = next-6;}  goto p2; \n\n::  d_step {my_place!=6-1;my_place = my_place%6;}  goto p2; \n\nfi;\np2: if\n:: Slot[my_place]==1; goto p3; \n\nfi;\np3: if\n:: Slot[my_place] = 0; goto CS; \n\nfi;\nCS: if\n:: Slot[(my_place+1)%6] = 1; goto NCS; \n\nfi;\n}\n\nproctype P_5() { \nbyte my_place=0;\n\nNCS: if\n::  d_step {my_place = next;next = next+1;}  goto p1; \n\nfi;\np1: if\n::  d_step {my_place==6-1;next = next-6;}  goto p2; \n\n::  d_step {my_place!=6-1;my_place = my_place%6;}  goto p2; \n\nfi;\np2: if\n:: Slot[my_place]==1; goto p3; \n\nfi;\np3: if\n:: Slot[my_place] = 0; goto CS; \n\nfi;\nCS: if\n:: Slot[(my_place+1)%6] = 1; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually.\n\nSee also other mutex examples.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte Slot[6];\nbyte next=0;\n\n\ninit { \n d_step { \nSlot[0] =1; Slot[1] =0; Slot[2] =0; Slot[3] =0; Slot[4] =0; Slot[5] =0; }\natomic { \nrun P_0();\nrun P_1();\nrun P_2();\nrun P_3();\nrun P_4();\nrun P_5();\n} }\n\nproctype P_0() { \nbyte my_place=0;\n\nNCS: if\n::  d_step {my_place = next;next = next+1;}  goto p1; \n\nfi;\np1: if\n::  d_step {my_place==6-1;next = next-6;}  goto p2; \n\n::  d_step {my_place!=6-1;my_place = my_place%6;}  goto p2; \n\nfi;\np2: if\n:: Slot[my_place]==1; goto p3; \n\nfi;\np3: if\n:: Slot[(my_place+6-1)%6] = 0; goto CS; \n\nfi;\nCS: if\n:: Slot[(my_place+1)%6] = 1; goto NCS; \n\nfi;\n}\n\nproctype P_1() { \nbyte my_place=0;\n\nNCS: if\n::  d_step {my_place = next;next = next+1;}  goto p1; \n\nfi;\np1: if\n::  d_step {my_place==6-1;next = next-6;}  goto p2; \n\n::  d_step {my_place!=6-1;my_place = my_place%6;}  goto p2; \n\nfi;\np2: if\n:: Slot[my_place]==1; goto p3; \n\nfi;\np3: if\n:: Slot[(my_place+6-1)%6] = 0; goto CS; \n\nfi;\nCS: if\n:: Slot[(my_place+1)%6] = 1; goto NCS; \n\nfi;\n}\n\nproctype P_2() { \nbyte my_place=0;\n\nNCS: if\n::  d_step {my_place = next;next = next+1;}  goto p1; \n\nfi;\np1: if\n::  d_step {my_place==6-1;next = next-6;}  goto p2; \n\n::  d_step {my_place!=6-1;my_place = my_place%6;}  goto p2; \n\nfi;\np2: if\n:: Slot[my_place]==1; goto p3; \n\nfi;\np3: if\n:: Slot[(my_place+6-1)%6] = 0; goto CS; \n\nfi;\nCS: if\n:: Slot[(my_place+1)%6] = 1; goto NCS; \n\nfi;\n}\n\nproctype P_3() { \nbyte my_place=0;\n\nNCS: if\n::  d_step {my_place = next;next = next+1;}  goto p1; \n\nfi;\np1: if\n::  d_step {my_place==6-1;next = next-6;}  goto p2; \n\n::  d_step {my_place!=6-1;my_place = my_place%6;}  goto p2; \n\nfi;\np2: if\n:: Slot[my_place]==1; goto p3; \n\nfi;\np3: if\n:: Slot[(my_place+6-1)%6] = 0; goto CS; \n\nfi;\nCS: if\n:: Slot[(my_place+1)%6] = 1; goto NCS; \n\nfi;\n}\n\nproctype P_4() { \nbyte my_place=0;\n\nNCS: if\n::  d_step {my_place = next;next = next+1;}  goto p1; \n\nfi;\np1: if\n::  d_step {my_place==6-1;next = next-6;}  goto p2; \n\n::  d_step {my_place!=6-1;my_place = my_place%6;}  goto p2; \n\nfi;\np2: if\n:: Slot[my_place]==1; goto p3; \n\nfi;\np3: if\n:: Slot[(my_place+6-1)%6] = 0; goto CS; \n\nfi;\nCS: if\n:: Slot[(my_place+1)%6] = 1; goto NCS; \n\nfi;\n}\n\nproctype P_5() { \nbyte my_place=0;\n\nNCS: if\n::  d_step {my_place = next;next = next+1;}  goto p1; \n\nfi;\np1: if\n::  d_step {my_place==6-1;next = next-6;}  goto p2; \n\n::  d_step {my_place!=6-1;my_place = my_place%6;}  goto p2; \n\nfi;\np2: if\n:: Slot[my_place]==1; goto p3; \n\nfi;\np3: if\n:: Slot[(my_place+6-1)%6] = 0; goto CS; \n\nfi;\nCS: if\n:: Slot[(my_place+1)%6] = 1; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually.\n\nSee also other mutex examples.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte Slot[7];\nbyte next=0;\n\n\ninit { \n d_step { \nSlot[0] =1; Slot[1] =0; Slot[2] =0; Slot[3] =0; Slot[4] =0; Slot[5] =0; Slot[6] =0; }\natomic { \nrun P_0();\nrun P_1();\nrun P_2();\nrun P_3();\nrun P_4();\nrun P_5();\nrun P_6();\n} }\n\nproctype P_0() { \nbyte my_place=0;\n\nNCS: if\n::  d_step {my_place = next;next = next+1;}  goto p1; \n\nfi;\np1: if\n::  d_step {my_place==7-1;next = next-7;}  goto p2; \n\n::  d_step {my_place!=7-1;my_place = my_place%7;}  goto p2; \n\nfi;\np2: if\n:: Slot[my_place]==1; goto p3; \n\nfi;\np3: if\n:: Slot[my_place] = 0; goto CS; \n\nfi;\nCS: if\n:: Slot[(my_place+1)%7] = 1; goto NCS; \n\nfi;\n}\n\nproctype P_1() { \nbyte my_place=0;\n\nNCS: if\n::  d_step {my_place = next;next = next+1;}  goto p1; \n\nfi;\np1: if\n::  d_step {my_place==7-1;next = next-7;}  goto p2; \n\n::  d_step {my_place!=7-1;my_place = my_place%7;}  goto p2; \n\nfi;\np2: if\n:: Slot[my_place]==1; goto p3; \n\nfi;\np3: if\n:: Slot[my_place] = 0; goto CS; \n\nfi;\nCS: if\n:: Slot[(my_place+1)%7] = 1; goto NCS; \n\nfi;\n}\n\nproctype P_2() { \nbyte my_place=0;\n\nNCS: if\n::  d_step {my_place = next;next = next+1;}  goto p1; \n\nfi;\np1: if\n::  d_step {my_place==7-1;next = next-7;}  goto p2; \n\n::  d_step {my_place!=7-1;my_place = my_place%7;}  goto p2; \n\nfi;\np2: if\n:: Slot[my_place]==1; goto p3; \n\nfi;\np3: if\n:: Slot[my_place] = 0; goto CS; \n\nfi;\nCS: if\n:: Slot[(my_place+1)%7] = 1; goto NCS; \n\nfi;\n}\n\nproctype P_3() { \nbyte my_place=0;\n\nNCS: if\n::  d_step {my_place = next;next = next+1;}  goto p1; \n\nfi;\np1: if\n::  d_step {my_place==7-1;next = next-7;}  goto p2; \n\n::  d_step {my_place!=7-1;my_place = my_place%7;}  goto p2; \n\nfi;\np2: if\n:: Slot[my_place]==1; goto p3; \n\nfi;\np3: if\n:: Slot[my_place] = 0; goto CS; \n\nfi;\nCS: if\n:: Slot[(my_place+1)%7] = 1; goto NCS; \n\nfi;\n}\n\nproctype P_4() { \nbyte my_place=0;\n\nNCS: if\n::  d_step {my_place = next;next = next+1;}  goto p1; \n\nfi;\np1: if\n::  d_step {my_place==7-1;next = next-7;}  goto p2; \n\n::  d_step {my_place!=7-1;my_place = my_place%7;}  goto p2; \n\nfi;\np2: if\n:: Slot[my_place]==1; goto p3; \n\nfi;\np3: if\n:: Slot[my_place] = 0; goto CS; \n\nfi;\nCS: if\n:: Slot[(my_place+1)%7] = 1; goto NCS; \n\nfi;\n}\n\nproctype P_5() { \nbyte my_place=0;\n\nNCS: if\n::  d_step {my_place = next;next = next+1;}  goto p1; \n\nfi;\np1: if\n::  d_step {my_place==7-1;next = next-7;}  goto p2; \n\n::  d_step {my_place!=7-1;my_place = my_place%7;}  goto p2; \n\nfi;\np2: if\n:: Slot[my_place]==1; goto p3; \n\nfi;\np3: if\n:: Slot[my_place] = 0; goto CS; \n\nfi;\nCS: if\n:: Slot[(my_place+1)%7] = 1; goto NCS; \n\nfi;\n}\n\nproctype P_6() { \nbyte my_place=0;\n\nNCS: if\n::  d_step {my_place = next;next = next+1;}  goto p1; \n\nfi;\np1: if\n::  d_step {my_place==7-1;next = next-7;}  goto p2; \n\n::  d_step {my_place!=7-1;my_place = my_place%7;}  goto p2; \n\nfi;\np2: if\n:: Slot[my_place]==1; goto p3; \n\nfi;\np3: if\n:: Slot[my_place] = 0; goto CS; \n\nfi;\nCS: if\n:: Slot[(my_place+1)%7] = 1; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Dicrete time model of Alur-Taubenfeld fast timing-based\n    mutual exclusion algorithm.\n\nParameters:\n\n\n\n\n\nAtomic propositions:\n, , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte x=0;\nbyte y=255;\nbyte z=0;\nbyte t[3];\n\n\ninit { \n d_step { \nt[0] =255; t[1] =255; t[2] =255; }\natomic { \nrun Timer();\nrun P_0();\nrun P_1();\nrun P_2();\n} }\n\nproctype Timer() { \n\nq: if\n::  d_step {t[0]!=0 && t[1]!=0 && t[2]!=0;t[0] = (t[0]-1)|((t[0]==255)*255);t[1] = (t[1]-1)|((t[1]==255)*255);t[2] = (t[2]-1)|((t[2]==255)*255);}  goto q; \n\nfi;\n}\n\nproctype P_0() { \n\nNCS: if\n::  d_step {x = 0;t[0] = 255;}  goto p3; \n\nfi;\np3: if\n::  d_step {y==255;t[0] = 2;}  goto p4; \n\nfi;\np4: if\n::  d_step {y = 0;t[0] = 2;}  goto p5; \n\nfi;\np5: if\n::  d_step {x==0;t[0] = 2;}  goto p9; \n\n::  d_step {x!=0;t[0] = 5;}  goto p6; \n\nfi;\np6: if\n::  d_step {t[0]==0;t[0] = 2;}  goto p7; \n\nfi;\np7: if\n::  d_step {y!=0;t[0] = 2;}  goto NCS; \n\n::  d_step {y==0;t[0] = 255;}  goto p8; \n\nfi;\np8: if\n:: z==0; goto CS; \n\nfi;\np9: if\n::  d_step {z = 1;t[0] = 255;}  goto CS; \n\nfi;\nCS: if\n::  d_step {z = 0;t[0] = 2;}  goto p12; \n\nfi;\np12: if\n::  d_step {y!=0;t[0] = 255;}  goto NCS; \n\n::  d_step {y==0;t[0] = 2;}  goto p13; \n\nfi;\np13: if\n::  d_step {y = 255;t[0] = 255;}  goto NCS; \n\nfi;\np2: \n false; }\n\nproctype P_1() { \n\nNCS: if\n::  d_step {x = 1;t[1] = 255;}  goto p3; \n\nfi;\np3: if\n::  d_step {y==255;t[1] = 2;}  goto p4; \n\nfi;\np4: if\n::  d_step {y = 1;t[1] = 2;}  goto p5; \n\nfi;\np5: if\n::  d_step {x==1;t[1] = 2;}  goto p9; \n\n::  d_step {x!=1;t[1] = 5;}  goto p6; \n\nfi;\np6: if\n::  d_step {t[1]==0;t[1] = 2;}  goto p7; \n\nfi;\np7: if\n::  d_step {y!=1;t[1] = 2;}  goto NCS; \n\n::  d_step {y==1;t[1] = 255;}  goto p8; \n\nfi;\np8: if\n:: z==0; goto CS; \n\nfi;\np9: if\n::  d_step {z = 1;t[1] = 255;}  goto CS; \n\nfi;\nCS: if\n::  d_step {z = 0;t[1] = 2;}  goto p12; \n\nfi;\np12: if\n::  d_step {y!=1;t[1] = 255;}  goto NCS; \n\n::  d_step {y==1;t[1] = 2;}  goto p13; \n\nfi;\np13: if\n::  d_step {y = 255;t[1] = 255;}  goto NCS; \n\nfi;\np2: \n false; }\n\nproctype P_2() { \n\nNCS: if\n::  d_step {x = 2;t[2] = 255;}  goto p3; \n\nfi;\np3: if\n::  d_step {y==255;t[2] = 2;}  goto p4; \n\nfi;\np4: if\n::  d_step {y = 2;t[2] = 2;}  goto p5; \n\nfi;\np5: if\n::  d_step {x==2;t[2] = 2;}  goto p9; \n\n::  d_step {x!=2;t[2] = 5;}  goto p6; \n\nfi;\np6: if\n::  d_step {t[2]==0;t[2] = 2;}  goto p7; \n\nfi;\np7: if\n::  d_step {y!=2;t[2] = 2;}  goto NCS; \n\n::  d_step {y==2;t[2] = 255;}  goto p8; \n\nfi;\np8: if\n:: z==0; goto CS; \n\nfi;\np9: if\n::  d_step {z = 1;t[2] = 255;}  goto CS; \n\nfi;\nCS: if\n::  d_step {z = 0;t[2] = 2;}  goto p12; \n\nfi;\np12: if\n::  d_step {y!=2;t[2] = 255;}  goto NCS; \n\n::  d_step {y==2;t[2] = 2;}  goto p13; \n\nfi;\np13: if\n::  d_step {y = 255;t[2] = 255;}  goto NCS; \n\nfi;\np2: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Dicrete time model of Alur-Taubenfeld fast timing-based\n    mutual exclusion algorithm.\n\nParameters:\n\n\n\n\n\nAtomic propositions:\n, , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte x=0;\nbyte y=255;\nbyte z=0;\nbyte t[3];\n\n\ninit { \n d_step { \nt[0] =255; t[1] =255; t[2] =255; }\natomic { \nrun Timer();\nrun P_0();\nrun P_1();\nrun P_2();\n} }\n\nproctype Timer() { \n\nq: if\n::  d_step {t[0]!=0 && t[1]!=0 && t[2]!=0;t[0] = (t[0]-1)|((t[0]==255)*255);t[1] = (t[1]-1)|((t[1]==255)*255);t[2] = (t[2]-1)|((t[2]==255)*255);}  goto q; \n\nfi;\n}\n\nproctype P_0() { \n\nNCS: if\n::  d_step {x = 0;t[0] = 255;}  goto p3; \n\nfi;\np3: if\n::  d_step {y==255;t[0] = 2;}  goto p4; \n\nfi;\np4: if\n::  d_step {y = 0;t[0] = 2;}  goto p5; \n\nfi;\np5: if\n::  d_step {x==0;t[0] = 2;}  goto p9; \n\n::  d_step {x!=0;t[0] = 3;}  goto p6; \n\nfi;\np6: if\n::  d_step {t[0]==0;t[0] = 2;}  goto p7; \n\nfi;\np7: if\n::  d_step {y!=0;t[0] = 2;}  goto NCS; \n\n::  d_step {y==0;t[0] = 255;}  goto p8; \n\nfi;\np8: if\n:: z==0; goto CS; \n\nfi;\np9: if\n::  d_step {z = 1;t[0] = 255;}  goto CS; \n\nfi;\nCS: if\n::  d_step {z = 0;t[0] = 2;}  goto p12; \n\nfi;\np12: if\n::  d_step {y!=0;t[0] = 255;}  goto NCS; \n\n::  d_step {y==0;t[0] = 2;}  goto p13; \n\nfi;\np13: if\n::  d_step {y = 255;t[0] = 255;}  goto NCS; \n\nfi;\np2: \n false; }\n\nproctype P_1() { \n\nNCS: if\n::  d_step {x = 1;t[1] = 255;}  goto p3; \n\nfi;\np3: if\n::  d_step {y==255;t[1] = 2;}  goto p4; \n\nfi;\np4: if\n::  d_step {y = 1;t[1] = 2;}  goto p5; \n\nfi;\np5: if\n::  d_step {x==1;t[1] = 2;}  goto p9; \n\n::  d_step {x!=1;t[1] = 3;}  goto p6; \n\nfi;\np6: if\n::  d_step {t[1]==0;t[1] = 2;}  goto p7; \n\nfi;\np7: if\n::  d_step {y!=1;t[1] = 2;}  goto NCS; \n\n::  d_step {y==1;t[1] = 255;}  goto p8; \n\nfi;\np8: if\n:: z==0; goto CS; \n\nfi;\np9: if\n::  d_step {z = 1;t[1] = 255;}  goto CS; \n\nfi;\nCS: if\n::  d_step {z = 0;t[1] = 2;}  goto p12; \n\nfi;\np12: if\n::  d_step {y!=1;t[1] = 255;}  goto NCS; \n\n::  d_step {y==1;t[1] = 2;}  goto p13; \n\nfi;\np13: if\n::  d_step {y = 255;t[1] = 255;}  goto NCS; \n\nfi;\np2: \n false; }\n\nproctype P_2() { \n\nNCS: if\n::  d_step {x = 2;t[2] = 255;}  goto p3; \n\nfi;\np3: if\n::  d_step {y==255;t[2] = 2;}  goto p4; \n\nfi;\np4: if\n::  d_step {y = 2;t[2] = 2;}  goto p5; \n\nfi;\np5: if\n::  d_step {x==2;t[2] = 2;}  goto p9; \n\n::  d_step {x!=2;t[2] = 3;}  goto p6; \n\nfi;\np6: if\n::  d_step {t[2]==0;t[2] = 2;}  goto p7; \n\nfi;\np7: if\n::  d_step {y!=2;t[2] = 2;}  goto NCS; \n\n::  d_step {y==2;t[2] = 255;}  goto p8; \n\nfi;\np8: if\n:: z==0; goto CS; \n\nfi;\np9: if\n::  d_step {z = 1;t[2] = 255;}  goto CS; \n\nfi;\nCS: if\n::  d_step {z = 0;t[2] = 2;}  goto p12; \n\nfi;\np12: if\n::  d_step {y!=2;t[2] = 255;}  goto NCS; \n\n::  d_step {y==2;t[2] = 2;}  goto p13; \n\nfi;\np13: if\n::  d_step {y = 255;t[2] = 255;}  goto NCS; \n\nfi;\np2: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Dicrete time model of Alur-Taubenfeld fast timing-based\n    mutual exclusion algorithm.\n\nParameters:\n\n\n\n\n\nAtomic propositions:\n, , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte x=0;\nbyte y=255;\nbyte z=0;\nbyte t[4];\n\n\ninit { \n d_step { \nt[0] =255; t[1] =255; t[2] =255; t[3] =255; }\natomic { \nrun Timer();\nrun P_0();\nrun P_1();\nrun P_2();\nrun P_3();\n} }\n\nproctype Timer() { \n\nq: if\n::  d_step {t[0]!=0 && t[1]!=0 && t[2]!=0 && t[3]!=0;t[0] = (t[0]-1)|((t[0]==255)*255);t[1] = (t[1]-1)|((t[1]==255)*255);t[2] = (t[2]-1)|((t[2]==255)*255);t[3] = (t[3]-1)|((t[3]==255)*255);}  goto q; \n\nfi;\n}\n\nproctype P_0() { \n\nNCS: if\n::  d_step {x = 0;t[0] = 255;}  goto p3; \n\nfi;\np3: if\n::  d_step {y==255;t[0] = 2;}  goto p4; \n\nfi;\np4: if\n::  d_step {y = 0;t[0] = 2;}  goto p5; \n\nfi;\np5: if\n::  d_step {x==0;t[0] = 2;}  goto p9; \n\n::  d_step {x!=0;t[0] = 4;}  goto p6; \n\nfi;\np6: if\n::  d_step {t[0]==0;t[0] = 2;}  goto p7; \n\nfi;\np7: if\n::  d_step {y!=0;t[0] = 2;}  goto NCS; \n\n::  d_step {y==0;t[0] = 255;}  goto p8; \n\nfi;\np8: if\n:: z==0; goto CS; \n\nfi;\np9: if\n::  d_step {z = 1;t[0] = 255;}  goto CS; \n\nfi;\nCS: if\n::  d_step {z = 0;t[0] = 2;}  goto p12; \n\nfi;\np12: if\n::  d_step {y!=0;t[0] = 255;}  goto NCS; \n\n::  d_step {y==0;t[0] = 2;}  goto p13; \n\nfi;\np13: if\n::  d_step {y = 255;t[0] = 255;}  goto NCS; \n\nfi;\np2: \n false; }\n\nproctype P_1() { \n\nNCS: if\n::  d_step {x = 1;t[1] = 255;}  goto p3; \n\nfi;\np3: if\n::  d_step {y==255;t[1] = 2;}  goto p4; \n\nfi;\np4: if\n::  d_step {y = 1;t[1] = 2;}  goto p5; \n\nfi;\np5: if\n::  d_step {x==1;t[1] = 2;}  goto p9; \n\n::  d_step {x!=1;t[1] = 4;}  goto p6; \n\nfi;\np6: if\n::  d_step {t[1]==0;t[1] = 2;}  goto p7; \n\nfi;\np7: if\n::  d_step {y!=1;t[1] = 2;}  goto NCS; \n\n::  d_step {y==1;t[1] = 255;}  goto p8; \n\nfi;\np8: if\n:: z==0; goto CS; \n\nfi;\np9: if\n::  d_step {z = 1;t[1] = 255;}  goto CS; \n\nfi;\nCS: if\n::  d_step {z = 0;t[1] = 2;}  goto p12; \n\nfi;\np12: if\n::  d_step {y!=1;t[1] = 255;}  goto NCS; \n\n::  d_step {y==1;t[1] = 2;}  goto p13; \n\nfi;\np13: if\n::  d_step {y = 255;t[1] = 255;}  goto NCS; \n\nfi;\np2: \n false; }\n\nproctype P_2() { \n\nNCS: if\n::  d_step {x = 2;t[2] = 255;}  goto p3; \n\nfi;\np3: if\n::  d_step {y==255;t[2] = 2;}  goto p4; \n\nfi;\np4: if\n::  d_step {y = 2;t[2] = 2;}  goto p5; \n\nfi;\np5: if\n::  d_step {x==2;t[2] = 2;}  goto p9; \n\n::  d_step {x!=2;t[2] = 4;}  goto p6; \n\nfi;\np6: if\n::  d_step {t[2]==0;t[2] = 2;}  goto p7; \n\nfi;\np7: if\n::  d_step {y!=2;t[2] = 2;}  goto NCS; \n\n::  d_step {y==2;t[2] = 255;}  goto p8; \n\nfi;\np8: if\n:: z==0; goto CS; \n\nfi;\np9: if\n::  d_step {z = 1;t[2] = 255;}  goto CS; \n\nfi;\nCS: if\n::  d_step {z = 0;t[2] = 2;}  goto p12; \n\nfi;\np12: if\n::  d_step {y!=2;t[2] = 255;}  goto NCS; \n\n::  d_step {y==2;t[2] = 2;}  goto p13; \n\nfi;\np13: if\n::  d_step {y = 255;t[2] = 255;}  goto NCS; \n\nfi;\np2: \n false; }\n\nproctype P_3() { \n\nNCS: if\n::  d_step {x = 3;t[3] = 255;}  goto p3; \n\nfi;\np3: if\n::  d_step {y==255;t[3] = 2;}  goto p4; \n\nfi;\np4: if\n::  d_step {y = 3;t[3] = 2;}  goto p5; \n\nfi;\np5: if\n::  d_step {x==3;t[3] = 2;}  goto p9; \n\n::  d_step {x!=3;t[3] = 4;}  goto p6; \n\nfi;\np6: if\n::  d_step {t[3]==0;t[3] = 2;}  goto p7; \n\nfi;\np7: if\n::  d_step {y!=3;t[3] = 2;}  goto NCS; \n\n::  d_step {y==3;t[3] = 255;}  goto p8; \n\nfi;\np8: if\n:: z==0; goto CS; \n\nfi;\np9: if\n::  d_step {z = 1;t[3] = 255;}  goto CS; \n\nfi;\nCS: if\n::  d_step {z = 0;t[3] = 2;}  goto p12; \n\nfi;\np12: if\n::  d_step {y!=3;t[3] = 255;}  goto NCS; \n\n::  d_step {y==3;t[3] = 2;}  goto p13; \n\nfi;\np13: if\n::  d_step {y = 255;t[3] = 255;}  goto NCS; \n\nfi;\np2: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Dicrete time model of Alur-Taubenfeld fast timing-based\n    mutual exclusion algorithm.\n\nParameters:\n\n\n\n\n\nAtomic propositions:\n, , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte x=0;\nbyte y=255;\nbyte z=0;\nbyte t[5];\n\n\ninit { \n d_step { \nt[0] =255; t[1] =255; t[2] =255; t[3] =255; t[4] =255; }\natomic { \nrun Timer();\nrun P_0();\nrun P_1();\nrun P_2();\nrun P_3();\nrun P_4();\n} }\n\nproctype Timer() { \n\nq: if\n::  d_step {t[0]!=0 && t[1]!=0 && t[2]!=0 && t[3]!=0 && t[4]!=0;t[0] = (t[0]-1)|((t[0]==255)*255);t[1] = (t[1]-1)|((t[1]==255)*255);t[2] = (t[2]-1)|((t[2]==255)*255);t[3] = (t[3]-1)|((t[3]==255)*255);t[4] = (t[4]-1)|((t[4]==255)*255);}  goto q; \n\nfi;\n}\n\nproctype P_0() { \n\nNCS: if\n::  d_step {x = 0;t[0] = 255;}  goto p3; \n\nfi;\np3: if\n::  d_step {y==255;t[0] = 1;}  goto p4; \n\nfi;\np4: if\n::  d_step {y = 0;t[0] = 1;}  goto p5; \n\nfi;\np5: if\n::  d_step {x==0;t[0] = 1;}  goto p9; \n\n::  d_step {x!=0;t[0] = 3;}  goto p6; \n\nfi;\np6: if\n::  d_step {t[0]==0;t[0] = 1;}  goto p7; \n\nfi;\np7: if\n::  d_step {y!=0;t[0] = 1;}  goto NCS; \n\n::  d_step {y==0;t[0] = 255;}  goto p8; \n\nfi;\np8: if\n:: z==0; goto CS; \n\nfi;\np9: if\n::  d_step {z = 1;t[0] = 255;}  goto CS; \n\nfi;\nCS: if\n::  d_step {z = 0;t[0] = 1;}  goto p12; \n\nfi;\np12: if\n::  d_step {y!=0;t[0] = 255;}  goto NCS; \n\n::  d_step {y==0;t[0] = 1;}  goto p13; \n\nfi;\np13: if\n::  d_step {y = 255;t[0] = 255;}  goto NCS; \n\nfi;\np2: \n false; }\n\nproctype P_1() { \n\nNCS: if\n::  d_step {x = 1;t[1] = 255;}  goto p3; \n\nfi;\np3: if\n::  d_step {y==255;t[1] = 1;}  goto p4; \n\nfi;\np4: if\n::  d_step {y = 1;t[1] = 1;}  goto p5; \n\nfi;\np5: if\n::  d_step {x==1;t[1] = 1;}  goto p9; \n\n::  d_step {x!=1;t[1] = 3;}  goto p6; \n\nfi;\np6: if\n::  d_step {t[1]==0;t[1] = 1;}  goto p7; \n\nfi;\np7: if\n::  d_step {y!=1;t[1] = 1;}  goto NCS; \n\n::  d_step {y==1;t[1] = 255;}  goto p8; \n\nfi;\np8: if\n:: z==0; goto CS; \n\nfi;\np9: if\n::  d_step {z = 1;t[1] = 255;}  goto CS; \n\nfi;\nCS: if\n::  d_step {z = 0;t[1] = 1;}  goto p12; \n\nfi;\np12: if\n::  d_step {y!=1;t[1] = 255;}  goto NCS; \n\n::  d_step {y==1;t[1] = 1;}  goto p13; \n\nfi;\np13: if\n::  d_step {y = 255;t[1] = 255;}  goto NCS; \n\nfi;\np2: \n false; }\n\nproctype P_2() { \n\nNCS: if\n::  d_step {x = 2;t[2] = 255;}  goto p3; \n\nfi;\np3: if\n::  d_step {y==255;t[2] = 1;}  goto p4; \n\nfi;\np4: if\n::  d_step {y = 2;t[2] = 1;}  goto p5; \n\nfi;\np5: if\n::  d_step {x==2;t[2] = 1;}  goto p9; \n\n::  d_step {x!=2;t[2] = 3;}  goto p6; \n\nfi;\np6: if\n::  d_step {t[2]==0;t[2] = 1;}  goto p7; \n\nfi;\np7: if\n::  d_step {y!=2;t[2] = 1;}  goto NCS; \n\n::  d_step {y==2;t[2] = 255;}  goto p8; \n\nfi;\np8: if\n:: z==0; goto CS; \n\nfi;\np9: if\n::  d_step {z = 1;t[2] = 255;}  goto CS; \n\nfi;\nCS: if\n::  d_step {z = 0;t[2] = 1;}  goto p12; \n\nfi;\np12: if\n::  d_step {y!=2;t[2] = 255;}  goto NCS; \n\n::  d_step {y==2;t[2] = 1;}  goto p13; \n\nfi;\np13: if\n::  d_step {y = 255;t[2] = 255;}  goto NCS; \n\nfi;\np2: \n false; }\n\nproctype P_3() { \n\nNCS: if\n::  d_step {x = 3;t[3] = 255;}  goto p3; \n\nfi;\np3: if\n::  d_step {y==255;t[3] = 1;}  goto p4; \n\nfi;\np4: if\n::  d_step {y = 3;t[3] = 1;}  goto p5; \n\nfi;\np5: if\n::  d_step {x==3;t[3] = 1;}  goto p9; \n\n::  d_step {x!=3;t[3] = 3;}  goto p6; \n\nfi;\np6: if\n::  d_step {t[3]==0;t[3] = 1;}  goto p7; \n\nfi;\np7: if\n::  d_step {y!=3;t[3] = 1;}  goto NCS; \n\n::  d_step {y==3;t[3] = 255;}  goto p8; \n\nfi;\np8: if\n:: z==0; goto CS; \n\nfi;\np9: if\n::  d_step {z = 1;t[3] = 255;}  goto CS; \n\nfi;\nCS: if\n::  d_step {z = 0;t[3] = 1;}  goto p12; \n\nfi;\np12: if\n::  d_step {y!=3;t[3] = 255;}  goto NCS; \n\n::  d_step {y==3;t[3] = 1;}  goto p13; \n\nfi;\np13: if\n::  d_step {y = 255;t[3] = 255;}  goto NCS; \n\nfi;\np2: \n false; }\n\nproctype P_4() { \n\nNCS: if\n::  d_step {x = 4;t[4] = 255;}  goto p3; \n\nfi;\np3: if\n::  d_step {y==255;t[4] = 1;}  goto p4; \n\nfi;\np4: if\n::  d_step {y = 4;t[4] = 1;}  goto p5; \n\nfi;\np5: if\n::  d_step {x==4;t[4] = 1;}  goto p9; \n\n::  d_step {x!=4;t[4] = 3;}  goto p6; \n\nfi;\np6: if\n::  d_step {t[4]==0;t[4] = 1;}  goto p7; \n\nfi;\np7: if\n::  d_step {y!=4;t[4] = 1;}  goto NCS; \n\n::  d_step {y==4;t[4] = 255;}  goto p8; \n\nfi;\np8: if\n:: z==0; goto CS; \n\nfi;\np9: if\n::  d_step {z = 1;t[4] = 255;}  goto CS; \n\nfi;\nCS: if\n::  d_step {z = 0;t[4] = 1;}  goto p12; \n\nfi;\np12: if\n::  d_step {y!=4;t[4] = 255;}  goto NCS; \n\n::  d_step {y==4;t[4] = 1;}  goto p13; \n\nfi;\np13: if\n::  d_step {y = 255;t[4] = 255;}  goto NCS; \n\nfi;\np2: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Dicrete time model of Alur-Taubenfeld fast timing-based\n    mutual exclusion algorithm.\n\nParameters:\n\n\n\n\n\nAtomic propositions:\n, , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte x=0;\nbyte y=255;\nbyte z=0;\nbyte t[5];\n\n\ninit { \n d_step { \nt[0] =255; t[1] =255; t[2] =255; t[3] =255; t[4] =255; }\natomic { \nrun Timer();\nrun P_0();\nrun P_1();\nrun P_2();\nrun P_3();\nrun P_4();\n} }\n\nproctype Timer() { \n\nq: if\n::  d_step {t[0]!=0 && t[1]!=0 && t[2]!=0 && t[3]!=0 && t[4]!=0;t[0] = (t[0]-1)|((t[0]==255)*255);t[1] = (t[1]-1)|((t[1]==255)*255);t[2] = (t[2]-1)|((t[2]==255)*255);t[3] = (t[3]-1)|((t[3]==255)*255);t[4] = (t[4]-1)|((t[4]==255)*255);}  goto q; \n\nfi;\n}\n\nproctype P_0() { \n\nNCS: if\n::  d_step {x = 0;t[0] = 255;}  goto p3; \n\nfi;\np3: if\n::  d_step {y==255;t[0] = 2;}  goto p4; \n\nfi;\np4: if\n::  d_step {y = 0;t[0] = 2;}  goto p5; \n\nfi;\np5: if\n::  d_step {x==0;t[0] = 2;}  goto p9; \n\n::  d_step {x!=0;t[0] = 5;}  goto p6; \n\nfi;\np6: if\n::  d_step {t[0]==0;t[0] = 2;}  goto p7; \n\nfi;\np7: if\n::  d_step {y!=0;t[0] = 2;}  goto NCS; \n\n::  d_step {y==0;t[0] = 255;}  goto p8; \n\nfi;\np8: if\n:: z==0; goto CS; \n\nfi;\np9: if\n::  d_step {z = 1;t[0] = 255;}  goto CS; \n\nfi;\nCS: if\n::  d_step {z = 0;t[0] = 2;}  goto p12; \n\nfi;\np12: if\n::  d_step {y!=0;t[0] = 255;}  goto NCS; \n\n::  d_step {y==0;t[0] = 2;}  goto p13; \n\nfi;\np13: if\n::  d_step {y = 255;t[0] = 255;}  goto NCS; \n\nfi;\np2: \n false; }\n\nproctype P_1() { \n\nNCS: if\n::  d_step {x = 1;t[1] = 255;}  goto p3; \n\nfi;\np3: if\n::  d_step {y==255;t[1] = 2;}  goto p4; \n\nfi;\np4: if\n::  d_step {y = 1;t[1] = 2;}  goto p5; \n\nfi;\np5: if\n::  d_step {x==1;t[1] = 2;}  goto p9; \n\n::  d_step {x!=1;t[1] = 5;}  goto p6; \n\nfi;\np6: if\n::  d_step {t[1]==0;t[1] = 2;}  goto p7; \n\nfi;\np7: if\n::  d_step {y!=1;t[1] = 2;}  goto NCS; \n\n::  d_step {y==1;t[1] = 255;}  goto p8; \n\nfi;\np8: if\n:: z==0; goto CS; \n\nfi;\np9: if\n::  d_step {z = 1;t[1] = 255;}  goto CS; \n\nfi;\nCS: if\n::  d_step {z = 0;t[1] = 2;}  goto p12; \n\nfi;\np12: if\n::  d_step {y!=1;t[1] = 255;}  goto NCS; \n\n::  d_step {y==1;t[1] = 2;}  goto p13; \n\nfi;\np13: if\n::  d_step {y = 255;t[1] = 255;}  goto NCS; \n\nfi;\np2: \n false; }\n\nproctype P_2() { \n\nNCS: if\n::  d_step {x = 2;t[2] = 255;}  goto p3; \n\nfi;\np3: if\n::  d_step {y==255;t[2] = 2;}  goto p4; \n\nfi;\np4: if\n::  d_step {y = 2;t[2] = 2;}  goto p5; \n\nfi;\np5: if\n::  d_step {x==2;t[2] = 2;}  goto p9; \n\n::  d_step {x!=2;t[2] = 5;}  goto p6; \n\nfi;\np6: if\n::  d_step {t[2]==0;t[2] = 2;}  goto p7; \n\nfi;\np7: if\n::  d_step {y!=2;t[2] = 2;}  goto NCS; \n\n::  d_step {y==2;t[2] = 255;}  goto p8; \n\nfi;\np8: if\n:: z==0; goto CS; \n\nfi;\np9: if\n::  d_step {z = 1;t[2] = 255;}  goto CS; \n\nfi;\nCS: if\n::  d_step {z = 0;t[2] = 2;}  goto p12; \n\nfi;\np12: if\n::  d_step {y!=2;t[2] = 255;}  goto NCS; \n\n::  d_step {y==2;t[2] = 2;}  goto p13; \n\nfi;\np13: if\n::  d_step {y = 255;t[2] = 255;}  goto NCS; \n\nfi;\np2: \n false; }\n\nproctype P_3() { \n\nNCS: if\n::  d_step {x = 3;t[3] = 255;}  goto p3; \n\nfi;\np3: if\n::  d_step {y==255;t[3] = 2;}  goto p4; \n\nfi;\np4: if\n::  d_step {y = 3;t[3] = 2;}  goto p5; \n\nfi;\np5: if\n::  d_step {x==3;t[3] = 2;}  goto p9; \n\n::  d_step {x!=3;t[3] = 5;}  goto p6; \n\nfi;\np6: if\n::  d_step {t[3]==0;t[3] = 2;}  goto p7; \n\nfi;\np7: if\n::  d_step {y!=3;t[3] = 2;}  goto NCS; \n\n::  d_step {y==3;t[3] = 255;}  goto p8; \n\nfi;\np8: if\n:: z==0; goto CS; \n\nfi;\np9: if\n::  d_step {z = 1;t[3] = 255;}  goto CS; \n\nfi;\nCS: if\n::  d_step {z = 0;t[3] = 2;}  goto p12; \n\nfi;\np12: if\n::  d_step {y!=3;t[3] = 255;}  goto NCS; \n\n::  d_step {y==3;t[3] = 2;}  goto p13; \n\nfi;\np13: if\n::  d_step {y = 255;t[3] = 255;}  goto NCS; \n\nfi;\np2: \n false; }\n\nproctype P_4() { \n\nNCS: if\n::  d_step {x = 4;t[4] = 255;}  goto p3; \n\nfi;\np3: if\n::  d_step {y==255;t[4] = 2;}  goto p4; \n\nfi;\np4: if\n::  d_step {y = 4;t[4] = 2;}  goto p5; \n\nfi;\np5: if\n::  d_step {x==4;t[4] = 2;}  goto p9; \n\n::  d_step {x!=4;t[4] = 5;}  goto p6; \n\nfi;\np6: if\n::  d_step {t[4]==0;t[4] = 2;}  goto p7; \n\nfi;\np7: if\n::  d_step {y!=4;t[4] = 2;}  goto NCS; \n\n::  d_step {y==4;t[4] = 255;}  goto p8; \n\nfi;\np8: if\n:: z==0; goto CS; \n\nfi;\np9: if\n::  d_step {z = 1;t[4] = 255;}  goto CS; \n\nfi;\nCS: if\n::  d_step {z = 0;t[4] = 2;}  goto p12; \n\nfi;\np12: if\n::  d_step {y!=4;t[4] = 255;}  goto NCS; \n\n::  d_step {y==4;t[4] = 2;}  goto p13; \n\nfi;\np13: if\n::  d_step {y = 255;t[4] = 255;}  goto NCS; \n\nfi;\np2: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Dicrete time model of Alur-Taubenfeld fast timing-based\n    mutual exclusion algorithm.\n\nParameters:\n\n\n\n\n\nAtomic propositions:\n, , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte x=0;\nbyte y=255;\nbyte z=0;\nbyte t[5];\n\n\ninit { \n d_step { \nt[0] =255; t[1] =255; t[2] =255; t[3] =255; t[4] =255; }\natomic { \nrun Timer();\nrun P_0();\nrun P_1();\nrun P_2();\nrun P_3();\nrun P_4();\n} }\n\nproctype Timer() { \n\nq: if\n::  d_step {t[0]!=0 && t[1]!=0 && t[2]!=0 && t[3]!=0 && t[4]!=0;t[0] = (t[0]-1)|((t[0]==255)*255);t[1] = (t[1]-1)|((t[1]==255)*255);t[2] = (t[2]-1)|((t[2]==255)*255);t[3] = (t[3]-1)|((t[3]==255)*255);t[4] = (t[4]-1)|((t[4]==255)*255);}  goto q; \n\nfi;\n}\n\nproctype P_0() { \n\nNCS: if\n::  d_step {x = 0;t[0] = 255;}  goto p3; \n\nfi;\np3: if\n::  d_step {y==255;t[0] = 3;}  goto p4; \n\nfi;\np4: if\n::  d_step {y = 0;t[0] = 3;}  goto p5; \n\nfi;\np5: if\n::  d_step {x==0;t[0] = 3;}  goto p9; \n\n::  d_step {x!=0;t[0] = 5;}  goto p6; \n\nfi;\np6: if\n::  d_step {t[0]==0;t[0] = 3;}  goto p7; \n\nfi;\np7: if\n::  d_step {y!=0;t[0] = 3;}  goto NCS; \n\n::  d_step {y==0;t[0] = 255;}  goto p8; \n\nfi;\np8: if\n:: z==0; goto CS; \n\nfi;\np9: if\n::  d_step {z = 1;t[0] = 255;}  goto CS; \n\nfi;\nCS: if\n::  d_step {z = 0;t[0] = 3;}  goto p12; \n\nfi;\np12: if\n::  d_step {y!=0;t[0] = 255;}  goto NCS; \n\n::  d_step {y==0;t[0] = 3;}  goto p13; \n\nfi;\np13: if\n::  d_step {y = 255;t[0] = 255;}  goto NCS; \n\nfi;\np2: \n false; }\n\nproctype P_1() { \n\nNCS: if\n::  d_step {x = 1;t[1] = 255;}  goto p3; \n\nfi;\np3: if\n::  d_step {y==255;t[1] = 3;}  goto p4; \n\nfi;\np4: if\n::  d_step {y = 1;t[1] = 3;}  goto p5; \n\nfi;\np5: if\n::  d_step {x==1;t[1] = 3;}  goto p9; \n\n::  d_step {x!=1;t[1] = 5;}  goto p6; \n\nfi;\np6: if\n::  d_step {t[1]==0;t[1] = 3;}  goto p7; \n\nfi;\np7: if\n::  d_step {y!=1;t[1] = 3;}  goto NCS; \n\n::  d_step {y==1;t[1] = 255;}  goto p8; \n\nfi;\np8: if\n:: z==0; goto CS; \n\nfi;\np9: if\n::  d_step {z = 1;t[1] = 255;}  goto CS; \n\nfi;\nCS: if\n::  d_step {z = 0;t[1] = 3;}  goto p12; \n\nfi;\np12: if\n::  d_step {y!=1;t[1] = 255;}  goto NCS; \n\n::  d_step {y==1;t[1] = 3;}  goto p13; \n\nfi;\np13: if\n::  d_step {y = 255;t[1] = 255;}  goto NCS; \n\nfi;\np2: \n false; }\n\nproctype P_2() { \n\nNCS: if\n::  d_step {x = 2;t[2] = 255;}  goto p3; \n\nfi;\np3: if\n::  d_step {y==255;t[2] = 3;}  goto p4; \n\nfi;\np4: if\n::  d_step {y = 2;t[2] = 3;}  goto p5; \n\nfi;\np5: if\n::  d_step {x==2;t[2] = 3;}  goto p9; \n\n::  d_step {x!=2;t[2] = 5;}  goto p6; \n\nfi;\np6: if\n::  d_step {t[2]==0;t[2] = 3;}  goto p7; \n\nfi;\np7: if\n::  d_step {y!=2;t[2] = 3;}  goto NCS; \n\n::  d_step {y==2;t[2] = 255;}  goto p8; \n\nfi;\np8: if\n:: z==0; goto CS; \n\nfi;\np9: if\n::  d_step {z = 1;t[2] = 255;}  goto CS; \n\nfi;\nCS: if\n::  d_step {z = 0;t[2] = 3;}  goto p12; \n\nfi;\np12: if\n::  d_step {y!=2;t[2] = 255;}  goto NCS; \n\n::  d_step {y==2;t[2] = 3;}  goto p13; \n\nfi;\np13: if\n::  d_step {y = 255;t[2] = 255;}  goto NCS; \n\nfi;\np2: \n false; }\n\nproctype P_3() { \n\nNCS: if\n::  d_step {x = 3;t[3] = 255;}  goto p3; \n\nfi;\np3: if\n::  d_step {y==255;t[3] = 3;}  goto p4; \n\nfi;\np4: if\n::  d_step {y = 3;t[3] = 3;}  goto p5; \n\nfi;\np5: if\n::  d_step {x==3;t[3] = 3;}  goto p9; \n\n::  d_step {x!=3;t[3] = 5;}  goto p6; \n\nfi;\np6: if\n::  d_step {t[3]==0;t[3] = 3;}  goto p7; \n\nfi;\np7: if\n::  d_step {y!=3;t[3] = 3;}  goto NCS; \n\n::  d_step {y==3;t[3] = 255;}  goto p8; \n\nfi;\np8: if\n:: z==0; goto CS; \n\nfi;\np9: if\n::  d_step {z = 1;t[3] = 255;}  goto CS; \n\nfi;\nCS: if\n::  d_step {z = 0;t[3] = 3;}  goto p12; \n\nfi;\np12: if\n::  d_step {y!=3;t[3] = 255;}  goto NCS; \n\n::  d_step {y==3;t[3] = 3;}  goto p13; \n\nfi;\np13: if\n::  d_step {y = 255;t[3] = 255;}  goto NCS; \n\nfi;\np2: \n false; }\n\nproctype P_4() { \n\nNCS: if\n::  d_step {x = 4;t[4] = 255;}  goto p3; \n\nfi;\np3: if\n::  d_step {y==255;t[4] = 3;}  goto p4; \n\nfi;\np4: if\n::  d_step {y = 4;t[4] = 3;}  goto p5; \n\nfi;\np5: if\n::  d_step {x==4;t[4] = 3;}  goto p9; \n\n::  d_step {x!=4;t[4] = 5;}  goto p6; \n\nfi;\np6: if\n::  d_step {t[4]==0;t[4] = 3;}  goto p7; \n\nfi;\np7: if\n::  d_step {y!=4;t[4] = 3;}  goto NCS; \n\n::  d_step {y==4;t[4] = 255;}  goto p8; \n\nfi;\np8: if\n:: z==0; goto CS; \n\nfi;\np9: if\n::  d_step {z = 1;t[4] = 255;}  goto CS; \n\nfi;\nCS: if\n::  d_step {z = 0;t[4] = 3;}  goto p12; \n\nfi;\np12: if\n::  d_step {y!=4;t[4] = 255;}  goto NCS; \n\n::  d_step {y==4;t[4] = 3;}  goto p13; \n\nfi;\np13: if\n::  d_step {y = 255;t[4] = 255;}  goto NCS; \n\nfi;\np2: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Dicrete time model of Alur-Taubenfeld fast timing-based\n    mutual exclusion algorithm.\n\nParameters:\n\n\n\n\n\nAtomic propositions:\n, , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte x=0;\nbyte y=255;\nbyte z=0;\nbyte t[6];\n\n\ninit { \n d_step { \nt[0] =255; t[1] =255; t[2] =255; t[3] =255; t[4] =255; t[5] =255; }\natomic { \nrun Timer();\nrun P_0();\nrun P_1();\nrun P_2();\nrun P_3();\nrun P_4();\nrun P_5();\n} }\n\nproctype Timer() { \n\nq: if\n::  d_step {t[0]!=0 && t[1]!=0 && t[2]!=0 && t[3]!=0 && t[4]!=0 && t[5]!=0;t[0] = (t[0]-1)|((t[0]==255)*255);t[1] = (t[1]-1)|((t[1]==255)*255);t[2] = (t[2]-1)|((t[2]==255)*255);t[3] = (t[3]-1)|((t[3]==255)*255);t[4] = (t[4]-1)|((t[4]==255)*255);t[5] = (t[5]-1)|((t[5]==255)*255);}  goto q; \n\nfi;\n}\n\nproctype P_0() { \n\nNCS: if\n::  d_step {x = 0;t[0] = 255;}  goto p3; \n\nfi;\np3: if\n::  d_step {y==255;t[0] = 2;}  goto p4; \n\nfi;\np4: if\n::  d_step {y = 0;t[0] = 2;}  goto p5; \n\nfi;\np5: if\n::  d_step {x==0;t[0] = 2;}  goto p9; \n\n::  d_step {x!=0;t[0] = 5;}  goto p6; \n\nfi;\np6: if\n::  d_step {t[0]==0;t[0] = 2;}  goto p7; \n\nfi;\np7: if\n::  d_step {y!=0;t[0] = 2;}  goto NCS; \n\n::  d_step {y==0;t[0] = 255;}  goto p8; \n\nfi;\np8: if\n:: z==0; goto CS; \n\nfi;\np9: if\n::  d_step {z = 1;t[0] = 255;}  goto CS; \n\nfi;\nCS: if\n::  d_step {z = 0;t[0] = 2;}  goto p12; \n\nfi;\np12: if\n::  d_step {y!=0;t[0] = 255;}  goto NCS; \n\n::  d_step {y==0;t[0] = 2;}  goto p13; \n\nfi;\np13: if\n::  d_step {y = 255;t[0] = 255;}  goto NCS; \n\nfi;\np2: \n false; }\n\nproctype P_1() { \n\nNCS: if\n::  d_step {x = 1;t[1] = 255;}  goto p3; \n\nfi;\np3: if\n::  d_step {y==255;t[1] = 2;}  goto p4; \n\nfi;\np4: if\n::  d_step {y = 1;t[1] = 2;}  goto p5; \n\nfi;\np5: if\n::  d_step {x==1;t[1] = 2;}  goto p9; \n\n::  d_step {x!=1;t[1] = 5;}  goto p6; \n\nfi;\np6: if\n::  d_step {t[1]==0;t[1] = 2;}  goto p7; \n\nfi;\np7: if\n::  d_step {y!=1;t[1] = 2;}  goto NCS; \n\n::  d_step {y==1;t[1] = 255;}  goto p8; \n\nfi;\np8: if\n:: z==0; goto CS; \n\nfi;\np9: if\n::  d_step {z = 1;t[1] = 255;}  goto CS; \n\nfi;\nCS: if\n::  d_step {z = 0;t[1] = 2;}  goto p12; \n\nfi;\np12: if\n::  d_step {y!=1;t[1] = 255;}  goto NCS; \n\n::  d_step {y==1;t[1] = 2;}  goto p13; \n\nfi;\np13: if\n::  d_step {y = 255;t[1] = 255;}  goto NCS; \n\nfi;\np2: \n false; }\n\nproctype P_2() { \n\nNCS: if\n::  d_step {x = 2;t[2] = 255;}  goto p3; \n\nfi;\np3: if\n::  d_step {y==255;t[2] = 2;}  goto p4; \n\nfi;\np4: if\n::  d_step {y = 2;t[2] = 2;}  goto p5; \n\nfi;\np5: if\n::  d_step {x==2;t[2] = 2;}  goto p9; \n\n::  d_step {x!=2;t[2] = 5;}  goto p6; \n\nfi;\np6: if\n::  d_step {t[2]==0;t[2] = 2;}  goto p7; \n\nfi;\np7: if\n::  d_step {y!=2;t[2] = 2;}  goto NCS; \n\n::  d_step {y==2;t[2] = 255;}  goto p8; \n\nfi;\np8: if\n:: z==0; goto CS; \n\nfi;\np9: if\n::  d_step {z = 1;t[2] = 255;}  goto CS; \n\nfi;\nCS: if\n::  d_step {z = 0;t[2] = 2;}  goto p12; \n\nfi;\np12: if\n::  d_step {y!=2;t[2] = 255;}  goto NCS; \n\n::  d_step {y==2;t[2] = 2;}  goto p13; \n\nfi;\np13: if\n::  d_step {y = 255;t[2] = 255;}  goto NCS; \n\nfi;\np2: \n false; }\n\nproctype P_3() { \n\nNCS: if\n::  d_step {x = 3;t[3] = 255;}  goto p3; \n\nfi;\np3: if\n::  d_step {y==255;t[3] = 2;}  goto p4; \n\nfi;\np4: if\n::  d_step {y = 3;t[3] = 2;}  goto p5; \n\nfi;\np5: if\n::  d_step {x==3;t[3] = 2;}  goto p9; \n\n::  d_step {x!=3;t[3] = 5;}  goto p6; \n\nfi;\np6: if\n::  d_step {t[3]==0;t[3] = 2;}  goto p7; \n\nfi;\np7: if\n::  d_step {y!=3;t[3] = 2;}  goto NCS; \n\n::  d_step {y==3;t[3] = 255;}  goto p8; \n\nfi;\np8: if\n:: z==0; goto CS; \n\nfi;\np9: if\n::  d_step {z = 1;t[3] = 255;}  goto CS; \n\nfi;\nCS: if\n::  d_step {z = 0;t[3] = 2;}  goto p12; \n\nfi;\np12: if\n::  d_step {y!=3;t[3] = 255;}  goto NCS; \n\n::  d_step {y==3;t[3] = 2;}  goto p13; \n\nfi;\np13: if\n::  d_step {y = 255;t[3] = 255;}  goto NCS; \n\nfi;\np2: \n false; }\n\nproctype P_4() { \n\nNCS: if\n::  d_step {x = 4;t[4] = 255;}  goto p3; \n\nfi;\np3: if\n::  d_step {y==255;t[4] = 2;}  goto p4; \n\nfi;\np4: if\n::  d_step {y = 4;t[4] = 2;}  goto p5; \n\nfi;\np5: if\n::  d_step {x==4;t[4] = 2;}  goto p9; \n\n::  d_step {x!=4;t[4] = 5;}  goto p6; \n\nfi;\np6: if\n::  d_step {t[4]==0;t[4] = 2;}  goto p7; \n\nfi;\np7: if\n::  d_step {y!=4;t[4] = 2;}  goto NCS; \n\n::  d_step {y==4;t[4] = 255;}  goto p8; \n\nfi;\np8: if\n:: z==0; goto CS; \n\nfi;\np9: if\n::  d_step {z = 1;t[4] = 255;}  goto CS; \n\nfi;\nCS: if\n::  d_step {z = 0;t[4] = 2;}  goto p12; \n\nfi;\np12: if\n::  d_step {y!=4;t[4] = 255;}  goto NCS; \n\n::  d_step {y==4;t[4] = 2;}  goto p13; \n\nfi;\np13: if\n::  d_step {y = 255;t[4] = 255;}  goto NCS; \n\nfi;\np2: \n false; }\n\nproctype P_5() { \n\nNCS: if\n::  d_step {x = 5;t[5] = 255;}  goto p3; \n\nfi;\np3: if\n::  d_step {y==255;t[5] = 2;}  goto p4; \n\nfi;\np4: if\n::  d_step {y = 5;t[5] = 2;}  goto p5; \n\nfi;\np5: if\n::  d_step {x==5;t[5] = 2;}  goto p9; \n\n::  d_step {x!=5;t[5] = 5;}  goto p6; \n\nfi;\np6: if\n::  d_step {t[5]==0;t[5] = 2;}  goto p7; \n\nfi;\np7: if\n::  d_step {y!=5;t[5] = 2;}  goto NCS; \n\n::  d_step {y==5;t[5] = 255;}  goto p8; \n\nfi;\np8: if\n:: z==0; goto CS; \n\nfi;\np9: if\n::  d_step {z = 1;t[5] = 255;}  goto CS; \n\nfi;\nCS: if\n::  d_step {z = 0;t[5] = 2;}  goto p12; \n\nfi;\np12: if\n::  d_step {y!=5;t[5] = 255;}  goto NCS; \n\n::  d_step {y==5;t[5] = 2;}  goto p13; \n\nfi;\np13: if\n::  d_step {y = 255;t[5] = 255;}  goto NCS; \n\nfi;\np2: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte choosing[2];\nbyte number[2];\n\n\nactive proctype P_0() { \nbyte j=0;\nbyte max=0;\n\nNCS: if\n::  d_step {choosing[0] = 1;j = 0;max = 0;}  goto choose; \n\nfi;\nchoose: if\n::  d_step {j<2 && number[j]>max;max = number[j];j = j+1;}  goto choose; \n\n::  d_step {j<2 && number[j]<=max;j = j+1;}  goto choose; \n\n::  d_step {j==2 && max<9;number[0] = max+1;j = 0;choosing[0] = 0;}  goto for_loop; \n\nfi;\nfor_loop: if\n:: j<2 && choosing[j]==0; goto wait; \n\n:: j==2; goto CS; \n\nfi;\nwait: if\n::  d_step {number[j]==0 || (number[j]>number[0]) || (number[j]==number[0] && 0<=j);j = j+1;}  goto for_loop; \n\nfi;\nCS: if\n:: number[0] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte j=0;\nbyte max=0;\n\nNCS: if\n::  d_step {choosing[1] = 1;j = 0;max = 0;}  goto choose; \n\nfi;\nchoose: if\n::  d_step {j<2 && number[j]>max;max = number[j];j = j+1;}  goto choose; \n\n::  d_step {j<2 && number[j]<=max;j = j+1;}  goto choose; \n\n::  d_step {j==2 && max<9;number[1] = max+1;j = 0;choosing[1] = 0;}  goto for_loop; \n\nfi;\nfor_loop: if\n:: j<2 && choosing[j]==0; goto wait; \n\n:: j==2; goto CS; \n\nfi;\nwait: if\n::  d_step {number[j]==0 || (number[j]>number[1]) || (number[j]==number[1] && 1<=j);j = j+1;}  goto for_loop; \n\nfi;\nCS: if\n:: number[1] = 0; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte choosing[2];\nbyte number[2];\n\n\nactive proctype P_0() { \nbyte j=0;\nbyte max=0;\n\nNCS: if\n::  d_step {choosing[0] = 1;j = 0;max = 0;}  goto choose; \n\nfi;\nchoose: if\n::  d_step {j<2 && number[j]>max;max = number[j];j = j+1;}  goto choose; \n\n::  d_step {j<2 && number[j]<=max;j = j+1;}  goto choose; \n\n::  d_step {j==2 && max<6;number[0] = max+1;j = 0;choosing[0] = 0;}  goto for_loop; \n\nfi;\nfor_loop: if\n:: j<2 && choosing[j]==0; goto wait; \n\n:: j==2; goto CS; \n\nfi;\nwait: if\n::  d_step {number[j]==0 || (number[j]<number[0]) || (number[j]==number[0] && 0<=j);j = j+1;}  goto for_loop; \n\nfi;\nCS: if\n:: number[0] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte j=0;\nbyte max=0;\n\nNCS: if\n::  d_step {choosing[1] = 1;j = 0;max = 0;}  goto choose; \n\nfi;\nchoose: if\n::  d_step {j<2 && number[j]>max;max = number[j];j = j+1;}  goto choose; \n\n::  d_step {j<2 && number[j]<=max;j = j+1;}  goto choose; \n\n::  d_step {j==2 && max<6;number[1] = max+1;j = 0;choosing[1] = 0;}  goto for_loop; \n\nfi;\nfor_loop: if\n:: j<2 && choosing[j]==0; goto wait; \n\n:: j==2; goto CS; \n\nfi;\nwait: if\n::  d_step {number[j]==0 || (number[j]<number[1]) || (number[j]==number[1] && 1<=j);j = j+1;}  goto for_loop; \n\nfi;\nCS: if\n:: number[1] = 0; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte choosing[3];\nbyte number[3];\n\n\nactive proctype P_0() { \nbyte j=0;\nbyte max=0;\n\nNCS: if\n::  d_step {choosing[0] = 1;j = 0;max = 0;}  goto choose; \n\nfi;\nchoose: if\n::  d_step {j<3 && number[j]>max;max = number[j];j = j+1;}  goto choose; \n\n::  d_step {j<3 && number[j]<=max;j = j+1;}  goto choose; \n\n::  d_step {j==3 && max<4;number[0] = max+1;j = 0;choosing[0] = 0;}  goto for_loop; \n\nfi;\nfor_loop: if\n:: j<3 && choosing[j]==0; goto wait; \n\n:: j==3; goto CS; \n\nfi;\nwait: if\n::  d_step {number[j]==0 || (number[j]>number[0]) || (number[j]==number[0] && 0<=j);j = j+1;}  goto for_loop; \n\nfi;\nCS: if\n:: number[0] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte j=0;\nbyte max=0;\n\nNCS: if\n::  d_step {choosing[1] = 1;j = 0;max = 0;}  goto choose; \n\nfi;\nchoose: if\n::  d_step {j<3 && number[j]>max;max = number[j];j = j+1;}  goto choose; \n\n::  d_step {j<3 && number[j]<=max;j = j+1;}  goto choose; \n\n::  d_step {j==3 && max<4;number[1] = max+1;j = 0;choosing[1] = 0;}  goto for_loop; \n\nfi;\nfor_loop: if\n:: j<3 && choosing[j]==0; goto wait; \n\n:: j==3; goto CS; \n\nfi;\nwait: if\n::  d_step {number[j]==0 || (number[j]>number[1]) || (number[j]==number[1] && 1<=j);j = j+1;}  goto for_loop; \n\nfi;\nCS: if\n:: number[1] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte j=0;\nbyte max=0;\n\nNCS: if\n::  d_step {choosing[2] = 1;j = 0;max = 0;}  goto choose; \n\nfi;\nchoose: if\n::  d_step {j<3 && number[j]>max;max = number[j];j = j+1;}  goto choose; \n\n::  d_step {j<3 && number[j]<=max;j = j+1;}  goto choose; \n\n::  d_step {j==3 && max<4;number[2] = max+1;j = 0;choosing[2] = 0;}  goto for_loop; \n\nfi;\nfor_loop: if\n:: j<3 && choosing[j]==0; goto wait; \n\n:: j==3; goto CS; \n\nfi;\nwait: if\n::  d_step {number[j]==0 || (number[j]>number[2]) || (number[j]==number[2] && 2<=j);j = j+1;}  goto for_loop; \n\nfi;\nCS: if\n:: number[2] = 0; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte choosing[3];\nbyte number[3];\n\n\nactive proctype P_0() { \nbyte j=0;\nbyte max=0;\n\nNCS: if\n::  d_step {choosing[0] = 1;j = 0;max = 0;}  goto choose; \n\nfi;\nchoose: if\n::  d_step {j<3 && number[j]>max;max = number[j];j = j+1;}  goto choose; \n\n::  d_step {j<3 && number[j]<=max;j = j+1;}  goto choose; \n\n::  d_step {j==3 && max<6;number[0] = max+1;j = 0;choosing[0] = 0;}  goto for_loop; \n\nfi;\nfor_loop: if\n:: j<3 && choosing[j]==0; goto wait; \n\n:: j==3; goto CS; \n\nfi;\nwait: if\n::  d_step {number[j]==0 || (number[j]<number[0]) || (number[j]==number[0] && 0<=j);j = j+1;}  goto for_loop; \n\nfi;\nCS: if\n:: number[0] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte j=0;\nbyte max=0;\n\nNCS: if\n::  d_step {choosing[1] = 1;j = 0;max = 0;}  goto choose; \n\nfi;\nchoose: if\n::  d_step {j<3 && number[j]>max;max = number[j];j = j+1;}  goto choose; \n\n::  d_step {j<3 && number[j]<=max;j = j+1;}  goto choose; \n\n::  d_step {j==3 && max<6;number[1] = max+1;j = 0;choosing[1] = 0;}  goto for_loop; \n\nfi;\nfor_loop: if\n:: j<3 && choosing[j]==0; goto wait; \n\n:: j==3; goto CS; \n\nfi;\nwait: if\n::  d_step {number[j]==0 || (number[j]<number[1]) || (number[j]==number[1] && 1<=j);j = j+1;}  goto for_loop; \n\nfi;\nCS: if\n:: number[1] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte j=0;\nbyte max=0;\n\nNCS: if\n::  d_step {choosing[2] = 1;j = 0;max = 0;}  goto choose; \n\nfi;\nchoose: if\n::  d_step {j<3 && number[j]>max;max = number[j];j = j+1;}  goto choose; \n\n::  d_step {j<3 && number[j]<=max;j = j+1;}  goto choose; \n\n::  d_step {j==3 && max<6;number[2] = max+1;j = 0;choosing[2] = 0;}  goto for_loop; \n\nfi;\nfor_loop: if\n:: j<3 && choosing[j]==0; goto wait; \n\n:: j==3; goto CS; \n\nfi;\nwait: if\n::  d_step {number[j]==0 || (number[j]<number[2]) || (number[j]==number[2] && 2<=j);j = j+1;}  goto for_loop; \n\nfi;\nCS: if\n:: number[2] = 0; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte choosing[4];\nbyte number[4];\n\n\nactive proctype P_0() { \nbyte j=0;\nbyte max=0;\n\nNCS: if\n::  d_step {choosing[0] = 1;j = 0;max = 0;}  goto choose; \n\nfi;\nchoose: if\n::  d_step {j<4 && number[j]>max;max = number[j];j = j+1;}  goto choose; \n\n::  d_step {j<4 && number[j]<=max;j = j+1;}  goto choose; \n\n::  d_step {j==4 && max<7;number[0] = max+1;j = 0;choosing[0] = 0;}  goto for_loop; \n\nfi;\nfor_loop: if\n:: j<4 && choosing[j]==0; goto wait; \n\n:: j==4; goto CS; \n\nfi;\nwait: if\n::  d_step {number[j]==0 || (number[j]>number[0]) || (number[j]==number[0] && 0<=j);j = j+1;}  goto for_loop; \n\nfi;\nCS: if\n:: number[0] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte j=0;\nbyte max=0;\n\nNCS: if\n::  d_step {choosing[1] = 1;j = 0;max = 0;}  goto choose; \n\nfi;\nchoose: if\n::  d_step {j<4 && number[j]>max;max = number[j];j = j+1;}  goto choose; \n\n::  d_step {j<4 && number[j]<=max;j = j+1;}  goto choose; \n\n::  d_step {j==4 && max<7;number[1] = max+1;j = 0;choosing[1] = 0;}  goto for_loop; \n\nfi;\nfor_loop: if\n:: j<4 && choosing[j]==0; goto wait; \n\n:: j==4; goto CS; \n\nfi;\nwait: if\n::  d_step {number[j]==0 || (number[j]>number[1]) || (number[j]==number[1] && 1<=j);j = j+1;}  goto for_loop; \n\nfi;\nCS: if\n:: number[1] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte j=0;\nbyte max=0;\n\nNCS: if\n::  d_step {choosing[2] = 1;j = 0;max = 0;}  goto choose; \n\nfi;\nchoose: if\n::  d_step {j<4 && number[j]>max;max = number[j];j = j+1;}  goto choose; \n\n::  d_step {j<4 && number[j]<=max;j = j+1;}  goto choose; \n\n::  d_step {j==4 && max<7;number[2] = max+1;j = 0;choosing[2] = 0;}  goto for_loop; \n\nfi;\nfor_loop: if\n:: j<4 && choosing[j]==0; goto wait; \n\n:: j==4; goto CS; \n\nfi;\nwait: if\n::  d_step {number[j]==0 || (number[j]>number[2]) || (number[j]==number[2] && 2<=j);j = j+1;}  goto for_loop; \n\nfi;\nCS: if\n:: number[2] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_3() { \nbyte j=0;\nbyte max=0;\n\nNCS: if\n::  d_step {choosing[3] = 1;j = 0;max = 0;}  goto choose; \n\nfi;\nchoose: if\n::  d_step {j<4 && number[j]>max;max = number[j];j = j+1;}  goto choose; \n\n::  d_step {j<4 && number[j]<=max;j = j+1;}  goto choose; \n\n::  d_step {j==4 && max<7;number[3] = max+1;j = 0;choosing[3] = 0;}  goto for_loop; \n\nfi;\nfor_loop: if\n:: j<4 && choosing[j]==0; goto wait; \n\n:: j==4; goto CS; \n\nfi;\nwait: if\n::  d_step {number[j]==0 || (number[j]>number[3]) || (number[j]==number[3] && 3<=j);j = j+1;}  goto for_loop; \n\nfi;\nCS: if\n:: number[3] = 0; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte choosing[4];\nbyte number[4];\n\n\nactive proctype P_0() { \nbyte j=0;\nbyte max=0;\n\nNCS: if\n::  d_step {choosing[0] = 1;j = 0;max = 0;}  goto choose; \n\nfi;\nchoose: if\n::  d_step {j<4 && number[j]>max;max = number[j];j = j+1;}  goto choose; \n\n::  d_step {j<4 && number[j]<=max;j = j+1;}  goto choose; \n\n::  d_step {j==4 && max<5;number[0] = max+1;j = 0;choosing[0] = 0;}  goto for_loop; \n\nfi;\nfor_loop: if\n:: j<4 && choosing[j]==0; goto wait; \n\n:: j==4; goto CS; \n\nfi;\nwait: if\n::  d_step {number[j]==0 || (number[j]<number[0]) || (number[j]==number[0] && 0<=j);j = j+1;}  goto for_loop; \n\nfi;\nCS: if\n:: number[0] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte j=0;\nbyte max=0;\n\nNCS: if\n::  d_step {choosing[1] = 1;j = 0;max = 0;}  goto choose; \n\nfi;\nchoose: if\n::  d_step {j<4 && number[j]>max;max = number[j];j = j+1;}  goto choose; \n\n::  d_step {j<4 && number[j]<=max;j = j+1;}  goto choose; \n\n::  d_step {j==4 && max<5;number[1] = max+1;j = 0;choosing[1] = 0;}  goto for_loop; \n\nfi;\nfor_loop: if\n:: j<4 && choosing[j]==0; goto wait; \n\n:: j==4; goto CS; \n\nfi;\nwait: if\n::  d_step {number[j]==0 || (number[j]<number[1]) || (number[j]==number[1] && 1<=j);j = j+1;}  goto for_loop; \n\nfi;\nCS: if\n:: number[1] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte j=0;\nbyte max=0;\n\nNCS: if\n::  d_step {choosing[2] = 1;j = 0;max = 0;}  goto choose; \n\nfi;\nchoose: if\n::  d_step {j<4 && number[j]>max;max = number[j];j = j+1;}  goto choose; \n\n::  d_step {j<4 && number[j]<=max;j = j+1;}  goto choose; \n\n::  d_step {j==4 && max<5;number[2] = max+1;j = 0;choosing[2] = 0;}  goto for_loop; \n\nfi;\nfor_loop: if\n:: j<4 && choosing[j]==0; goto wait; \n\n:: j==4; goto CS; \n\nfi;\nwait: if\n::  d_step {number[j]==0 || (number[j]<number[2]) || (number[j]==number[2] && 2<=j);j = j+1;}  goto for_loop; \n\nfi;\nCS: if\n:: number[2] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_3() { \nbyte j=0;\nbyte max=0;\n\nNCS: if\n::  d_step {choosing[3] = 1;j = 0;max = 0;}  goto choose; \n\nfi;\nchoose: if\n::  d_step {j<4 && number[j]>max;max = number[j];j = j+1;}  goto choose; \n\n::  d_step {j<4 && number[j]<=max;j = j+1;}  goto choose; \n\n::  d_step {j==4 && max<5;number[3] = max+1;j = 0;choosing[3] = 0;}  goto for_loop; \n\nfi;\nfor_loop: if\n:: j<4 && choosing[j]==0; goto wait; \n\n:: j==4; goto CS; \n\nfi;\nwait: if\n::  d_step {number[j]==0 || (number[j]<number[3]) || (number[j]==number[3] && 3<=j);j = j+1;}  goto for_loop; \n\nfi;\nCS: if\n:: number[3] = 0; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte choosing[4];\nbyte number[4];\n\n\nactive proctype P_0() { \nbyte j=0;\nbyte max=0;\n\nNCS: if\n::  d_step {choosing[0] = 1;j = 0;max = 0;}  goto choose; \n\nfi;\nchoose: if\n::  d_step {j<4 && number[j]>max;max = number[j];j = j+1;}  goto choose; \n\n::  d_step {j<4 && number[j]<=max;j = j+1;}  goto choose; \n\n::  d_step {j==4 && max<12;number[0] = max+1;j = 0;choosing[0] = 0;}  goto for_loop; \n\nfi;\nfor_loop: if\n:: j<4 && choosing[j]==0; goto wait; \n\n:: j==4; goto CS; \n\nfi;\nwait: if\n::  d_step {number[j]==0 || (number[j]>number[0]) || (number[j]==number[0] && 0<=j);j = j+1;}  goto for_loop; \n\nfi;\nCS: if\n:: number[0] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte j=0;\nbyte max=0;\n\nNCS: if\n::  d_step {choosing[1] = 1;j = 0;max = 0;}  goto choose; \n\nfi;\nchoose: if\n::  d_step {j<4 && number[j]>max;max = number[j];j = j+1;}  goto choose; \n\n::  d_step {j<4 && number[j]<=max;j = j+1;}  goto choose; \n\n::  d_step {j==4 && max<12;number[1] = max+1;j = 0;choosing[1] = 0;}  goto for_loop; \n\nfi;\nfor_loop: if\n:: j<4 && choosing[j]==0; goto wait; \n\n:: j==4; goto CS; \n\nfi;\nwait: if\n::  d_step {number[j]==0 || (number[j]>number[1]) || (number[j]==number[1] && 1<=j);j = j+1;}  goto for_loop; \n\nfi;\nCS: if\n:: number[1] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte j=0;\nbyte max=0;\n\nNCS: if\n::  d_step {choosing[2] = 1;j = 0;max = 0;}  goto choose; \n\nfi;\nchoose: if\n::  d_step {j<4 && number[j]>max;max = number[j];j = j+1;}  goto choose; \n\n::  d_step {j<4 && number[j]<=max;j = j+1;}  goto choose; \n\n::  d_step {j==4 && max<12;number[2] = max+1;j = 0;choosing[2] = 0;}  goto for_loop; \n\nfi;\nfor_loop: if\n:: j<4 && choosing[j]==0; goto wait; \n\n:: j==4; goto CS; \n\nfi;\nwait: if\n::  d_step {number[j]==0 || (number[j]>number[2]) || (number[j]==number[2] && 2<=j);j = j+1;}  goto for_loop; \n\nfi;\nCS: if\n:: number[2] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_3() { \nbyte j=0;\nbyte max=0;\n\nNCS: if\n::  d_step {choosing[3] = 1;j = 0;max = 0;}  goto choose; \n\nfi;\nchoose: if\n::  d_step {j<4 && number[j]>max;max = number[j];j = j+1;}  goto choose; \n\n::  d_step {j<4 && number[j]<=max;j = j+1;}  goto choose; \n\n::  d_step {j==4 && max<12;number[3] = max+1;j = 0;choosing[3] = 0;}  goto for_loop; \n\nfi;\nfor_loop: if\n:: j<4 && choosing[j]==0; goto wait; \n\n:: j==4; goto CS; \n\nfi;\nwait: if\n::  d_step {number[j]==0 || (number[j]>number[3]) || (number[j]==number[3] && 3<=j);j = j+1;}  goto for_loop; \n\nfi;\nCS: if\n:: number[3] = 0; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte choosing[5];\nbyte number[5];\n\n\nactive proctype P_0() { \nbyte j=0;\nbyte max=0;\n\nNCS: if\n::  d_step {choosing[0] = 1;j = 0;max = 0;}  goto choose; \n\nfi;\nchoose: if\n::  d_step {j<5 && number[j]>max;max = number[j];j = j+1;}  goto choose; \n\n::  d_step {j<5 && number[j]<=max;j = j+1;}  goto choose; \n\n::  d_step {j==5 && max<5;number[0] = max+1;j = 0;choosing[0] = 0;}  goto for_loop; \n\nfi;\nfor_loop: if\n:: j<5 && choosing[j]==0; goto wait; \n\n:: j==5; goto CS; \n\nfi;\nwait: if\n::  d_step {number[j]==0 || (number[j]>number[0]) || (number[j]==number[0] && 0<=j);j = j+1;}  goto for_loop; \n\nfi;\nCS: if\n:: number[0] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte j=0;\nbyte max=0;\n\nNCS: if\n::  d_step {choosing[1] = 1;j = 0;max = 0;}  goto choose; \n\nfi;\nchoose: if\n::  d_step {j<5 && number[j]>max;max = number[j];j = j+1;}  goto choose; \n\n::  d_step {j<5 && number[j]<=max;j = j+1;}  goto choose; \n\n::  d_step {j==5 && max<5;number[1] = max+1;j = 0;choosing[1] = 0;}  goto for_loop; \n\nfi;\nfor_loop: if\n:: j<5 && choosing[j]==0; goto wait; \n\n:: j==5; goto CS; \n\nfi;\nwait: if\n::  d_step {number[j]==0 || (number[j]>number[1]) || (number[j]==number[1] && 1<=j);j = j+1;}  goto for_loop; \n\nfi;\nCS: if\n:: number[1] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte j=0;\nbyte max=0;\n\nNCS: if\n::  d_step {choosing[2] = 1;j = 0;max = 0;}  goto choose; \n\nfi;\nchoose: if\n::  d_step {j<5 && number[j]>max;max = number[j];j = j+1;}  goto choose; \n\n::  d_step {j<5 && number[j]<=max;j = j+1;}  goto choose; \n\n::  d_step {j==5 && max<5;number[2] = max+1;j = 0;choosing[2] = 0;}  goto for_loop; \n\nfi;\nfor_loop: if\n:: j<5 && choosing[j]==0; goto wait; \n\n:: j==5; goto CS; \n\nfi;\nwait: if\n::  d_step {number[j]==0 || (number[j]>number[2]) || (number[j]==number[2] && 2<=j);j = j+1;}  goto for_loop; \n\nfi;\nCS: if\n:: number[2] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_3() { \nbyte j=0;\nbyte max=0;\n\nNCS: if\n::  d_step {choosing[3] = 1;j = 0;max = 0;}  goto choose; \n\nfi;\nchoose: if\n::  d_step {j<5 && number[j]>max;max = number[j];j = j+1;}  goto choose; \n\n::  d_step {j<5 && number[j]<=max;j = j+1;}  goto choose; \n\n::  d_step {j==5 && max<5;number[3] = max+1;j = 0;choosing[3] = 0;}  goto for_loop; \n\nfi;\nfor_loop: if\n:: j<5 && choosing[j]==0; goto wait; \n\n:: j==5; goto CS; \n\nfi;\nwait: if\n::  d_step {number[j]==0 || (number[j]>number[3]) || (number[j]==number[3] && 3<=j);j = j+1;}  goto for_loop; \n\nfi;\nCS: if\n:: number[3] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_4() { \nbyte j=0;\nbyte max=0;\n\nNCS: if\n::  d_step {choosing[4] = 1;j = 0;max = 0;}  goto choose; \n\nfi;\nchoose: if\n::  d_step {j<5 && number[j]>max;max = number[j];j = j+1;}  goto choose; \n\n::  d_step {j<5 && number[j]<=max;j = j+1;}  goto choose; \n\n::  d_step {j==5 && max<5;number[4] = max+1;j = 0;choosing[4] = 0;}  goto for_loop; \n\nfi;\nfor_loop: if\n:: j<5 && choosing[j]==0; goto wait; \n\n:: j==5; goto CS; \n\nfi;\nwait: if\n::  d_step {number[j]==0 || (number[j]>number[4]) || (number[j]==number[4] && 4<=j);j = j+1;}  goto for_loop; \n\nfi;\nCS: if\n:: number[4] = 0; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Popular example from planning community. There is a set\n    of blocks on infinite table and the goal is to put blocks into a certain\n    configuration.\n\nParameters:\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte on[6];\nbyte clear[6];\nbyte holding=253;\n\n\ninit { \n d_step { \non[0] =2; on[1] =254; on[2] =254; on[3] =0; on[4] =1; on[5] =4; clear[0] =0; clear[1] =0; clear[2] =0; clear[3] =1; clear[4] =0; clear[5] =1; }\natomic { \nrun Hand();\n} }\n\nproctype Hand() { \n\nemptyhand: if\n:: on[3]==2 && on[2]==0 && on[0]==4 && on[4]==5 && on[5]==3; goto done; \n\n::  d_step {clear[0]==1 && on[0]==254;on[0] = 255;clear[0] = 0;holding = 0;}  goto fullhand; \n\n::  d_step {clear[1]==1 && on[1]==254;on[1] = 255;clear[1] = 0;holding = 1;}  goto fullhand; \n\n::  d_step {clear[2]==1 && on[2]==254;on[2] = 255;clear[2] = 0;holding = 2;}  goto fullhand; \n\n::  d_step {clear[3]==1 && on[3]==254;on[3] = 255;clear[3] = 0;holding = 3;}  goto fullhand; \n\n::  d_step {clear[4]==1 && on[4]==254;on[4] = 255;clear[4] = 0;holding = 4;}  goto fullhand; \n\n::  d_step {clear[5]==1 && on[5]==254;on[5] = 255;clear[5] = 0;holding = 5;}  goto fullhand; \n\n::  d_step {clear[0]==1 && on[0]!=254;clear[on[0]] = 1;on[0] = 255;clear[0] = 0;holding = 0;}  goto fullhand; \n\n::  d_step {clear[1]==1 && on[1]!=254;clear[on[1]] = 1;on[1] = 255;clear[1] = 0;holding = 1;}  goto fullhand; \n\n::  d_step {clear[2]==1 && on[2]!=254;clear[on[2]] = 1;on[2] = 255;clear[2] = 0;holding = 2;}  goto fullhand; \n\n::  d_step {clear[3]==1 && on[3]!=254;clear[on[3]] = 1;on[3] = 255;clear[3] = 0;holding = 3;}  goto fullhand; \n\n::  d_step {clear[4]==1 && on[4]!=254;clear[on[4]] = 1;on[4] = 255;clear[4] = 0;holding = 4;}  goto fullhand; \n\n::  d_step {clear[5]==1 && on[5]!=254;clear[on[5]] = 1;on[5] = 255;clear[5] = 0;holding = 5;}  goto fullhand; \n\nfi;\nfullhand: if\n::  d_step {clear[0]==1;clear[0] = 0;clear[holding] = 1;on[holding] = 0;holding = 253;}  goto emptyhand; \n\n::  d_step {clear[1]==1;clear[1] = 0;clear[holding] = 1;on[holding] = 1;holding = 253;}  goto emptyhand; \n\n::  d_step {clear[2]==1;clear[2] = 0;clear[holding] = 1;on[holding] = 2;holding = 253;}  goto emptyhand; \n\n::  d_step {clear[3]==1;clear[3] = 0;clear[holding] = 1;on[holding] = 3;holding = 253;}  goto emptyhand; \n\n::  d_step {clear[4]==1;clear[4] = 0;clear[holding] = 1;on[holding] = 4;holding = 253;}  goto emptyhand; \n\n::  d_step {clear[5]==1;clear[5] = 0;clear[holding] = 1;on[holding] = 5;holding = 253;}  goto emptyhand; \n\n::  d_step {clear[holding] = 1;on[holding] = 254;holding = 253;}  goto emptyhand; \n\nfi;\ndone: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Popular example from planning community. There is a set\n    of blocks on infinite table and the goal is to put blocks into a certain\n    configuration.\n\nParameters:\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte on[8];\nbyte clear[8];\nbyte holding=253;\n\n\ninit { \n d_step { \non[0] =2; on[1] =254; on[2] =254; on[3] =0; on[4] =1; on[5] =4; on[6] =254; on[7] =254; clear[0] =0; clear[1] =0; clear[2] =0; clear[3] =1; clear[4] =0; clear[5] =1; clear[6] =1; clear[7] =1; }\natomic { \nrun Hand();\n} }\n\nproctype Hand() { \n\nemptyhand: if\n:: on[3]==5 && on[5]==4 && on[4]==7 && on[7]==2 && on[2]==0 && on[0]==6 && on[6]==1; goto done; \n\n::  d_step {clear[0]==1 && on[0]==254;on[0] = 255;clear[0] = 0;holding = 0;}  goto fullhand; \n\n::  d_step {clear[1]==1 && on[1]==254;on[1] = 255;clear[1] = 0;holding = 1;}  goto fullhand; \n\n::  d_step {clear[2]==1 && on[2]==254;on[2] = 255;clear[2] = 0;holding = 2;}  goto fullhand; \n\n::  d_step {clear[3]==1 && on[3]==254;on[3] = 255;clear[3] = 0;holding = 3;}  goto fullhand; \n\n::  d_step {clear[4]==1 && on[4]==254;on[4] = 255;clear[4] = 0;holding = 4;}  goto fullhand; \n\n::  d_step {clear[5]==1 && on[5]==254;on[5] = 255;clear[5] = 0;holding = 5;}  goto fullhand; \n\n::  d_step {clear[6]==1 && on[6]==254;on[6] = 255;clear[6] = 0;holding = 6;}  goto fullhand; \n\n::  d_step {clear[7]==1 && on[7]==254;on[7] = 255;clear[7] = 0;holding = 7;}  goto fullhand; \n\n::  d_step {clear[0]==1 && on[0]!=254;clear[on[0]] = 1;on[0] = 255;clear[0] = 0;holding = 0;}  goto fullhand; \n\n::  d_step {clear[1]==1 && on[1]!=254;clear[on[1]] = 1;on[1] = 255;clear[1] = 0;holding = 1;}  goto fullhand; \n\n::  d_step {clear[2]==1 && on[2]!=254;clear[on[2]] = 1;on[2] = 255;clear[2] = 0;holding = 2;}  goto fullhand; \n\n::  d_step {clear[3]==1 && on[3]!=254;clear[on[3]] = 1;on[3] = 255;clear[3] = 0;holding = 3;}  goto fullhand; \n\n::  d_step {clear[4]==1 && on[4]!=254;clear[on[4]] = 1;on[4] = 255;clear[4] = 0;holding = 4;}  goto fullhand; \n\n::  d_step {clear[5]==1 && on[5]!=254;clear[on[5]] = 1;on[5] = 255;clear[5] = 0;holding = 5;}  goto fullhand; \n\n::  d_step {clear[6]==1 && on[6]!=254;clear[on[6]] = 1;on[6] = 255;clear[6] = 0;holding = 6;}  goto fullhand; \n\n::  d_step {clear[7]==1 && on[7]!=254;clear[on[7]] = 1;on[7] = 255;clear[7] = 0;holding = 7;}  goto fullhand; \n\nfi;\nfullhand: if\n::  d_step {clear[0]==1;clear[0] = 0;clear[holding] = 1;on[holding] = 0;holding = 253;}  goto emptyhand; \n\n::  d_step {clear[1]==1;clear[1] = 0;clear[holding] = 1;on[holding] = 1;holding = 253;}  goto emptyhand; \n\n::  d_step {clear[2]==1;clear[2] = 0;clear[holding] = 1;on[holding] = 2;holding = 253;}  goto emptyhand; \n\n::  d_step {clear[3]==1;clear[3] = 0;clear[holding] = 1;on[holding] = 3;holding = 253;}  goto emptyhand; \n\n::  d_step {clear[4]==1;clear[4] = 0;clear[holding] = 1;on[holding] = 4;holding = 253;}  goto emptyhand; \n\n::  d_step {clear[5]==1;clear[5] = 0;clear[holding] = 1;on[holding] = 5;holding = 253;}  goto emptyhand; \n\n::  d_step {clear[6]==1;clear[6] = 0;clear[holding] = 1;on[holding] = 6;holding = 253;}  goto emptyhand; \n\n::  d_step {clear[7]==1;clear[7] = 0;clear[holding] = 1;on[holding] = 7;holding = 253;}  goto emptyhand; \n\n::  d_step {clear[holding] = 1;on[holding] = 254;holding = 253;}  goto emptyhand; \n\nfi;\ndone: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Popular example from planning community. There is a set\n    of blocks on infinite table and the goal is to put blocks into a certain\n    configuration.\n\nParameters:\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte on[10];\nbyte clear[10];\nbyte holding=253;\n\n\ninit { \n d_step { \non[0] =3; on[1] =6; on[2] =4; on[3] =8; on[4] =9; on[5] =254; on[6] =7; on[7] =0; on[8] =254; on[9] =1; clear[0] =0; clear[1] =0; clear[2] =1; clear[3] =0; clear[4] =0; clear[5] =1; clear[6] =0; clear[7] =0; clear[8] =0; clear[9] =0; }\natomic { \nrun Hand();\n} }\n\nproctype Hand() { \n\nemptyhand: if\n:: on[3]==2 && on[2]==5 && on[5]==9 && on[9]==4 && on[4]==7 && on[7]==1 && on[1]==0 && on[0]==6 && on[6]==8; goto done; \n\n::  d_step {clear[0]==1 && on[0]==254;on[0] = 255;clear[0] = 0;holding = 0;}  goto fullhand; \n\n::  d_step {clear[1]==1 && on[1]==254;on[1] = 255;clear[1] = 0;holding = 1;}  goto fullhand; \n\n::  d_step {clear[2]==1 && on[2]==254;on[2] = 255;clear[2] = 0;holding = 2;}  goto fullhand; \n\n::  d_step {clear[3]==1 && on[3]==254;on[3] = 255;clear[3] = 0;holding = 3;}  goto fullhand; \n\n::  d_step {clear[4]==1 && on[4]==254;on[4] = 255;clear[4] = 0;holding = 4;}  goto fullhand; \n\n::  d_step {clear[5]==1 && on[5]==254;on[5] = 255;clear[5] = 0;holding = 5;}  goto fullhand; \n\n::  d_step {clear[6]==1 && on[6]==254;on[6] = 255;clear[6] = 0;holding = 6;}  goto fullhand; \n\n::  d_step {clear[7]==1 && on[7]==254;on[7] = 255;clear[7] = 0;holding = 7;}  goto fullhand; \n\n::  d_step {clear[8]==1 && on[8]==254;on[8] = 255;clear[8] = 0;holding = 8;}  goto fullhand; \n\n::  d_step {clear[9]==1 && on[9]==254;on[9] = 255;clear[9] = 0;holding = 9;}  goto fullhand; \n\n::  d_step {clear[0]==1 && on[0]!=254;clear[on[0]] = 1;on[0] = 255;clear[0] = 0;holding = 0;}  goto fullhand; \n\n::  d_step {clear[1]==1 && on[1]!=254;clear[on[1]] = 1;on[1] = 255;clear[1] = 0;holding = 1;}  goto fullhand; \n\n::  d_step {clear[2]==1 && on[2]!=254;clear[on[2]] = 1;on[2] = 255;clear[2] = 0;holding = 2;}  goto fullhand; \n\n::  d_step {clear[3]==1 && on[3]!=254;clear[on[3]] = 1;on[3] = 255;clear[3] = 0;holding = 3;}  goto fullhand; \n\n::  d_step {clear[4]==1 && on[4]!=254;clear[on[4]] = 1;on[4] = 255;clear[4] = 0;holding = 4;}  goto fullhand; \n\n::  d_step {clear[5]==1 && on[5]!=254;clear[on[5]] = 1;on[5] = 255;clear[5] = 0;holding = 5;}  goto fullhand; \n\n::  d_step {clear[6]==1 && on[6]!=254;clear[on[6]] = 1;on[6] = 255;clear[6] = 0;holding = 6;}  goto fullhand; \n\n::  d_step {clear[7]==1 && on[7]!=254;clear[on[7]] = 1;on[7] = 255;clear[7] = 0;holding = 7;}  goto fullhand; \n\n::  d_step {clear[8]==1 && on[8]!=254;clear[on[8]] = 1;on[8] = 255;clear[8] = 0;holding = 8;}  goto fullhand; \n\n::  d_step {clear[9]==1 && on[9]!=254;clear[on[9]] = 1;on[9] = 255;clear[9] = 0;holding = 9;}  goto fullhand; \n\nfi;\nfullhand: if\n::  d_step {clear[0]==1;clear[0] = 0;clear[holding] = 1;on[holding] = 0;holding = 253;}  goto emptyhand; \n\n::  d_step {clear[1]==1;clear[1] = 0;clear[holding] = 1;on[holding] = 1;holding = 253;}  goto emptyhand; \n\n::  d_step {clear[2]==1;clear[2] = 0;clear[holding] = 1;on[holding] = 2;holding = 253;}  goto emptyhand; \n\n::  d_step {clear[3]==1;clear[3] = 0;clear[holding] = 1;on[holding] = 3;holding = 253;}  goto emptyhand; \n\n::  d_step {clear[4]==1;clear[4] = 0;clear[holding] = 1;on[holding] = 4;holding = 253;}  goto emptyhand; \n\n::  d_step {clear[5]==1;clear[5] = 0;clear[holding] = 1;on[holding] = 5;holding = 253;}  goto emptyhand; \n\n::  d_step {clear[6]==1;clear[6] = 0;clear[holding] = 1;on[holding] = 6;holding = 253;}  goto emptyhand; \n\n::  d_step {clear[7]==1;clear[7] = 0;clear[holding] = 1;on[holding] = 7;holding = 253;}  goto emptyhand; \n\n::  d_step {clear[8]==1;clear[8] = 0;clear[holding] = 1;on[holding] = 8;holding = 253;}  goto emptyhand; \n\n::  d_step {clear[9]==1;clear[9] = 0;clear[holding] = 1;on[holding] = 9;holding = 253;}  goto emptyhand; \n\n::  d_step {clear[holding] = 1;on[holding] = 254;holding = 253;}  goto emptyhand; \n\nfi;\ndone: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "This protocol controls the transitions between stand-by\n    mode and power on mode in the company's new series of products, where power\n    consumption minimization is an important feature. (The model is manual\n    translation of the Uppaal model; currently without time)\n\nParameters:\n\n\n\nAtomic propositions:\n, , , , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte cur=0;\nbyte sleeping=0;\nbyte sleep_op=0;\nbyte sw_stand_by=0;\nbyte generated_ap_interrupt=0;\nbyte lsl_command=0;\nbyte lsl_running=0;\nbyte lsl_data=0;\nbyte ap_interrupt=0;\nbyte enabled_lsl_interrupt=0;\nbyte lsl_interrupt=0;\nbyte lsl_interrupt_ex=0;\nbyte generated_lsl_interrupt=0;\nbyte some_running=0;\nbyte some_data=0;\nbyte some_interrupt=0;\n\nchan ap_down =[0] of {int};\nchan ap_actv =[0] of {int};\nchan ap_down_ack =[0] of {int};\nchan ap_down_nack =[0] of {int};\nchan calc =[0] of {int};\n\nactive proctype AP() { \nbyte no_ap_ints=0;\n\nactv: if\n:: ap_actv?0; goto actv; \n\n::  d_step {no_ap_ints<1;generated_ap_interrupt = 1;no_ap_ints = no_ap_ints+1;}  goto actv; \n\n:: ap_down!0; goto prepare_ack; \n\nfi;\nprepare_ack: if\n:: ap_down!0; goto prepare_ack; \n\n:: ap_down_nack?0; goto actv; \n\n:: ap_down_ack?0; goto stand_by; \n\nfi;\nstand_by: if\n::  goto actv; \n\n:: ap_actv?0; goto actv; \n\nfi;\n}\n\nactive proctype LSL_Interrupt_Handler() { \n\nlsl_int_service: if\n::  d_step {cur==0 && enabled_lsl_interrupt==1 && generated_lsl_interrupt==1;cur = 1;lsl_interrupt_ex = 1;}  goto interrupt_received; \n\nfi;\ninterrupt_received: if\n:: cur==1 && sleeping==0; goto awake; \n\n::  d_step {cur==1 && sleeping==1;sleeping = 0;}  goto awake; \n\nfi;\nawake: if\n::  d_step {cur==1;enabled_lsl_interrupt = 0;generated_lsl_interrupt = 0;lsl_interrupt = 1;lsl_interrupt_ex = 0;some_interrupt = 1;}  goto check_stand_by; \n\nfi;\ncheck_stand_by: if\n::  d_step {cur==1 && sw_stand_by==0;cur = 0;}  goto lsl_int_service; \n\n:: cur==1 && sw_stand_by==1; goto insert_noop; \n\nfi;\ninsert_noop: if\n::  d_step {cur==1;sleep_op = 0;}  goto clear_stand_by; \n\nfi;\nclear_stand_by: if\n::  d_step {cur==1;sw_stand_by = 0;cur = 0;}  goto lsl_int_service; \n\nfi;\n}\n\nactive proctype AP_Interrupt_Handler() { \nbyte old_cur=0;\n\nap_int_service: if\n::  d_step {generated_ap_interrupt==1 && lsl_interrupt_ex==0;generated_ap_interrupt = 0;}  goto set_cur; \n\nfi;\nset_cur: if\n::  d_step {cur==0;old_cur = 0;cur = 2;}  goto interrupt_received; \n\n::  d_step {cur==1;old_cur = 1;cur = 2;}  goto interrupt_received; \n\nfi;\ninterrupt_received: if\n:: sleeping==0; goto awake; \n\n::  d_step {sleeping==1;sleeping = 0;}  goto awake; \n\nfi;\nawake: if\n::  d_step {enabled_lsl_interrupt = 0;generated_lsl_interrupt = 0;ap_interrupt = 1;some_interrupt = 1;}  goto check_stand_by; \n\nfi;\ncheck_stand_by: if\n:: sw_stand_by==0; goto reset_cur; \n\n:: sw_stand_by==1; goto insert_noop; \n\nfi;\nreset_cur: if\n::  d_step {old_cur==0;cur = 0;}  goto ap_int_service; \n\n::  d_step {old_cur==1;cur = 1;}  goto ap_int_service; \n\nfi;\ninsert_noop: if\n:: sleep_op = 0; goto clear_stand_by; \n\nfi;\nclear_stand_by: if\n:: sw_stand_by = 0; goto reset_cur; \n\nfi;\n}\n\nactive proctype Interrupt_Generator() { \nbyte no_lsl_ints=0;\n\ngenerate: if\n::  d_step {enabled_lsl_interrupt==1 && no_lsl_ints<2;generated_lsl_interrupt = 1;no_lsl_ints = no_lsl_ints+1;}  goto generate; \n\nfi;\n}\n\nactive proctype LSL_Driver() { \n\nstand_by: if\n::  d_step {cur==0 && lsl_command==3;lsl_command = 0;}  goto stand_by; \n\n::  d_step {cur==0 && lsl_command==1;lsl_command = 0;}  goto up_down_received; \n\n::  d_step {cur==0 && lsl_command==2;lsl_command = 0;}  goto up_down_received; \n\nfi;\nup_down_received: if\n:: cur==0; goto react; \n\nfi;\nreact: if\n::  d_step {cur==0;lsl_running = 0;lsl_data = 0;}  goto call; \n\n::  d_step {cur==0;lsl_running = 1;lsl_data = 1;some_running = 1;some_data = 1;}  goto stand_by; \n\nfi;\ncall: if\n:: calc!0; goto stand_by; \n\nfi;\n}\n\nactive proctype Calc() { \n\nidle: if\n:: calc?0; goto calc_data; \n\nfi;\ncalc_data: if\n:: lsl_data==1; goto calc_running; \n\n::  d_step {lsl_data==0;some_data = 0;}  goto calc_running; \n\nfi;\ncalc_running: if\n:: lsl_running==1; goto idle; \n\n::  d_step {lsl_running==0;some_running = 0;}  goto idle; \n\nfi;\n}\n\nactive proctype IOP() { \n\nactv: if\n::  atomic {cur==0;ap_down?0;}  goto down_received; \n\nfi;\ngoing_down: if\n::  d_step {cur==0;lsl_data = 0;some_data = 0;lsl_running = 1;some_running = 1;}  goto clear_interrupts; \n\nfi;\nclear_interrupts: if\n::  d_step {cur==0;ap_interrupt = 0;lsl_interrupt = 0;some_interrupt = 0;}  goto enable_lsl_interrupt; \n\nfi;\nenable_lsl_interrupt: if\n::  d_step {cur==0;enabled_lsl_interrupt = 1;generated_lsl_interrupt = 0;}  goto issue_down_lsl; \n\nfi;\nissue_down_lsl: if\n::  d_step {cur==0;lsl_command = 2;}  goto wait_for_down; \n\nfi;\nwait_for_down: if\n:: cur==0 && some_running==0; goto down_expected; \n\n:: cur==0 && some_data==1; goto down_expected; \n\nfi;\ndown_expected: if\n:: cur==0 && some_data==1; goto disable_lsl_interrupt; \n\n:: cur==0 && some_data==0; goto down_verified; \n\nfi;\ndisable_lsl_interrupt: if\n::  d_step {cur==0;enabled_lsl_interrupt = 0;generated_lsl_interrupt = 0;}  goto issue_actv_commands; \n\nfi;\ndown_verified: if\n:: ap_down_ack!0; goto insert_noop; \n\nfi;\ndown_received: if\n::  goto going_down; \n\nfi;\ninsert_noop: if\n::  d_step {cur==0;sleep_op = 1;}  goto set_stand_by; \n\nfi;\nset_stand_by: if\n::  d_step {cur==0;sw_stand_by = 1;}  goto check_interrupts; \n\nfi;\ncheck_interrupts: if\n:: cur==0 && some_interrupt==0; goto check_noop; \n\n:: cur==0 && some_interrupt==1; goto wake_up; \n\nfi;\ncheck_noop: if\n:: cur==0 && sleep_op==0; goto wake_up; \n\n::  d_step {cur==0 && sleep_op==1;sleeping = 1;}  goto w_stand_by; \n\nfi;\nw_stand_by: if\n:: cur==0; goto stand_by; \n\nfi;\nwake_up: if\n::  d_step {cur==0;sw_stand_by = 0;lsl_data = 0;some_data = 0;lsl_running = 1;some_running = 1;}  goto clear_int; \n\nfi;\nstand_by: if\n:: cur==0 && some_interrupt==1; goto wake_up; \n\nfi;\nclear_int: if\n::  d_step {cur==0;ap_interrupt = 0;lsl_interrupt = 0;some_interrupt = 0;}  goto issue_lsl_up; \n\nfi;\nissue_lsl_up: if\n::  d_step {cur==0;lsl_command = 1;}  goto wait_init_response; \n\nfi;\nwait_init_response: if\n:: cur==0 && some_running==0; goto data_expected; \n\n:: cur==0 && some_data==1; goto data_expected; \n\nfi;\ndata_expected: if\n:: cur==0 && some_data==1; goto s_actv; \n\n:: cur==0 && some_data==0; goto noise; \n\nfi;\nnoise: if\n::  d_step {cur==0;lsl_data = 0;some_data = 0;lsl_running = 1;some_running = 1;}  goto re_enable_lsl_interrupt; \n\nfi;\ns_actv: if\n:: ap_actv!0; goto now_wait; \n\nfi;\nnow_wait: if\n:: cur==0; goto actv; \n\nfi;\nre_enable_lsl_interrupt: if\n::  d_step {cur==0;enabled_lsl_interrupt = 1;}  goto re_issue_lsl_down; \n\nfi;\nre_issue_lsl_down: if\n::  d_step {cur==0;lsl_command = 2;}  goto wait_response; \n\nfi;\nwait_response: if\n:: cur==0 && some_running==0; goto observe_status; \n\n:: cur==0 && some_data==1; goto observe_status; \n\nfi;\nobserve_status: if\n:: cur==0 && some_data==0; goto insert_noop; \n\n:: cur==0 && some_data==1; goto clear_lsl_interrupt; \n\nfi;\nclear_lsl_interrupt: if\n::  d_step {cur==0;enabled_lsl_interrupt = 0;generated_lsl_interrupt = 0;}  goto send_actv_command; \n\nfi;\nsend_actv_command: if\n::  atomic {ap_actv!0;lsl_command = 3;}  goto back_to_actv; \n\nfi;\nback_to_actv: if\n:: cur==0; goto actv; \n\nfi;\nissue_actv_commands: if\n::  d_step {cur==0;lsl_command = 3;}  goto send_nack; \n\nfi;\nsend_nack: if\n:: ap_down_nack!0; goto enter_actv; \n\nfi;\nenter_actv: if\n:: cur==0; goto actv; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "This protocol controls the transitions between stand-by\n    mode and power on mode in the company's new series of products, where power\n    consumption minimization is an important feature. (The model is manual\n    translation of the Uppaal model; currently without time)\n\nParameters:\n\n\n\nAtomic propositions:\n, , , , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte cur=0;\nbyte sleeping=0;\nbyte sleep_op=0;\nbyte sw_stand_by=0;\nbyte generated_ap_interrupt=0;\nbyte lsl_command=0;\nbyte lsl_running=0;\nbyte lsl_data=0;\nbyte ap_interrupt=0;\nbyte enabled_lsl_interrupt=0;\nbyte lsl_interrupt=0;\nbyte lsl_interrupt_ex=0;\nbyte generated_lsl_interrupt=0;\nbyte some_running=0;\nbyte some_data=0;\nbyte some_interrupt=0;\n\nchan ap_down =[0] of {int};\nchan ap_actv =[0] of {int};\nchan ap_down_ack =[0] of {int};\nchan ap_down_nack =[0] of {int};\nchan calc =[0] of {int};\n\nactive proctype AP() { \n\nactv: if\n:: ap_actv?0; goto actv; \n\n:: generated_ap_interrupt = 1; goto actv; \n\n:: ap_down!0; goto prepare_ack; \n\nfi;\nprepare_ack: if\n:: ap_down!0; goto prepare_ack; \n\n:: ap_down_nack?0; goto actv; \n\n:: ap_down_ack?0; goto stand_by; \n\nfi;\nstand_by: if\n::  goto actv; \n\n:: ap_actv?0; goto actv; \n\nfi;\n}\n\nactive proctype LSL_Interrupt_Handler() { \n\nlsl_int_service: if\n::  d_step {cur==0 && enabled_lsl_interrupt==1 && generated_lsl_interrupt==1;cur = 1;lsl_interrupt_ex = 1;}  goto interrupt_received; \n\nfi;\ninterrupt_received: if\n:: cur==1 && sleeping==0; goto awake; \n\n::  d_step {cur==1 && sleeping==1;sleeping = 0;}  goto awake; \n\nfi;\nawake: if\n::  d_step {cur==1;enabled_lsl_interrupt = 0;generated_lsl_interrupt = 0;lsl_interrupt = 1;lsl_interrupt_ex = 0;some_interrupt = 1;}  goto check_stand_by; \n\nfi;\ncheck_stand_by: if\n::  d_step {cur==1 && sw_stand_by==0;cur = 0;}  goto lsl_int_service; \n\n:: cur==1 && sw_stand_by==1; goto insert_noop; \n\nfi;\ninsert_noop: if\n::  d_step {cur==1;sleep_op = 0;}  goto clear_stand_by; \n\nfi;\nclear_stand_by: if\n::  d_step {cur==1;sw_stand_by = 0;cur = 0;}  goto lsl_int_service; \n\nfi;\n}\n\nactive proctype AP_Interrupt_Handler() { \nbyte old_cur=0;\n\nap_int_service: if\n::  d_step {generated_ap_interrupt==1 && lsl_interrupt_ex==0;generated_ap_interrupt = 0;}  goto set_cur; \n\nfi;\nset_cur: if\n::  d_step {cur==0;old_cur = 0;cur = 2;}  goto interrupt_received; \n\n::  d_step {cur==1;old_cur = 1;cur = 2;}  goto interrupt_received; \n\nfi;\ninterrupt_received: if\n:: sleeping==0; goto awake; \n\n::  d_step {sleeping==1;sleeping = 0;}  goto awake; \n\nfi;\nawake: if\n::  d_step {enabled_lsl_interrupt = 0;generated_lsl_interrupt = 0;ap_interrupt = 1;some_interrupt = 1;}  goto check_stand_by; \n\nfi;\ncheck_stand_by: if\n:: sw_stand_by==0; goto reset_cur; \n\n:: sw_stand_by==1; goto insert_noop; \n\nfi;\nreset_cur: if\n::  d_step {old_cur==0;cur = 0;}  goto ap_int_service; \n\n::  d_step {old_cur==1;cur = 1;}  goto ap_int_service; \n\nfi;\ninsert_noop: if\n:: sleep_op = 0; goto clear_stand_by; \n\nfi;\nclear_stand_by: if\n:: sw_stand_by = 0; goto reset_cur; \n\nfi;\n}\n\nactive proctype Interrupt_Generator() { \n\ngenerate: if\n::  d_step {enabled_lsl_interrupt==1;generated_lsl_interrupt = 1;}  goto generate; \n\nfi;\n}\n\nactive proctype LSL_Driver() { \n\nstand_by: if\n::  d_step {cur==0 && lsl_command==3;lsl_command = 0;}  goto stand_by; \n\n::  d_step {cur==0 && lsl_command==1;lsl_command = 0;}  goto up_down_received; \n\n::  d_step {cur==0 && lsl_command==2;lsl_command = 0;}  goto up_down_received; \n\nfi;\nup_down_received: if\n:: cur==0; goto react; \n\nfi;\nreact: if\n::  d_step {cur==0;lsl_running = 0;lsl_data = 0;}  goto call; \n\n::  d_step {cur==0;lsl_running = 1;lsl_data = 1;some_running = 1;some_data = 1;}  goto stand_by; \n\nfi;\ncall: if\n:: calc!0; goto stand_by; \n\nfi;\n}\n\nactive proctype Calc() { \n\nidle: if\n:: calc?0; goto calc_data; \n\nfi;\ncalc_data: if\n:: lsl_data==1; goto calc_running; \n\n::  d_step {lsl_data==0;some_data = 0;}  goto calc_running; \n\nfi;\ncalc_running: if\n:: lsl_running==1; goto idle; \n\n::  d_step {lsl_running==0;some_running = 0;}  goto idle; \n\nfi;\n}\n\nactive proctype IOP() { \n\nactv: if\n::  atomic {cur==0;ap_down?0;}  goto down_received; \n\nfi;\ngoing_down: if\n::  d_step {cur==0;lsl_data = 0;some_data = 0;lsl_running = 1;some_running = 1;}  goto clear_interrupts; \n\nfi;\nclear_interrupts: if\n::  d_step {cur==0;ap_interrupt = 0;lsl_interrupt = 0;some_interrupt = 0;}  goto enable_lsl_interrupt; \n\nfi;\nenable_lsl_interrupt: if\n::  d_step {cur==0;enabled_lsl_interrupt = 1;generated_lsl_interrupt = 0;}  goto issue_down_lsl; \n\nfi;\nissue_down_lsl: if\n::  d_step {cur==0;lsl_command = 2;}  goto wait_for_down; \n\nfi;\nwait_for_down: if\n:: cur==0 && some_running==0; goto down_expected; \n\n:: cur==0 && some_data==1; goto down_expected; \n\nfi;\ndown_expected: if\n:: cur==0 && some_data==1; goto disable_lsl_interrupt; \n\n:: cur==0 && some_data==0; goto down_verified; \n\nfi;\ndisable_lsl_interrupt: if\n::  d_step {cur==0;enabled_lsl_interrupt = 0;generated_lsl_interrupt = 0;}  goto issue_actv_commands; \n\nfi;\ndown_verified: if\n:: ap_down_ack!0; goto insert_noop; \n\nfi;\ndown_received: if\n::  goto going_down; \n\nfi;\ninsert_noop: if\n::  d_step {cur==0;sleep_op = 1;}  goto set_stand_by; \n\nfi;\nset_stand_by: if\n::  d_step {cur==0;sw_stand_by = 1;}  goto check_interrupts; \n\nfi;\ncheck_interrupts: if\n:: cur==0 && some_interrupt==0; goto check_noop; \n\n:: cur==0 && some_interrupt==1; goto wake_up; \n\nfi;\ncheck_noop: if\n:: cur==0 && sleep_op==0; goto wake_up; \n\n::  d_step {cur==0 && sleep_op==1;sleeping = 1;}  goto w_stand_by; \n\nfi;\nw_stand_by: if\n:: cur==0; goto stand_by; \n\nfi;\nwake_up: if\n::  d_step {cur==0;sw_stand_by = 0;lsl_data = 0;some_data = 0;lsl_running = 1;some_running = 1;}  goto clear_int; \n\nfi;\nstand_by: if\n:: cur==0 && some_interrupt==1; goto wake_up; \n\nfi;\nclear_int: if\n::  d_step {cur==0;ap_interrupt = 0;lsl_interrupt = 0;some_interrupt = 0;}  goto issue_lsl_up; \n\nfi;\nissue_lsl_up: if\n::  d_step {cur==0;lsl_command = 1;}  goto wait_init_response; \n\nfi;\nwait_init_response: if\n:: cur==0 && some_running==0; goto data_expected; \n\n:: cur==0 && some_data==1; goto data_expected; \n\nfi;\ndata_expected: if\n:: cur==0 && some_data==1; goto s_actv; \n\n:: cur==0 && some_data==0; goto noise; \n\nfi;\nnoise: if\n::  d_step {cur==0;lsl_data = 0;some_data = 0;lsl_running = 1;some_running = 1;}  goto re_enable_lsl_interrupt; \n\nfi;\ns_actv: if\n:: ap_actv!0; goto now_wait; \n\nfi;\nnow_wait: if\n:: cur==0; goto actv; \n\nfi;\nre_enable_lsl_interrupt: if\n::  d_step {cur==0;enabled_lsl_interrupt = 1;}  goto re_issue_lsl_down; \n\nfi;\nre_issue_lsl_down: if\n::  d_step {cur==0;lsl_command = 2;}  goto wait_response; \n\nfi;\nwait_response: if\n:: cur==0 && some_running==0; goto observe_status; \n\n:: cur==0 && some_data==1; goto observe_status; \n\nfi;\nobserve_status: if\n:: cur==0 && some_data==0; goto insert_noop; \n\n:: cur==0 && some_data==1; goto clear_lsl_interrupt; \n\nfi;\nclear_lsl_interrupt: if\n::  d_step {cur==0;enabled_lsl_interrupt = 0;generated_lsl_interrupt = 0;}  goto send_actv_command; \n\nfi;\nsend_actv_command: if\n::  atomic {ap_actv!0;lsl_command = 3;}  goto back_to_actv; \n\nfi;\nback_to_actv: if\n:: cur==0; goto actv; \n\nfi;\nissue_actv_commands: if\n::  d_step {cur==0;lsl_command = 3;}  goto send_nack; \n\nfi;\nsend_nack: if\n:: ap_down_nack!0; goto enter_actv; \n\nfi;\nenter_actv: if\n:: cur==0; goto actv; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "This protocol controls the transitions between stand-by\n    mode and power on mode in the company's new series of products, where power\n    consumption minimization is an important feature. (The model is manual\n    translation of the Uppaal model; currently without time)\n\nParameters:\n\n\n\nAtomic propositions:\n, , , , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte cur=0;\nbyte sleeping=0;\nbyte sleep_op=0;\nbyte sw_stand_by=0;\nbyte generated_ap_interrupt=0;\nbyte lsl_command=0;\nbyte lsl_running=0;\nbyte lsl_data=0;\nbyte ap_interrupt=0;\nbyte enabled_lsl_interrupt=0;\nbyte lsl_interrupt=0;\nbyte lsl_interrupt_ex=0;\nbyte generated_lsl_interrupt=0;\nbyte some_running=0;\nbyte some_data=0;\nbyte some_interrupt=0;\n\nchan ap_down =[0] of {int};\nchan ap_actv =[0] of {int};\nchan ap_down_ack =[0] of {int};\nchan ap_down_nack =[0] of {int};\nchan calc =[0] of {int};\n\nactive proctype AP() { \nbyte no_ap_ints=0;\n\nactv: if\n:: ap_actv?0; goto actv; \n\n::  d_step {no_ap_ints<7;generated_ap_interrupt = 1;no_ap_ints = no_ap_ints+1;}  goto actv; \n\n:: ap_down!0; goto prepare_ack; \n\nfi;\nprepare_ack: if\n:: ap_down!0; goto prepare_ack; \n\n:: ap_down_nack?0; goto actv; \n\n:: ap_down_ack?0; goto stand_by; \n\nfi;\nstand_by: if\n::  goto actv; \n\n:: ap_actv?0; goto actv; \n\nfi;\n}\n\nactive proctype LSL_Interrupt_Handler() { \n\nlsl_int_service: if\n::  d_step {cur==0 && enabled_lsl_interrupt==1 && generated_lsl_interrupt==1;cur = 1;lsl_interrupt_ex = 1;}  goto interrupt_received; \n\nfi;\ninterrupt_received: if\n:: cur==1 && sleeping==0; goto awake; \n\n::  d_step {cur==1 && sleeping==1;sleeping = 0;}  goto awake; \n\nfi;\nawake: if\n::  d_step {cur==1;enabled_lsl_interrupt = 0;generated_lsl_interrupt = 0;lsl_interrupt = 1;lsl_interrupt_ex = 0;some_interrupt = 1;}  goto check_stand_by; \n\nfi;\ncheck_stand_by: if\n::  d_step {cur==1 && sw_stand_by==0;cur = 0;}  goto lsl_int_service; \n\n:: cur==1 && sw_stand_by==1; goto insert_noop; \n\nfi;\ninsert_noop: if\n::  d_step {cur==1;sleep_op = 0;}  goto clear_stand_by; \n\nfi;\nclear_stand_by: if\n::  d_step {cur==1;sw_stand_by = 0;cur = 0;}  goto lsl_int_service; \n\nfi;\n}\n\nactive proctype AP_Interrupt_Handler() { \nbyte old_cur=0;\n\nap_int_service: if\n::  d_step {generated_ap_interrupt==1 && lsl_interrupt_ex==0;generated_ap_interrupt = 0;}  goto set_cur; \n\nfi;\nset_cur: if\n::  d_step {cur==0;old_cur = 0;cur = 2;}  goto interrupt_received; \n\n::  d_step {cur==1;old_cur = 1;cur = 2;}  goto interrupt_received; \n\nfi;\ninterrupt_received: if\n:: sleeping==0; goto awake; \n\n::  d_step {sleeping==1;sleeping = 0;}  goto awake; \n\nfi;\nawake: if\n::  d_step {enabled_lsl_interrupt = 0;generated_lsl_interrupt = 0;ap_interrupt = 1;some_interrupt = 1;}  goto check_stand_by; \n\nfi;\ncheck_stand_by: if\n:: sw_stand_by==0; goto reset_cur; \n\n:: sw_stand_by==1; goto insert_noop; \n\nfi;\nreset_cur: if\n::  d_step {old_cur==0;cur = 0;}  goto ap_int_service; \n\n::  d_step {old_cur==1;cur = 1;}  goto ap_int_service; \n\nfi;\ninsert_noop: if\n:: sleep_op = 0; goto clear_stand_by; \n\nfi;\nclear_stand_by: if\n:: sw_stand_by = 0; goto reset_cur; \n\nfi;\n}\n\nactive proctype Interrupt_Generator() { \nbyte no_lsl_ints=0;\n\ngenerate: if\n::  d_step {enabled_lsl_interrupt==1 && no_lsl_ints<7;generated_lsl_interrupt = 1;no_lsl_ints = no_lsl_ints+1;}  goto generate; \n\nfi;\n}\n\nactive proctype LSL_Driver() { \n\nstand_by: if\n::  d_step {cur==0 && lsl_command==3;lsl_command = 0;}  goto stand_by; \n\n::  d_step {cur==0 && lsl_command==1;lsl_command = 0;}  goto up_down_received; \n\n::  d_step {cur==0 && lsl_command==2;lsl_command = 0;}  goto up_down_received; \n\nfi;\nup_down_received: if\n:: cur==0; goto react; \n\nfi;\nreact: if\n::  d_step {cur==0;lsl_running = 0;lsl_data = 0;}  goto call; \n\n::  d_step {cur==0;lsl_running = 1;lsl_data = 1;some_running = 1;some_data = 1;}  goto stand_by; \n\nfi;\ncall: if\n:: calc!0; goto stand_by; \n\nfi;\n}\n\nactive proctype Calc() { \n\nidle: if\n:: calc?0; goto calc_data; \n\nfi;\ncalc_data: if\n:: lsl_data==1; goto calc_running; \n\n::  d_step {lsl_data==0;some_data = 0;}  goto calc_running; \n\nfi;\ncalc_running: if\n:: lsl_running==1; goto idle; \n\n::  d_step {lsl_running==0;some_running = 0;}  goto idle; \n\nfi;\n}\n\nactive proctype IOP() { \n\nactv: if\n::  atomic {cur==0;ap_down?0;}  goto down_received; \n\nfi;\ngoing_down: if\n::  d_step {cur==0;lsl_data = 0;some_data = 0;lsl_running = 1;some_running = 1;}  goto clear_interrupts; \n\nfi;\nclear_interrupts: if\n::  d_step {cur==0;ap_interrupt = 0;lsl_interrupt = 0;some_interrupt = 0;}  goto enable_lsl_interrupt; \n\nfi;\nenable_lsl_interrupt: if\n::  d_step {cur==0;enabled_lsl_interrupt = 1;generated_lsl_interrupt = 0;}  goto issue_down_lsl; \n\nfi;\nissue_down_lsl: if\n::  d_step {cur==0;lsl_command = 2;}  goto wait_for_down; \n\nfi;\nwait_for_down: if\n:: cur==0 && some_running==0; goto down_expected; \n\n:: cur==0 && some_data==1; goto down_expected; \n\nfi;\ndown_expected: if\n:: cur==0 && some_data==1; goto disable_lsl_interrupt; \n\n:: cur==0 && some_data==0; goto down_verified; \n\nfi;\ndisable_lsl_interrupt: if\n::  d_step {cur==0;enabled_lsl_interrupt = 0;generated_lsl_interrupt = 0;}  goto issue_actv_commands; \n\nfi;\ndown_verified: if\n:: ap_down_ack!0; goto insert_noop; \n\nfi;\ndown_received: if\n::  goto going_down; \n\nfi;\ninsert_noop: if\n::  d_step {cur==0;sleep_op = 1;}  goto set_stand_by; \n\nfi;\nset_stand_by: if\n::  d_step {cur==0;sw_stand_by = 1;}  goto check_interrupts; \n\nfi;\ncheck_interrupts: if\n:: cur==0 && some_interrupt==0; goto check_noop; \n\n:: cur==0 && some_interrupt==1; goto wake_up; \n\nfi;\ncheck_noop: if\n:: cur==0 && sleep_op==0; goto wake_up; \n\n::  d_step {cur==0 && sleep_op==1;sleeping = 1;}  goto w_stand_by; \n\nfi;\nw_stand_by: if\n:: cur==0; goto stand_by; \n\nfi;\nwake_up: if\n::  d_step {cur==0;sw_stand_by = 0;lsl_data = 0;some_data = 0;lsl_running = 1;some_running = 1;}  goto clear_int; \n\nfi;\nstand_by: if\n:: cur==0 && some_interrupt==1; goto wake_up; \n\nfi;\nclear_int: if\n::  d_step {cur==0;ap_interrupt = 0;lsl_interrupt = 0;some_interrupt = 0;}  goto issue_lsl_up; \n\nfi;\nissue_lsl_up: if\n::  d_step {cur==0;lsl_command = 1;}  goto wait_init_response; \n\nfi;\nwait_init_response: if\n:: cur==0 && some_running==0; goto data_expected; \n\n:: cur==0 && some_data==1; goto data_expected; \n\nfi;\ndata_expected: if\n:: cur==0 && some_data==1; goto s_actv; \n\n:: cur==0 && some_data==0; goto noise; \n\nfi;\nnoise: if\n::  d_step {cur==0;lsl_data = 0;some_data = 0;lsl_running = 1;some_running = 1;}  goto re_enable_lsl_interrupt; \n\nfi;\ns_actv: if\n:: ap_actv!0; goto now_wait; \n\nfi;\nnow_wait: if\n:: cur==0; goto actv; \n\nfi;\nre_enable_lsl_interrupt: if\n::  d_step {cur==0;enabled_lsl_interrupt = 1;}  goto re_issue_lsl_down; \n\nfi;\nre_issue_lsl_down: if\n::  d_step {cur==0;lsl_command = 2;}  goto wait_response; \n\nfi;\nwait_response: if\n:: cur==0 && some_running==0; goto observe_status; \n\n:: cur==0 && some_data==1; goto observe_status; \n\nfi;\nobserve_status: if\n:: cur==0 && some_data==0; goto insert_noop; \n\n:: cur==0 && some_data==1; goto clear_lsl_interrupt; \n\nfi;\nclear_lsl_interrupt: if\n::  d_step {cur==0;enabled_lsl_interrupt = 0;generated_lsl_interrupt = 0;}  goto send_actv_command; \n\nfi;\nsend_actv_command: if\n::  atomic {ap_actv!0;lsl_command = 3;}  goto back_to_actv; \n\nfi;\nback_to_actv: if\n:: cur==0; goto actv; \n\nfi;\nissue_actv_commands: if\n::  d_step {cur==0;lsl_command = 3;}  goto send_nack; \n\nfi;\nsend_nack: if\n:: ap_down_nack!0; goto enter_actv; \n\nfi;\nenter_actv: if\n:: cur==0; goto actv; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Four men have to cross a bridge at night. The bridge is\n  old and dilapidated and can hold at most two people at a time. There are no\n  railings, and the men have only one flashlight. Any party who crosses, either\n  one or two men, must carry the flashlight with them. The flashlight must be\n  walked back and forth; it cannot be thrown, etc. Each man walks at a\n  different speed. One takes 5 minute to cross, another 10 minutes, another 20,\n  and the last 25 minutes. If two men cross together, they must walk at the\n  slower man's pace. Can they get to the other side in 60 minutes? (The model\n  is generalized to larger number of men.)\n\nParameters:\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte total_time=0;\nbyte where_is_torch=0;\nbyte on_right=0;\n\nchan wanna_go =[0] of {int};\nchan lets_go =[0] of {int};\n\nactive proctype torch() { \nbyte time1=0;\nbyte time2=0;\n\nfree: if\n:: wanna_go?time1; goto one; \n\nfi;\none: if\n:: wanna_go?time2; goto two; \n\n::  goto going; \n\nfi;\ntwo: if\n::  atomic {time1>=time2;lets_go!0;}  goto going; \n\n::  atomic {time1<time2;lets_go!0;time1 = time2;time2 = 0;}  goto going; \n\nfi;\ngoing: if\n::  atomic {total_time+time1<=60;lets_go!0;total_time = total_time+time1;time1 = 0;where_is_torch = 1-where_is_torch;}  goto free; \n\nfi;\n}\n\nactive proctype soldier_1() { \n\nleft: if\n::  atomic {where_is_torch==0;wanna_go!5;}  goto go_right; \n\nfi;\ngo_right: if\n::  atomic {lets_go?0;on_right = on_right+1;}  goto right; \n\nfi;\nright: if\n::  atomic {where_is_torch==1;wanna_go!5;on_right = on_right-1;}  goto go_left; \n\nfi;\ngo_left: if\n:: lets_go?0; goto left; \n\nfi;\n}\n\nactive proctype soldier_2() { \n\nleft: if\n::  atomic {where_is_torch==0;wanna_go!10;}  goto go_right; \n\nfi;\ngo_right: if\n::  atomic {lets_go?0;on_right = on_right+1;}  goto right; \n\nfi;\nright: if\n::  atomic {where_is_torch==1;wanna_go!10;on_right = on_right-1;}  goto go_left; \n\nfi;\ngo_left: if\n:: lets_go?0; goto left; \n\nfi;\n}\n\nactive proctype soldier_3() { \n\nleft: if\n::  atomic {where_is_torch==0;wanna_go!20;}  goto go_right; \n\nfi;\ngo_right: if\n::  atomic {lets_go?0;on_right = on_right+1;}  goto right; \n\nfi;\nright: if\n::  atomic {where_is_torch==1;wanna_go!20;on_right = on_right-1;}  goto go_left; \n\nfi;\ngo_left: if\n:: lets_go?0; goto left; \n\nfi;\n}\n\nactive proctype soldier_4() { \n\nleft: if\n::  atomic {where_is_torch==0;wanna_go!25;}  goto go_right; \n\nfi;\ngo_right: if\n::  atomic {lets_go?0;on_right = on_right+1;}  goto right; \n\nfi;\nright: if\n::  atomic {where_is_torch==1;wanna_go!25;on_right = on_right-1;}  goto go_left; \n\nfi;\ngo_left: if\n:: lets_go?0; goto left; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Four men have to cross a bridge at night. The bridge is\n  old and dilapidated and can hold at most two people at a time. There are no\n  railings, and the men have only one flashlight. Any party who crosses, either\n  one or two men, must carry the flashlight with them. The flashlight must be\n  walked back and forth; it cannot be thrown, etc. Each man walks at a\n  different speed. One takes 5 minute to cross, another 10 minutes, another 20,\n  and the last 25 minutes. If two men cross together, they must walk at the\n  slower man's pace. Can they get to the other side in 60 minutes? (The model\n  is generalized to larger number of men.)\n\nParameters:\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte total_time=0;\nbyte where_is_torch=0;\nbyte on_right=0;\n\nchan wanna_go =[0] of {int};\nchan lets_go =[0] of {int};\n\nactive proctype torch() { \nbyte time1=0;\nbyte time2=0;\n\nfree: if\n:: wanna_go?time1; goto one; \n\nfi;\none: if\n:: wanna_go?time2; goto two; \n\n::  goto going; \n\nfi;\ntwo: if\n::  atomic {time1>=time2;lets_go!0;}  goto going; \n\n::  atomic {time1<time2;lets_go!0;time1 = time2;time2 = 0;}  goto going; \n\nfi;\ngoing: if\n::  atomic {total_time+time1<=140;lets_go!0;total_time = total_time+time1;time1 = 0;where_is_torch = 1-where_is_torch;}  goto free; \n\nfi;\n}\n\nactive proctype soldier_1() { \n\nleft: if\n::  atomic {where_is_torch==0;wanna_go!5;}  goto go_right; \n\nfi;\ngo_right: if\n::  atomic {lets_go?0;on_right = on_right+1;}  goto right; \n\nfi;\nright: if\n::  atomic {where_is_torch==1;wanna_go!5;on_right = on_right-1;}  goto go_left; \n\nfi;\ngo_left: if\n:: lets_go?0; goto left; \n\nfi;\n}\n\nactive proctype soldier_2() { \n\nleft: if\n::  atomic {where_is_torch==0;wanna_go!10;}  goto go_right; \n\nfi;\ngo_right: if\n::  atomic {lets_go?0;on_right = on_right+1;}  goto right; \n\nfi;\nright: if\n::  atomic {where_is_torch==1;wanna_go!10;on_right = on_right-1;}  goto go_left; \n\nfi;\ngo_left: if\n:: lets_go?0; goto left; \n\nfi;\n}\n\nactive proctype soldier_3() { \n\nleft: if\n::  atomic {where_is_torch==0;wanna_go!20;}  goto go_right; \n\nfi;\ngo_right: if\n::  atomic {lets_go?0;on_right = on_right+1;}  goto right; \n\nfi;\nright: if\n::  atomic {where_is_torch==1;wanna_go!20;on_right = on_right-1;}  goto go_left; \n\nfi;\ngo_left: if\n:: lets_go?0; goto left; \n\nfi;\n}\n\nactive proctype soldier_4() { \n\nleft: if\n::  atomic {where_is_torch==0;wanna_go!25;}  goto go_right; \n\nfi;\ngo_right: if\n::  atomic {lets_go?0;on_right = on_right+1;}  goto right; \n\nfi;\nright: if\n::  atomic {where_is_torch==1;wanna_go!25;on_right = on_right-1;}  goto go_left; \n\nfi;\ngo_left: if\n:: lets_go?0; goto left; \n\nfi;\n}\n\nactive proctype soldier_5() { \n\nleft: if\n::  atomic {where_is_torch==0;wanna_go!30;}  goto go_right; \n\nfi;\ngo_right: if\n::  atomic {lets_go?0;on_right = on_right+1;}  goto right; \n\nfi;\nright: if\n::  atomic {where_is_torch==1;wanna_go!30;on_right = on_right-1;}  goto go_left; \n\nfi;\ngo_left: if\n:: lets_go?0; goto left; \n\nfi;\n}\n\nactive proctype soldier_6() { \n\nleft: if\n::  atomic {where_is_torch==0;wanna_go!30;}  goto go_right; \n\nfi;\ngo_right: if\n::  atomic {lets_go?0;on_right = on_right+1;}  goto right; \n\nfi;\nright: if\n::  atomic {where_is_torch==1;wanna_go!30;on_right = on_right-1;}  goto go_left; \n\nfi;\ngo_left: if\n:: lets_go?0; goto left; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Four men have to cross a bridge at night. The bridge is\n  old and dilapidated and can hold at most two people at a time. There are no\n  railings, and the men have only one flashlight. Any party who crosses, either\n  one or two men, must carry the flashlight with them. The flashlight must be\n  walked back and forth; it cannot be thrown, etc. Each man walks at a\n  different speed. One takes 5 minute to cross, another 10 minutes, another 20,\n  and the last 25 minutes. If two men cross together, they must walk at the\n  slower man's pace. Can they get to the other side in 60 minutes? (The model\n  is generalized to larger number of men.)\n\nParameters:\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte total_time=0;\nbyte where_is_torch=0;\nbyte on_right=0;\n\nchan wanna_go =[0] of {int};\nchan lets_go =[0] of {int};\n\nactive proctype torch() { \nbyte time1=0;\nbyte time2=0;\n\nfree: if\n:: wanna_go?time1; goto one; \n\nfi;\none: if\n:: wanna_go?time2; goto two; \n\n::  goto going; \n\nfi;\ntwo: if\n::  atomic {time1>=time2;lets_go!0;}  goto going; \n\n::  atomic {time1<time2;lets_go!0;time1 = time2;time2 = 0;}  goto going; \n\nfi;\ngoing: if\n::  atomic {total_time+time1<=200;lets_go!0;total_time = total_time+time1;time1 = 0;where_is_torch = 1-where_is_torch;}  goto free; \n\nfi;\n}\n\nactive proctype soldier_1() { \n\nleft: if\n::  atomic {where_is_torch==0;wanna_go!5;}  goto go_right; \n\nfi;\ngo_right: if\n::  atomic {lets_go?0;on_right = on_right+1;}  goto right; \n\nfi;\nright: if\n::  atomic {where_is_torch==1;wanna_go!5;on_right = on_right-1;}  goto go_left; \n\nfi;\ngo_left: if\n:: lets_go?0; goto left; \n\nfi;\n}\n\nactive proctype soldier_2() { \n\nleft: if\n::  atomic {where_is_torch==0;wanna_go!10;}  goto go_right; \n\nfi;\ngo_right: if\n::  atomic {lets_go?0;on_right = on_right+1;}  goto right; \n\nfi;\nright: if\n::  atomic {where_is_torch==1;wanna_go!10;on_right = on_right-1;}  goto go_left; \n\nfi;\ngo_left: if\n:: lets_go?0; goto left; \n\nfi;\n}\n\nactive proctype soldier_3() { \n\nleft: if\n::  atomic {where_is_torch==0;wanna_go!20;}  goto go_right; \n\nfi;\ngo_right: if\n::  atomic {lets_go?0;on_right = on_right+1;}  goto right; \n\nfi;\nright: if\n::  atomic {where_is_torch==1;wanna_go!20;on_right = on_right-1;}  goto go_left; \n\nfi;\ngo_left: if\n:: lets_go?0; goto left; \n\nfi;\n}\n\nactive proctype soldier_4() { \n\nleft: if\n::  atomic {where_is_torch==0;wanna_go!25;}  goto go_right; \n\nfi;\ngo_right: if\n::  atomic {lets_go?0;on_right = on_right+1;}  goto right; \n\nfi;\nright: if\n::  atomic {where_is_torch==1;wanna_go!25;on_right = on_right-1;}  goto go_left; \n\nfi;\ngo_left: if\n:: lets_go?0; goto left; \n\nfi;\n}\n\nactive proctype soldier_5() { \n\nleft: if\n::  atomic {where_is_torch==0;wanna_go!30;}  goto go_right; \n\nfi;\ngo_right: if\n::  atomic {lets_go?0;on_right = on_right+1;}  goto right; \n\nfi;\nright: if\n::  atomic {where_is_torch==1;wanna_go!30;on_right = on_right-1;}  goto go_left; \n\nfi;\ngo_left: if\n:: lets_go?0; goto left; \n\nfi;\n}\n\nactive proctype soldier_6() { \n\nleft: if\n::  atomic {where_is_torch==0;wanna_go!30;}  goto go_right; \n\nfi;\ngo_right: if\n::  atomic {lets_go?0;on_right = on_right+1;}  goto right; \n\nfi;\nright: if\n::  atomic {where_is_torch==1;wanna_go!30;on_right = on_right-1;}  goto go_left; \n\nfi;\ngo_left: if\n:: lets_go?0; goto left; \n\nfi;\n}\n\nactive proctype soldier_7() { \n\nleft: if\n::  atomic {where_is_torch==0;wanna_go!40;}  goto go_right; \n\nfi;\ngo_right: if\n::  atomic {lets_go?0;on_right = on_right+1;}  goto right; \n\nfi;\nright: if\n::  atomic {where_is_torch==1;wanna_go!40;on_right = on_right-1;}  goto go_left; \n\nfi;\ngo_left: if\n:: lets_go?0; goto left; \n\nfi;\n}\n\nactive proctype soldier_8() { \n\nleft: if\n::  atomic {where_is_torch==0;wanna_go!45;}  goto go_right; \n\nfi;\ngo_right: if\n::  atomic {lets_go?0;on_right = on_right+1;}  goto right; \n\nfi;\nright: if\n::  atomic {where_is_torch==1;wanna_go!45;on_right = on_right-1;}  goto go_left; \n\nfi;\ngo_left: if\n:: lets_go?0; goto left; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The Bounded Retransmission Protocol is a protocol used in\n    one of the Philips' products. It is based on the well-known alternating bit\n    protocol. It allows only bounded number of retransmissions of each frame\n    (piece of a file). This model does not include timing aspects.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte prod_n=0;\n\nchan Sin =[0] of {int};\nchan Sout =[0] of {int};\nchan toK =[0] of {int};\nchan fromK =[0] of {int};\nchan toL =[0] of {int};\nchan fromL =[0] of {int};\nchan timeisout =[0] of {int};\nchan Rout =[0] of {int};\nchan shake =[0] of {int};\nchan shakePC =[0] of {int};\n\nactive proctype Producer() { \nbyte result=0;\nbyte n=0;\n\nready: if\n:: prod_n = 1; goto start_send; \n\n:: prod_n = 2; goto start_send; \n\n:: prod_n = 3; goto start_send; \n\n:: prod_n = 4; goto start_send; \n\n:: prod_n = 5; goto start_send; \n\nfi;\nstart_send: if\n:: Sin!prod_n; goto wait_result; \n\nfi;\nwait_result: if\n:: Sout?result; goto check; \n\nfi;\ncheck: if\n::  atomic {result==1;shakePC!0;}  goto ready; \n\n:: result==2 || result==3; goto start_send; \n\nfi;\n}\n\nactive proctype Consumer() { \nbyte m=0;\nbyte n=0;\n\nready: if\n::  atomic {Rout?m;n = n+1;}  goto get_msg; \n\nfi;\nget_msg: if\n:: (m==4) || (m==5); goto ready; \n\n::  d_step {m==2;n = 0;}  goto ready; \n\n:: m==1; goto check; \n\nfi;\ncheck: if\n::  atomic {n==prod_n;shakePC?0;n = 0;}  goto ready; \n\n:: n!=prod_n; goto st_error; \n\nfi;\nst_error: \n false; }\n\nactive proctype Sender() { \nbyte ab=0;\nbyte n=0;\nbyte i=0;\nbyte counter=0;\n\nidle: if\n::  atomic {Sin?n;i = 1;}  goto next_frame; \n\nfi;\nnext_frame: if\n:: counter = 0; goto send; \n\nfi;\nwait_ack: if\n::  atomic {fromL?0;ab = 1-ab;}  goto success; \n\n::  atomic {counter==3;timeisout?0;}  goto q_error; \n\n::  atomic {counter<3;timeisout?0;counter = counter+1;}  goto send; \n\nfi;\nsend: if\n::  atomic {i==1 && i==n;toK!(4+2+ab);}  goto wait_ack; \n\n::  atomic {i>1 && i==n;toK!(2+ab);}  goto wait_ack; \n\n::  atomic {i==1 && i<n;toK!(4+ab);}  goto wait_ack; \n\n::  atomic {i>1 && i<n;toK!ab;}  goto wait_ack; \n\nfi;\nsuccess: if\n::  d_step {i<n;i = i+1;}  goto next_frame; \n\n::  atomic {i==n;Sout!1;}  goto ret; \n\nfi;\nq_error: if\n::  atomic {i<n;Sout!2;}  goto ret; \n\n::  atomic {i==n;Sout!3;}  goto ret; \n\nfi;\nret: if\n:: shake!0; goto idle; \n\nfi;\n}\n\nactive proctype Receiver() { \nbyte value=0;\nbyte exp_ab=0;\n\nnew_file: if\n:: fromK?value; goto first_safe; \n\n:: shake?0; goto new_file; \n\nfi;\nidle: if\n:: fromK?value; goto frame_received; \n\n:: (value&2)==2; goto ret; \n\n:: Rout!2; goto ret; \n\nfi;\nframe_received: if\n::  atomic {(value&1)==exp_ab && (value&2)==2;Rout!1;}  goto frame_reported; \n\n::  atomic {((value&1)==exp_ab) && ((value&2)==0) && ((value&4)==0);Rout!5;}  goto frame_reported; \n\n::  atomic {((value&1)==exp_ab) && ((value&2)==0) && ((value&4)==4);Rout!4;}  goto frame_reported; \n\n::  atomic {exp_ab!=(value&1);toL!0;}  goto idle; \n\nfi;\nframe_reported: if\n::  atomic {toL!0;exp_ab = 1-exp_ab;}  goto idle; \n\nfi;\nfirst_safe: if\n:: exp_ab = (value&1); goto frame_received; \n\nfi;\nret: if\n:: shake?0; goto new_file; \n\nfi;\n}\n\nactive proctype K() { \nbyte value=0;\n\nready: if\n:: toK?value; goto got_msg; \n\nfi;\ngot_msg: if\n:: timeisout!0; goto ready; \n\n:: fromK!value; goto ready; \n\nfi;\n}\n\nactive proctype L() { \n\nready: if\n:: toL?0; goto got_msg; \n\nfi;\ngot_msg: if\n:: fromL!0; goto ready; \n\n:: timeisout!0; goto ready; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The Bounded Retransmission Protocol is a protocol used in\n    one of the Philips' products. It is based on the well-known alternating bit\n    protocol. It allows only bounded number of retransmissions of each frame\n    (piece of a file). This model does not include timing aspects.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte prod_n=0;\n\nchan Sin =[0] of {int};\nchan Sout =[0] of {int};\nchan toK =[0] of {int};\nchan fromK =[0] of {int};\nchan toL =[0] of {int};\nchan fromL =[0] of {int};\nchan timeisout =[0] of {int};\nchan Rout =[0] of {int};\nchan shake =[0] of {int};\nchan shakePC =[0] of {int};\n\nactive proctype Producer() { \nbyte result=0;\nbyte n=0;\n\nready: if\n:: prod_n = 1; goto start_send; \n\n:: prod_n = 2; goto start_send; \n\n:: prod_n = 3; goto start_send; \n\nfi;\nstart_send: if\n:: Sin!prod_n; goto wait_result; \n\nfi;\nwait_result: if\n:: Sout?result; goto check; \n\nfi;\ncheck: if\n::  atomic {result==1;shakePC!0;}  goto ready; \n\n:: result==2 || result==3; goto start_send; \n\nfi;\n}\n\nactive proctype Consumer() { \nbyte m=0;\nbyte n=0;\n\nready: if\n::  atomic {Rout?m;n = n+1;}  goto get_msg; \n\nfi;\nget_msg: if\n:: (m==4) || (m==5); goto ready; \n\n::  d_step {m==2;n = 0;}  goto ready; \n\n:: m==1; goto check; \n\nfi;\ncheck: if\n::  atomic {n==prod_n;shakePC?0;}  goto ready; \n\n:: n!=prod_n; goto st_error; \n\nfi;\nst_error: \n false; }\n\nactive proctype Sender() { \nbyte ab=0;\nbyte n=0;\nbyte i=0;\nbyte counter=0;\n\nidle: if\n::  atomic {Sin?n;i = 1;}  goto next_frame; \n\nfi;\nnext_frame: if\n:: counter = 0; goto send; \n\nfi;\nwait_ack: if\n::  atomic {fromL?0;ab = 1-ab;}  goto success; \n\n::  atomic {counter==5;timeisout?0;}  goto q_error; \n\n::  atomic {counter<5;timeisout?0;counter = counter+1;}  goto send; \n\nfi;\nsend: if\n::  atomic {i==1 && i==n;toK!(4+2+ab);}  goto wait_ack; \n\n::  atomic {i>1 && i==n;toK!(2+ab);}  goto wait_ack; \n\n::  atomic {i==1 && i<n;toK!(4+ab);}  goto wait_ack; \n\n::  atomic {i>1 && i<n;toK!ab;}  goto wait_ack; \n\nfi;\nsuccess: if\n::  d_step {i<n;i = i+1;}  goto next_frame; \n\n::  atomic {i==n;Sout!1;}  goto ret; \n\nfi;\nq_error: if\n::  atomic {i<n;Sout!2;}  goto ret; \n\n::  atomic {i==n;Sout!3;}  goto ret; \n\nfi;\nret: if\n:: shake!0; goto idle; \n\nfi;\n}\n\nactive proctype Receiver() { \nbyte value=0;\nbyte exp_ab=0;\n\nnew_file: if\n:: fromK?value; goto first_safe; \n\n:: shake?0; goto new_file; \n\nfi;\nidle: if\n:: fromK?value; goto frame_received; \n\n:: (value&2)==2; goto ret; \n\n:: Rout!2; goto ret; \n\nfi;\nframe_received: if\n::  atomic {(value&1)==exp_ab && (value&2)==2;Rout!1;}  goto frame_reported; \n\n::  atomic {((value&1)==exp_ab) && ((value&2)==0) && ((value&4)==0);Rout!5;}  goto frame_reported; \n\n::  atomic {((value&1)==exp_ab) && ((value&2)==0) && ((value&4)==4);Rout!4;}  goto frame_reported; \n\n::  atomic {exp_ab!=(value&1);toL!0;}  goto idle; \n\nfi;\nframe_reported: if\n::  atomic {toL!0;exp_ab = 1-exp_ab;}  goto idle; \n\nfi;\nfirst_safe: if\n:: exp_ab = (value&1); goto frame_received; \n\nfi;\nret: if\n:: shake?0; goto new_file; \n\nfi;\n}\n\nactive proctype K() { \nbyte value=0;\n\nready: if\n:: toK?value; goto got_msg; \n\nfi;\ngot_msg: if\n:: timeisout!0; goto ready; \n\n:: fromK!value; goto ready; \n\nfi;\n}\n\nactive proctype L() { \n\nready: if\n:: toL?0; goto got_msg; \n\nfi;\ngot_msg: if\n:: fromL!0; goto ready; \n\n:: timeisout!0; goto ready; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The Bounded Retransmission Protocol is a protocol used in\n    one of the Philips' products. It is based on the well-known alternating bit\n    protocol. It allows only bounded number of retransmissions of each frame\n    (piece of a file). This model does not include timing aspects.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte prod_n=0;\n\nchan Sin =[0] of {int};\nchan Sout =[0] of {int};\nchan toK =[0] of {int};\nchan fromK =[0] of {int};\nchan toL =[0] of {int};\nchan fromL =[0] of {int};\nchan timeisout =[0] of {int};\nchan Rout =[0] of {int};\nchan shake =[0] of {int};\nchan shakePC =[0] of {int};\n\nactive proctype Producer() { \nbyte result=0;\nbyte n=0;\n\nready: if\n:: prod_n = 1; goto start_send; \n\n:: prod_n = 2; goto start_send; \n\n:: prod_n = 3; goto start_send; \n\n:: prod_n = 4; goto start_send; \n\n:: prod_n = 5; goto start_send; \n\n:: prod_n = 6; goto start_send; \n\n:: prod_n = 7; goto start_send; \n\n:: prod_n = 8; goto start_send; \n\n:: prod_n = 9; goto start_send; \n\n:: prod_n = 10; goto start_send; \n\nfi;\nstart_send: if\n:: Sin!prod_n; goto wait_result; \n\nfi;\nwait_result: if\n:: Sout?result; goto check; \n\nfi;\ncheck: if\n::  atomic {result==1;shakePC!0;}  goto ready; \n\n:: result==2 || result==3; goto start_send; \n\nfi;\n}\n\nactive proctype Consumer() { \nbyte m=0;\nbyte n=0;\n\nready: if\n::  atomic {Rout?m;n = n+1;}  goto get_msg; \n\nfi;\nget_msg: if\n:: (m==4) || (m==5); goto ready; \n\n::  d_step {m==2;n = 0;}  goto ready; \n\n:: m==1; goto check; \n\nfi;\ncheck: if\n::  atomic {n==prod_n;shakePC?0;}  goto ready; \n\n:: n!=prod_n; goto st_error; \n\nfi;\nst_error: \n false; }\n\nactive proctype Sender() { \nbyte ab=0;\nbyte n=0;\nbyte i=0;\nbyte counter=0;\n\nidle: if\n::  atomic {Sin?n;i = 1;}  goto next_frame; \n\nfi;\nnext_frame: if\n:: counter = 0; goto send; \n\nfi;\nwait_ack: if\n::  atomic {fromL?0;ab = 1-ab;}  goto success; \n\n::  atomic {counter==10;timeisout?0;}  goto q_error; \n\n::  atomic {counter<10;timeisout?0;counter = counter+1;}  goto send; \n\nfi;\nsend: if\n::  atomic {i==1 && i==n;toK!(4+2+ab);}  goto wait_ack; \n\n::  atomic {i>1 && i==n;toK!(2+ab);}  goto wait_ack; \n\n::  atomic {i==1 && i<n;toK!(4+ab);}  goto wait_ack; \n\n::  atomic {i>1 && i<n;toK!ab;}  goto wait_ack; \n\nfi;\nsuccess: if\n::  d_step {i<n;i = i+1;}  goto next_frame; \n\n::  atomic {i==n;Sout!1;}  goto ret; \n\nfi;\nq_error: if\n::  atomic {i<n;Sout!2;}  goto ret; \n\n::  atomic {i==n;Sout!3;}  goto ret; \n\nfi;\nret: if\n:: shake!0; goto idle; \n\nfi;\n}\n\nactive proctype Receiver() { \nbyte value=0;\nbyte exp_ab=0;\n\nnew_file: if\n:: fromK?value; goto first_safe; \n\n:: shake?0; goto new_file; \n\nfi;\nidle: if\n:: fromK?value; goto frame_received; \n\n:: (value&2)==2; goto ret; \n\n:: Rout!2; goto ret; \n\nfi;\nframe_received: if\n::  atomic {(value&1)==exp_ab && (value&2)==2;Rout!1;}  goto frame_reported; \n\n::  atomic {((value&1)==exp_ab) && ((value&2)==0) && ((value&4)==0);Rout!5;}  goto frame_reported; \n\n::  atomic {((value&1)==exp_ab) && ((value&2)==0) && ((value&4)==4);Rout!4;}  goto frame_reported; \n\n::  atomic {exp_ab!=(value&1);toL!0;}  goto idle; \n\nfi;\nframe_reported: if\n::  atomic {toL!0;exp_ab = 1-exp_ab;}  goto idle; \n\nfi;\nfirst_safe: if\n:: exp_ab = (value&1); goto frame_received; \n\nfi;\nret: if\n:: shake?0; goto new_file; \n\nfi;\n}\n\nactive proctype K() { \nbyte value=0;\n\nready: if\n:: toK?value; goto got_msg; \n\nfi;\ngot_msg: if\n:: timeisout!0; goto ready; \n\n:: fromK!value; goto ready; \n\nfi;\n}\n\nactive proctype L() { \n\nready: if\n:: toL?0; goto got_msg; \n\nfi;\ngot_msg: if\n:: fromL!0; goto ready; \n\n:: timeisout!0; goto ready; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The Bounded Retransmission Protocol is a protocol used in\n    one of the Philips' products. It is based on the well-known alternating bit\n    protocol. It allows only bounded number of retransmissions of each frame\n    (piece of a file). This model does not include timing aspects.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte prod_n=0;\n\nchan Sin =[0] of {int};\nchan Sout =[0] of {int};\nchan toK =[0] of {int};\nchan fromK =[0] of {int};\nchan toL =[0] of {int};\nchan fromL =[0] of {int};\nchan timeisout =[0] of {int};\nchan Rout =[0] of {int};\nchan shake =[0] of {int};\nchan shakePC =[0] of {int};\n\nactive proctype Producer() { \nbyte result=0;\nbyte n=0;\n\nready: if\n:: prod_n = 1; goto start_send; \n\n:: prod_n = 2; goto start_send; \n\n:: prod_n = 3; goto start_send; \n\n:: prod_n = 4; goto start_send; \n\n:: prod_n = 5; goto start_send; \n\n:: prod_n = 6; goto start_send; \n\n:: prod_n = 7; goto start_send; \n\n:: prod_n = 8; goto start_send; \n\n:: prod_n = 9; goto start_send; \n\n:: prod_n = 10; goto start_send; \n\n:: prod_n = 11; goto start_send; \n\n:: prod_n = 12; goto start_send; \n\n:: prod_n = 13; goto start_send; \n\n:: prod_n = 14; goto start_send; \n\n:: prod_n = 15; goto start_send; \n\n:: prod_n = 16; goto start_send; \n\n:: prod_n = 17; goto start_send; \n\n:: prod_n = 18; goto start_send; \n\n:: prod_n = 19; goto start_send; \n\n:: prod_n = 20; goto start_send; \n\nfi;\nstart_send: if\n:: Sin!prod_n; goto wait_result; \n\nfi;\nwait_result: if\n:: Sout?result; goto check; \n\nfi;\ncheck: if\n::  atomic {result==1;shakePC!0;}  goto ready; \n\n:: result==2 || result==3; goto start_send; \n\nfi;\n}\n\nactive proctype Consumer() { \nbyte m=0;\nbyte n=0;\n\nready: if\n::  atomic {Rout?m;n = n+1;}  goto get_msg; \n\nfi;\nget_msg: if\n:: (m==4) || (m==5); goto ready; \n\n::  d_step {m==2;n = 0;}  goto ready; \n\n:: m==1; goto check; \n\nfi;\ncheck: if\n::  atomic {n==prod_n;shakePC?0;}  goto ready; \n\n:: n!=prod_n; goto st_error; \n\nfi;\nst_error: \n false; }\n\nactive proctype Sender() { \nbyte ab=0;\nbyte n=0;\nbyte i=0;\nbyte counter=0;\n\nidle: if\n::  atomic {Sin?n;i = 1;}  goto next_frame; \n\nfi;\nnext_frame: if\n:: counter = 0; goto send; \n\nfi;\nwait_ack: if\n::  atomic {fromL?0;ab = 1-ab;}  goto success; \n\n::  atomic {counter==20;timeisout?0;}  goto q_error; \n\n::  atomic {counter<20;timeisout?0;counter = counter+1;}  goto send; \n\nfi;\nsend: if\n::  atomic {i==1 && i==n;toK!(4+2+ab);}  goto wait_ack; \n\n::  atomic {i>1 && i==n;toK!(2+ab);}  goto wait_ack; \n\n::  atomic {i==1 && i<n;toK!(4+ab);}  goto wait_ack; \n\n::  atomic {i>1 && i<n;toK!ab;}  goto wait_ack; \n\nfi;\nsuccess: if\n::  d_step {i<n;i = i+1;}  goto next_frame; \n\n::  atomic {i==n;Sout!1;}  goto ret; \n\nfi;\nq_error: if\n::  atomic {i<n;Sout!2;}  goto ret; \n\n::  atomic {i==n;Sout!3;}  goto ret; \n\nfi;\nret: if\n:: shake!0; goto idle; \n\nfi;\n}\n\nactive proctype Receiver() { \nbyte value=0;\nbyte exp_ab=0;\n\nnew_file: if\n:: fromK?value; goto first_safe; \n\n:: shake?0; goto new_file; \n\nfi;\nidle: if\n:: fromK?value; goto frame_received; \n\n:: (value&2)==2; goto ret; \n\n:: Rout!2; goto ret; \n\nfi;\nframe_received: if\n::  atomic {(value&1)==exp_ab && (value&2)==2;Rout!1;}  goto frame_reported; \n\n::  atomic {((value&1)==exp_ab) && ((value&2)==0) && ((value&4)==0);Rout!5;}  goto frame_reported; \n\n::  atomic {((value&1)==exp_ab) && ((value&2)==0) && ((value&4)==4);Rout!4;}  goto frame_reported; \n\n::  atomic {exp_ab!=(value&1);toL!0;}  goto idle; \n\nfi;\nframe_reported: if\n::  atomic {toL!0;exp_ab = 1-exp_ab;}  goto idle; \n\nfi;\nfirst_safe: if\n:: exp_ab = (value&1); goto frame_received; \n\nfi;\nret: if\n:: shake?0; goto new_file; \n\nfi;\n}\n\nactive proctype K() { \nbyte value=0;\n\nready: if\n:: toK?value; goto got_msg; \n\nfi;\ngot_msg: if\n:: timeisout!0; goto ready; \n\n:: fromK!value; goto ready; \n\nfi;\n}\n\nactive proctype L() { \n\nready: if\n:: toL?0; goto got_msg; \n\nfi;\ngot_msg: if\n:: fromL!0; goto ready; \n\n:: timeisout!0; goto ready; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The Bounded Retransmission Protocol is a protocol used in\n    one of the Philips' products. It is based on the well-known alternating bit\n    protocol. It allows only bounded number of retransmissions of each frame\n    (piece of a file). This model does not include timing aspects.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte prod_n=0;\n\nchan Sin =[0] of {int};\nchan Sout =[0] of {int};\nchan toK =[0] of {int};\nchan fromK =[0] of {int};\nchan toL =[0] of {int};\nchan fromL =[0] of {int};\nchan timeisout =[0] of {int};\nchan Rout =[0] of {int};\nchan shake =[0] of {int};\nchan shakePC =[0] of {int};\n\nactive proctype Producer() { \nbyte result=0;\nbyte n=0;\n\nready: if\n:: prod_n = 1; goto start_send; \n\n:: prod_n = 2; goto start_send; \n\n:: prod_n = 3; goto start_send; \n\n:: prod_n = 4; goto start_send; \n\n:: prod_n = 5; goto start_send; \n\n:: prod_n = 6; goto start_send; \n\n:: prod_n = 7; goto start_send; \n\n:: prod_n = 8; goto start_send; \n\n:: prod_n = 9; goto start_send; \n\n:: prod_n = 10; goto start_send; \n\n:: prod_n = 11; goto start_send; \n\n:: prod_n = 12; goto start_send; \n\n:: prod_n = 13; goto start_send; \n\n:: prod_n = 14; goto start_send; \n\n:: prod_n = 15; goto start_send; \n\n:: prod_n = 16; goto start_send; \n\n:: prod_n = 17; goto start_send; \n\n:: prod_n = 18; goto start_send; \n\n:: prod_n = 19; goto start_send; \n\n:: prod_n = 20; goto start_send; \n\nfi;\nstart_send: if\n:: Sin!prod_n; goto wait_result; \n\nfi;\nwait_result: if\n:: Sout?result; goto check; \n\nfi;\ncheck: if\n::  atomic {result==1;shakePC!0;}  goto ready; \n\n:: result==2 || result==3; goto start_send; \n\nfi;\n}\n\nactive proctype Consumer() { \nbyte m=0;\nbyte n=0;\n\nready: if\n::  atomic {Rout?m;n = n+1;}  goto get_msg; \n\nfi;\nget_msg: if\n:: (m==4) || (m==5); goto ready; \n\n::  d_step {m==2;n = 0;}  goto ready; \n\n:: m==1; goto check; \n\nfi;\ncheck: if\n::  atomic {n==prod_n;shakePC?0;}  goto ready; \n\n:: n!=prod_n; goto st_error; \n\nfi;\nst_error: \n false; }\n\nactive proctype Sender() { \nbyte ab=0;\nbyte n=0;\nbyte i=0;\nbyte counter=0;\n\nidle: if\n::  atomic {Sin?n;i = 1;}  goto next_frame; \n\nfi;\nnext_frame: if\n:: counter = 0; goto send; \n\nfi;\nwait_ack: if\n::  atomic {fromL?0;ab = 1-ab;}  goto success; \n\n::  atomic {counter==30;timeisout?0;}  goto q_error; \n\n::  atomic {counter<30;timeisout?0;counter = counter+1;}  goto send; \n\nfi;\nsend: if\n::  atomic {i==1 && i==n;toK!(4+2+ab);}  goto wait_ack; \n\n::  atomic {i>1 && i==n;toK!(2+ab);}  goto wait_ack; \n\n::  atomic {i==1 && i<n;toK!(4+ab);}  goto wait_ack; \n\n::  atomic {i>1 && i<n;toK!ab;}  goto wait_ack; \n\nfi;\nsuccess: if\n::  d_step {i<n;i = i+1;}  goto next_frame; \n\n::  atomic {i==n;Sout!1;}  goto ret; \n\nfi;\nq_error: if\n::  atomic {i<n;Sout!2;}  goto ret; \n\n::  atomic {i==n;Sout!3;}  goto ret; \n\nfi;\nret: if\n:: shake!0; goto idle; \n\nfi;\n}\n\nactive proctype Receiver() { \nbyte value=0;\nbyte exp_ab=0;\n\nnew_file: if\n:: fromK?value; goto first_safe; \n\n:: shake?0; goto new_file; \n\nfi;\nidle: if\n:: fromK?value; goto frame_received; \n\n:: (value&2)==2; goto ret; \n\n:: Rout!2; goto ret; \n\nfi;\nframe_received: if\n::  atomic {(value&1)==exp_ab && (value&2)==2;Rout!1;}  goto frame_reported; \n\n::  atomic {((value&1)==exp_ab) && ((value&2)==0) && ((value&4)==0);Rout!5;}  goto frame_reported; \n\n::  atomic {((value&1)==exp_ab) && ((value&2)==0) && ((value&4)==4);Rout!4;}  goto frame_reported; \n\n::  atomic {exp_ab!=(value&1);toL!0;}  goto idle; \n\nfi;\nframe_reported: if\n::  atomic {toL!0;exp_ab = 1-exp_ab;}  goto idle; \n\nfi;\nfirst_safe: if\n:: exp_ab = (value&1); goto frame_received; \n\nfi;\nret: if\n:: shake?0; goto new_file; \n\nfi;\n}\n\nactive proctype K() { \nbyte value=0;\n\nready: if\n:: toK?value; goto got_msg; \n\nfi;\ngot_msg: if\n:: timeisout!0; goto ready; \n\n:: fromK!value; goto ready; \n\nfi;\n}\n\nactive proctype L() { \n\nready: if\n:: toL?0; goto got_msg; \n\nfi;\ngot_msg: if\n:: fromL!0; goto ready; \n\n:: timeisout!0; goto ready; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The Bounded Retransmission Protocol is a protocol used in\n    one of the Philips' products. It is based on the well-known alternating bit\n    protocol. It allows only bounded number of retransmissions of each frame\n    (piece of a file). This model does not include timing aspects.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte prod_n=0;\n\nchan Sin =[0] of {int};\nchan Sout =[0] of {int};\nchan toK =[0] of {int};\nchan fromK =[0] of {int};\nchan toL =[0] of {int};\nchan fromL =[0] of {int};\nchan timeisout =[0] of {int};\nchan Rout =[0] of {int};\nchan shake =[0] of {int};\nchan shakePC =[0] of {int};\n\nactive proctype Producer() { \nbyte result=0;\nbyte n=0;\n\nready: if\n:: prod_n = 1; goto start_send; \n\n:: prod_n = 2; goto start_send; \n\n:: prod_n = 3; goto start_send; \n\n:: prod_n = 4; goto start_send; \n\n:: prod_n = 5; goto start_send; \n\n:: prod_n = 6; goto start_send; \n\n:: prod_n = 7; goto start_send; \n\n:: prod_n = 8; goto start_send; \n\n:: prod_n = 9; goto start_send; \n\n:: prod_n = 10; goto start_send; \n\n:: prod_n = 11; goto start_send; \n\n:: prod_n = 12; goto start_send; \n\n:: prod_n = 13; goto start_send; \n\n:: prod_n = 14; goto start_send; \n\n:: prod_n = 15; goto start_send; \n\n:: prod_n = 16; goto start_send; \n\n:: prod_n = 17; goto start_send; \n\n:: prod_n = 18; goto start_send; \n\n:: prod_n = 19; goto start_send; \n\n:: prod_n = 20; goto start_send; \n\n:: prod_n = 21; goto start_send; \n\n:: prod_n = 22; goto start_send; \n\n:: prod_n = 23; goto start_send; \n\n:: prod_n = 24; goto start_send; \n\n:: prod_n = 25; goto start_send; \n\n:: prod_n = 26; goto start_send; \n\n:: prod_n = 27; goto start_send; \n\n:: prod_n = 28; goto start_send; \n\n:: prod_n = 29; goto start_send; \n\n:: prod_n = 30; goto start_send; \n\nfi;\nstart_send: if\n:: Sin!prod_n; goto wait_result; \n\nfi;\nwait_result: if\n:: Sout?result; goto check; \n\nfi;\ncheck: if\n::  atomic {result==1;shakePC!0;}  goto ready; \n\n:: result==2 || result==3; goto start_send; \n\nfi;\n}\n\nactive proctype Consumer() { \nbyte m=0;\nbyte n=0;\n\nready: if\n::  atomic {Rout?m;n = n+1;}  goto get_msg; \n\nfi;\nget_msg: if\n:: (m==4) || (m==5); goto ready; \n\n::  d_step {m==2;n = 0;}  goto ready; \n\n:: m==1; goto check; \n\nfi;\ncheck: if\n::  atomic {n==prod_n;shakePC?0;}  goto ready; \n\n:: n!=prod_n; goto st_error; \n\nfi;\nst_error: \n false; }\n\nactive proctype Sender() { \nbyte ab=0;\nbyte n=0;\nbyte i=0;\nbyte counter=0;\n\nidle: if\n::  atomic {Sin?n;i = 1;}  goto next_frame; \n\nfi;\nnext_frame: if\n:: counter = 0; goto send; \n\nfi;\nwait_ack: if\n::  atomic {fromL?0;ab = 1-ab;}  goto success; \n\n::  atomic {counter==23;timeisout?0;}  goto q_error; \n\n::  atomic {counter<23;timeisout?0;counter = counter+1;}  goto send; \n\nfi;\nsend: if\n::  atomic {i==1 && i==n;toK!(4+2+ab);}  goto wait_ack; \n\n::  atomic {i>1 && i==n;toK!(2+ab);}  goto wait_ack; \n\n::  atomic {i==1 && i<n;toK!(4+ab);}  goto wait_ack; \n\n::  atomic {i>1 && i<n;toK!ab;}  goto wait_ack; \n\nfi;\nsuccess: if\n::  d_step {i<n;i = i+1;}  goto next_frame; \n\n::  atomic {i==n;Sout!1;}  goto ret; \n\nfi;\nq_error: if\n::  atomic {i<n;Sout!2;}  goto ret; \n\n::  atomic {i==n;Sout!3;}  goto ret; \n\nfi;\nret: if\n:: shake!0; goto idle; \n\nfi;\n}\n\nactive proctype Receiver() { \nbyte value=0;\nbyte exp_ab=0;\n\nnew_file: if\n:: fromK?value; goto first_safe; \n\n:: shake?0; goto new_file; \n\nfi;\nidle: if\n:: fromK?value; goto frame_received; \n\n:: (value&2)==2; goto ret; \n\n:: Rout!2; goto ret; \n\nfi;\nframe_received: if\n::  atomic {(value&1)==exp_ab && (value&2)==2;Rout!1;}  goto frame_reported; \n\n::  atomic {((value&1)==exp_ab) && ((value&2)==0) && ((value&4)==0);Rout!5;}  goto frame_reported; \n\n::  atomic {((value&1)==exp_ab) && ((value&2)==0) && ((value&4)==4);Rout!4;}  goto frame_reported; \n\n::  atomic {exp_ab!=(value&1);toL!0;}  goto idle; \n\nfi;\nframe_reported: if\n::  atomic {toL!0;exp_ab = 1-exp_ab;}  goto idle; \n\nfi;\nfirst_safe: if\n:: exp_ab = (value&1); goto frame_received; \n\nfi;\nret: if\n:: shake?0; goto new_file; \n\nfi;\n}\n\nactive proctype K() { \nbyte value=0;\n\nready: if\n:: toK?value; goto got_msg; \n\nfi;\ngot_msg: if\n:: timeisout!0; goto ready; \n\n:: fromK!value; goto ready; \n\nfi;\n}\n\nactive proctype L() { \n\nready: if\n:: toL?0; goto got_msg; \n\nfi;\ngot_msg: if\n:: fromL!0; goto ready; \n\n:: timeisout!0; goto ready; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Protocol for communication between two sides (sender and\n    receiver) over (loosy) medium.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, \n\nProperties to verify:"}, {"role": "assistant", "content": "chan toK =[0] of {int};\nchan fromK =[0] of {int};\nchan toL =[0] of {int};\nchan fromL =[0] of {int};\nchan sRESET1 =[0] of {int};\nchan sRESET2 =[0] of {int};\nchan rRESET1 =[0] of {int};\nchan rRESET2 =[0] of {int};\nchan sRDY1 =[0] of {int};\nchan sRDY2 =[0] of {int};\nchan sNOTRDY1 =[0] of {int};\nchan sNOTRDY2 =[0] of {int};\nchan rDATA1 =[0] of {int};\nchan rDATA2 =[0] of {int};\nchan rNODATA1 =[0] of {int};\nchan rNODATA2 =[0] of {int};\n\nactive proctype Sender() { \nint n=-1;\nint m=0;\n\nidle: if\n:: sRESET1?0; goto ack_reset; \n\n:: sNOTRDY1?m; goto q_i; \n\n:: sRDY1?m; goto q_a; \n\n:: rRESET1!0; goto reset; \n\nfi;\nack_reset: if\n::  atomic {rRESET1!0;n = -1;}  goto idle; \n\nfi;\nreset: if\n:: sNOTRDY1?m; goto reset; \n\n:: sRDY1?m; goto reset; \n\n::  atomic {sRESET1?0;n = -1;}  goto idle; \n\nfi;\nadvance: if\n:: rNODATA1!n; goto N; \n\n:: rDATA1!n; goto E; \n\nfi;\nN: if\n:: rRESET1!0; goto reset; \n\n:: sRESET1?0; goto ack_reset; \n\n:: rDATA1!n; goto E; \n\n:: sRDY1?m; goto q_n; \n\nfi;\nE: if\n:: rRESET1!0; goto reset; \n\n:: sRESET1?0; goto ack_reset; \n\n:: sNOTRDY1?m; goto q_e; \n\n:: sRDY1?m; goto q_e; \n\nfi;\nq_i: if\n:: m==(n+1)%4; goto idle; \n\n:: m!=(n+1)%4; goto q_error; \n\nfi;\nq_e: if\n::  atomic {m==n;rDATA1!n;}  goto E; \n\n::  d_step {m==(n+1)%4;n = (n+1)%4;}  goto advance; \n\nfi;\nq_n: if\n::  atomic {m==n;rNODATA1!n;}  goto N; \n\n:: m!=n; goto q_error; \n\nfi;\nq_a: if\n::  d_step {m==(n+1)%4;n = (n+1)%4;}  goto advance; \n\n:: m!=(n+1)%4; goto q_error; \n\nfi;\nq_error: \n false; }\n\nactive proctype Receiver() { \nint n=0;\nint m=0;\n\nidle: if\n:: rRESET2?0; goto ack_reset; \n\n:: rNODATA2?m; goto q_i; \n\n:: rDATA2?m; goto q_a; \n\n:: sRESET2!0; goto reset; \n\n:: sRDY2!n; goto E; \n\nfi;\nack_reset: if\n::  atomic {sRESET2!0;n = 0;}  goto idle; \n\nfi;\nreset: if\n:: rDATA2?m; goto reset; \n\n:: rNODATA2?m; goto reset; \n\n::  atomic {rRESET2?0;n = 0;}  goto idle; \n\nfi;\nadvance: if\n:: sNOTRDY2!n; goto N; \n\n:: sRDY2!n; goto E; \n\nfi;\nN: if\n:: sRESET2!0; goto reset; \n\n:: rRESET2?0; goto ack_reset; \n\n:: sRDY2!n; goto E; \n\n:: rDATA2?m; goto q_n; \n\nfi;\nE: if\n:: sRESET2!0; goto reset; \n\n:: rRESET2?0; goto ack_reset; \n\n:: sRDY2!n; goto E; \n\n:: rDATA2?m; goto q_e; \n\n:: rNODATA2?m; goto q_e2; \n\nfi;\nq_i: if\n:: m==n; goto idle; \n\n:: m!=n; goto q_error; \n\nfi;\nq_e: if\n::  atomic {(m+1)%4==n;sRDY2!n;}  goto E; \n\n::  d_step {m==n;n = (n+1)%4;}  goto advance; \n\nfi;\nq_n: if\n::  atomic {(m+1)%4==n;sNOTRDY2!n;}  goto N; \n\n:: (m+1)%4!=n; goto N; \n\nfi;\nq_a: if\n::  d_step {m==n;n = (n+1)%4;}  goto advance; \n\n:: m!=n; goto q_error; \n\nfi;\nq_e2: if\n:: m==n; goto idle; \n\n:: m!=n; goto q_error; \n\nfi;\nq_error: \n false; }\n\nactive proctype StoR() { \nbyte buf[3];\nbyte buf_act=0;\nbyte n=0;\n\nq: if\n::  atomic { ! (buf_act==3);rRESET1?0;buf[buf_act] = 0;buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==3);rDATA1?n;buf[buf_act] = 3+8*n;buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==3);rNODATA1?n;buf[buf_act] = 4+8*n;buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]==0;rRESET2!0;buf[0] = buf[1];buf[1] = buf[2];buf[2] = 0;buf_act = buf_act-1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]%8==3;rDATA2!(buf[0]/8);buf[0] = buf[1];buf[1] = buf[2];buf[2] = 0;buf_act = buf_act-1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]%8==4;rNODATA2!(buf[0]/8);buf[0] = buf[1];buf[1] = buf[2];buf[2] = 0;buf_act = buf_act-1;}  goto q; \n\nfi;\n}\n\nactive proctype RtoS() { \nbyte buf[3];\nbyte buf_act=0;\nbyte n=0;\n\nq: if\n::  atomic { ! (buf_act==3);sRESET2?0;buf[buf_act] = 0;buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==3);sRDY2?n;buf[buf_act] = 1+8*n;buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==3);sNOTRDY2?n;buf[buf_act] = 2+8*n;buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]==0;sRESET1!0;buf[0] = buf[1];buf[1] = buf[2];buf[2] = 0;buf_act = buf_act-1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]%8==1;sRDY1!(buf[0]/8);buf[0] = buf[1];buf[1] = buf[2];buf[2] = 0;buf_act = buf_act-1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]%8==2;sNOTRDY1!(buf[0]/8);buf[0] = buf[1];buf[1] = buf[2];buf[2] = 0;buf_act = buf_act-1;}  goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Protocol for communication between two sides (sender and\n    receiver) over (loosy) medium.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, \n\nProperties to verify:"}, {"role": "assistant", "content": "chan toK =[0] of {int};\nchan fromK =[0] of {int};\nchan toL =[0] of {int};\nchan fromL =[0] of {int};\nchan sRESET1 =[0] of {int};\nchan sRESET2 =[0] of {int};\nchan rRESET1 =[0] of {int};\nchan rRESET2 =[0] of {int};\nchan sRDY1 =[0] of {int};\nchan sRDY2 =[0] of {int};\nchan sNOTRDY1 =[0] of {int};\nchan sNOTRDY2 =[0] of {int};\nchan rDATA1 =[0] of {int};\nchan rDATA2 =[0] of {int};\nchan rNODATA1 =[0] of {int};\nchan rNODATA2 =[0] of {int};\n\nactive proctype Sender() { \nint n=-1;\nint m=0;\n\nidle: if\n:: sRESET1?0; goto ack_reset; \n\n:: sNOTRDY1?m; goto q_i; \n\n:: sRDY1?m; goto q_a; \n\n:: rRESET1!0; goto reset; \n\nfi;\nack_reset: if\n::  atomic {rRESET1!0;n = -1;}  goto idle; \n\nfi;\nreset: if\n:: sNOTRDY1?m; goto reset; \n\n:: sRDY1?m; goto reset; \n\n::  atomic {sRESET1?0;n = -1;}  goto idle; \n\nfi;\nadvance: if\n:: rNODATA1!n; goto N; \n\n:: rDATA1!n; goto E; \n\nfi;\nN: if\n:: rRESET1!0; goto reset; \n\n:: sRESET1?0; goto ack_reset; \n\n:: rDATA1!n; goto E; \n\n:: sRDY1?m; goto q_n; \n\nfi;\nE: if\n:: rRESET1!0; goto reset; \n\n:: sRESET1?0; goto ack_reset; \n\n:: sNOTRDY1?m; goto q_e; \n\n:: sRDY1?m; goto q_e; \n\nfi;\nq_i: if\n:: m==(n+1)%4; goto idle; \n\n:: m!=(n+1)%4; goto q_error; \n\nfi;\nq_e: if\n::  atomic {m==n;rDATA1!n;}  goto E; \n\n::  d_step {m==(n+1)%4;n = (n+1)%4;}  goto advance; \n\nfi;\nq_n: if\n::  atomic {m==n;rDATA1!n;}  goto N; \n\n:: m!=n; goto q_error; \n\nfi;\nq_a: if\n::  d_step {m==(n+1)%4;n = (n+1)%4;}  goto advance; \n\n:: m!=(n+1)%4; goto q_error; \n\nfi;\nq_error: \n false; }\n\nactive proctype Receiver() { \nint n=0;\nint m=0;\n\nidle: if\n:: rRESET2?0; goto ack_reset; \n\n:: rNODATA2?m; goto q_i; \n\n:: rDATA2?m; goto q_a; \n\n:: sRESET2!0; goto reset; \n\n:: sRDY2!n; goto E; \n\nfi;\nack_reset: if\n::  atomic {sRESET2!0;n = 0;}  goto idle; \n\nfi;\nreset: if\n:: rDATA2?m; goto reset; \n\n:: rNODATA2?m; goto reset; \n\n::  atomic {rRESET2?0;n = 0;}  goto idle; \n\nfi;\nadvance: if\n:: sNOTRDY2!n; goto N; \n\n:: sRDY2!n; goto E; \n\nfi;\nN: if\n:: sRESET2!0; goto reset; \n\n:: rRESET2?0; goto ack_reset; \n\n:: sRDY2!n; goto E; \n\n:: rDATA2?m; goto q_n; \n\nfi;\nE: if\n:: sRESET2!0; goto reset; \n\n:: rRESET2?0; goto ack_reset; \n\n:: sRDY2!n; goto E; \n\n:: rDATA2?m; goto q_e; \n\n:: rNODATA2?m; goto q_e2; \n\nfi;\nq_i: if\n:: m==n; goto idle; \n\n:: m!=n; goto q_error; \n\nfi;\nq_e: if\n::  atomic {(m+1)%4==n;sRDY2!n;}  goto E; \n\n::  d_step {m==n;n = (n+1)%4;}  goto advance; \n\nfi;\nq_n: if\n::  atomic {(m+1)%4==n;sNOTRDY2!n;}  goto N; \n\n:: (m+1)%4!=n; goto N; \n\nfi;\nq_a: if\n::  d_step {m==n;n = (n+1)%4;}  goto advance; \n\n:: m!=n; goto q_error; \n\nfi;\nq_e2: if\n:: m==n; goto idle; \n\n:: m!=n; goto q_error; \n\nfi;\nq_error: \n false; }\n\nactive proctype StoR() { \nbyte buf[3];\nbyte buf_act=0;\nbyte n=0;\n\nq: if\n::  atomic { ! (buf_act==3);rRESET1?0;buf[buf_act] = 0;buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==3);rDATA1?n;buf[buf_act] = 3+8*n;buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==3);rNODATA1?n;buf[buf_act] = 4+8*n;buf_act = buf_act+1;}  goto q; \n\n::  d_step { ! (buf_act==0);buf[0] = buf[1];buf[1] = buf[2];buf[2] = 0;buf_act = buf_act-1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]==0;rRESET2!0;buf[0] = buf[1];buf[1] = buf[2];buf[2] = 0;buf_act = buf_act-1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]%8==3;rDATA2!(buf[0]/8);buf[0] = buf[1];buf[1] = buf[2];buf[2] = 0;buf_act = buf_act-1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]%8==4;rNODATA2!(buf[0]/8);buf[0] = buf[1];buf[1] = buf[2];buf[2] = 0;buf_act = buf_act-1;}  goto q; \n\nfi;\n}\n\nactive proctype RtoS() { \nbyte buf[3];\nbyte buf_act=0;\nbyte n=0;\n\nq: if\n::  atomic { ! (buf_act==3);sRESET2?0;buf[buf_act] = 0;buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==3);sRDY2?n;buf[buf_act] = 1+8*n;buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==3);sNOTRDY2?n;buf[buf_act] = 2+8*n;buf_act = buf_act+1;}  goto q; \n\n::  d_step { ! (buf_act==0);buf[0] = buf[1];buf[1] = buf[2];buf[2] = 0;buf_act = buf_act-1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]==0;sRESET1!0;buf[0] = buf[1];buf[1] = buf[2];buf[2] = 0;buf_act = buf_act-1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]%8==1;sRDY1!(buf[0]/8);buf[0] = buf[1];buf[1] = buf[2];buf[2] = 0;buf_act = buf_act-1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]%8==2;sNOTRDY1!(buf[0]/8);buf[0] = buf[1];buf[1] = buf[2];buf[2] = 0;buf_act = buf_act-1;}  goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Protocol for communication between two sides (sender and\n    receiver) over (loosy) medium.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, \n\nProperties to verify:"}, {"role": "assistant", "content": "chan toK =[0] of {int};\nchan fromK =[0] of {int};\nchan toL =[0] of {int};\nchan fromL =[0] of {int};\nchan sRESET1 =[0] of {int};\nchan sRESET2 =[0] of {int};\nchan rRESET1 =[0] of {int};\nchan rRESET2 =[0] of {int};\nchan sRDY1 =[0] of {int};\nchan sRDY2 =[0] of {int};\nchan sNOTRDY1 =[0] of {int};\nchan sNOTRDY2 =[0] of {int};\nchan rDATA1 =[0] of {int};\nchan rDATA2 =[0] of {int};\nchan rNODATA1 =[0] of {int};\nchan rNODATA2 =[0] of {int};\n\nactive proctype Sender() { \nint n=-1;\nint m=0;\n\nidle: if\n:: sRESET1?0; goto ack_reset; \n\n:: sNOTRDY1?m; goto q_i; \n\n:: sRDY1?m; goto q_a; \n\n:: rRESET1!0; goto reset; \n\nfi;\nack_reset: if\n::  atomic {rRESET1!0;n = -1;}  goto idle; \n\nfi;\nreset: if\n:: sNOTRDY1?m; goto reset; \n\n:: sRDY1?m; goto reset; \n\n::  atomic {sRESET1?0;n = -1;}  goto idle; \n\nfi;\nadvance: if\n:: rNODATA1!n; goto N; \n\n:: rDATA1!n; goto E; \n\nfi;\nN: if\n:: rRESET1!0; goto reset; \n\n:: sRESET1?0; goto ack_reset; \n\n:: rDATA1!n; goto E; \n\n:: sRDY1?m; goto q_n; \n\nfi;\nE: if\n:: rRESET1!0; goto reset; \n\n:: sRESET1?0; goto ack_reset; \n\n:: sNOTRDY1?m; goto q_i; \n\n:: sRDY1?m; goto q_e; \n\nfi;\nq_i: if\n:: m==(n+1)%4; goto idle; \n\n:: m!=(n+1)%4; goto q_error; \n\nfi;\nq_e: if\n::  atomic {m==n;rDATA1!n;}  goto E; \n\n::  d_step {m==(n+1)%4;n = (n+1)%4;}  goto advance; \n\nfi;\nq_n: if\n::  atomic {m==n;rNODATA1!n;}  goto N; \n\n:: m!=n; goto q_error; \n\nfi;\nq_a: if\n::  d_step {m==(n+1)%4;n = (n+1)%4;}  goto advance; \n\n:: m!=(n+1)%4; goto q_error; \n\nfi;\nq_error: \n false; }\n\nactive proctype Receiver() { \nint n=0;\nint m=0;\n\nidle: if\n:: rRESET2?0; goto ack_reset; \n\n:: rNODATA2?m; goto q_i; \n\n:: rDATA2?m; goto q_a; \n\n:: sRESET2!0; goto reset; \n\n:: sRDY2!n; goto E; \n\nfi;\nack_reset: if\n::  atomic {sRESET2!0;n = 0;}  goto idle; \n\nfi;\nreset: if\n:: rDATA2?m; goto reset; \n\n:: rNODATA2?m; goto reset; \n\n::  atomic {rRESET2?0;n = 0;}  goto idle; \n\nfi;\nadvance: if\n:: sNOTRDY2!n; goto N; \n\n:: sRDY2!n; goto E; \n\nfi;\nN: if\n:: sRESET2!0; goto reset; \n\n:: rRESET2?0; goto ack_reset; \n\n:: sRDY2!n; goto E; \n\n:: rDATA2?m; goto q_n; \n\nfi;\nE: if\n:: sRESET2!0; goto reset; \n\n:: rRESET2?0; goto ack_reset; \n\n:: sRDY2!n; goto E; \n\n:: rDATA2?m; goto q_e; \n\n:: rNODATA2?m; goto q_e2; \n\nfi;\nq_i: if\n:: m==n; goto idle; \n\n:: m!=n; goto q_error; \n\nfi;\nq_e: if\n::  atomic {(m+1)%4==n;sRDY2!n;}  goto E; \n\n::  d_step {m==n;n = (n+1)%4;}  goto advance; \n\nfi;\nq_n: if\n::  atomic {(m+1)%4==n;sNOTRDY2!n;}  goto N; \n\n:: (m+1)%4!=n; goto N; \n\nfi;\nq_a: if\n::  d_step {m==n;n = (n+1)%4;}  goto advance; \n\n:: m!=n; goto q_error; \n\nfi;\nq_e2: if\n:: m==n; goto idle; \n\n:: m!=n; goto q_error; \n\nfi;\nq_error: \n false; }\n\nactive proctype StoR() { \nbyte buf[4];\nbyte buf_act=0;\nbyte n=0;\n\nq: if\n::  atomic { ! (buf_act==4);rRESET1?0;buf[buf_act] = 0;buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==4);rDATA1?n;buf[buf_act] = 3+8*n;buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==4);rNODATA1?n;buf[buf_act] = 4+8*n;buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]==0;rRESET2!0;buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = 0;buf_act = buf_act-1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]%8==3;rDATA2!(buf[0]/8);buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = 0;buf_act = buf_act-1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]%8==4;rNODATA2!(buf[0]/8);buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = 0;buf_act = buf_act-1;}  goto q; \n\nfi;\n}\n\nactive proctype RtoS() { \nbyte buf[4];\nbyte buf_act=0;\nbyte n=0;\n\nq: if\n::  atomic { ! (buf_act==4);sRESET2?0;buf[buf_act] = 0;buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==4);sRDY2?n;buf[buf_act] = 1+8*n;buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==4);sNOTRDY2?n;buf[buf_act] = 2+8*n;buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]==0;sRESET1!0;buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = 0;buf_act = buf_act-1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]%8==1;sRDY1!(buf[0]/8);buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = 0;buf_act = buf_act-1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]%8==2;sNOTRDY1!(buf[0]/8);buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = 0;buf_act = buf_act-1;}  goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Protocol for communication between two sides (sender and\n    receiver) over (loosy) medium.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, \n\nProperties to verify:"}, {"role": "assistant", "content": "chan toK =[0] of {int};\nchan fromK =[0] of {int};\nchan toL =[0] of {int};\nchan fromL =[0] of {int};\nchan sRESET1 =[0] of {int};\nchan sRESET2 =[0] of {int};\nchan rRESET1 =[0] of {int};\nchan rRESET2 =[0] of {int};\nchan sRDY1 =[0] of {int};\nchan sRDY2 =[0] of {int};\nchan sNOTRDY1 =[0] of {int};\nchan sNOTRDY2 =[0] of {int};\nchan rDATA1 =[0] of {int};\nchan rDATA2 =[0] of {int};\nchan rNODATA1 =[0] of {int};\nchan rNODATA2 =[0] of {int};\n\nactive proctype Sender() { \nint n=-1;\nint m=0;\n\nidle: if\n:: sRESET1?0; goto ack_reset; \n\n:: sNOTRDY1?m; goto q_i; \n\n:: sRDY1?m; goto q_a; \n\n:: rRESET1!0; goto reset; \n\nfi;\nack_reset: if\n::  atomic {rRESET1!0;n = -1;}  goto idle; \n\nfi;\nreset: if\n:: sNOTRDY1?m; goto reset; \n\n:: sRDY1?m; goto reset; \n\n::  atomic {sRESET1?0;n = -1;}  goto idle; \n\nfi;\nadvance: if\n:: rNODATA1!n; goto N; \n\n:: rDATA1!n; goto E; \n\nfi;\nN: if\n:: rRESET1!0; goto reset; \n\n:: sRESET1?0; goto ack_reset; \n\n:: rDATA1!n; goto E; \n\n:: sRDY1?m; goto q_n; \n\nfi;\nE: if\n:: rRESET1!0; goto reset; \n\n:: sRESET1?0; goto ack_reset; \n\n:: sNOTRDY1?m; goto q_e; \n\n:: sRDY1?m; goto q_e; \n\nfi;\nq_i: if\n:: m==(n+1)%4; goto idle; \n\n:: m!=(n+1)%4; goto q_error; \n\nfi;\nq_e: if\n::  atomic {m==n;rDATA1!n;}  goto E; \n\n::  d_step {m==(n+1)%4;n = (n+1)%4;}  goto advance; \n\nfi;\nq_n: if\n::  atomic {m==n;rNODATA1!n;}  goto N; \n\n:: m!=n; goto q_error; \n\nfi;\nq_a: if\n::  d_step {m==(n+1)%4;n = (n+1)%4;}  goto advance; \n\n:: m!=(n+1)%4; goto q_error; \n\nfi;\nq_error: \n false; }\n\nactive proctype Receiver() { \nint n=0;\nint m=0;\n\nidle: if\n:: rRESET2?0; goto ack_reset; \n\n:: rNODATA2?m; goto q_i; \n\n:: rDATA2?m; goto q_a; \n\n:: sRESET2!0; goto reset; \n\n:: sRDY2!n; goto E; \n\nfi;\nack_reset: if\n::  atomic {sRESET2!0;n = 0;}  goto idle; \n\nfi;\nreset: if\n:: rDATA2?m; goto reset; \n\n:: rNODATA2?m; goto reset; \n\n::  atomic {rRESET2?0;n = 0;}  goto idle; \n\nfi;\nadvance: if\n:: sNOTRDY2!n; goto N; \n\n:: sRDY2!n; goto E; \n\nfi;\nN: if\n:: sRESET2!0; goto reset; \n\n:: rRESET2?0; goto ack_reset; \n\n:: sRDY2!n; goto E; \n\n:: rDATA2?m; goto q_n; \n\nfi;\nE: if\n:: sRESET2!0; goto reset; \n\n:: rRESET2?0; goto ack_reset; \n\n:: sRDY2!n; goto E; \n\n:: rDATA2?m; goto q_e; \n\n:: rNODATA2?m; goto q_e2; \n\nfi;\nq_i: if\n:: m==n; goto idle; \n\n:: m!=n; goto q_error; \n\nfi;\nq_e: if\n::  atomic {(m+1)%4==n;sRDY2!n;}  goto E; \n\n:: m==n; goto advance; \n\nfi;\nq_n: if\n::  atomic {(m+1)%4==n;sNOTRDY2!n;}  goto N; \n\n:: (m+1)%4!=n; goto N; \n\nfi;\nq_a: if\n::  d_step {m==n;n = (n+1)%4;}  goto advance; \n\n:: m!=n; goto q_error; \n\nfi;\nq_e2: if\n:: m==n; goto idle; \n\n:: m!=n; goto q_error; \n\nfi;\nq_error: \n false; }\n\nactive proctype StoR() { \nbyte buf[5];\nbyte buf_act=0;\nbyte n=0;\n\nq: if\n::  atomic { ! (buf_act==5);rRESET1?0;buf[buf_act] = 0;buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==5);rDATA1?n;buf[buf_act] = 3+8*n;buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==5);rNODATA1?n;buf[buf_act] = 4+8*n;buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]==0;rRESET2!0;buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = buf[4];buf[4] = 0;buf_act = buf_act-1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]%8==3;rDATA2!(buf[0]/8);buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = buf[4];buf[4] = 0;buf_act = buf_act-1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]%8==4;rNODATA2!(buf[0]/8);buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = buf[4];buf[4] = 0;buf_act = buf_act-1;}  goto q; \n\nfi;\n}\n\nactive proctype RtoS() { \nbyte buf[5];\nbyte buf_act=0;\nbyte n=0;\n\nq: if\n::  atomic { ! (buf_act==5);sRESET2?0;buf[buf_act] = 0;buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==5);sRDY2?n;buf[buf_act] = 1+8*n;buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==5);sNOTRDY2?n;buf[buf_act] = 2+8*n;buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]==0;sRESET1!0;buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = buf[4];buf[4] = 0;buf_act = buf_act-1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]%8==1;sRDY1!(buf[0]/8);buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = buf[4];buf[4] = 0;buf_act = buf_act-1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]%8==2;sNOTRDY1!(buf[0]/8);buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = buf[4];buf[4] = 0;buf_act = buf_act-1;}  goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Protocol for communication between two sides (sender and\n    receiver) over (loosy) medium.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, \n\nProperties to verify:"}, {"role": "assistant", "content": "chan toK =[0] of {int};\nchan fromK =[0] of {int};\nchan toL =[0] of {int};\nchan fromL =[0] of {int};\nchan sRESET1 =[0] of {int};\nchan sRESET2 =[0] of {int};\nchan rRESET1 =[0] of {int};\nchan rRESET2 =[0] of {int};\nchan sRDY1 =[0] of {int};\nchan sRDY2 =[0] of {int};\nchan sNOTRDY1 =[0] of {int};\nchan sNOTRDY2 =[0] of {int};\nchan rDATA1 =[0] of {int};\nchan rDATA2 =[0] of {int};\nchan rNODATA1 =[0] of {int};\nchan rNODATA2 =[0] of {int};\n\nactive proctype Sender() { \nint n=-1;\nint m=0;\n\nidle: if\n:: sRESET1?0; goto ack_reset; \n\n:: sNOTRDY1?m; goto q_i; \n\n:: sRDY1?m; goto q_a; \n\n:: rRESET1!0; goto reset; \n\nfi;\nack_reset: if\n::  atomic {rRESET1!0;n = -1;}  goto idle; \n\nfi;\nreset: if\n:: sNOTRDY1?m; goto reset; \n\n:: sRDY1?m; goto reset; \n\n::  atomic {sRESET1?0;n = -1;}  goto idle; \n\nfi;\nadvance: if\n:: rNODATA1!n; goto N; \n\n:: rDATA1!n; goto E; \n\nfi;\nN: if\n:: rRESET1!0; goto reset; \n\n:: sRESET1?0; goto ack_reset; \n\n:: rDATA1!n; goto E; \n\n:: sRDY1?m; goto q_n; \n\nfi;\nE: if\n:: rRESET1!0; goto reset; \n\n:: sRESET1?0; goto ack_reset; \n\n:: sNOTRDY1?m; goto q_e; \n\n:: sRDY1?m; goto q_e; \n\nfi;\nq_i: if\n:: m==(n+1)%4; goto idle; \n\n:: m!=(n+1)%4; goto q_error; \n\nfi;\nq_e: if\n::  atomic {m==n;rDATA1!n;}  goto E; \n\n::  d_step {m==(n+1)%4;n = (n+1)%4;}  goto advance; \n\nfi;\nq_n: if\n::  atomic {m==n;rNODATA1!n;}  goto N; \n\n:: m!=n; goto q_error; \n\nfi;\nq_a: if\n::  d_step {m==(n+1)%4;n = (n+1)%4;}  goto advance; \n\n:: m!=(n+1)%4; goto q_error; \n\nfi;\nq_error: \n false; }\n\nactive proctype Receiver() { \nint n=0;\nint m=0;\n\nidle: if\n:: rRESET2?0; goto ack_reset; \n\n:: rNODATA2?m; goto q_i; \n\n:: rDATA2?m; goto q_a; \n\n:: sRESET2!0; goto reset; \n\n:: sRDY2!n; goto E; \n\nfi;\nack_reset: if\n::  atomic {sRESET2!0;n = 0;}  goto idle; \n\nfi;\nreset: if\n:: rDATA2?m; goto reset; \n\n:: rNODATA2?m; goto reset; \n\n::  atomic {rRESET2?0;n = 0;}  goto idle; \n\nfi;\nadvance: if\n:: sNOTRDY2!n; goto N; \n\n:: sRDY2!n; goto E; \n\nfi;\nN: if\n:: sRESET2!0; goto reset; \n\n:: rRESET2?0; goto ack_reset; \n\n:: sRDY2!n; goto E; \n\n:: rDATA2?m; goto q_n; \n\nfi;\nE: if\n:: sRESET2!0; goto reset; \n\n:: rRESET2?0; goto ack_reset; \n\n:: sRDY2!n; goto E; \n\n:: rDATA2?m; goto q_e; \n\n:: rNODATA2?m; goto q_e2; \n\nfi;\nq_i: if\n:: m==n; goto idle; \n\n:: m!=n; goto q_error; \n\nfi;\nq_e: if\n::  atomic {(m+1)%4==n;sRDY2!n;}  goto E; \n\n::  d_step {m==n;n = (n+1)%4;}  goto advance; \n\nfi;\nq_n: if\n::  atomic {(m+1)%4==n;sNOTRDY2!n;}  goto N; \n\n:: (m+1)%4!=n; goto N; \n\nfi;\nq_a: if\n::  d_step {m==n;n = (n+1)%4;}  goto advance; \n\n:: m!=n; goto q_error; \n\nfi;\nq_e2: if\n:: m==n; goto idle; \n\n:: m!=n; goto q_error; \n\nfi;\nq_error: \n false; }\n\nactive proctype StoR() { \nbyte buf[10];\nbyte buf_act=0;\nbyte n=0;\n\nq: if\n::  atomic { ! (buf_act==10);rRESET1?0;buf[buf_act] = 0;buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==10);rDATA1?n;buf[buf_act] = 3+8*n;buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==10);rNODATA1?n;buf[buf_act] = 4+8*n;buf_act = buf_act+1;}  goto q; \n\n::  d_step { ! (buf_act==0);buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = buf[4];buf[4] = buf[5];buf[5] = buf[6];buf[6] = buf[7];buf[7] = buf[8];buf[8] = buf[9];buf[9] = 0;buf_act = buf_act-1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]==0;rRESET2!0;buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = buf[4];buf[4] = buf[5];buf[5] = buf[6];buf[6] = buf[7];buf[7] = buf[8];buf[8] = buf[9];buf[9] = 0;buf_act = buf_act-1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]%8==3;rDATA2!(buf[0]/8);buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = buf[4];buf[4] = buf[5];buf[5] = buf[6];buf[6] = buf[7];buf[7] = buf[8];buf[8] = buf[9];buf[9] = 0;buf_act = buf_act-1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]%8==4;rNODATA2!(buf[0]/8);buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = buf[4];buf[4] = buf[5];buf[5] = buf[6];buf[6] = buf[7];buf[7] = buf[8];buf[8] = buf[9];buf[9] = 0;buf_act = buf_act-1;}  goto q; \n\nfi;\n}\n\nactive proctype RtoS() { \nbyte buf[10];\nbyte buf_act=0;\nbyte n=0;\n\nq: if\n::  atomic { ! (buf_act==10);sRESET2?0;buf[buf_act] = 0;buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==10);sRDY2?n;buf[buf_act] = 1+8*n;buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==10);sNOTRDY2?n;buf[buf_act] = 2+8*n;buf_act = buf_act+1;}  goto q; \n\n::  d_step { ! (buf_act==0);buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = buf[4];buf[4] = buf[5];buf[5] = buf[6];buf[6] = buf[7];buf[7] = buf[8];buf[8] = buf[9];buf[9] = 0;buf_act = buf_act-1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]==0;sRESET1!0;buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = buf[4];buf[4] = buf[5];buf[5] = buf[6];buf[6] = buf[7];buf[7] = buf[8];buf[8] = buf[9];buf[9] = 0;buf_act = buf_act-1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]%8==1;sRDY1!(buf[0]/8);buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = buf[4];buf[4] = buf[5];buf[5] = buf[6];buf[6] = buf[7];buf[7] = buf[8];buf[8] = buf[9];buf[9] = 0;buf_act = buf_act-1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]%8==2;sNOTRDY1!(buf[0]/8);buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = buf[4];buf[4] = buf[5];buf[5] = buf[6];buf[6] = buf[7];buf[7] = buf[8];buf[8] = buf[9];buf[9] = 0;buf_act = buf_act-1;}  goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Protocol for communication between two sides (sender and\n    receiver) over (loosy) medium.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, \n\nProperties to verify:"}, {"role": "assistant", "content": "chan toK =[0] of {int};\nchan fromK =[0] of {int};\nchan toL =[0] of {int};\nchan fromL =[0] of {int};\nchan sRESET1 =[0] of {int};\nchan sRESET2 =[0] of {int};\nchan rRESET1 =[0] of {int};\nchan rRESET2 =[0] of {int};\nchan sRDY1 =[0] of {int};\nchan sRDY2 =[0] of {int};\nchan sNOTRDY1 =[0] of {int};\nchan sNOTRDY2 =[0] of {int};\nchan rDATA1 =[0] of {int};\nchan rDATA2 =[0] of {int};\nchan rNODATA1 =[0] of {int};\nchan rNODATA2 =[0] of {int};\n\nactive proctype Sender() { \nint n=-1;\nint m=0;\n\nidle: if\n:: sRESET1?0; goto ack_reset; \n\n:: sNOTRDY1?m; goto q_i; \n\n:: sRDY1?m; goto q_a; \n\n:: rRESET1!0; goto reset; \n\nfi;\nack_reset: if\n::  atomic {rRESET1!0;n = -1;}  goto idle; \n\nfi;\nreset: if\n:: sNOTRDY1?m; goto reset; \n\n:: sRDY1?m; goto reset; \n\n::  atomic {sRESET1?0;n = -1;}  goto idle; \n\nfi;\nadvance: if\n:: rNODATA1!n; goto N; \n\n:: rDATA1!n; goto E; \n\nfi;\nN: if\n:: rRESET1!0; goto reset; \n\n:: sRESET1?0; goto ack_reset; \n\n:: rDATA1!n; goto E; \n\n:: sRDY1?m; goto q_n; \n\nfi;\nE: if\n:: rRESET1!0; goto reset; \n\n:: sRESET1?0; goto ack_reset; \n\n:: sNOTRDY1?m; goto q_e; \n\n:: sRDY1?m; goto q_e; \n\nfi;\nq_i: if\n:: m==(n+1)%4; goto idle; \n\n:: m!=(n+1)%4; goto q_error; \n\nfi;\nq_e: if\n::  atomic {m==n;rDATA1!n;}  goto E; \n\n::  d_step {m==(n+1)%4;n = (n+1)%4;}  goto advance; \n\nfi;\nq_n: if\n::  atomic {m==n;rDATA1!n;}  goto N; \n\n:: m!=n; goto q_error; \n\nfi;\nq_a: if\n::  d_step {m==(n+1)%4;n = (n+1)%4;}  goto advance; \n\n:: m!=(n+1)%4; goto q_error; \n\nfi;\nq_error: \n false; }\n\nactive proctype Receiver() { \nint n=0;\nint m=0;\n\nidle: if\n:: rRESET2?0; goto ack_reset; \n\n:: rNODATA2?m; goto q_i; \n\n:: rDATA2?m; goto q_a; \n\n:: sRESET2!0; goto reset; \n\n:: sRDY2!n; goto E; \n\nfi;\nack_reset: if\n::  atomic {sRESET2!0;n = 0;}  goto idle; \n\nfi;\nreset: if\n:: rDATA2?m; goto reset; \n\n:: rNODATA2?m; goto reset; \n\n::  atomic {rRESET2?0;n = 0;}  goto idle; \n\nfi;\nadvance: if\n:: sNOTRDY2!n; goto N; \n\n:: sRDY2!n; goto E; \n\nfi;\nN: if\n:: sRESET2!0; goto reset; \n\n:: rRESET2?0; goto ack_reset; \n\n:: sRDY2!n; goto E; \n\n:: rDATA2?m; goto q_n; \n\nfi;\nE: if\n:: sRESET2!0; goto reset; \n\n:: rRESET2?0; goto ack_reset; \n\n:: sRDY2!n; goto E; \n\n:: rDATA2?m; goto q_e; \n\n:: rNODATA2?m; goto q_e2; \n\nfi;\nq_i: if\n:: m==n; goto idle; \n\n:: m!=n; goto q_error; \n\nfi;\nq_e: if\n::  atomic {(m+1)%4==n;sRDY2!n;}  goto E; \n\n::  d_step {m==n;n = (n+1)%4;}  goto advance; \n\nfi;\nq_n: if\n::  atomic {(m+1)%4==n;sNOTRDY2!n;}  goto N; \n\n:: (m+1)%4!=n; goto N; \n\nfi;\nq_a: if\n::  d_step {m==n;n = (n+1)%4;}  goto advance; \n\n:: m!=n; goto q_error; \n\nfi;\nq_e2: if\n:: m==n; goto idle; \n\n:: m!=n; goto q_error; \n\nfi;\nq_error: \n false; }\n\nactive proctype StoR() { \nbyte buf[15];\nbyte buf_act=0;\nbyte n=0;\n\nq: if\n::  atomic { ! (buf_act==15);rRESET1?0;buf[buf_act] = 0;buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==15);rDATA1?n;buf[buf_act] = 3+8*n;buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==15);rNODATA1?n;buf[buf_act] = 4+8*n;buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]==0;rRESET2!0;buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = buf[4];buf[4] = buf[5];buf[5] = buf[6];buf[6] = buf[7];buf[7] = buf[8];buf[8] = buf[9];buf[9] = buf[10];buf[10] = buf[11];buf[11] = buf[12];buf[12] = buf[13];buf[13] = buf[14];buf[14] = 0;buf_act = buf_act-1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]%8==3;rDATA2!(buf[0]/8);buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = buf[4];buf[4] = buf[5];buf[5] = buf[6];buf[6] = buf[7];buf[7] = buf[8];buf[8] = buf[9];buf[9] = buf[10];buf[10] = buf[11];buf[11] = buf[12];buf[12] = buf[13];buf[13] = buf[14];buf[14] = 0;buf_act = buf_act-1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]%8==4;rNODATA2!(buf[0]/8);buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = buf[4];buf[4] = buf[5];buf[5] = buf[6];buf[6] = buf[7];buf[7] = buf[8];buf[8] = buf[9];buf[9] = buf[10];buf[10] = buf[11];buf[11] = buf[12];buf[12] = buf[13];buf[13] = buf[14];buf[14] = 0;buf_act = buf_act-1;}  goto q; \n\nfi;\n}\n\nactive proctype RtoS() { \nbyte buf[15];\nbyte buf_act=0;\nbyte n=0;\n\nq: if\n::  atomic { ! (buf_act==15);sRESET2?0;buf[buf_act] = 0;buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==15);sRDY2?n;buf[buf_act] = 1+8*n;buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==15);sNOTRDY2?n;buf[buf_act] = 2+8*n;buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]==0;sRESET1!0;buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = buf[4];buf[4] = buf[5];buf[5] = buf[6];buf[6] = buf[7];buf[7] = buf[8];buf[8] = buf[9];buf[9] = buf[10];buf[10] = buf[11];buf[11] = buf[12];buf[12] = buf[13];buf[13] = buf[14];buf[14] = 0;buf_act = buf_act-1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]%8==1;sRDY1!(buf[0]/8);buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = buf[4];buf[4] = buf[5];buf[5] = buf[6];buf[6] = buf[7];buf[7] = buf[8];buf[8] = buf[9];buf[9] = buf[10];buf[10] = buf[11];buf[11] = buf[12];buf[12] = buf[13];buf[13] = buf[14];buf[14] = 0;buf_act = buf_act-1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]%8==2;sNOTRDY1!(buf[0]/8);buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = buf[4];buf[4] = buf[5];buf[5] = buf[6];buf[6] = buf[7];buf[7] = buf[8];buf[8] = buf[9];buf[9] = buf[10];buf[10] = buf[11];buf[11] = buf[12];buf[12] = buf[13];buf[13] = buf[14];buf[14] = 0;buf_act = buf_act-1;}  goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Protocol for communication between two sides (sender and\n    receiver) over (loosy) medium.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, \n\nProperties to verify:"}, {"role": "assistant", "content": "chan toK =[0] of {int};\nchan fromK =[0] of {int};\nchan toL =[0] of {int};\nchan fromL =[0] of {int};\nchan sRESET1 =[0] of {int};\nchan sRESET2 =[0] of {int};\nchan rRESET1 =[0] of {int};\nchan rRESET2 =[0] of {int};\nchan sRDY1 =[0] of {int};\nchan sRDY2 =[0] of {int};\nchan sNOTRDY1 =[0] of {int};\nchan sNOTRDY2 =[0] of {int};\nchan rDATA1 =[0] of {int};\nchan rDATA2 =[0] of {int};\nchan rNODATA1 =[0] of {int};\nchan rNODATA2 =[0] of {int};\n\nactive proctype Sender() { \nint n=-1;\nint m=0;\n\nidle: if\n:: sRESET1?0; goto ack_reset; \n\n:: sNOTRDY1?m; goto q_i; \n\n:: sRDY1?m; goto q_a; \n\n:: rRESET1!0; goto reset; \n\nfi;\nack_reset: if\n::  atomic {rRESET1!0;n = -1;}  goto idle; \n\nfi;\nreset: if\n:: sNOTRDY1?m; goto reset; \n\n:: sRDY1?m; goto reset; \n\n::  atomic {sRESET1?0;n = -1;}  goto idle; \n\nfi;\nadvance: if\n:: rNODATA1!n; goto N; \n\n:: rDATA1!n; goto E; \n\nfi;\nN: if\n:: rRESET1!0; goto reset; \n\n:: sRESET1?0; goto ack_reset; \n\n:: rDATA1!n; goto E; \n\n:: sRDY1?m; goto q_n; \n\nfi;\nE: if\n:: rRESET1!0; goto reset; \n\n:: sRESET1?0; goto ack_reset; \n\n:: sNOTRDY1?m; goto q_e; \n\n:: sRDY1?m; goto q_e; \n\nfi;\nq_i: if\n:: m==(n+1)%4; goto idle; \n\n:: m!=(n+1)%4; goto q_error; \n\nfi;\nq_e: if\n::  atomic {m==n;rDATA1!n;}  goto E; \n\n::  d_step {m==(n+1)%4;n = (n+1)%4;}  goto advance; \n\nfi;\nq_n: if\n::  atomic {m==n;rDATA1!n;}  goto N; \n\n:: m!=n; goto q_error; \n\nfi;\nq_a: if\n::  d_step {m==(n+1)%4;n = (n+1)%4;}  goto advance; \n\n:: m!=(n+1)%4; goto q_error; \n\nfi;\nq_error: \n false; }\n\nactive proctype Receiver() { \nint n=0;\nint m=0;\n\nidle: if\n:: rRESET2?0; goto ack_reset; \n\n:: rNODATA2?m; goto q_i; \n\n:: rDATA2?m; goto q_a; \n\n:: sRESET2!0; goto reset; \n\n:: sRDY2!n; goto E; \n\nfi;\nack_reset: if\n::  atomic {sRESET2!0;n = 0;}  goto idle; \n\nfi;\nreset: if\n:: rDATA2?m; goto reset; \n\n:: rNODATA2?m; goto reset; \n\n::  atomic {rRESET2?0;n = 0;}  goto idle; \n\nfi;\nadvance: if\n:: sNOTRDY2!n; goto N; \n\n:: sRDY2!n; goto E; \n\nfi;\nN: if\n:: sRESET2!0; goto reset; \n\n:: rRESET2?0; goto ack_reset; \n\n:: sRDY2!n; goto E; \n\n:: rDATA2?m; goto q_n; \n\nfi;\nE: if\n:: sRESET2!0; goto reset; \n\n:: rRESET2?0; goto ack_reset; \n\n:: sRDY2!n; goto E; \n\n:: rDATA2?m; goto q_e; \n\n:: rNODATA2?m; goto q_e2; \n\nfi;\nq_i: if\n:: m==n; goto idle; \n\n:: m!=n; goto q_error; \n\nfi;\nq_e: if\n::  atomic {(m+1)%4==n;sRDY2!n;}  goto E; \n\n::  d_step {m==n;n = (n+1)%4;}  goto advance; \n\nfi;\nq_n: if\n::  atomic {(m+1)%4==n;sNOTRDY2!n;}  goto N; \n\n:: (m+1)%4!=n; goto N; \n\nfi;\nq_a: if\n::  d_step {m==n;n = (n+1)%4;}  goto advance; \n\n:: m!=n; goto q_error; \n\nfi;\nq_e2: if\n:: m==n; goto idle; \n\n:: m!=n; goto q_error; \n\nfi;\nq_error: \n false; }\n\nactive proctype StoR() { \nbyte buf[20];\nbyte buf_act=0;\nbyte n=0;\n\nq: if\n::  atomic { ! (buf_act==20);rRESET1?0;buf[buf_act] = 0;buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==20);rDATA1?n;buf[buf_act] = 3+8*n;buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==20);rNODATA1?n;buf[buf_act] = 4+8*n;buf_act = buf_act+1;}  goto q; \n\n::  d_step { ! (buf_act==0);buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = buf[4];buf[4] = buf[5];buf[5] = buf[6];buf[6] = buf[7];buf[7] = buf[8];buf[8] = buf[9];buf[9] = buf[10];buf[10] = buf[11];buf[11] = buf[12];buf[12] = buf[13];buf[13] = buf[14];buf[14] = buf[15];buf[15] = buf[16];buf[16] = buf[17];buf[17] = buf[18];buf[18] = buf[19];buf[19] = 0;buf_act = buf_act-1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]==0;rRESET2!0;buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = buf[4];buf[4] = buf[5];buf[5] = buf[6];buf[6] = buf[7];buf[7] = buf[8];buf[8] = buf[9];buf[9] = buf[10];buf[10] = buf[11];buf[11] = buf[12];buf[12] = buf[13];buf[13] = buf[14];buf[14] = buf[15];buf[15] = buf[16];buf[16] = buf[17];buf[17] = buf[18];buf[18] = buf[19];buf[19] = 0;buf_act = buf_act-1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]%8==3;rDATA2!(buf[0]/8);buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = buf[4];buf[4] = buf[5];buf[5] = buf[6];buf[6] = buf[7];buf[7] = buf[8];buf[8] = buf[9];buf[9] = buf[10];buf[10] = buf[11];buf[11] = buf[12];buf[12] = buf[13];buf[13] = buf[14];buf[14] = buf[15];buf[15] = buf[16];buf[16] = buf[17];buf[17] = buf[18];buf[18] = buf[19];buf[19] = 0;buf_act = buf_act-1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]%8==4;rNODATA2!(buf[0]/8);buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = buf[4];buf[4] = buf[5];buf[5] = buf[6];buf[6] = buf[7];buf[7] = buf[8];buf[8] = buf[9];buf[9] = buf[10];buf[10] = buf[11];buf[11] = buf[12];buf[12] = buf[13];buf[13] = buf[14];buf[14] = buf[15];buf[15] = buf[16];buf[16] = buf[17];buf[17] = buf[18];buf[18] = buf[19];buf[19] = 0;buf_act = buf_act-1;}  goto q; \n\nfi;\n}\n\nactive proctype RtoS() { \nbyte buf[20];\nbyte buf_act=0;\nbyte n=0;\n\nq: if\n::  atomic { ! (buf_act==20);sRESET2?0;buf[buf_act] = 0;buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==20);sRDY2?n;buf[buf_act] = 1+8*n;buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==20);sNOTRDY2?n;buf[buf_act] = 2+8*n;buf_act = buf_act+1;}  goto q; \n\n::  d_step { ! (buf_act==0);buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = buf[4];buf[4] = buf[5];buf[5] = buf[6];buf[6] = buf[7];buf[7] = buf[8];buf[8] = buf[9];buf[9] = buf[10];buf[10] = buf[11];buf[11] = buf[12];buf[12] = buf[13];buf[13] = buf[14];buf[14] = buf[15];buf[15] = buf[16];buf[16] = buf[17];buf[17] = buf[18];buf[18] = buf[19];buf[19] = 0;buf_act = buf_act-1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]==0;sRESET1!0;buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = buf[4];buf[4] = buf[5];buf[5] = buf[6];buf[6] = buf[7];buf[7] = buf[8];buf[8] = buf[9];buf[9] = buf[10];buf[10] = buf[11];buf[11] = buf[12];buf[12] = buf[13];buf[13] = buf[14];buf[14] = buf[15];buf[15] = buf[16];buf[16] = buf[17];buf[17] = buf[18];buf[18] = buf[19];buf[19] = 0;buf_act = buf_act-1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]%8==1;sRDY1!(buf[0]/8);buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = buf[4];buf[4] = buf[5];buf[5] = buf[6];buf[6] = buf[7];buf[7] = buf[8];buf[8] = buf[9];buf[9] = buf[10];buf[10] = buf[11];buf[11] = buf[12];buf[12] = buf[13];buf[13] = buf[14];buf[14] = buf[15];buf[15] = buf[16];buf[16] = buf[17];buf[17] = buf[18];buf[18] = buf[19];buf[19] = 0;buf_act = buf_act-1;}  goto q; \n\n::  atomic { ! (buf_act==0) && buf[0]%8==2;sNOTRDY1!(buf[0]/8);buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = buf[4];buf[4] = buf[5];buf[5] = buf[6];buf[6] = buf[7];buf[7] = buf[8];buf[8] = buf[9];buf[9] = buf[10];buf[10] = buf[11];buf[11] = buf[12];buf[12] = buf[13];buf[13] = buf[14];buf[14] = buf[15];buf[15] = buf[16];buf[16] = buf[17];buf[17] = buf[18];buf[18] = buf[19];buf[19] = 0;buf_act = buf_act-1;}  goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "todo\n\nParameters:\n\n\n\n\n\n\n\nAtomic propositions:\n, , , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte request[2];\nbyte starvers[2];\nbyte resources[2];\nint res0[2];\nint res1[2];\nint acquiring[2];\nint entryRound=1;\nbyte phase=0;\nbyte fire=0;\n\n\nactive proctype round_about() { \nint i=0;\n\nreset: if\n::  d_step {i<2;res0[i] = -1;res1[i] = -1;acquiring[i] = -1;i = i+1;}  goto reset; \n\n::  d_step {i==2;i = 0;phase = 0;}  goto begin0; \n\nfi;\nbegin0: if\n::  d_step {i<2;resources[i] = 0;i = i+1;}  goto begin0; \n\n::  d_step {i==2;i = 0;}  goto begin1; \n\nfi;\nbegin1: if\n::  d_step {i<2 && res0[i]!=-1;resources[res0[i]*2] = entryRound;resources[res0[i]*2+1] = i;i = i+1;}  goto begin1; \n\n::  d_step {i<2 && res0[i]==-1;i = i+1;}  goto begin1; \n\n::  d_step {i==2;i = 0;}  goto begin2; \n\nfi;\nbegin2: if\n::  d_step {i<2 && res1[i]!=-1;resources[res1[i]*2] = entryRound;resources[res1[i]*2+1] = i;i = i+1;}  goto begin2; \n\n::  d_step {i<2 && res1[i]==-1;i = i+1;}  goto begin2; \n\n::  d_step {i==2;i = 0;phase = 1;fire = 0;}  goto action; \n\nfi;\naction: if\n::  d_step {fire==2;fire = 0;phase = 2;}  goto end0; \n\nfi;\nend0: if\n::  d_step {i<1 && resources[2*i]!=0;request[1*resources[2*i+1]+i] = 0;starvers[1*resources[2*i+1]+i] = 0;i = i+1;}  goto end0; \n\n::  d_step {i<1 && resources[2*i]==0;i = i+1;}  goto end0; \n\n::  d_step {i==1;i = 0;}  goto end1; \n\nfi;\nend1: if\n::  d_step {i<2;i = i+1;}  goto end1; \n\n::  d_step {i==2 && fire==2;phase = 0;i = 0;}  goto begin0; \n\nfi;\nbegin3: \nend2: \n false; }\n\nactive proctype phil_0() { \nint i=0;\n\naction: if\n::  d_step {phase==1 && res0[0]!=-1;resources[res0[0]] = 0;resources[res0[0]+1] = 0;res0[0] = res1[0];res1[0] = -1;fire = fire+1;}  goto end; \n\n::  d_step {phase==1 && res1[0]==-1 && acquiring[0]==-1;acquiring[0] = 0;fire = fire+1;request[0*1+0] = entryRound;}  goto end; \n\n::  d_step {phase==1;fire = fire+1;}  goto end; \n\nfi;\nend: if\n::  d_step {phase==2 && acquiring[0]==-1;fire = fire+1;}  goto action; \n\n:: phase==2 && acquiring[0]!=-1 && fire==0; goto mutex; \n\n::  d_step {phase==2 && acquiring[0]!=-1;fire = fire+1;}  goto action; \n\nfi;\nmutex: if\n::  d_step {i<2 && res0[i]!=acquiring[0] && res1[i]!=acquiring[0];i = i+1;}  goto mutex; \n\n::  d_step {i<2 && (res0[i]==acquiring[0] || res1[i]==acquiring[0]);fire = fire+1;i = i+1;}  goto action; \n\n::  d_step {i==2 && res0[0]==-1;res0[0] = acquiring[0];acquiring[0] = -1;fire = fire+1;i = 0;}  goto action; \n\n::  d_step {i==2 && res0[0]!=-1;res1[0] = acquiring[0];acquiring[0] = -1;fire = fire+1;i = 0;}  goto action; \n\nfi;\n}\n\nactive proctype phil_1() { \nint i=0;\n\naction: if\n::  d_step {phase==1 && res0[1]!=-1;resources[res0[1]] = 0;resources[res0[1]+1] = 0;res0[1] = res1[1];res1[1] = -1;fire = fire+1;}  goto end; \n\n::  d_step {phase==1 && res1[1]==-1 && acquiring[1]==-1;acquiring[1] = 0;fire = fire+1;request[1*1+0] = entryRound;}  goto end; \n\n::  d_step {phase==1;fire = fire+1;}  goto end; \n\nfi;\nend: if\n::  d_step {phase==2 && acquiring[1]==-1;fire = fire+1;}  goto action; \n\n:: phase==2 && acquiring[1]!=-1 && fire==1; goto mutex; \n\n::  d_step {phase==2 && acquiring[1]!=-1;fire = fire+1;}  goto action; \n\nfi;\nmutex: if\n::  d_step {i<2 && res0[i]!=acquiring[1] && res1[i]!=acquiring[1];i = i+1;}  goto mutex; \n\n::  d_step {i<2 && (res0[i]==acquiring[1] || res1[i]==acquiring[1]);fire = fire+1;i = i+1;}  goto action; \n\n::  d_step {i==2 && res0[1]==-1;res0[1] = acquiring[1];acquiring[1] = -1;fire = fire+1;i = 0;}  goto action; \n\n::  d_step {i==2 && res0[1]!=-1;res1[1] = acquiring[1];acquiring[1] = -1;fire = fire+1;i = 0;}  goto action; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "todo\n\nParameters:\n\n\n\n\n\n\n\nAtomic propositions:\n, , , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte request[3];\nbyte starvers[3];\nbyte resources[2];\nint res0[3];\nint res1[3];\nint acquiring[3];\nint entryRound=1;\nbyte phase=0;\nbyte fire=0;\n\n\nactive proctype round_about() { \nint i=0;\n\nreset: if\n::  d_step {i<3;res0[i] = -1;res1[i] = -1;acquiring[i] = -1;i = i+1;}  goto reset; \n\n::  d_step {i==3;i = 0;phase = 0;}  goto begin0; \n\nfi;\nbegin0: if\n::  d_step {i<2;resources[i] = 0;i = i+1;}  goto begin0; \n\n::  d_step {i==2;i = 0;}  goto begin1; \n\nfi;\nbegin1: if\n::  d_step {i<3 && res0[i]!=-1;resources[res0[i]*2] = entryRound;resources[res0[i]*2+1] = i;i = i+1;}  goto begin1; \n\n::  d_step {i<3 && res0[i]==-1;i = i+1;}  goto begin1; \n\n::  d_step {i==3;i = 0;}  goto begin2; \n\nfi;\nbegin2: if\n::  d_step {i<3 && res1[i]!=-1;resources[res1[i]*2] = entryRound;resources[res1[i]*2+1] = i;i = i+1;}  goto begin2; \n\n::  d_step {i<3 && res1[i]==-1;i = i+1;}  goto begin2; \n\n::  d_step {i==3;i = 0;phase = 1;fire = 0;}  goto action; \n\nfi;\naction: if\n::  d_step {fire==3;fire = 0;phase = 2;}  goto end0; \n\nfi;\nend0: if\n::  d_step {i<1 && resources[2*i]!=0;request[1*resources[2*i+1]+i] = 0;starvers[1*resources[2*i+1]+i] = 0;i = i+1;}  goto end0; \n\n::  d_step {i<1 && resources[2*i]==0;i = i+1;}  goto end0; \n\n::  d_step {i==1;i = 0;}  goto end1; \n\nfi;\nend1: if\n::  d_step {i<3;i = i+1;}  goto end1; \n\n::  d_step {i==3 && fire==3;phase = 0;i = 0;}  goto begin0; \n\nfi;\nbegin3: \nend2: \n false; }\n\nactive proctype phil_0() { \nint i=0;\n\naction: if\n::  d_step {phase==1 && res0[0]!=-1;resources[res0[0]] = 0;resources[res0[0]+1] = 0;res0[0] = res1[0];res1[0] = -1;fire = fire+1;}  goto end; \n\n::  d_step {phase==1 && res1[0]==-1 && acquiring[0]==-1;acquiring[0] = 0;fire = fire+1;request[0*1+0] = entryRound;}  goto end; \n\n::  d_step {phase==1;fire = fire+1;}  goto end; \n\nfi;\nend: if\n::  d_step {phase==2 && acquiring[0]==-1;fire = fire+1;}  goto action; \n\n::  d_step {phase==2 && acquiring[0]!=-1 && res0[0]==-1;res0[0] = acquiring[0];acquiring[0] = -1;fire = fire+1;}  goto action; \n\n::  d_step {phase==2 && acquiring[0]!=-1 && res0[0]!=-1;res1[0] = acquiring[0];acquiring[0] = -1;fire = fire+1;}  goto action; \n\nfi;\nmutex: \n false; }\n\nactive proctype phil_1() { \nint i=0;\n\naction: if\n::  d_step {phase==1 && res0[1]!=-1;resources[res0[1]] = 0;resources[res0[1]+1] = 0;res0[1] = res1[1];res1[1] = -1;fire = fire+1;}  goto end; \n\n::  d_step {phase==1 && res1[1]==-1 && acquiring[1]==-1;acquiring[1] = 0;fire = fire+1;request[1*1+0] = entryRound;}  goto end; \n\n::  d_step {phase==1;fire = fire+1;}  goto end; \n\nfi;\nend: if\n::  d_step {phase==2 && acquiring[1]==-1;fire = fire+1;}  goto action; \n\n::  d_step {phase==2 && acquiring[1]!=-1 && res0[1]==-1;res0[1] = acquiring[1];acquiring[1] = -1;fire = fire+1;}  goto action; \n\n::  d_step {phase==2 && acquiring[1]!=-1 && res0[1]!=-1;res1[1] = acquiring[1];acquiring[1] = -1;fire = fire+1;}  goto action; \n\nfi;\nmutex: \n false; }\n\nactive proctype phil_2() { \nint i=0;\n\naction: if\n::  d_step {phase==1 && res0[2]!=-1;resources[res0[2]] = 0;resources[res0[2]+1] = 0;res0[2] = res1[2];res1[2] = -1;fire = fire+1;}  goto end; \n\n::  d_step {phase==1 && res1[2]==-1 && acquiring[2]==-1;acquiring[2] = 0;fire = fire+1;request[2*1+0] = entryRound;}  goto end; \n\n::  d_step {phase==1;fire = fire+1;}  goto end; \n\nfi;\nend: if\n::  d_step {phase==2 && acquiring[2]==-1;fire = fire+1;}  goto action; \n\n::  d_step {phase==2 && acquiring[2]!=-1 && res0[2]==-1;res0[2] = acquiring[2];acquiring[2] = -1;fire = fire+1;}  goto action; \n\n::  d_step {phase==2 && acquiring[2]!=-1 && res0[2]!=-1;res1[2] = acquiring[2];acquiring[2] = -1;fire = fire+1;}  goto action; \n\nfi;\nmutex: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "todo\n\nParameters:\n\n\n\n\n\n\n\nAtomic propositions:\n, , , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte request[3];\nbyte starvers[3];\nbyte resources[2];\nint res0[3];\nint res1[3];\nint acquiring[3];\nint entryRound=1;\nbyte phase=0;\nbyte fire=0;\n\n\nactive proctype round_about() { \nint i=0;\n\nreset: if\n::  d_step {i<3;res0[i] = -1;res1[i] = -1;acquiring[i] = -1;i = i+1;}  goto reset; \n\n::  d_step {i==3;i = 0;phase = 0;}  goto begin0; \n\nfi;\nbegin0: if\n::  d_step {i<2;resources[i] = 0;i = i+1;}  goto begin0; \n\n::  d_step {i==2;i = 0;}  goto begin1; \n\nfi;\nbegin1: if\n::  d_step {i<3 && res0[i]!=-1;resources[res0[i]*2] = entryRound;resources[res0[i]*2+1] = i;i = i+1;}  goto begin1; \n\n::  d_step {i<3 && res0[i]==-1;i = i+1;}  goto begin1; \n\n::  d_step {i==3;i = 0;}  goto begin2; \n\nfi;\nbegin2: if\n::  d_step {i<3 && res1[i]!=-1;resources[res1[i]*2] = entryRound;resources[res1[i]*2+1] = i;i = i+1;}  goto begin2; \n\n::  d_step {i<3 && res1[i]==-1;i = i+1;}  goto begin2; \n\n::  d_step {i==3;i = 0;phase = 1;fire = 0;}  goto action; \n\nfi;\naction: if\n::  d_step {fire==3;fire = 0;phase = 2;}  goto end0; \n\nfi;\nend0: if\n::  d_step {i<1 && resources[2*i]!=0;request[1*resources[2*i+1]+i] = 0;starvers[1*resources[2*i+1]+i] = 0;i = i+1;}  goto end0; \n\n::  d_step {i<1 && resources[2*i]==0;i = i+1;}  goto end0; \n\n::  d_step {i==1;i = 0;}  goto end1; \n\nfi;\nend1: if\n::  d_step {i<3 && request[i]<entryRound-5;starvers[i] = request[i];i = i+1;}  goto end1; \n\n::  d_step {i<3;i = i+1;}  goto end1; \n\n::  d_step {i==3 && fire==3 && entryRound!=15;phase = 0;entryRound = entryRound+1;i = 0;}  goto begin0; \n\n:: entryRound==15; goto end2; \n\nfi;\nbegin3: \nend2: \n false; }\n\nactive proctype phil_0() { \nint i=0;\n\naction: if\n::  d_step {phase==1 && res0[0]!=-1;resources[res0[0]] = 0;resources[res0[0]+1] = 0;res0[0] = res1[0];res1[0] = -1;fire = fire+1;}  goto end; \n\n::  d_step {phase==1 && res1[0]==-1 && acquiring[0]==-1;acquiring[0] = 0;fire = fire+1;request[0*1+0] = entryRound;}  goto end; \n\n::  d_step {phase==1;fire = fire+1;}  goto end; \n\nfi;\nend: if\n::  d_step {phase==2 && acquiring[0]==-1;fire = fire+1;}  goto action; \n\n:: phase==2 && acquiring[0]!=-1 && fire==0; goto mutex; \n\n::  d_step {phase==2 && acquiring[0]!=-1;fire = fire+1;}  goto action; \n\nfi;\nmutex: if\n::  d_step {i<3 && res0[i]!=acquiring[0] && res1[i]!=acquiring[0];i = i+1;}  goto mutex; \n\n::  d_step {i<3 && (res0[i]==acquiring[0] || res1[i]==acquiring[0]);fire = fire+1;i = i+1;}  goto action; \n\n::  d_step {i==3 && res0[0]==-1;res0[0] = acquiring[0];acquiring[0] = -1;fire = fire+1;i = 0;}  goto action; \n\n::  d_step {i==3 && res0[0]!=-1;res1[0] = acquiring[0];acquiring[0] = -1;fire = fire+1;i = 0;}  goto action; \n\nfi;\n}\n\nactive proctype phil_1() { \nint i=0;\n\naction: if\n::  d_step {phase==1 && res0[1]!=-1;resources[res0[1]] = 0;resources[res0[1]+1] = 0;res0[1] = res1[1];res1[1] = -1;fire = fire+1;}  goto end; \n\n::  d_step {phase==1 && res1[1]==-1 && acquiring[1]==-1;acquiring[1] = 0;fire = fire+1;request[1*1+0] = entryRound;}  goto end; \n\n::  d_step {phase==1;fire = fire+1;}  goto end; \n\nfi;\nend: if\n::  d_step {phase==2 && acquiring[1]==-1;fire = fire+1;}  goto action; \n\n:: phase==2 && acquiring[1]!=-1 && fire==1; goto mutex; \n\n::  d_step {phase==2 && acquiring[1]!=-1;fire = fire+1;}  goto action; \n\nfi;\nmutex: if\n::  d_step {i<3 && res0[i]!=acquiring[1] && res1[i]!=acquiring[1];i = i+1;}  goto mutex; \n\n::  d_step {i<3 && (res0[i]==acquiring[1] || res1[i]==acquiring[1]);fire = fire+1;i = i+1;}  goto action; \n\n::  d_step {i==3 && res0[1]==-1;res0[1] = acquiring[1];acquiring[1] = -1;fire = fire+1;i = 0;}  goto action; \n\n::  d_step {i==3 && res0[1]!=-1;res1[1] = acquiring[1];acquiring[1] = -1;fire = fire+1;i = 0;}  goto action; \n\nfi;\n}\n\nactive proctype phil_2() { \nint i=0;\n\naction: if\n::  d_step {phase==1 && res0[2]!=-1;resources[res0[2]] = 0;resources[res0[2]+1] = 0;res0[2] = res1[2];res1[2] = -1;fire = fire+1;}  goto end; \n\n::  d_step {phase==1 && res1[2]==-1 && acquiring[2]==-1;acquiring[2] = 0;fire = fire+1;request[2*1+0] = entryRound;}  goto end; \n\n::  d_step {phase==1;fire = fire+1;}  goto end; \n\nfi;\nend: if\n::  d_step {phase==2 && acquiring[2]==-1;fire = fire+1;}  goto action; \n\n:: phase==2 && acquiring[2]!=-1 && fire==2; goto mutex; \n\n::  d_step {phase==2 && acquiring[2]!=-1;fire = fire+1;}  goto action; \n\nfi;\nmutex: if\n::  d_step {i<3 && res0[i]!=acquiring[2] && res1[i]!=acquiring[2];i = i+1;}  goto mutex; \n\n::  d_step {i<3 && (res0[i]==acquiring[2] || res1[i]==acquiring[2]);fire = fire+1;i = i+1;}  goto action; \n\n::  d_step {i==3 && res0[2]==-1;res0[2] = acquiring[2];acquiring[2] = -1;fire = fire+1;i = 0;}  goto action; \n\n::  d_step {i==3 && res0[2]!=-1;res1[2] = acquiring[2];acquiring[2] = -1;fire = fire+1;i = 0;}  goto action; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "todo\n\nParameters:\n\n\n\n\n\n\n\nAtomic propositions:\n, , , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte request[6];\nbyte starvers[6];\nbyte resources[4];\nint res0[3];\nint res1[3];\nint acquiring[3];\nint entryRound=1;\nbyte phase=0;\nbyte fire=0;\n\n\nactive proctype round_about() { \nint i=0;\n\nreset: if\n::  d_step {i<3;res0[i] = -1;res1[i] = -1;acquiring[i] = -1;i = i+1;}  goto reset; \n\n::  d_step {i==3;i = 0;phase = 0;}  goto begin0; \n\nfi;\nbegin0: if\n::  d_step {i<4;resources[i] = 0;i = i+1;}  goto begin0; \n\n::  d_step {i==4;i = 0;}  goto begin1; \n\nfi;\nbegin1: if\n::  d_step {i<3 && res0[i]!=-1;resources[res0[i]*2] = entryRound;resources[res0[i]*2+1] = i;i = i+1;}  goto begin1; \n\n::  d_step {i<3 && res0[i]==-1;i = i+1;}  goto begin1; \n\n::  d_step {i==3;i = 0;}  goto begin2; \n\nfi;\nbegin2: if\n::  d_step {i<3 && res1[i]!=-1;resources[res1[i]*2] = entryRound;resources[res1[i]*2+1] = i;i = i+1;}  goto begin2; \n\n::  d_step {i<3 && res1[i]==-1;i = i+1;}  goto begin2; \n\n::  d_step {i==3;i = 0;phase = 1;fire = 0;}  goto action; \n\nfi;\naction: if\n::  d_step {fire==3;fire = 0;phase = 2;}  goto end0; \n\nfi;\nend0: if\n::  d_step {i<2 && resources[2*i]!=0;request[2*resources[2*i+1]+i] = 0;starvers[2*resources[2*i+1]+i] = 0;i = i+1;}  goto end0; \n\n::  d_step {i<2 && resources[2*i]==0;i = i+1;}  goto end0; \n\n::  d_step {i==2;i = 0;}  goto end1; \n\nfi;\nend1: if\n::  d_step {i<6;i = i+1;}  goto end1; \n\n::  d_step {i==6 && fire==3;phase = 0;i = 0;}  goto begin0; \n\nfi;\nbegin3: \nend2: \n false; }\n\nactive proctype phil_0() { \nint i=0;\n\naction: if\n::  d_step {phase==1 && res0[0]!=-1;resources[res0[0]] = 0;resources[res0[0]+1] = 0;res0[0] = res1[0];res1[0] = -1;fire = fire+1;}  goto end; \n\n::  d_step {phase==1 && res1[0]==-1 && acquiring[0]==-1;acquiring[0] = 0;fire = fire+1;request[0*2+0] = entryRound;}  goto end; \n\n::  d_step {phase==1 && res1[0]==-1 && acquiring[0]==-1;acquiring[0] = 1;fire = fire+1;request[0*2+1] = entryRound;}  goto end; \n\n::  d_step {phase==1;fire = fire+1;}  goto end; \n\nfi;\nend: if\n::  d_step {phase==2 && acquiring[0]==-1;fire = fire+1;}  goto action; \n\n:: phase==2 && acquiring[0]!=-1 && fire==0; goto mutex; \n\n::  d_step {phase==2 && acquiring[0]!=-1;fire = fire+1;}  goto action; \n\nfi;\nmutex: if\n::  d_step {i<3 && res0[i]!=acquiring[0] && res1[i]!=acquiring[0];i = i+1;}  goto mutex; \n\n::  d_step {i<3 && (res0[i]==acquiring[0] || res1[i]==acquiring[0]);fire = fire+1;i = i+1;}  goto action; \n\n::  d_step {i==3 && res0[0]==-1;res0[0] = acquiring[0];acquiring[0] = -1;fire = fire+1;i = 0;}  goto action; \n\n::  d_step {i==3 && res0[0]!=-1;res1[0] = acquiring[0];acquiring[0] = -1;fire = fire+1;i = 0;}  goto action; \n\nfi;\n}\n\nactive proctype phil_1() { \nint i=0;\n\naction: if\n::  d_step {phase==1 && res0[1]!=-1;resources[res0[1]] = 0;resources[res0[1]+1] = 0;res0[1] = res1[1];res1[1] = -1;fire = fire+1;}  goto end; \n\n::  d_step {phase==1 && res1[1]==-1 && acquiring[1]==-1;acquiring[1] = 0;fire = fire+1;request[1*2+0] = entryRound;}  goto end; \n\n::  d_step {phase==1 && res1[1]==-1 && acquiring[1]==-1;acquiring[1] = 1;fire = fire+1;request[1*2+1] = entryRound;}  goto end; \n\n::  d_step {phase==1;fire = fire+1;}  goto end; \n\nfi;\nend: if\n::  d_step {phase==2 && acquiring[1]==-1;fire = fire+1;}  goto action; \n\n:: phase==2 && acquiring[1]!=-1 && fire==1; goto mutex; \n\n::  d_step {phase==2 && acquiring[1]!=-1;fire = fire+1;}  goto action; \n\nfi;\nmutex: if\n::  d_step {i<3 && res0[i]!=acquiring[1] && res1[i]!=acquiring[1];i = i+1;}  goto mutex; \n\n::  d_step {i<3 && (res0[i]==acquiring[1] || res1[i]==acquiring[1]);fire = fire+1;i = i+1;}  goto action; \n\n::  d_step {i==3 && res0[1]==-1;res0[1] = acquiring[1];acquiring[1] = -1;fire = fire+1;i = 0;}  goto action; \n\n::  d_step {i==3 && res0[1]!=-1;res1[1] = acquiring[1];acquiring[1] = -1;fire = fire+1;i = 0;}  goto action; \n\nfi;\n}\n\nactive proctype phil_2() { \nint i=0;\n\naction: if\n::  d_step {phase==1 && res0[2]!=-1;resources[res0[2]] = 0;resources[res0[2]+1] = 0;res0[2] = res1[2];res1[2] = -1;fire = fire+1;}  goto end; \n\n::  d_step {phase==1 && res1[2]==-1 && acquiring[2]==-1;acquiring[2] = 0;fire = fire+1;request[2*2+0] = entryRound;}  goto end; \n\n::  d_step {phase==1 && res1[2]==-1 && acquiring[2]==-1;acquiring[2] = 1;fire = fire+1;request[2*2+1] = entryRound;}  goto end; \n\n::  d_step {phase==1;fire = fire+1;}  goto end; \n\nfi;\nend: if\n::  d_step {phase==2 && acquiring[2]==-1;fire = fire+1;}  goto action; \n\n:: phase==2 && acquiring[2]!=-1 && fire==2; goto mutex; \n\n::  d_step {phase==2 && acquiring[2]!=-1;fire = fire+1;}  goto action; \n\nfi;\nmutex: if\n::  d_step {i<3 && res0[i]!=acquiring[2] && res1[i]!=acquiring[2];i = i+1;}  goto mutex; \n\n::  d_step {i<3 && (res0[i]==acquiring[2] || res1[i]==acquiring[2]);fire = fire+1;i = i+1;}  goto action; \n\n::  d_step {i==3 && res0[2]==-1;res0[2] = acquiring[2];acquiring[2] = -1;fire = fire+1;i = 0;}  goto action; \n\n::  d_step {i==3 && res0[2]!=-1;res1[2] = acquiring[2];acquiring[2] = -1;fire = fire+1;i = 0;}  goto action; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "todo\n\nParameters:\n\n\n\n\n\n\n\nAtomic propositions:\n, , , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte request[6];\nbyte starvers[6];\nbyte resources[4];\nint res0[3];\nint res1[3];\nint acquiring[3];\nint entryRound=1;\nbyte phase=0;\nbyte fire=0;\n\n\nactive proctype round_about() { \nint i=0;\n\nreset: if\n::  d_step {i<3;res0[i] = -1;res1[i] = -1;acquiring[i] = -1;i = i+1;}  goto reset; \n\n::  d_step {i==3;i = 0;phase = 0;}  goto begin0; \n\nfi;\nbegin0: if\n::  d_step {i<4;resources[i] = 0;i = i+1;}  goto begin0; \n\n::  d_step {i==4;i = 0;}  goto begin1; \n\nfi;\nbegin1: if\n::  d_step {i<3 && res0[i]!=-1;resources[res0[i]*2] = entryRound;resources[res0[i]*2+1] = i;i = i+1;}  goto begin1; \n\n::  d_step {i<3 && res0[i]==-1;i = i+1;}  goto begin1; \n\n::  d_step {i==3;i = 0;}  goto begin2; \n\nfi;\nbegin2: if\n::  d_step {i<3 && res1[i]!=-1;resources[res1[i]*2] = entryRound;resources[res1[i]*2+1] = i;i = i+1;}  goto begin2; \n\n::  d_step {i<3 && res1[i]==-1;i = i+1;}  goto begin2; \n\n::  d_step {i==3;i = 0;phase = 1;fire = 0;}  goto action; \n\nfi;\naction: if\n::  d_step {fire==3;fire = 0;phase = 2;}  goto end0; \n\nfi;\nend0: if\n::  d_step {i<2 && resources[2*i]!=0;request[2*resources[2*i+1]+i] = 0;starvers[2*resources[2*i+1]+i] = 0;i = i+1;}  goto end0; \n\n::  d_step {i<2 && resources[2*i]==0;i = i+1;}  goto end0; \n\n::  d_step {i==2;i = 0;}  goto end1; \n\nfi;\nend1: if\n::  d_step {i<6 && request[i]<entryRound-3;starvers[i] = request[i];i = i+1;}  goto end1; \n\n::  d_step {i<6;i = i+1;}  goto end1; \n\n::  d_step {i==6 && fire==3 && entryRound!=10;phase = 0;entryRound = entryRound+1;i = 0;}  goto begin0; \n\n:: entryRound==10; goto end2; \n\nfi;\nbegin3: \nend2: \n false; }\n\nactive proctype phil_0() { \nint i=0;\n\naction: if\n::  d_step {phase==1 && res0[0]!=-1;resources[res0[0]] = 0;resources[res0[0]+1] = 0;res0[0] = res1[0];res1[0] = -1;fire = fire+1;}  goto end; \n\n::  d_step {phase==1 && res1[0]==-1 && acquiring[0]==-1;acquiring[0] = 0;fire = fire+1;request[0*2+0] = entryRound;}  goto end; \n\n::  d_step {phase==1 && res1[0]==-1 && acquiring[0]==-1;acquiring[0] = 1;fire = fire+1;request[0*2+1] = entryRound;}  goto end; \n\n::  d_step {phase==1;fire = fire+1;}  goto end; \n\nfi;\nend: if\n::  d_step {phase==2 && acquiring[0]==-1;fire = fire+1;}  goto action; \n\n::  d_step {phase==2 && acquiring[0]!=-1 && res0[0]==-1;res0[0] = acquiring[0];acquiring[0] = -1;fire = fire+1;}  goto action; \n\n::  d_step {phase==2 && acquiring[0]!=-1 && res0[0]!=-1;res1[0] = acquiring[0];acquiring[0] = -1;fire = fire+1;}  goto action; \n\nfi;\nmutex: \n false; }\n\nactive proctype phil_1() { \nint i=0;\n\naction: if\n::  d_step {phase==1 && res0[1]!=-1;resources[res0[1]] = 0;resources[res0[1]+1] = 0;res0[1] = res1[1];res1[1] = -1;fire = fire+1;}  goto end; \n\n::  d_step {phase==1 && res1[1]==-1 && acquiring[1]==-1;acquiring[1] = 0;fire = fire+1;request[1*2+0] = entryRound;}  goto end; \n\n::  d_step {phase==1 && res1[1]==-1 && acquiring[1]==-1;acquiring[1] = 1;fire = fire+1;request[1*2+1] = entryRound;}  goto end; \n\n::  d_step {phase==1;fire = fire+1;}  goto end; \n\nfi;\nend: if\n::  d_step {phase==2 && acquiring[1]==-1;fire = fire+1;}  goto action; \n\n::  d_step {phase==2 && acquiring[1]!=-1 && res0[1]==-1;res0[1] = acquiring[1];acquiring[1] = -1;fire = fire+1;}  goto action; \n\n::  d_step {phase==2 && acquiring[1]!=-1 && res0[1]!=-1;res1[1] = acquiring[1];acquiring[1] = -1;fire = fire+1;}  goto action; \n\nfi;\nmutex: \n false; }\n\nactive proctype phil_2() { \nint i=0;\n\naction: if\n::  d_step {phase==1 && res0[2]!=-1;resources[res0[2]] = 0;resources[res0[2]+1] = 0;res0[2] = res1[2];res1[2] = -1;fire = fire+1;}  goto end; \n\n::  d_step {phase==1 && res1[2]==-1 && acquiring[2]==-1;acquiring[2] = 0;fire = fire+1;request[2*2+0] = entryRound;}  goto end; \n\n::  d_step {phase==1 && res1[2]==-1 && acquiring[2]==-1;acquiring[2] = 1;fire = fire+1;request[2*2+1] = entryRound;}  goto end; \n\n::  d_step {phase==1;fire = fire+1;}  goto end; \n\nfi;\nend: if\n::  d_step {phase==2 && acquiring[2]==-1;fire = fire+1;}  goto action; \n\n::  d_step {phase==2 && acquiring[2]!=-1 && res0[2]==-1;res0[2] = acquiring[2];acquiring[2] = -1;fire = fire+1;}  goto action; \n\n::  d_step {phase==2 && acquiring[2]!=-1 && res0[2]!=-1;res1[2] = acquiring[2];acquiring[2] = -1;fire = fire+1;}  goto action; \n\nfi;\nmutex: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Just some variation on the popular elevator\n  theme.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte floor_queue_0[2];\nbyte floor_queue_0_act=0;\nbyte floor_queue_1[2];\nbyte floor_queue_1_act=0;\nbyte floor_queue_2[2];\nbyte floor_queue_2_act=0;\nbyte floor_queue_3[2];\nbyte floor_queue_3_act=0;\nbyte floor_queue_4[2];\nbyte floor_queue_4_act=0;\nbyte current=0;\n\nchan call_0 =[0] of {int};\nchan get_in_0 =[0] of {int};\nchan get_out_0 =[0] of {int};\nchan call_1 =[0] of {int};\nchan get_in_1 =[0] of {int};\nchan get_out_1 =[0] of {int};\n\nactive proctype Person_0() { \nbyte at_floor=0;\n\nout: if\n:: call_0!at_floor; goto waiting; \n\nfi;\nwaiting: if\n::  atomic {0!=at_floor;get_in_0!0;}  goto in_elevator; \n\n::  atomic {1!=at_floor;get_in_0!1;}  goto in_elevator; \n\n::  atomic {2!=at_floor;get_in_0!2;}  goto in_elevator; \n\n::  atomic {3!=at_floor;get_in_0!3;}  goto in_elevator; \n\n::  atomic {4!=at_floor;get_in_0!4;}  goto in_elevator; \n\nfi;\nin_elevator: if\n:: get_out_0?at_floor; goto out; \n\nfi;\n}\n\nactive proctype Person_1() { \nbyte at_floor=0;\n\nout: if\n:: call_1!at_floor; goto waiting; \n\nfi;\nwaiting: if\n::  atomic {0!=at_floor;get_in_1!0;}  goto in_elevator; \n\n::  atomic {1!=at_floor;get_in_1!1;}  goto in_elevator; \n\n::  atomic {2!=at_floor;get_in_1!2;}  goto in_elevator; \n\n::  atomic {3!=at_floor;get_in_1!3;}  goto in_elevator; \n\n::  atomic {4!=at_floor;get_in_1!4;}  goto in_elevator; \n\nfi;\nin_elevator: if\n:: get_out_1?at_floor; goto out; \n\nfi;\n}\n\nactive proctype Servis() { \nbyte floor=0;\nbyte caller=0;\n\nq: if\n::  atomic {call_0?floor;caller = 0;}  goto r; \n\n::  atomic {call_1?floor;caller = 1;}  goto r; \n\nfi;\nr: if\n::  d_step {0==floor;floor_queue_0[floor_queue_0_act] = caller;floor_queue_0_act = floor_queue_0_act+1;}  goto q; \n\n::  d_step {1==floor;floor_queue_1[floor_queue_1_act] = caller;floor_queue_1_act = floor_queue_1_act+1;}  goto q; \n\n::  d_step {2==floor;floor_queue_2[floor_queue_2_act] = caller;floor_queue_2_act = floor_queue_2_act+1;}  goto q; \n\n::  d_step {3==floor;floor_queue_3[floor_queue_3_act] = caller;floor_queue_3_act = floor_queue_3_act+1;}  goto q; \n\n::  d_step {4==floor;floor_queue_4[floor_queue_4_act] = caller;floor_queue_4_act = floor_queue_4_act+1;}  goto q; \n\nfi;\n}\n\nactive proctype Elevator() { \nbyte going_to=0;\nbyte serving=0;\nbyte who=0;\n\nchoose_next: if\n::  d_step {0==serving && floor_queue_0_act==0 && ( ! (floor_queue_0_act==0) ||  ! (floor_queue_1_act==0) ||  ! (floor_queue_2_act==0) ||  ! (floor_queue_3_act==0) ||  ! (floor_queue_4_act==0));serving = (serving+1)%5;}  goto choose_next; \n\n::  d_step {1==serving && floor_queue_1_act==0 && ( ! (floor_queue_0_act==0) ||  ! (floor_queue_1_act==0) ||  ! (floor_queue_2_act==0) ||  ! (floor_queue_3_act==0) ||  ! (floor_queue_4_act==0));serving = (serving+1)%5;}  goto choose_next; \n\n::  d_step {2==serving && floor_queue_2_act==0 && ( ! (floor_queue_0_act==0) ||  ! (floor_queue_1_act==0) ||  ! (floor_queue_2_act==0) ||  ! (floor_queue_3_act==0) ||  ! (floor_queue_4_act==0));serving = (serving+1)%5;}  goto choose_next; \n\n::  d_step {3==serving && floor_queue_3_act==0 && ( ! (floor_queue_0_act==0) ||  ! (floor_queue_1_act==0) ||  ! (floor_queue_2_act==0) ||  ! (floor_queue_3_act==0) ||  ! (floor_queue_4_act==0));serving = (serving+1)%5;}  goto choose_next; \n\n::  d_step {4==serving && floor_queue_4_act==0 && ( ! (floor_queue_0_act==0) ||  ! (floor_queue_1_act==0) ||  ! (floor_queue_2_act==0) ||  ! (floor_queue_3_act==0) ||  ! (floor_queue_4_act==0));serving = (serving+1)%5;}  goto choose_next; \n\n:: 0==serving && ( ! (floor_queue_0_act==0)); goto move_next; \n\n:: 1==serving && ( ! (floor_queue_1_act==0)); goto move_next; \n\n:: 2==serving && ( ! (floor_queue_2_act==0)); goto move_next; \n\n:: 3==serving && ( ! (floor_queue_3_act==0)); goto move_next; \n\n:: 4==serving && ( ! (floor_queue_4_act==0)); goto move_next; \n\nfi;\nmove_next: if\n::  d_step {serving<current;current = current-1;}  goto move_next; \n\n::  d_step {serving>current;current = current+1;}  goto move_next; \n\n::  d_step {serving==current && 0==current;who = floor_queue_0[0];floor_queue_0[0] = floor_queue_0[1];floor_queue_0[1] = 0;floor_queue_0_act = floor_queue_0_act-1;}  goto q; \n\n::  d_step {serving==current && 1==current;who = floor_queue_1[0];floor_queue_1[0] = floor_queue_1[1];floor_queue_1[1] = 0;floor_queue_1_act = floor_queue_1_act-1;}  goto q; \n\n::  d_step {serving==current && 2==current;who = floor_queue_2[0];floor_queue_2[0] = floor_queue_2[1];floor_queue_2[1] = 0;floor_queue_2_act = floor_queue_2_act-1;}  goto q; \n\n::  d_step {serving==current && 3==current;who = floor_queue_3[0];floor_queue_3[0] = floor_queue_3[1];floor_queue_3[1] = 0;floor_queue_3_act = floor_queue_3_act-1;}  goto q; \n\n::  d_step {serving==current && 4==current;who = floor_queue_4[0];floor_queue_4[0] = floor_queue_4[1];floor_queue_4[1] = 0;floor_queue_4_act = floor_queue_4_act-1;}  goto q; \n\nfi;\nq: if\n::  atomic {0==who;get_in_0?going_to;}  goto transporting; \n\n::  atomic {1==who;get_in_1?going_to;}  goto transporting; \n\nfi;\ntransporting: if\n::  atomic {0==who && going_to==current;get_out_0!current;going_to = 0;who = 0;}  goto choose_next; \n\n::  atomic {1==who && going_to==current;get_out_1!current;going_to = 0;who = 0;}  goto choose_next; \n\n::  d_step {going_to<current;current = current-1;}  goto transporting; \n\n::  d_step {going_to>current;current = current+1;}  goto transporting; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Just some variation on the popular elevator\n  theme.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte floor_queue_0[2];\nbyte floor_queue_0_act=0;\nbyte floor_queue_1[2];\nbyte floor_queue_1_act=0;\nbyte floor_queue_2[2];\nbyte floor_queue_2_act=0;\nbyte floor_queue_3[2];\nbyte floor_queue_3_act=0;\nbyte current=0;\n\nchan call_0 =[0] of {int};\nchan get_in_0 =[0] of {int};\nchan get_out_0 =[0] of {int};\nchan call_1 =[0] of {int};\nchan get_in_1 =[0] of {int};\nchan get_out_1 =[0] of {int};\n\nactive proctype Person_0() { \nbyte at_floor=0;\n\nout: if\n:: call_0!at_floor; goto waiting; \n\nfi;\nwaiting: if\n::  atomic {0!=at_floor;get_in_0!0;}  goto in_elevator; \n\n::  atomic {1!=at_floor;get_in_0!1;}  goto in_elevator; \n\n::  atomic {2!=at_floor;get_in_0!2;}  goto in_elevator; \n\n::  atomic {3!=at_floor;get_in_0!3;}  goto in_elevator; \n\nfi;\nin_elevator: if\n:: get_out_0?at_floor; goto out; \n\nfi;\n}\n\nactive proctype Person_1() { \nbyte at_floor=0;\n\nout: if\n:: call_1!at_floor; goto waiting; \n\nfi;\nwaiting: if\n::  atomic {0!=at_floor;get_in_1!0;}  goto in_elevator; \n\n::  atomic {1!=at_floor;get_in_1!1;}  goto in_elevator; \n\n::  atomic {2!=at_floor;get_in_1!2;}  goto in_elevator; \n\n::  atomic {3!=at_floor;get_in_1!3;}  goto in_elevator; \n\nfi;\nin_elevator: if\n:: get_out_1?at_floor; goto out; \n\nfi;\n}\n\nactive proctype Servis() { \nbyte floor=0;\nbyte caller=0;\n\nq: if\n::  atomic {call_0?floor;caller = 0;}  goto r; \n\n::  atomic {call_1?floor;caller = 1;}  goto r; \n\nfi;\nr: if\n::  d_step {0==floor;floor_queue_0[floor_queue_0_act] = caller;floor_queue_0_act = floor_queue_0_act+1;}  goto q; \n\n::  d_step {1==floor;floor_queue_1[floor_queue_1_act] = caller;floor_queue_1_act = floor_queue_1_act+1;}  goto q; \n\n::  d_step {2==floor;floor_queue_2[floor_queue_2_act] = caller;floor_queue_2_act = floor_queue_2_act+1;}  goto q; \n\n::  d_step {3==floor;floor_queue_3[floor_queue_3_act] = caller;floor_queue_3_act = floor_queue_3_act+1;}  goto q; \n\nfi;\n}\n\nactive proctype Elevator() { \nbyte going_to=0;\nbyte serving=0;\nbyte who=0;\n\nchoose_next: if\n::  d_step {0==serving && floor_queue_0_act==0 && ( ! (floor_queue_0_act==0) ||  ! (floor_queue_1_act==0) ||  ! (floor_queue_2_act==0) ||  ! (floor_queue_3_act==0));serving = (serving+1)%4;}  goto choose_next; \n\n::  d_step {1==serving && floor_queue_1_act==0 && ( ! (floor_queue_0_act==0) ||  ! (floor_queue_1_act==0) ||  ! (floor_queue_2_act==0) ||  ! (floor_queue_3_act==0));serving = (serving+1)%4;}  goto choose_next; \n\n::  d_step {2==serving && floor_queue_2_act==0 && ( ! (floor_queue_0_act==0) ||  ! (floor_queue_1_act==0) ||  ! (floor_queue_2_act==0) ||  ! (floor_queue_3_act==0));serving = (serving+1)%4;}  goto choose_next; \n\n::  d_step {3==serving && floor_queue_3_act==0 && ( ! (floor_queue_0_act==0) ||  ! (floor_queue_1_act==0) ||  ! (floor_queue_2_act==0) ||  ! (floor_queue_3_act==0));serving = (serving+1)%4;}  goto choose_next; \n\n:: 0==serving && ( ! (floor_queue_0_act==0)); goto move_next; \n\n:: 1==serving && ( ! (floor_queue_1_act==0)); goto move_next; \n\n:: 2==serving && ( ! (floor_queue_2_act==0)); goto move_next; \n\n:: 3==serving && ( ! (floor_queue_3_act==0)); goto move_next; \n\nfi;\nmove_next: if\n::  d_step {serving<current;current = current-1;}  goto move_next; \n\n::  d_step {serving>current;current = current+1;}  goto move_next; \n\n::  d_step {serving==current && 0==current;who = floor_queue_0[0];floor_queue_0[0] = floor_queue_0[1];floor_queue_0[1] = 0;floor_queue_0_act = floor_queue_0_act-1;}  goto q; \n\n::  d_step {serving==current && 1==current;who = floor_queue_1[0];floor_queue_1[0] = floor_queue_1[1];floor_queue_1[1] = 0;floor_queue_1_act = floor_queue_1_act-1;}  goto q; \n\n::  d_step {serving==current && 2==current;who = floor_queue_2[0];floor_queue_2[0] = floor_queue_2[1];floor_queue_2[1] = 0;floor_queue_2_act = floor_queue_2_act-1;}  goto q; \n\n::  d_step {serving==current && 3==current;who = floor_queue_3[0];floor_queue_3[0] = floor_queue_3[1];floor_queue_3[1] = 0;floor_queue_3_act = floor_queue_3_act-1;}  goto q; \n\nfi;\nq: if\n::  atomic {0==who;get_in_0?going_to;}  goto transporting; \n\n::  atomic {1==who;get_in_1?going_to;}  goto transporting; \n\nfi;\ntransporting: if\n::  atomic {0==who && going_to==current;get_out_0!current;going_to = 0;who = 0;serving = current;}  goto choose_next; \n\n::  atomic {1==who && going_to==current;get_out_1!current;going_to = 0;who = 0;serving = current;}  goto choose_next; \n\n::  d_step {going_to<current;current = current-1;}  goto transporting; \n\n::  d_step {going_to>current;current = current+1;}  goto transporting; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Just some variation on the popular elevator\n  theme.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte floor_queue_0[3];\nbyte floor_queue_0_act=0;\nbyte floor_queue_1[3];\nbyte floor_queue_1_act=0;\nbyte floor_queue_2[3];\nbyte floor_queue_2_act=0;\nbyte floor_queue_3[3];\nbyte floor_queue_3_act=0;\nbyte floor_queue_4[3];\nbyte floor_queue_4_act=0;\nbyte floor_queue_5[3];\nbyte floor_queue_5_act=0;\nbyte current=0;\n\nchan call_0 =[0] of {int};\nchan get_in_0 =[0] of {int};\nchan get_out_0 =[0] of {int};\nchan call_1 =[0] of {int};\nchan get_in_1 =[0] of {int};\nchan get_out_1 =[0] of {int};\nchan call_2 =[0] of {int};\nchan get_in_2 =[0] of {int};\nchan get_out_2 =[0] of {int};\n\nactive proctype Person_0() { \nbyte at_floor=0;\n\nout: if\n:: call_0!at_floor; goto waiting; \n\nfi;\nwaiting: if\n::  atomic {0!=at_floor;get_in_0!0;}  goto in_elevator; \n\n::  atomic {1!=at_floor;get_in_0!1;}  goto in_elevator; \n\n::  atomic {2!=at_floor;get_in_0!2;}  goto in_elevator; \n\n::  atomic {3!=at_floor;get_in_0!3;}  goto in_elevator; \n\n::  atomic {4!=at_floor;get_in_0!4;}  goto in_elevator; \n\n::  atomic {5!=at_floor;get_in_0!5;}  goto in_elevator; \n\nfi;\nin_elevator: if\n:: get_out_0?at_floor; goto out; \n\nfi;\n}\n\nactive proctype Person_1() { \nbyte at_floor=0;\n\nout: if\n:: call_1!at_floor; goto waiting; \n\nfi;\nwaiting: if\n::  atomic {0!=at_floor;get_in_1!0;}  goto in_elevator; \n\n::  atomic {1!=at_floor;get_in_1!1;}  goto in_elevator; \n\n::  atomic {2!=at_floor;get_in_1!2;}  goto in_elevator; \n\n::  atomic {3!=at_floor;get_in_1!3;}  goto in_elevator; \n\n::  atomic {4!=at_floor;get_in_1!4;}  goto in_elevator; \n\n::  atomic {5!=at_floor;get_in_1!5;}  goto in_elevator; \n\nfi;\nin_elevator: if\n:: get_out_1?at_floor; goto out; \n\nfi;\n}\n\nactive proctype Person_2() { \nbyte at_floor=0;\n\nout: if\n:: call_2!at_floor; goto waiting; \n\nfi;\nwaiting: if\n::  atomic {0!=at_floor;get_in_2!0;}  goto in_elevator; \n\n::  atomic {1!=at_floor;get_in_2!1;}  goto in_elevator; \n\n::  atomic {2!=at_floor;get_in_2!2;}  goto in_elevator; \n\n::  atomic {3!=at_floor;get_in_2!3;}  goto in_elevator; \n\n::  atomic {4!=at_floor;get_in_2!4;}  goto in_elevator; \n\n::  atomic {5!=at_floor;get_in_2!5;}  goto in_elevator; \n\nfi;\nin_elevator: if\n:: get_out_2?at_floor; goto out; \n\nfi;\n}\n\nactive proctype Servis() { \nbyte floor=0;\nbyte caller=0;\n\nq: if\n::  atomic {call_0?floor;caller = 0;}  goto r; \n\n::  atomic {call_1?floor;caller = 1;}  goto r; \n\n::  atomic {call_2?floor;caller = 2;}  goto r; \n\nfi;\nr: if\n::  d_step {0==floor;floor_queue_0[floor_queue_0_act] = caller;floor_queue_0_act = floor_queue_0_act+1;}  goto q; \n\n::  d_step {1==floor;floor_queue_1[floor_queue_1_act] = caller;floor_queue_1_act = floor_queue_1_act+1;}  goto q; \n\n::  d_step {2==floor;floor_queue_2[floor_queue_2_act] = caller;floor_queue_2_act = floor_queue_2_act+1;}  goto q; \n\n::  d_step {3==floor;floor_queue_3[floor_queue_3_act] = caller;floor_queue_3_act = floor_queue_3_act+1;}  goto q; \n\n::  d_step {4==floor;floor_queue_4[floor_queue_4_act] = caller;floor_queue_4_act = floor_queue_4_act+1;}  goto q; \n\n::  d_step {5==floor;floor_queue_5[floor_queue_5_act] = caller;floor_queue_5_act = floor_queue_5_act+1;}  goto q; \n\nfi;\n}\n\nactive proctype Elevator() { \nbyte going_to=0;\nbyte serving=0;\nbyte who=0;\n\nchoose_next: if\n::  d_step {0==serving && floor_queue_0_act==0 && ( ! (floor_queue_0_act==0) ||  ! (floor_queue_1_act==0) ||  ! (floor_queue_2_act==0) ||  ! (floor_queue_3_act==0) ||  ! (floor_queue_4_act==0) ||  ! (floor_queue_5_act==0));serving = (serving+1)%6;}  goto choose_next; \n\n::  d_step {1==serving && floor_queue_1_act==0 && ( ! (floor_queue_0_act==0) ||  ! (floor_queue_1_act==0) ||  ! (floor_queue_2_act==0) ||  ! (floor_queue_3_act==0) ||  ! (floor_queue_4_act==0) ||  ! (floor_queue_5_act==0));serving = (serving+1)%6;}  goto choose_next; \n\n::  d_step {2==serving && floor_queue_2_act==0 && ( ! (floor_queue_0_act==0) ||  ! (floor_queue_1_act==0) ||  ! (floor_queue_2_act==0) ||  ! (floor_queue_3_act==0) ||  ! (floor_queue_4_act==0) ||  ! (floor_queue_5_act==0));serving = (serving+1)%6;}  goto choose_next; \n\n::  d_step {3==serving && floor_queue_3_act==0 && ( ! (floor_queue_0_act==0) ||  ! (floor_queue_1_act==0) ||  ! (floor_queue_2_act==0) ||  ! (floor_queue_3_act==0) ||  ! (floor_queue_4_act==0) ||  ! (floor_queue_5_act==0));serving = (serving+1)%6;}  goto choose_next; \n\n::  d_step {4==serving && floor_queue_4_act==0 && ( ! (floor_queue_0_act==0) ||  ! (floor_queue_1_act==0) ||  ! (floor_queue_2_act==0) ||  ! (floor_queue_3_act==0) ||  ! (floor_queue_4_act==0) ||  ! (floor_queue_5_act==0));serving = (serving+1)%6;}  goto choose_next; \n\n::  d_step {5==serving && floor_queue_5_act==0 && ( ! (floor_queue_0_act==0) ||  ! (floor_queue_1_act==0) ||  ! (floor_queue_2_act==0) ||  ! (floor_queue_3_act==0) ||  ! (floor_queue_4_act==0) ||  ! (floor_queue_5_act==0));serving = (serving+1)%6;}  goto choose_next; \n\n:: 0==serving && ( ! (floor_queue_0_act==0)); goto move_next; \n\n:: 1==serving && ( ! (floor_queue_1_act==0)); goto move_next; \n\n:: 2==serving && ( ! (floor_queue_2_act==0)); goto move_next; \n\n:: 3==serving && ( ! (floor_queue_3_act==0)); goto move_next; \n\n:: 4==serving && ( ! (floor_queue_4_act==0)); goto move_next; \n\n:: 5==serving && ( ! (floor_queue_5_act==0)); goto move_next; \n\nfi;\nmove_next: if\n::  d_step {serving<current;current = current-1;}  goto move_next; \n\n::  d_step {serving>current;current = current+1;}  goto move_next; \n\n::  d_step {serving==current && 0==current;who = floor_queue_0[0];floor_queue_0[0] = floor_queue_0[1];floor_queue_0[1] = floor_queue_0[2];floor_queue_0[2] = 0;floor_queue_0_act = floor_queue_0_act-1;}  goto q; \n\n::  d_step {serving==current && 1==current;who = floor_queue_1[0];floor_queue_1[0] = floor_queue_1[1];floor_queue_1[1] = floor_queue_1[2];floor_queue_1[2] = 0;floor_queue_1_act = floor_queue_1_act-1;}  goto q; \n\n::  d_step {serving==current && 2==current;who = floor_queue_2[0];floor_queue_2[0] = floor_queue_2[1];floor_queue_2[1] = floor_queue_2[2];floor_queue_2[2] = 0;floor_queue_2_act = floor_queue_2_act-1;}  goto q; \n\n::  d_step {serving==current && 3==current;who = floor_queue_3[0];floor_queue_3[0] = floor_queue_3[1];floor_queue_3[1] = floor_queue_3[2];floor_queue_3[2] = 0;floor_queue_3_act = floor_queue_3_act-1;}  goto q; \n\n::  d_step {serving==current && 4==current;who = floor_queue_4[0];floor_queue_4[0] = floor_queue_4[1];floor_queue_4[1] = floor_queue_4[2];floor_queue_4[2] = 0;floor_queue_4_act = floor_queue_4_act-1;}  goto q; \n\n::  d_step {serving==current && 5==current;who = floor_queue_5[0];floor_queue_5[0] = floor_queue_5[1];floor_queue_5[1] = floor_queue_5[2];floor_queue_5[2] = 0;floor_queue_5_act = floor_queue_5_act-1;}  goto q; \n\nfi;\nq: if\n::  atomic {0==who;get_in_0?going_to;}  goto transporting; \n\n::  atomic {1==who;get_in_1?going_to;}  goto transporting; \n\n::  atomic {2==who;get_in_2?going_to;}  goto transporting; \n\nfi;\ntransporting: if\n::  atomic {0==who && going_to==current;get_out_0!current;going_to = 0;who = 0;serving = current;}  goto choose_next; \n\n::  atomic {1==who && going_to==current;get_out_1!current;going_to = 0;who = 0;serving = current;}  goto choose_next; \n\n::  atomic {2==who && going_to==current;get_out_2!current;going_to = 0;who = 0;serving = current;}  goto choose_next; \n\n::  d_step {going_to<current;current = current-1;}  goto transporting; \n\n::  d_step {going_to>current;current = current+1;}  goto transporting; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Just some variation on the popular elevator\n  theme.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte floor_queue_0[4];\nbyte floor_queue_0_act=0;\nbyte floor_queue_1[4];\nbyte floor_queue_1_act=0;\nbyte floor_queue_2[4];\nbyte floor_queue_2_act=0;\nbyte floor_queue_3[4];\nbyte floor_queue_3_act=0;\nbyte current=0;\n\nchan call_0 =[0] of {int};\nchan get_in_0 =[0] of {int};\nchan get_out_0 =[0] of {int};\nchan call_1 =[0] of {int};\nchan get_in_1 =[0] of {int};\nchan get_out_1 =[0] of {int};\nchan call_2 =[0] of {int};\nchan get_in_2 =[0] of {int};\nchan get_out_2 =[0] of {int};\nchan call_3 =[0] of {int};\nchan get_in_3 =[0] of {int};\nchan get_out_3 =[0] of {int};\n\nactive proctype Person_0() { \nbyte at_floor=0;\n\nout: if\n:: call_0!at_floor; goto waiting; \n\nfi;\nwaiting: if\n::  atomic {0!=at_floor;get_in_0!0;}  goto in_elevator; \n\n::  atomic {1!=at_floor;get_in_0!1;}  goto in_elevator; \n\n::  atomic {2!=at_floor;get_in_0!2;}  goto in_elevator; \n\n::  atomic {3!=at_floor;get_in_0!3;}  goto in_elevator; \n\nfi;\nin_elevator: if\n:: get_out_0?at_floor; goto out; \n\nfi;\n}\n\nactive proctype Person_1() { \nbyte at_floor=0;\n\nout: if\n:: call_1!at_floor; goto waiting; \n\nfi;\nwaiting: if\n::  atomic {0!=at_floor;get_in_1!0;}  goto in_elevator; \n\n::  atomic {1!=at_floor;get_in_1!1;}  goto in_elevator; \n\n::  atomic {2!=at_floor;get_in_1!2;}  goto in_elevator; \n\n::  atomic {3!=at_floor;get_in_1!3;}  goto in_elevator; \n\nfi;\nin_elevator: if\n:: get_out_1?at_floor; goto out; \n\nfi;\n}\n\nactive proctype Person_2() { \nbyte at_floor=0;\n\nout: if\n:: call_2!at_floor; goto waiting; \n\nfi;\nwaiting: if\n::  atomic {0!=at_floor;get_in_2!0;}  goto in_elevator; \n\n::  atomic {1!=at_floor;get_in_2!1;}  goto in_elevator; \n\n::  atomic {2!=at_floor;get_in_2!2;}  goto in_elevator; \n\n::  atomic {3!=at_floor;get_in_2!3;}  goto in_elevator; \n\nfi;\nin_elevator: if\n:: get_out_2?at_floor; goto out; \n\nfi;\n}\n\nactive proctype Person_3() { \nbyte at_floor=0;\n\nout: if\n:: call_3!at_floor; goto waiting; \n\nfi;\nwaiting: if\n::  atomic {0!=at_floor;get_in_3!0;}  goto in_elevator; \n\n::  atomic {1!=at_floor;get_in_3!1;}  goto in_elevator; \n\n::  atomic {2!=at_floor;get_in_3!2;}  goto in_elevator; \n\n::  atomic {3!=at_floor;get_in_3!3;}  goto in_elevator; \n\nfi;\nin_elevator: if\n:: get_out_3?at_floor; goto out; \n\nfi;\n}\n\nactive proctype Servis() { \nbyte floor=0;\nbyte caller=0;\n\nq: if\n::  atomic {call_0?floor;caller = 0;}  goto r; \n\n::  atomic {call_1?floor;caller = 1;}  goto r; \n\n::  atomic {call_2?floor;caller = 2;}  goto r; \n\n::  atomic {call_3?floor;caller = 3;}  goto r; \n\nfi;\nr: if\n::  d_step {0==floor;floor_queue_0[floor_queue_0_act] = caller;floor_queue_0_act = floor_queue_0_act+1;}  goto q; \n\n::  d_step {1==floor;floor_queue_1[floor_queue_1_act] = caller;floor_queue_1_act = floor_queue_1_act+1;}  goto q; \n\n::  d_step {2==floor;floor_queue_2[floor_queue_2_act] = caller;floor_queue_2_act = floor_queue_2_act+1;}  goto q; \n\n::  d_step {3==floor;floor_queue_3[floor_queue_3_act] = caller;floor_queue_3_act = floor_queue_3_act+1;}  goto q; \n\nfi;\n}\n\nactive proctype Elevator() { \nbyte going_to=0;\nbyte serving=0;\nbyte who=0;\n\nchoose_next: if\n::  d_step {0==serving && floor_queue_0_act==0 && ( ! (floor_queue_0_act==0) ||  ! (floor_queue_1_act==0) ||  ! (floor_queue_2_act==0) ||  ! (floor_queue_3_act==0));serving = (serving+1)%4;}  goto choose_next; \n\n::  d_step {1==serving && floor_queue_1_act==0 && ( ! (floor_queue_0_act==0) ||  ! (floor_queue_1_act==0) ||  ! (floor_queue_2_act==0) ||  ! (floor_queue_3_act==0));serving = (serving+1)%4;}  goto choose_next; \n\n::  d_step {2==serving && floor_queue_2_act==0 && ( ! (floor_queue_0_act==0) ||  ! (floor_queue_1_act==0) ||  ! (floor_queue_2_act==0) ||  ! (floor_queue_3_act==0));serving = (serving+1)%4;}  goto choose_next; \n\n::  d_step {3==serving && floor_queue_3_act==0 && ( ! (floor_queue_0_act==0) ||  ! (floor_queue_1_act==0) ||  ! (floor_queue_2_act==0) ||  ! (floor_queue_3_act==0));serving = (serving+1)%4;}  goto choose_next; \n\n:: 0==serving && ( ! (floor_queue_0_act==0)); goto move_next; \n\n:: 1==serving && ( ! (floor_queue_1_act==0)); goto move_next; \n\n:: 2==serving && ( ! (floor_queue_2_act==0)); goto move_next; \n\n:: 3==serving && ( ! (floor_queue_3_act==0)); goto move_next; \n\nfi;\nmove_next: if\n::  d_step {serving<current;current = current-1;}  goto move_next; \n\n::  d_step {serving>current;current = current+1;}  goto move_next; \n\n::  d_step {serving==current && 0==current;who = floor_queue_0[0];floor_queue_0[0] = floor_queue_0[1];floor_queue_0[1] = floor_queue_0[2];floor_queue_0[2] = floor_queue_0[3];floor_queue_0[3] = 0;floor_queue_0_act = floor_queue_0_act-1;}  goto q; \n\n::  d_step {serving==current && 1==current;who = floor_queue_1[0];floor_queue_1[0] = floor_queue_1[1];floor_queue_1[1] = floor_queue_1[2];floor_queue_1[2] = floor_queue_1[3];floor_queue_1[3] = 0;floor_queue_1_act = floor_queue_1_act-1;}  goto q; \n\n::  d_step {serving==current && 2==current;who = floor_queue_2[0];floor_queue_2[0] = floor_queue_2[1];floor_queue_2[1] = floor_queue_2[2];floor_queue_2[2] = floor_queue_2[3];floor_queue_2[3] = 0;floor_queue_2_act = floor_queue_2_act-1;}  goto q; \n\n::  d_step {serving==current && 3==current;who = floor_queue_3[0];floor_queue_3[0] = floor_queue_3[1];floor_queue_3[1] = floor_queue_3[2];floor_queue_3[2] = floor_queue_3[3];floor_queue_3[3] = 0;floor_queue_3_act = floor_queue_3_act-1;}  goto q; \n\nfi;\nq: if\n::  atomic {0==who;get_in_0?going_to;}  goto transporting; \n\n::  atomic {1==who;get_in_1?going_to;}  goto transporting; \n\n::  atomic {2==who;get_in_2?going_to;}  goto transporting; \n\n::  atomic {3==who;get_in_3?going_to;}  goto transporting; \n\nfi;\ntransporting: if\n::  atomic {0==who && going_to==current;get_out_0!current;going_to = 0;who = 0;}  goto choose_next; \n\n::  atomic {1==who && going_to==current;get_out_1!current;going_to = 0;who = 0;}  goto choose_next; \n\n::  atomic {2==who && going_to==current;get_out_2!current;going_to = 0;who = 0;}  goto choose_next; \n\n::  atomic {3==who && going_to==current;get_out_3!current;going_to = 0;who = 0;}  goto choose_next; \n\n::  d_step {going_to<current;current = current-1;}  goto transporting; \n\n::  d_step {going_to>current;current = current+1;}  goto transporting; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Just some variation on the popular elevator\n  theme.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte floor_queue_0[5];\nbyte floor_queue_0_act=0;\nbyte floor_queue_1[5];\nbyte floor_queue_1_act=0;\nbyte floor_queue_2[5];\nbyte floor_queue_2_act=0;\nbyte floor_queue_3[5];\nbyte floor_queue_3_act=0;\nbyte floor_queue_4[5];\nbyte floor_queue_4_act=0;\nbyte floor_queue_5[5];\nbyte floor_queue_5_act=0;\nbyte current=0;\n\nchan call_0 =[0] of {int};\nchan get_in_0 =[0] of {int};\nchan get_out_0 =[0] of {int};\nchan call_1 =[0] of {int};\nchan get_in_1 =[0] of {int};\nchan get_out_1 =[0] of {int};\nchan call_2 =[0] of {int};\nchan get_in_2 =[0] of {int};\nchan get_out_2 =[0] of {int};\nchan call_3 =[0] of {int};\nchan get_in_3 =[0] of {int};\nchan get_out_3 =[0] of {int};\nchan call_4 =[0] of {int};\nchan get_in_4 =[0] of {int};\nchan get_out_4 =[0] of {int};\n\nactive proctype Person_0() { \nbyte at_floor=0;\n\nout: if\n:: call_0!at_floor; goto waiting; \n\nfi;\nwaiting: if\n::  atomic {0!=at_floor;get_in_0!0;}  goto in_elevator; \n\n::  atomic {1!=at_floor;get_in_0!1;}  goto in_elevator; \n\n::  atomic {2!=at_floor;get_in_0!2;}  goto in_elevator; \n\n::  atomic {3!=at_floor;get_in_0!3;}  goto in_elevator; \n\n::  atomic {4!=at_floor;get_in_0!4;}  goto in_elevator; \n\n::  atomic {5!=at_floor;get_in_0!5;}  goto in_elevator; \n\nfi;\nin_elevator: if\n:: get_out_0?at_floor; goto out; \n\nfi;\n}\n\nactive proctype Person_1() { \nbyte at_floor=0;\n\nout: if\n:: call_1!at_floor; goto waiting; \n\nfi;\nwaiting: if\n::  atomic {0!=at_floor;get_in_1!0;}  goto in_elevator; \n\n::  atomic {1!=at_floor;get_in_1!1;}  goto in_elevator; \n\n::  atomic {2!=at_floor;get_in_1!2;}  goto in_elevator; \n\n::  atomic {3!=at_floor;get_in_1!3;}  goto in_elevator; \n\n::  atomic {4!=at_floor;get_in_1!4;}  goto in_elevator; \n\n::  atomic {5!=at_floor;get_in_1!5;}  goto in_elevator; \n\nfi;\nin_elevator: if\n:: get_out_1?at_floor; goto out; \n\nfi;\n}\n\nactive proctype Person_2() { \nbyte at_floor=0;\n\nout: if\n:: call_2!at_floor; goto waiting; \n\nfi;\nwaiting: if\n::  atomic {0!=at_floor;get_in_2!0;}  goto in_elevator; \n\n::  atomic {1!=at_floor;get_in_2!1;}  goto in_elevator; \n\n::  atomic {2!=at_floor;get_in_2!2;}  goto in_elevator; \n\n::  atomic {3!=at_floor;get_in_2!3;}  goto in_elevator; \n\n::  atomic {4!=at_floor;get_in_2!4;}  goto in_elevator; \n\n::  atomic {5!=at_floor;get_in_2!5;}  goto in_elevator; \n\nfi;\nin_elevator: if\n:: get_out_2?at_floor; goto out; \n\nfi;\n}\n\nactive proctype Person_3() { \nbyte at_floor=0;\n\nout: if\n:: call_3!at_floor; goto waiting; \n\nfi;\nwaiting: if\n::  atomic {0!=at_floor;get_in_3!0;}  goto in_elevator; \n\n::  atomic {1!=at_floor;get_in_3!1;}  goto in_elevator; \n\n::  atomic {2!=at_floor;get_in_3!2;}  goto in_elevator; \n\n::  atomic {3!=at_floor;get_in_3!3;}  goto in_elevator; \n\n::  atomic {4!=at_floor;get_in_3!4;}  goto in_elevator; \n\n::  atomic {5!=at_floor;get_in_3!5;}  goto in_elevator; \n\nfi;\nin_elevator: if\n:: get_out_3?at_floor; goto out; \n\nfi;\n}\n\nactive proctype Person_4() { \nbyte at_floor=0;\n\nout: if\n:: call_4!at_floor; goto waiting; \n\nfi;\nwaiting: if\n::  atomic {0!=at_floor;get_in_4!0;}  goto in_elevator; \n\n::  atomic {1!=at_floor;get_in_4!1;}  goto in_elevator; \n\n::  atomic {2!=at_floor;get_in_4!2;}  goto in_elevator; \n\n::  atomic {3!=at_floor;get_in_4!3;}  goto in_elevator; \n\n::  atomic {4!=at_floor;get_in_4!4;}  goto in_elevator; \n\n::  atomic {5!=at_floor;get_in_4!5;}  goto in_elevator; \n\nfi;\nin_elevator: if\n:: get_out_4?at_floor; goto out; \n\nfi;\n}\n\nactive proctype Servis() { \nbyte floor=0;\nbyte caller=0;\n\nq: if\n::  atomic {call_0?floor;caller = 0;}  goto r; \n\n::  atomic {call_1?floor;caller = 1;}  goto r; \n\n::  atomic {call_2?floor;caller = 2;}  goto r; \n\n::  atomic {call_3?floor;caller = 3;}  goto r; \n\n::  atomic {call_4?floor;caller = 4;}  goto r; \n\nfi;\nr: if\n::  d_step {0==floor;floor_queue_0[floor_queue_0_act] = caller;floor_queue_0_act = floor_queue_0_act+1;}  goto q; \n\n::  d_step {1==floor;floor_queue_1[floor_queue_1_act] = caller;floor_queue_1_act = floor_queue_1_act+1;}  goto q; \n\n::  d_step {2==floor;floor_queue_2[floor_queue_2_act] = caller;floor_queue_2_act = floor_queue_2_act+1;}  goto q; \n\n::  d_step {3==floor;floor_queue_3[floor_queue_3_act] = caller;floor_queue_3_act = floor_queue_3_act+1;}  goto q; \n\n::  d_step {4==floor;floor_queue_4[floor_queue_4_act] = caller;floor_queue_4_act = floor_queue_4_act+1;}  goto q; \n\n::  d_step {5==floor;floor_queue_5[floor_queue_5_act] = caller;floor_queue_5_act = floor_queue_5_act+1;}  goto q; \n\nfi;\n}\n\nactive proctype Elevator() { \nbyte going_to=0;\nbyte serving=0;\nbyte who=0;\n\nchoose_next: if\n::  d_step {0==serving && floor_queue_0_act==0 && ( ! (floor_queue_0_act==0) ||  ! (floor_queue_1_act==0) ||  ! (floor_queue_2_act==0) ||  ! (floor_queue_3_act==0) ||  ! (floor_queue_4_act==0) ||  ! (floor_queue_5_act==0));serving = (serving+1)%6;}  goto choose_next; \n\n::  d_step {1==serving && floor_queue_1_act==0 && ( ! (floor_queue_0_act==0) ||  ! (floor_queue_1_act==0) ||  ! (floor_queue_2_act==0) ||  ! (floor_queue_3_act==0) ||  ! (floor_queue_4_act==0) ||  ! (floor_queue_5_act==0));serving = (serving+1)%6;}  goto choose_next; \n\n::  d_step {2==serving && floor_queue_2_act==0 && ( ! (floor_queue_0_act==0) ||  ! (floor_queue_1_act==0) ||  ! (floor_queue_2_act==0) ||  ! (floor_queue_3_act==0) ||  ! (floor_queue_4_act==0) ||  ! (floor_queue_5_act==0));serving = (serving+1)%6;}  goto choose_next; \n\n::  d_step {3==serving && floor_queue_3_act==0 && ( ! (floor_queue_0_act==0) ||  ! (floor_queue_1_act==0) ||  ! (floor_queue_2_act==0) ||  ! (floor_queue_3_act==0) ||  ! (floor_queue_4_act==0) ||  ! (floor_queue_5_act==0));serving = (serving+1)%6;}  goto choose_next; \n\n::  d_step {4==serving && floor_queue_4_act==0 && ( ! (floor_queue_0_act==0) ||  ! (floor_queue_1_act==0) ||  ! (floor_queue_2_act==0) ||  ! (floor_queue_3_act==0) ||  ! (floor_queue_4_act==0) ||  ! (floor_queue_5_act==0));serving = (serving+1)%6;}  goto choose_next; \n\n::  d_step {5==serving && floor_queue_5_act==0 && ( ! (floor_queue_0_act==0) ||  ! (floor_queue_1_act==0) ||  ! (floor_queue_2_act==0) ||  ! (floor_queue_3_act==0) ||  ! (floor_queue_4_act==0) ||  ! (floor_queue_5_act==0));serving = (serving+1)%6;}  goto choose_next; \n\n:: 0==serving && ( ! (floor_queue_0_act==0)); goto move_next; \n\n:: 1==serving && ( ! (floor_queue_1_act==0)); goto move_next; \n\n:: 2==serving && ( ! (floor_queue_2_act==0)); goto move_next; \n\n:: 3==serving && ( ! (floor_queue_3_act==0)); goto move_next; \n\n:: 4==serving && ( ! (floor_queue_4_act==0)); goto move_next; \n\n:: 5==serving && ( ! (floor_queue_5_act==0)); goto move_next; \n\nfi;\nmove_next: if\n::  d_step {serving<current;current = current-1;}  goto move_next; \n\n::  d_step {serving>current;current = current+1;}  goto move_next; \n\n::  d_step {serving==current && 0==current;who = floor_queue_0[0];floor_queue_0[0] = floor_queue_0[1];floor_queue_0[1] = floor_queue_0[2];floor_queue_0[2] = floor_queue_0[3];floor_queue_0[3] = floor_queue_0[4];floor_queue_0[4] = 0;floor_queue_0_act = floor_queue_0_act-1;}  goto q; \n\n::  d_step {serving==current && 1==current;who = floor_queue_1[0];floor_queue_1[0] = floor_queue_1[1];floor_queue_1[1] = floor_queue_1[2];floor_queue_1[2] = floor_queue_1[3];floor_queue_1[3] = floor_queue_1[4];floor_queue_1[4] = 0;floor_queue_1_act = floor_queue_1_act-1;}  goto q; \n\n::  d_step {serving==current && 2==current;who = floor_queue_2[0];floor_queue_2[0] = floor_queue_2[1];floor_queue_2[1] = floor_queue_2[2];floor_queue_2[2] = floor_queue_2[3];floor_queue_2[3] = floor_queue_2[4];floor_queue_2[4] = 0;floor_queue_2_act = floor_queue_2_act-1;}  goto q; \n\n::  d_step {serving==current && 3==current;who = floor_queue_3[0];floor_queue_3[0] = floor_queue_3[1];floor_queue_3[1] = floor_queue_3[2];floor_queue_3[2] = floor_queue_3[3];floor_queue_3[3] = floor_queue_3[4];floor_queue_3[4] = 0;floor_queue_3_act = floor_queue_3_act-1;}  goto q; \n\n::  d_step {serving==current && 4==current;who = floor_queue_4[0];floor_queue_4[0] = floor_queue_4[1];floor_queue_4[1] = floor_queue_4[2];floor_queue_4[2] = floor_queue_4[3];floor_queue_4[3] = floor_queue_4[4];floor_queue_4[4] = 0;floor_queue_4_act = floor_queue_4_act-1;}  goto q; \n\n::  d_step {serving==current && 5==current;who = floor_queue_5[0];floor_queue_5[0] = floor_queue_5[1];floor_queue_5[1] = floor_queue_5[2];floor_queue_5[2] = floor_queue_5[3];floor_queue_5[3] = floor_queue_5[4];floor_queue_5[4] = 0;floor_queue_5_act = floor_queue_5_act-1;}  goto q; \n\nfi;\nq: if\n::  atomic {0==who;get_in_0?going_to;}  goto transporting; \n\n::  atomic {1==who;get_in_1?going_to;}  goto transporting; \n\n::  atomic {2==who;get_in_2?going_to;}  goto transporting; \n\n::  atomic {3==who;get_in_3?going_to;}  goto transporting; \n\n::  atomic {4==who;get_in_4?going_to;}  goto transporting; \n\nfi;\ntransporting: if\n::  atomic {0==who && going_to==current;get_out_0!current;going_to = 0;who = 0;serving = current;}  goto choose_next; \n\n::  atomic {1==who && going_to==current;get_out_1!current;going_to = 0;who = 0;serving = current;}  goto choose_next; \n\n::  atomic {2==who && going_to==current;get_out_2!current;going_to = 0;who = 0;serving = current;}  goto choose_next; \n\n::  atomic {3==who && going_to==current;get_out_3!current;going_to = 0;who = 0;serving = current;}  goto choose_next; \n\n::  atomic {4==who && going_to==current;get_out_4!current;going_to = 0;who = 0;serving = current;}  goto choose_next; \n\n::  d_step {going_to<current;current = current-1;}  goto transporting; \n\n::  d_step {going_to>current;current = current+1;}  goto transporting; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Motivated by elevator promela model from the SPIN\n  distribution, but actually implements LEGO elevator model built in the\n  Paradise laboratory. Naive controller chooses the next floor to be served\n  randomly, clever controller chooses the next floor to be served to be the\n  next requested one in the direction of the last cab movement, if there is no\n  such floor then in direction oposite to the direction of the last cab\n  movement.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte req[4];\nint t=0;\nint p=0;\nbyte v=0;\n\n\nactive proctype cabin() { \n\nidle: if\n:: v>0; goto mov; \n\nfi;\nmov: if\n:: t==p; goto open; \n\n::  d_step {t<p;p = p-1;}  goto mov; \n\n::  d_step {t>p;p = p+1;}  goto mov; \n\nfi;\nopen: if\n::  d_step {req[p] = 0;v = 0;}  goto idle; \n\nfi;\n}\n\nactive proctype environment() { \n\nread: if\n::  d_step {req[0]==0;req[0] = 1;}  goto read; \n\n::  d_step {req[1]==0;req[1] = 1;}  goto read; \n\n::  d_step {req[2]==0;req[2] = 1;}  goto read; \n\n::  d_step {req[3]==0;req[3] = 1;}  goto read; \n\nfi;\n}\n\nactive proctype controller() { \nbyte ldir=0;\n\nwait: if\n::  d_step {v==0;t = t+(2*ldir)-1;}  goto work; \n\nfi;\nwork: if\n::  d_step {t<0 || t==4;ldir = 1-ldir;}  goto wait; \n\n:: t>=0 && t<4 && req[t]==1; goto done; \n\n::  d_step {t>=0 && t<4 && req[t]==0;t = t+(2*ldir)-1;}  goto work; \n\nfi;\ndone: if\n:: v = 1; goto wait; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Motivated by elevator promela model from the SPIN\n  distribution, but actually implements LEGO elevator model built in the\n  Paradise laboratory. Naive controller chooses the next floor to be served\n  randomly, clever controller chooses the next floor to be served to be the\n  next requested one in the direction of the last cab movement, if there is no\n  such floor then in direction oposite to the direction of the last cab\n  movement.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte req[10];\nint t=0;\nint p=0;\nbyte v=0;\n\n\nactive proctype cabin() { \n\nidle: if\n:: v>0; goto mov; \n\nfi;\nmov: if\n:: t==p; goto open; \n\n::  d_step {t<p;p = p-1;}  goto mov; \n\n::  d_step {t>p;p = p+1;}  goto mov; \n\nfi;\nopen: if\n::  d_step {req[p] = 0;v = 0;}  goto idle; \n\nfi;\n}\n\nactive proctype environment() { \n\nread: if\n::  d_step {req[0]==0;req[0] = 1;}  goto read; \n\n::  d_step {req[1]==0;req[1] = 1;}  goto read; \n\n::  d_step {req[2]==0;req[2] = 1;}  goto read; \n\n::  d_step {req[3]==0;req[3] = 1;}  goto read; \n\n::  d_step {req[4]==0;req[4] = 1;}  goto read; \n\n::  d_step {req[5]==0;req[5] = 1;}  goto read; \n\n::  d_step {req[6]==0;req[6] = 1;}  goto read; \n\n::  d_step {req[7]==0;req[7] = 1;}  goto read; \n\n::  d_step {req[8]==0;req[8] = 1;}  goto read; \n\n::  d_step {req[9]==0;req[9] = 1;}  goto read; \n\nfi;\n}\n\nactive proctype controller() { \n\nwait: if\n:: v==0; goto work; \n\nfi;\nwork: if\n::  d_step {req[0]==1;t = 0;}  goto done; \n\n::  d_step {req[1]==1;t = 1;}  goto done; \n\n::  d_step {req[2]==1;t = 2;}  goto done; \n\n::  d_step {req[3]==1;t = 3;}  goto done; \n\n::  d_step {req[4]==1;t = 4;}  goto done; \n\n::  d_step {req[5]==1;t = 5;}  goto done; \n\n::  d_step {req[6]==1;t = 6;}  goto done; \n\n::  d_step {req[7]==1;t = 7;}  goto done; \n\n::  d_step {req[8]==1;t = 8;}  goto done; \n\n::  d_step {req[9]==1;t = 9;}  goto done; \n\nfi;\ndone: if\n:: v = 1; goto wait; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Motivated by elevator promela model from the SPIN\n  distribution, but actually implements LEGO elevator model built in the\n  Paradise laboratory. Naive controller chooses the next floor to be served\n  randomly, clever controller chooses the next floor to be served to be the\n  next requested one in the direction of the last cab movement, if there is no\n  such floor then in direction oposite to the direction of the last cab\n  movement.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte req[13];\nint t=0;\nint p=0;\nbyte v=0;\n\n\nactive proctype cabin() { \n\nidle: if\n:: v>0; goto mov; \n\nfi;\nmov: if\n:: t==p; goto open; \n\n::  d_step {t<p;p = p-1;}  goto mov; \n\n::  d_step {t>p;p = p+1;}  goto mov; \n\nfi;\nopen: if\n::  d_step {req[p] = 0;v = 0;}  goto idle; \n\nfi;\n}\n\nactive proctype environment() { \n\nread: if\n::  d_step {req[0]==0;req[0] = 1;}  goto read; \n\n::  d_step {req[1]==0;req[1] = 1;}  goto read; \n\n::  d_step {req[2]==0;req[2] = 1;}  goto read; \n\n::  d_step {req[3]==0;req[3] = 1;}  goto read; \n\n::  d_step {req[4]==0;req[4] = 1;}  goto read; \n\n::  d_step {req[5]==0;req[5] = 1;}  goto read; \n\n::  d_step {req[6]==0;req[6] = 1;}  goto read; \n\n::  d_step {req[7]==0;req[7] = 1;}  goto read; \n\n::  d_step {req[8]==0;req[8] = 1;}  goto read; \n\n::  d_step {req[9]==0;req[9] = 1;}  goto read; \n\n::  d_step {req[10]==0;req[10] = 1;}  goto read; \n\n::  d_step {req[11]==0;req[11] = 1;}  goto read; \n\n::  d_step {req[12]==0;req[12] = 1;}  goto read; \n\nfi;\n}\n\nactive proctype controller() { \nbyte ldir=0;\n\nwait: if\n::  d_step {v==0;t = t+(2*ldir)-1;}  goto work; \n\nfi;\nwork: if\n::  d_step {t<0 || t==13;ldir = 1-ldir;}  goto wait; \n\n:: t>=0 && t<13 && req[t]==1; goto done; \n\n::  d_step {t>=0 && t<13 && req[t]==0;t = t+(2*ldir)-1;}  goto work; \n\nfi;\ndone: if\n:: v = 1; goto wait; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Example from AIPS: the goal is to serve pasanger, there\n    are several restricting constraints (capacity of the elevator, conflicts\n    between pasangers, etc.)\n\nParameters:\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte person[5];\nbyte conflictA[5];\nbyte conflictB[5];\nbyte not_alone[5];\nbyte at=0;\nbyte inA=0;\nbyte inB=0;\nbyte in=0;\nbyte alone=0;\nbyte i=0;\n\n\ninit { \n d_step { \nperson[0] =0; person[1] =1; person[2] =2; person[3] =3; person[4] =4; conflictA[0] =1; conflictA[1] =0; conflictA[2] =0; conflictA[3] =1; conflictA[4] =1; conflictB[0] =0; conflictB[1] =1; conflictB[2] =1; not_alone[0] =1; not_alone[1] =1; not_alone[2] =0; not_alone[3] =0; not_alone[4] =0; }\natomic { \nrun Elevator();\n} }\n\nproctype Elevator() { \n\nq: if\n:: person[0]==0 && person[1]==0 && person[2]==0 && person[3]==0 && person[4]==0; goto done; \n\n::  d_step {person[0]==at && in<3 && (conflictA[0]==0 || inB==0) && (conflictB[0]==0 || inA==0) && (not_alone[0]==0 || in>0);person[0] = 255;in = in+1;inA = inA+conflictA[0];inB = inB+conflictB[0];alone = alone+not_alone[0];}  goto q; \n\n::  d_step {person[1]==at && in<3 && (conflictA[1]==0 || inB==0) && (conflictB[1]==0 || inA==0) && (not_alone[1]==0 || in>0);person[1] = 255;in = in+1;inA = inA+conflictA[1];inB = inB+conflictB[1];alone = alone+not_alone[1];}  goto q; \n\n::  d_step {person[2]==at && in<3 && (conflictA[2]==0 || inB==0) && (conflictB[2]==0 || inA==0) && (not_alone[2]==0 || in>0);person[2] = 255;in = in+1;inA = inA+conflictA[2];inB = inB+conflictB[2];alone = alone+not_alone[2];}  goto q; \n\n::  d_step {person[3]==at && in<3 && (conflictA[3]==0 || inB==0) && (conflictB[3]==0 || inA==0) && (not_alone[3]==0 || in>0);person[3] = 255;in = in+1;inA = inA+conflictA[3];inB = inB+conflictB[3];alone = alone+not_alone[3];}  goto q; \n\n::  d_step {person[4]==at && in<3 && (conflictA[4]==0 || inB==0) && (conflictB[4]==0 || inA==0) && (not_alone[4]==0 || in>0);person[4] = 255;in = in+1;inA = inA+conflictA[4];inB = inB+conflictB[4];alone = alone+not_alone[4];}  goto q; \n\n::  d_step {person[0]==255 && (in>2 || (alone-not_alone[0]==0));person[0] = at;in = in-1;inA = inA-conflictA[0];inB = inB-conflictB[0];alone = alone-not_alone[0];}  goto q; \n\n::  d_step {person[1]==255 && (in>2 || (alone-not_alone[1]==0));person[1] = at;in = in-1;inA = inA-conflictA[1];inB = inB-conflictB[1];alone = alone-not_alone[1];}  goto q; \n\n::  d_step {person[2]==255 && (in>2 || (alone-not_alone[2]==0));person[2] = at;in = in-1;inA = inA-conflictA[2];inB = inB-conflictB[2];alone = alone-not_alone[2];}  goto q; \n\n::  d_step {person[3]==255 && (in>2 || (alone-not_alone[3]==0));person[3] = at;in = in-1;inA = inA-conflictA[3];inB = inB-conflictB[3];alone = alone-not_alone[3];}  goto q; \n\n::  d_step {person[4]==255 && (in>2 || (alone-not_alone[4]==0));person[4] = at;in = in-1;inA = inA-conflictA[4];inB = inB-conflictB[4];alone = alone-not_alone[4];}  goto q; \n\n:: at = 0; goto q; \n\n:: at = 1; goto q; \n\n:: at = 2; goto q; \n\n:: at = 3; goto q; \n\n:: at = 4; goto q; \n\nfi;\ndone: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Example from AIPS: the goal is to serve pasanger, there\n    are several restricting constraints (capacity of the elevator, conflicts\n    between pasangers, etc.)\n\nParameters:\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte person[7];\nbyte conflictA[7];\nbyte conflictB[7];\nbyte not_alone[7];\nbyte at=0;\nbyte inA=0;\nbyte inB=0;\nbyte in=0;\nbyte alone=0;\nbyte i=0;\n\n\ninit { \n d_step { \nperson[0] =0; person[1] =1; person[2] =2; person[3] =3; person[4] =4; person[5] =0; person[6] =3; conflictA[0] =1; conflictA[1] =0; conflictA[2] =0; conflictA[3] =1; conflictA[4] =1; conflictA[5] =0; conflictA[6] =0; conflictB[0] =0; conflictB[1] =1; conflictB[2] =1; conflictB[3] =0; conflictB[4] =0; conflictB[5] =1; conflictB[6] =0; not_alone[0] =1; not_alone[1] =1; not_alone[2] =0; not_alone[3] =0; not_alone[4] =0; not_alone[5] =0; not_alone[6] =0; }\natomic { \nrun Elevator();\n} }\n\nproctype Elevator() { \n\nq: if\n:: person[0]==0 && person[1]==0 && person[2]==0 && person[3]==0 && person[4]==0 && person[5]==0 && person[6]==0; goto done; \n\n::  d_step {person[0]==at && in<3 && (conflictA[0]==0 || inB==0) && (conflictB[0]==0 || inA==0) && (not_alone[0]==0 || in>0);person[0] = 255;in = in+1;inA = inA+conflictA[0];inB = inB+conflictB[0];alone = alone+not_alone[0];}  goto q; \n\n::  d_step {person[1]==at && in<3 && (conflictA[1]==0 || inB==0) && (conflictB[1]==0 || inA==0) && (not_alone[1]==0 || in>0);person[1] = 255;in = in+1;inA = inA+conflictA[1];inB = inB+conflictB[1];alone = alone+not_alone[1];}  goto q; \n\n::  d_step {person[2]==at && in<3 && (conflictA[2]==0 || inB==0) && (conflictB[2]==0 || inA==0) && (not_alone[2]==0 || in>0);person[2] = 255;in = in+1;inA = inA+conflictA[2];inB = inB+conflictB[2];alone = alone+not_alone[2];}  goto q; \n\n::  d_step {person[3]==at && in<3 && (conflictA[3]==0 || inB==0) && (conflictB[3]==0 || inA==0) && (not_alone[3]==0 || in>0);person[3] = 255;in = in+1;inA = inA+conflictA[3];inB = inB+conflictB[3];alone = alone+not_alone[3];}  goto q; \n\n::  d_step {person[4]==at && in<3 && (conflictA[4]==0 || inB==0) && (conflictB[4]==0 || inA==0) && (not_alone[4]==0 || in>0);person[4] = 255;in = in+1;inA = inA+conflictA[4];inB = inB+conflictB[4];alone = alone+not_alone[4];}  goto q; \n\n::  d_step {person[5]==at && in<3 && (conflictA[5]==0 || inB==0) && (conflictB[5]==0 || inA==0) && (not_alone[5]==0 || in>0);person[5] = 255;in = in+1;inA = inA+conflictA[5];inB = inB+conflictB[5];alone = alone+not_alone[5];}  goto q; \n\n::  d_step {person[6]==at && in<3 && (conflictA[6]==0 || inB==0) && (conflictB[6]==0 || inA==0) && (not_alone[6]==0 || in>0);person[6] = 255;in = in+1;inA = inA+conflictA[6];inB = inB+conflictB[6];alone = alone+not_alone[6];}  goto q; \n\n::  d_step {person[0]==255 && (in>2 || (alone-not_alone[0]==0));person[0] = at;in = in-1;inA = inA-conflictA[0];inB = inB-conflictB[0];alone = alone-not_alone[0];}  goto q; \n\n::  d_step {person[1]==255 && (in>2 || (alone-not_alone[1]==0));person[1] = at;in = in-1;inA = inA-conflictA[1];inB = inB-conflictB[1];alone = alone-not_alone[1];}  goto q; \n\n::  d_step {person[2]==255 && (in>2 || (alone-not_alone[2]==0));person[2] = at;in = in-1;inA = inA-conflictA[2];inB = inB-conflictB[2];alone = alone-not_alone[2];}  goto q; \n\n::  d_step {person[3]==255 && (in>2 || (alone-not_alone[3]==0));person[3] = at;in = in-1;inA = inA-conflictA[3];inB = inB-conflictB[3];alone = alone-not_alone[3];}  goto q; \n\n::  d_step {person[4]==255 && (in>2 || (alone-not_alone[4]==0));person[4] = at;in = in-1;inA = inA-conflictA[4];inB = inB-conflictB[4];alone = alone-not_alone[4];}  goto q; \n\n::  d_step {person[5]==255 && (in>2 || (alone-not_alone[5]==0));person[5] = at;in = in-1;inA = inA-conflictA[5];inB = inB-conflictB[5];alone = alone-not_alone[5];}  goto q; \n\n::  d_step {person[6]==255 && (in>2 || (alone-not_alone[6]==0));person[6] = at;in = in-1;inA = inA-conflictA[6];inB = inB-conflictB[6];alone = alone-not_alone[6];}  goto q; \n\n:: at = 0; goto q; \n\n:: at = 1; goto q; \n\n:: at = 2; goto q; \n\n:: at = 3; goto q; \n\n:: at = 4; goto q; \n\n:: at = 5; goto q; \n\n:: at = 6; goto q; \n\nfi;\ndone: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Example from AIPS: the goal is to serve pasanger, there\n    are several restricting constraints (capacity of the elevator, conflicts\n    between pasangers, etc.)\n\nParameters:\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte person[4];\nbyte conflictA[4];\nbyte conflictB[4];\nbyte not_alone[4];\nbyte at=0;\nbyte inA=0;\nbyte inB=0;\nbyte in=0;\nbyte alone=0;\nbyte i=0;\n\n\ninit { \n d_step { \nperson[0] =7; person[1] =2; person[2] =6; person[3] =5; conflictA[0] =0; conflictA[1] =0; conflictA[2] =0; conflictA[3] =0; conflictB[0] =0; conflictB[1] =0; conflictB[2] =0; conflictB[3] =0; not_alone[0] =0; not_alone[1] =0; not_alone[2] =0; not_alone[3] =0; }\natomic { \nrun Elevator();\n} }\n\nproctype Elevator() { \n\nq: if\n:: person[0]==0 && person[1]==0 && person[2]==0 && person[3]==0; goto done; \n\n::  d_step {person[0]==at && in<4 && (conflictA[0]==0 || inB==0) && (conflictB[0]==0 || inA==0) && (not_alone[0]==0 || in>0);person[0] = 255;in = in+1;inA = inA+conflictA[0];inB = inB+conflictB[0];alone = alone+not_alone[0];}  goto q; \n\n::  d_step {person[1]==at && in<4 && (conflictA[1]==0 || inB==0) && (conflictB[1]==0 || inA==0) && (not_alone[1]==0 || in>0);person[1] = 255;in = in+1;inA = inA+conflictA[1];inB = inB+conflictB[1];alone = alone+not_alone[1];}  goto q; \n\n::  d_step {person[2]==at && in<4 && (conflictA[2]==0 || inB==0) && (conflictB[2]==0 || inA==0) && (not_alone[2]==0 || in>0);person[2] = 255;in = in+1;inA = inA+conflictA[2];inB = inB+conflictB[2];alone = alone+not_alone[2];}  goto q; \n\n::  d_step {person[3]==at && in<4 && (conflictA[3]==0 || inB==0) && (conflictB[3]==0 || inA==0) && (not_alone[3]==0 || in>0);person[3] = 255;in = in+1;inA = inA+conflictA[3];inB = inB+conflictB[3];alone = alone+not_alone[3];}  goto q; \n\n::  d_step {person[0]==255 && (in>2 || (alone-not_alone[0]==0));person[0] = at;in = in-1;inA = inA-conflictA[0];inB = inB-conflictB[0];alone = alone-not_alone[0];}  goto q; \n\n::  d_step {person[1]==255 && (in>2 || (alone-not_alone[1]==0));person[1] = at;in = in-1;inA = inA-conflictA[1];inB = inB-conflictB[1];alone = alone-not_alone[1];}  goto q; \n\n::  d_step {person[2]==255 && (in>2 || (alone-not_alone[2]==0));person[2] = at;in = in-1;inA = inA-conflictA[2];inB = inB-conflictB[2];alone = alone-not_alone[2];}  goto q; \n\n::  d_step {person[3]==255 && (in>2 || (alone-not_alone[3]==0));person[3] = at;in = in-1;inA = inA-conflictA[3];inB = inB-conflictB[3];alone = alone-not_alone[3];}  goto q; \n\n:: at = 0; goto q; \n\n:: at = 1; goto q; \n\n:: at = 2; goto q; \n\n:: at = 3; goto q; \n\n:: at = 4; goto q; \n\n:: at = 5; goto q; \n\n:: at = 6; goto q; \n\n:: at = 7; goto q; \n\nfi;\ndone: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Leader election algorithm for arbitrary networks based on\n    echo wave algorithm and extinction technique. The model uses a fixed\n    topology.\n\nParameters:\n\n\n\nAtomic propositions:\n, \n\nProperties to verify:"}, {"role": "assistant", "content": "byte leaders_num=0;\n\nchan ch_0_in =[0] of {int};\nchan ch_0_out =[0] of {int};\nchan ch_1_in =[0] of {int};\nchan ch_1_out =[0] of {int};\nchan ch_2_in =[0] of {int};\nchan ch_2_out =[0] of {int};\n\nactive proctype Node_0() { \nbyte caw=0;\nbyte rec=0;\nbyte father=255;\nbyte lrec=0;\nbyte win=255;\nbyte j=0;\nbyte m=0;\n\nstart: if\n::  atomic {j==0;ch_1_in!((0)+(0)*10+(0*10*10));j = j+1;}  goto start; \n\n:: j==1; goto wait; \n\nfi;\nwait: if\n:: ch_0_out?m; goto got_msg; \n\n::  d_step {lrec==1 && win==0;leaders_num = leaders_num+1;}  goto leader; \n\n:: lrec==1 && win!=0; goto lost; \n\nfi;\ngot_msg: if\n:: ((m)/(10*10))==1; goto ldr_msg; \n\n:: ((m)/(10*10))==0; goto tok_msg; \n\nfi;\nldr_msg: if\n::  d_step {lrec==0;j = 0;}  goto ldr_to_all; \n\n:: lrec>0; goto l2; \n\nfi;\nldr_to_all: if\n::  atomic {j==0;ch_1_in!((0)+((((m)%(10*10))/10))*10+(1*10*10));j = j+1;}  goto ldr_to_all; \n\n:: j==1; goto l2; \n\nfi;\nl2: if\n::  d_step {lrec = lrec+1;win = (((m)%(10*10))/10);}  goto wait; \n\nfi;\ntok_msg: if\n::  d_step {(((m)%(10*10))/10)<caw;caw = (((m)%(10*10))/10);rec = 0;father = ((m)%10);j = 0;}  goto reinicialize; \n\n::  d_step {(((m)%(10*10))/10)==caw;rec = rec+1;}  goto same; \n\n:: (((m)%(10*10))/10)>caw; goto wait; \n\nfi;\nreinicialize: if\n::  atomic {j==0;ch_1_in!((0)+(caw)*10+(0*10*10));j = j+1;}  goto reinicialize; \n\n:: j==1; goto wait; \n\nfi;\nsame: if\n:: rec<1; goto wait; \n\n:: rec==1; goto all; \n\nfi;\nall: if\n::  atomic {caw!=0 && father==0;ch_0_in!((0)+(caw)*10+(0*10*10));}  goto wait; \n\n::  atomic {caw!=0 && father==1;ch_1_in!((0)+(caw)*10+(0*10*10));}  goto wait; \n\n::  atomic {caw!=0 && father==2;ch_2_in!((0)+(caw)*10+(0*10*10));}  goto wait; \n\n::  d_step {caw==0;j = 0;}  goto become_leader; \n\nfi;\nbecome_leader: if\n::  atomic {j==0;ch_1_in!((0)+(0)*10+(1*10*10));j = j+1;}  goto become_leader; \n\n:: j==1; goto wait; \n\nfi;\nleader: \nlost: \n false; }\n\nactive proctype Node_1() { \nbyte caw=1;\nbyte rec=0;\nbyte father=255;\nbyte lrec=0;\nbyte win=255;\nbyte j=0;\nbyte m=0;\n\nstart: if\n::  atomic {j==0;ch_0_in!((1)+(1)*10+(0*10*10));j = j+1;}  goto start; \n\n::  atomic {j==1;ch_2_in!((1)+(1)*10+(0*10*10));j = j+1;}  goto start; \n\n:: j==2; goto wait; \n\nfi;\nwait: if\n:: ch_1_out?m; goto got_msg; \n\n::  d_step {lrec==2 && win==1;leaders_num = leaders_num+1;}  goto leader; \n\n:: lrec==2 && win!=1; goto lost; \n\nfi;\ngot_msg: if\n:: ((m)/(10*10))==1; goto ldr_msg; \n\n:: ((m)/(10*10))==0; goto tok_msg; \n\nfi;\nldr_msg: if\n::  d_step {lrec==0;j = 0;}  goto ldr_to_all; \n\n:: lrec>0; goto l2; \n\nfi;\nldr_to_all: if\n::  atomic {j==0;ch_0_in!((1)+((((m)%(10*10))/10))*10+(1*10*10));j = j+1;}  goto ldr_to_all; \n\n::  atomic {j==1;ch_2_in!((1)+((((m)%(10*10))/10))*10+(1*10*10));j = j+1;}  goto ldr_to_all; \n\n:: j==2; goto l2; \n\nfi;\nl2: if\n::  d_step {lrec = lrec+1;win = (((m)%(10*10))/10);}  goto wait; \n\nfi;\ntok_msg: if\n::  d_step {(((m)%(10*10))/10)<caw;caw = (((m)%(10*10))/10);rec = 0;father = ((m)%10);j = 0;}  goto reinicialize; \n\n::  d_step {(((m)%(10*10))/10)==caw;rec = rec+1;}  goto same; \n\n:: (((m)%(10*10))/10)>caw; goto wait; \n\nfi;\nreinicialize: if\n::  atomic {j==0;ch_0_in!((1)+(caw)*10+(0*10*10));j = j+1;}  goto reinicialize; \n\n::  atomic {j==1;ch_2_in!((1)+(caw)*10+(0*10*10));j = j+1;}  goto reinicialize; \n\n:: j==2; goto wait; \n\nfi;\nsame: if\n:: rec<2; goto wait; \n\n:: rec==2; goto all; \n\nfi;\nall: if\n::  atomic {caw!=1 && father==0;ch_0_in!((1)+(caw)*10+(0*10*10));}  goto wait; \n\n::  atomic {caw!=1 && father==1;ch_1_in!((1)+(caw)*10+(0*10*10));}  goto wait; \n\n::  atomic {caw!=1 && father==2;ch_2_in!((1)+(caw)*10+(0*10*10));}  goto wait; \n\n::  d_step {caw==1;j = 0;}  goto become_leader; \n\nfi;\nbecome_leader: if\n::  atomic {j==0;ch_0_in!((1)+(1)*10+(1*10*10));j = j+1;}  goto become_leader; \n\n::  atomic {j==1;ch_2_in!((1)+(1)*10+(1*10*10));j = j+1;}  goto become_leader; \n\n:: j==2; goto wait; \n\nfi;\nleader: \nlost: \n false; }\n\nactive proctype Node_2() { \nbyte caw=2;\nbyte rec=0;\nbyte father=255;\nbyte lrec=0;\nbyte win=255;\nbyte j=0;\nbyte m=0;\n\nstart: if\n::  atomic {j==0;ch_1_in!((2)+(2)*10+(0*10*10));j = j+1;}  goto start; \n\n:: j==1; goto wait; \n\nfi;\nwait: if\n:: ch_2_out?m; goto got_msg; \n\n::  d_step {lrec==1 && win==2;leaders_num = leaders_num+1;}  goto leader; \n\n:: lrec==1 && win!=2; goto lost; \n\nfi;\ngot_msg: if\n:: ((m)/(10*10))==1; goto ldr_msg; \n\n:: ((m)/(10*10))==0; goto tok_msg; \n\nfi;\nldr_msg: if\n::  d_step {lrec==0;j = 0;}  goto ldr_to_all; \n\n:: lrec>0; goto l2; \n\nfi;\nldr_to_all: if\n::  atomic {j==0;ch_1_in!((2)+((((m)%(10*10))/10))*10+(1*10*10));j = j+1;}  goto ldr_to_all; \n\n:: j==1; goto l2; \n\nfi;\nl2: if\n::  d_step {lrec = lrec+1;win = (((m)%(10*10))/10);}  goto wait; \n\nfi;\ntok_msg: if\n::  d_step {(((m)%(10*10))/10)<caw;caw = (((m)%(10*10))/10);rec = 0;father = ((m)%10);j = 0;}  goto reinicialize; \n\n::  d_step {(((m)%(10*10))/10)==caw;rec = rec+1;}  goto same; \n\n:: (((m)%(10*10))/10)>caw; goto wait; \n\nfi;\nreinicialize: if\n::  atomic {j==0;ch_1_in!((2)+(caw)*10+(0*10*10));j = j+1;}  goto reinicialize; \n\n:: j==1; goto wait; \n\nfi;\nsame: if\n:: rec<1; goto wait; \n\n:: rec==1; goto all; \n\nfi;\nall: if\n::  atomic {caw!=2 && father==0;ch_0_in!((2)+(caw)*10+(0*10*10));}  goto wait; \n\n::  atomic {caw!=2 && father==1;ch_1_in!((2)+(caw)*10+(0*10*10));}  goto wait; \n\n::  atomic {caw!=2 && father==2;ch_2_in!((2)+(caw)*10+(0*10*10));}  goto wait; \n\n::  d_step {caw==2;j = 0;}  goto become_leader; \n\nfi;\nbecome_leader: if\n::  atomic {j==0;ch_1_in!((2)+(2)*10+(1*10*10));j = j+1;}  goto become_leader; \n\n:: j==1; goto wait; \n\nfi;\nleader: \nlost: \n false; }\n\nactive proctype chnlnel_ch_0() { \nbyte buf[3];\nbyte buf_act=0;\n\nq: if\n::  atomic { ! (buf_act==3);ch_0_in?buf[buf_act];buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==0);ch_0_out!buf[0];buf[0] = buf[1];buf[1] = buf[2];buf[2] = 0;buf_act = buf_act-1;}  goto q; \n\nfi;\n}\n\nactive proctype chnlnel_ch_1() { \nbyte buf[3];\nbyte buf_act=0;\n\nq: if\n::  atomic { ! (buf_act==3);ch_1_in?buf[buf_act];buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==0);ch_1_out!buf[0];buf[0] = buf[1];buf[1] = buf[2];buf[2] = 0;buf_act = buf_act-1;}  goto q; \n\nfi;\n}\n\nactive proctype chnlnel_ch_2() { \nbyte buf[3];\nbyte buf_act=0;\n\nq: if\n::  atomic { ! (buf_act==3);ch_2_in?buf[buf_act];buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==0);ch_2_out!buf[0];buf[0] = buf[1];buf[1] = buf[2];buf[2] = 0;buf_act = buf_act-1;}  goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Leader election algorithm for arbitrary networks based on\n    echo wave algorithm and extinction technique. The model uses a fixed\n    topology.\n\nParameters:\n\n\n\nAtomic propositions:\n, \n\nProperties to verify:"}, {"role": "assistant", "content": "byte leaders_num=0;\n\nchan ch_0_in =[0] of {int};\nchan ch_0_out =[0] of {int};\nchan ch_1_in =[0] of {int};\nchan ch_1_out =[0] of {int};\nchan ch_2_in =[0] of {int};\nchan ch_2_out =[0] of {int};\n\nactive proctype Node_0() { \nbyte caw=0;\nbyte rec=0;\nbyte father=255;\nbyte lrec=0;\nbyte win=255;\nbyte j=0;\nbyte m=0;\n\nstart: if\n::  atomic {j==0;ch_1_in!((0)+(0)*10+(0*10*10));j = j+1;}  goto start; \n\n:: j==1; goto wait; \n\nfi;\nwait: if\n:: ch_0_out?m; goto got_msg; \n\n::  d_step {lrec==1 && win==0;leaders_num = leaders_num+1;}  goto leader; \n\n:: lrec==1 && win!=0; goto lost; \n\nfi;\ngot_msg: if\n:: ((m)/(10*10))==1; goto ldr_msg; \n\n:: ((m)/(10*10))==0; goto tok_msg; \n\nfi;\nldr_msg: if\n::  d_step {lrec==0;j = 0;}  goto ldr_to_all; \n\n:: lrec>0; goto l2; \n\nfi;\nldr_to_all: if\n::  atomic {j==0;ch_1_in!((0)+((((m)%(10*10))/10))*10+(1*10*10));j = j+1;}  goto ldr_to_all; \n\n:: j==1; goto l2; \n\nfi;\nl2: if\n::  d_step {lrec = lrec+1;win = (((m)%(10*10))/10);}  goto wait; \n\nfi;\ntok_msg: if\n::  d_step {(((m)%(10*10))/10)<caw;caw = (((m)%(10*10))/10);rec = 0;father = ((m)%10);j = 0;}  goto reinicialize; \n\n::  d_step {(((m)%(10*10))/10)==caw;rec = rec+1;}  goto same; \n\n:: (((m)%(10*10))/10)>caw; goto wait; \n\nfi;\nreinicialize: if\n::  atomic {j==0;ch_1_in!((0)+(caw)*10+(0*10*10));j = j+1;}  goto reinicialize; \n\n:: j==1; goto wait; \n\nfi;\nsame: if\n:: rec<1; goto wait; \n\n:: rec==1; goto all; \n\nfi;\nall: if\n::  atomic {caw!=0 && father==0;ch_0_in!((0)+(caw)*10+(0*10*10));}  goto wait; \n\n::  atomic {caw!=0 && father==1;ch_1_in!((0)+(caw)*10+(0*10*10));}  goto wait; \n\n::  atomic {caw!=0 && father==2;ch_2_in!((0)+(caw)*10+(0*10*10));}  goto wait; \n\n::  d_step {caw==0;j = 0;}  goto become_leader; \n\nfi;\nbecome_leader: if\n::  atomic {j==0;ch_1_in!((0)+(0)*10+(1*10*10));j = j+1;}  goto become_leader; \n\n:: j==1; goto wait; \n\nfi;\nleader: \nlost: \n false; }\n\nactive proctype Node_1() { \nbyte caw=1;\nbyte rec=0;\nbyte father=255;\nbyte lrec=0;\nbyte win=255;\nbyte j=0;\nbyte m=0;\n\nstart: if\n::  atomic {j==0;ch_0_in!((1)+(1)*10+(0*10*10));j = j+1;}  goto start; \n\n::  atomic {j==1;ch_2_in!((1)+(1)*10+(0*10*10));j = j+1;}  goto start; \n\n:: j==2; goto wait; \n\nfi;\nwait: if\n:: ch_1_out?m; goto got_msg; \n\n::  d_step {lrec==2 && win==1;leaders_num = leaders_num+1;}  goto leader; \n\n:: lrec==2 && win!=1; goto lost; \n\nfi;\ngot_msg: if\n:: ((m)/(10*10))==1; goto ldr_msg; \n\n:: ((m)/(10*10))==0; goto tok_msg; \n\nfi;\nldr_msg: if\n::  d_step {lrec==0;j = 0;}  goto ldr_to_all; \n\n:: lrec>0; goto l2; \n\nfi;\nldr_to_all: if\n::  atomic {j==0;ch_0_in!((1)+((((m)%(10*10))/10))*10+(1*10*10));j = j+1;}  goto ldr_to_all; \n\n::  atomic {j==1;ch_2_in!((1)+((((m)%(10*10))/10))*10+(1*10*10));j = j+1;}  goto ldr_to_all; \n\n:: j==2; goto l2; \n\nfi;\nl2: if\n::  d_step {lrec = lrec+1;win = (((m)%(10*10))/10);}  goto wait; \n\nfi;\ntok_msg: if\n::  d_step {(((m)%(10*10))/10)<caw;caw = (((m)%(10*10))/10);rec = 0;father = ((m)%10);j = 0;}  goto reinicialize; \n\n::  d_step {(((m)%(10*10))/10)==caw;rec = rec+1;}  goto same; \n\n:: (((m)%(10*10))/10)>caw; goto wait; \n\nfi;\nreinicialize: if\n::  atomic {j==0;ch_0_in!((1)+(caw)*10+(0*10*10));j = j+1;}  goto reinicialize; \n\n::  atomic {j==1;ch_2_in!((1)+(caw)*10+(0*10*10));j = j+1;}  goto reinicialize; \n\n:: j==2; goto wait; \n\nfi;\nsame: if\n:: rec<2; goto wait; \n\n:: rec==2; goto all; \n\nfi;\nall: if\n::  atomic {caw!=1 && father==0;ch_0_in!((1)+(caw)*10+(0*10*10));}  goto wait; \n\n::  atomic {caw!=1 && father==1;ch_1_in!((1)+(caw)*10+(0*10*10));}  goto wait; \n\n::  atomic {caw!=1 && father==2;ch_2_in!((1)+(caw)*10+(0*10*10));}  goto wait; \n\n::  d_step {caw==1;j = 0;}  goto become_leader; \n\nfi;\nbecome_leader: if\n::  atomic {j==0;ch_0_in!((1)+(1)*10+(1*10*10));j = j+1;}  goto become_leader; \n\n::  atomic {j==1;ch_2_in!((1)+(1)*10+(1*10*10));j = j+1;}  goto become_leader; \n\n:: j==2; goto wait; \n\nfi;\nleader: \nlost: \n false; }\n\nactive proctype Node_2() { \nbyte caw=2;\nbyte rec=0;\nbyte father=255;\nbyte lrec=0;\nbyte win=255;\nbyte j=0;\nbyte m=0;\n\nstart: if\n::  atomic {j==0;ch_1_in!((2)+(2)*10+(0*10*10));j = j+1;}  goto start; \n\n:: j==1; goto wait; \n\nfi;\nwait: if\n:: ch_2_out?m; goto got_msg; \n\n::  d_step {lrec==1 && win==2;leaders_num = leaders_num+1;}  goto leader; \n\n:: lrec==1 && win!=2; goto lost; \n\nfi;\ngot_msg: if\n:: ((m)/(10*10))==1; goto ldr_msg; \n\n:: ((m)/(10*10))==0; goto tok_msg; \n\nfi;\nldr_msg: if\n::  d_step {lrec==0;j = 0;}  goto ldr_to_all; \n\n:: lrec>0; goto l2; \n\nfi;\nldr_to_all: if\n::  atomic {j==0;ch_1_in!((2)+((((m)%(10*10))/10))*10+(1*10*10));j = j+1;}  goto ldr_to_all; \n\n:: j==1; goto l2; \n\nfi;\nl2: if\n::  d_step {lrec = lrec+1;win = (((m)%(10*10))/10);}  goto wait; \n\nfi;\ntok_msg: if\n::  d_step {(((m)%(10*10))/10)<caw;caw = (((m)%(10*10))/10);rec = 0;father = ((m)%10);j = 0;}  goto reinicialize; \n\n::  d_step {(((m)%(10*10))/10)==caw;rec = rec+1;}  goto same; \n\n:: (((m)%(10*10))/10)>caw; goto wait; \n\nfi;\nreinicialize: if\n::  atomic {j==0;ch_1_in!((2)+(caw)*10+(0*10*10));j = j+1;}  goto reinicialize; \n\n:: j==1; goto wait; \n\nfi;\nsame: if\n:: rec<1; goto wait; \n\n:: rec==1; goto all; \n\nfi;\nall: if\n::  atomic {caw!=2 && father==0;ch_0_in!((2)+(caw)*10+(0*10*10));}  goto wait; \n\n::  atomic {caw!=2 && father==1;ch_1_in!((2)+(caw)*10+(0*10*10));}  goto wait; \n\n::  atomic {caw!=2 && father==2;ch_2_in!((2)+(caw)*10+(0*10*10));}  goto wait; \n\n::  d_step {caw==2;j = 0;}  goto become_leader; \n\nfi;\nbecome_leader: if\n::  atomic {j==0;ch_1_in!((2)+(2)*10+(1*10*10));j = j+1;}  goto become_leader; \n\n:: j==1; goto wait; \n\nfi;\nleader: \nlost: \n false; }\n\nactive proctype chnlnel_ch_0() { \nbyte buf[10];\nbyte buf_act=0;\n\nq: if\n::  atomic { ! (buf_act==10);ch_0_in?buf[buf_act];buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==0);ch_0_out!buf[0];buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = buf[4];buf[4] = buf[5];buf[5] = buf[6];buf[6] = buf[7];buf[7] = buf[8];buf[8] = buf[9];buf[9] = 0;buf_act = buf_act-1;}  goto q; \n\nfi;\n}\n\nactive proctype chnlnel_ch_1() { \nbyte buf[10];\nbyte buf_act=0;\n\nq: if\n::  atomic { ! (buf_act==10);ch_1_in?buf[buf_act];buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==0);ch_1_out!buf[0];buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = buf[4];buf[4] = buf[5];buf[5] = buf[6];buf[6] = buf[7];buf[7] = buf[8];buf[8] = buf[9];buf[9] = 0;buf_act = buf_act-1;}  goto q; \n\nfi;\n}\n\nactive proctype chnlnel_ch_2() { \nbyte buf[10];\nbyte buf_act=0;\n\nq: if\n::  atomic { ! (buf_act==10);ch_2_in?buf[buf_act];buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==0);ch_2_out!buf[0];buf[0] = buf[1];buf[1] = buf[2];buf[2] = buf[3];buf[3] = buf[4];buf[4] = buf[5];buf[5] = buf[6];buf[6] = buf[7];buf[7] = buf[8];buf[8] = buf[9];buf[9] = 0;buf_act = buf_act-1;}  goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Leader election algorithm for arbitrary networks based on\n    echo wave algorithm and extinction technique. The model uses a fixed\n    topology.\n\nParameters:\n\n\n\nAtomic propositions:\n, \n\nProperties to verify:"}, {"role": "assistant", "content": "byte leaders_num=0;\n\nchan ch_0_in =[0] of {int};\nchan ch_0_out =[0] of {int};\nchan ch_1_in =[0] of {int};\nchan ch_1_out =[0] of {int};\nchan ch_2_in =[0] of {int};\nchan ch_2_out =[0] of {int};\nchan ch_3_in =[0] of {int};\nchan ch_3_out =[0] of {int};\n\nactive proctype Node_0() { \nbyte caw=0;\nbyte rec=0;\nbyte father=255;\nbyte lrec=0;\nbyte win=255;\nbyte j=0;\nbyte m=0;\n\nstart: if\n::  atomic {j==0;ch_2_in!((0)+(0)*10+(0*10*10));j = j+1;}  goto start; \n\n::  atomic {j==1;ch_3_in!((0)+(0)*10+(0*10*10));j = j+1;}  goto start; \n\n:: j==2; goto wait; \n\nfi;\nwait: if\n:: ch_0_out?m; goto got_msg; \n\n::  d_step {lrec==2 && win==0;leaders_num = leaders_num+1;}  goto leader; \n\n:: lrec==2 && win!=0; goto lost; \n\nfi;\ngot_msg: if\n:: ((m)/(10*10))==1; goto ldr_msg; \n\n:: ((m)/(10*10))==0; goto tok_msg; \n\nfi;\nldr_msg: if\n::  d_step {lrec==0;j = 0;}  goto ldr_to_all; \n\n:: lrec>0; goto l2; \n\nfi;\nldr_to_all: if\n::  atomic {j==0;ch_2_in!((0)+((((m)%(10*10))/10))*10+(1*10*10));j = j+1;}  goto ldr_to_all; \n\n::  atomic {j==1;ch_3_in!((0)+((((m)%(10*10))/10))*10+(1*10*10));j = j+1;}  goto ldr_to_all; \n\n:: j==2; goto l2; \n\nfi;\nl2: if\n::  d_step {lrec = lrec+1;win = (((m)%(10*10))/10);}  goto wait; \n\nfi;\ntok_msg: if\n::  d_step {(((m)%(10*10))/10)<caw;caw = (((m)%(10*10))/10);rec = 0;father = ((m)%10);j = 0;}  goto reinicialize; \n\n::  d_step {(((m)%(10*10))/10)==caw;rec = rec+1;}  goto same; \n\n:: (((m)%(10*10))/10)>caw; goto wait; \n\nfi;\nreinicialize: if\n::  atomic {j==0;ch_2_in!((0)+(caw)*10+(0*10*10));j = j+1;}  goto reinicialize; \n\n::  atomic {j==1;ch_3_in!((0)+(caw)*10+(0*10*10));j = j+1;}  goto reinicialize; \n\n:: j==2; goto wait; \n\nfi;\nsame: if\n:: rec<2; goto wait; \n\n:: rec==2; goto all; \n\nfi;\nall: if\n::  atomic {caw!=0 && father==0;ch_0_in!((0)+(caw)*10+(0*10*10));}  goto wait; \n\n::  atomic {caw!=0 && father==1;ch_1_in!((0)+(caw)*10+(0*10*10));}  goto wait; \n\n::  atomic {caw!=0 && father==2;ch_2_in!((0)+(caw)*10+(0*10*10));}  goto wait; \n\n::  atomic {caw!=0 && father==3;ch_3_in!((0)+(caw)*10+(0*10*10));}  goto wait; \n\n::  d_step {caw==0;j = 0;}  goto become_leader; \n\nfi;\nbecome_leader: if\n::  atomic {j==0;ch_2_in!((0)+(0)*10+(1*10*10));j = j+1;}  goto become_leader; \n\n::  atomic {j==1;ch_3_in!((0)+(0)*10+(1*10*10));j = j+1;}  goto become_leader; \n\n:: j==2; goto wait; \n\nfi;\nleader: \nlost: \n false; }\n\nactive proctype Node_1() { \nbyte caw=1;\nbyte rec=0;\nbyte father=255;\nbyte lrec=0;\nbyte win=255;\nbyte j=0;\nbyte m=0;\n\nstart: if\n::  atomic {j==0;ch_3_in!((1)+(1)*10+(0*10*10));j = j+1;}  goto start; \n\n:: j==1; goto wait; \n\nfi;\nwait: if\n:: ch_1_out?m; goto got_msg; \n\n::  d_step {lrec==1 && win==1;leaders_num = leaders_num+1;}  goto leader; \n\n:: lrec==1 && win!=1; goto lost; \n\nfi;\ngot_msg: if\n:: ((m)/(10*10))==1; goto ldr_msg; \n\n:: ((m)/(10*10))==0; goto tok_msg; \n\nfi;\nldr_msg: if\n::  d_step {lrec==0;j = 0;}  goto ldr_to_all; \n\n:: lrec>0; goto l2; \n\nfi;\nldr_to_all: if\n::  atomic {j==0;ch_3_in!((1)+((((m)%(10*10))/10))*10+(1*10*10));j = j+1;}  goto ldr_to_all; \n\n:: j==1; goto l2; \n\nfi;\nl2: if\n::  d_step {lrec = lrec+1;win = (((m)%(10*10))/10);}  goto wait; \n\nfi;\ntok_msg: if\n::  d_step {(((m)%(10*10))/10)<caw;caw = (((m)%(10*10))/10);rec = 0;father = ((m)%10);j = 0;}  goto reinicialize; \n\n::  d_step {(((m)%(10*10))/10)==caw;rec = rec+1;}  goto same; \n\n:: (((m)%(10*10))/10)>caw; goto wait; \n\nfi;\nreinicialize: if\n::  atomic {j==0;ch_3_in!((1)+(caw)*10+(0*10*10));j = j+1;}  goto reinicialize; \n\n:: j==1; goto wait; \n\nfi;\nsame: if\n:: rec<1; goto wait; \n\n:: rec==1; goto all; \n\nfi;\nall: if\n::  atomic {caw!=1 && father==0;ch_0_in!((1)+(caw)*10+(0*10*10));}  goto wait; \n\n::  atomic {caw!=1 && father==1;ch_1_in!((1)+(caw)*10+(0*10*10));}  goto wait; \n\n::  atomic {caw!=1 && father==2;ch_2_in!((1)+(caw)*10+(0*10*10));}  goto wait; \n\n::  atomic {caw!=1 && father==3;ch_3_in!((1)+(caw)*10+(0*10*10));}  goto wait; \n\n::  d_step {caw==1;j = 0;}  goto become_leader; \n\nfi;\nbecome_leader: if\n::  atomic {j==0;ch_3_in!((1)+(1)*10+(1*10*10));j = j+1;}  goto become_leader; \n\n:: j==1; goto wait; \n\nfi;\nleader: \nlost: \n false; }\n\nactive proctype Node_2() { \nbyte caw=2;\nbyte rec=0;\nbyte father=255;\nbyte lrec=0;\nbyte win=255;\nbyte j=0;\nbyte m=0;\n\nstart: if\n::  atomic {j==0;ch_0_in!((2)+(2)*10+(0*10*10));j = j+1;}  goto start; \n\n:: j==1; goto wait; \n\nfi;\nwait: if\n:: ch_2_out?m; goto got_msg; \n\n::  d_step {lrec==1 && win==2;leaders_num = leaders_num+1;}  goto leader; \n\n:: lrec==1 && win!=2; goto lost; \n\nfi;\ngot_msg: if\n:: ((m)/(10*10))==1; goto ldr_msg; \n\n:: ((m)/(10*10))==0; goto tok_msg; \n\nfi;\nldr_msg: if\n::  d_step {lrec==0;j = 0;}  goto ldr_to_all; \n\n:: lrec>0; goto l2; \n\nfi;\nldr_to_all: if\n::  atomic {j==0;ch_0_in!((2)+((((m)%(10*10))/10))*10+(1*10*10));j = j+1;}  goto ldr_to_all; \n\n:: j==1; goto l2; \n\nfi;\nl2: if\n::  d_step {lrec = lrec+1;win = (((m)%(10*10))/10);}  goto wait; \n\nfi;\ntok_msg: if\n::  d_step {(((m)%(10*10))/10)<caw;caw = (((m)%(10*10))/10);rec = 0;father = ((m)%10);j = 0;}  goto reinicialize; \n\n::  d_step {(((m)%(10*10))/10)==caw;rec = rec+1;}  goto same; \n\n:: (((m)%(10*10))/10)>caw; goto wait; \n\nfi;\nreinicialize: if\n::  atomic {j==0;ch_0_in!((2)+(caw)*10+(0*10*10));j = j+1;}  goto reinicialize; \n\n:: j==1; goto wait; \n\nfi;\nsame: if\n:: rec<1; goto wait; \n\n:: rec==1; goto all; \n\nfi;\nall: if\n::  atomic {caw!=2 && father==0;ch_0_in!((2)+(caw)*10+(0*10*10));}  goto wait; \n\n::  atomic {caw!=2 && father==1;ch_1_in!((2)+(caw)*10+(0*10*10));}  goto wait; \n\n::  atomic {caw!=2 && father==2;ch_2_in!((2)+(caw)*10+(0*10*10));}  goto wait; \n\n::  atomic {caw!=2 && father==3;ch_3_in!((2)+(caw)*10+(0*10*10));}  goto wait; \n\n::  d_step {caw==2;j = 0;}  goto become_leader; \n\nfi;\nbecome_leader: if\n::  atomic {j==0;ch_0_in!((2)+(2)*10+(1*10*10));j = j+1;}  goto become_leader; \n\n:: j==1; goto wait; \n\nfi;\nleader: \nlost: \n false; }\n\nactive proctype Node_3() { \nbyte caw=3;\nbyte rec=0;\nbyte father=255;\nbyte lrec=0;\nbyte win=255;\nbyte j=0;\nbyte m=0;\n\nstart: if\n::  atomic {j==0;ch_0_in!((3)+(3)*10+(0*10*10));j = j+1;}  goto start; \n\n::  atomic {j==1;ch_1_in!((3)+(3)*10+(0*10*10));j = j+1;}  goto start; \n\n:: j==2; goto wait; \n\nfi;\nwait: if\n:: ch_3_out?m; goto got_msg; \n\n::  d_step {lrec==2 && win==3;leaders_num = leaders_num+1;}  goto leader; \n\n:: lrec==2 && win!=3; goto lost; \n\nfi;\ngot_msg: if\n:: ((m)/(10*10))==1; goto ldr_msg; \n\n:: ((m)/(10*10))==0; goto tok_msg; \n\nfi;\nldr_msg: if\n::  d_step {lrec==0;j = 0;}  goto ldr_to_all; \n\n:: lrec>0; goto l2; \n\nfi;\nldr_to_all: if\n::  atomic {j==0;ch_0_in!((3)+((((m)%(10*10))/10))*10+(1*10*10));j = j+1;}  goto ldr_to_all; \n\n::  atomic {j==1;ch_1_in!((3)+((((m)%(10*10))/10))*10+(1*10*10));j = j+1;}  goto ldr_to_all; \n\n:: j==2; goto l2; \n\nfi;\nl2: if\n::  d_step {lrec = lrec+1;win = (((m)%(10*10))/10);}  goto wait; \n\nfi;\ntok_msg: if\n::  d_step {(((m)%(10*10))/10)<caw;caw = (((m)%(10*10))/10);rec = 0;father = ((m)%10);j = 0;}  goto reinicialize; \n\n::  d_step {(((m)%(10*10))/10)==caw;rec = rec+1;}  goto same; \n\n:: (((m)%(10*10))/10)>caw; goto wait; \n\nfi;\nreinicialize: if\n::  atomic {j==0;ch_0_in!((3)+(caw)*10+(0*10*10));j = j+1;}  goto reinicialize; \n\n::  atomic {j==1;ch_1_in!((3)+(caw)*10+(0*10*10));j = j+1;}  goto reinicialize; \n\n:: j==2; goto wait; \n\nfi;\nsame: if\n:: rec<2; goto wait; \n\n:: rec==2; goto all; \n\nfi;\nall: if\n::  atomic {caw!=3 && father==0;ch_0_in!((3)+(caw)*10+(0*10*10));}  goto wait; \n\n::  atomic {caw!=3 && father==1;ch_1_in!((3)+(caw)*10+(0*10*10));}  goto wait; \n\n::  atomic {caw!=3 && father==2;ch_2_in!((3)+(caw)*10+(0*10*10));}  goto wait; \n\n::  atomic {caw!=3 && father==3;ch_3_in!((3)+(caw)*10+(0*10*10));}  goto wait; \n\n::  d_step {caw==3;j = 0;}  goto become_leader; \n\nfi;\nbecome_leader: if\n::  atomic {j==0;ch_0_in!((3)+(3)*10+(1*10*10));j = j+1;}  goto become_leader; \n\n::  atomic {j==1;ch_1_in!((3)+(3)*10+(1*10*10));j = j+1;}  goto become_leader; \n\n:: j==2; goto wait; \n\nfi;\nleader: \nlost: \n false; }\n\nactive proctype chnlnel_ch_0() { \nbyte buf[2];\nbyte buf_act=0;\n\nq: if\n::  atomic { ! (buf_act==2);ch_0_in?buf[buf_act];buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==0);ch_0_out!buf[0];buf[0] = buf[1];buf[1] = 0;buf_act = buf_act-1;}  goto q; \n\nfi;\n}\n\nactive proctype chnlnel_ch_1() { \nbyte buf[2];\nbyte buf_act=0;\n\nq: if\n::  atomic { ! (buf_act==2);ch_1_in?buf[buf_act];buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==0);ch_1_out!buf[0];buf[0] = buf[1];buf[1] = 0;buf_act = buf_act-1;}  goto q; \n\nfi;\n}\n\nactive proctype chnlnel_ch_2() { \nbyte buf[2];\nbyte buf_act=0;\n\nq: if\n::  atomic { ! (buf_act==2);ch_2_in?buf[buf_act];buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==0);ch_2_out!buf[0];buf[0] = buf[1];buf[1] = 0;buf_act = buf_act-1;}  goto q; \n\nfi;\n}\n\nactive proctype chnlnel_ch_3() { \nbyte buf[2];\nbyte buf_act=0;\n\nq: if\n::  atomic { ! (buf_act==2);ch_3_in?buf[buf_act];buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==0);ch_3_out!buf[0];buf[0] = buf[1];buf[1] = 0;buf_act = buf_act-1;}  goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Leader election algorithm for arbitrary networks based on\n    echo wave algorithm and extinction technique. The model uses a fixed\n    topology.\n\nParameters:\n\n\n\nAtomic propositions:\n, \n\nProperties to verify:"}, {"role": "assistant", "content": "byte leaders_num=0;\n\nchan ch_0_in =[0] of {int};\nchan ch_0_out =[0] of {int};\nchan ch_1_in =[0] of {int};\nchan ch_1_out =[0] of {int};\nchan ch_2_in =[0] of {int};\nchan ch_2_out =[0] of {int};\nchan ch_3_in =[0] of {int};\nchan ch_3_out =[0] of {int};\n\nactive proctype Node_0() { \nbyte caw=0;\nbyte rec=0;\nbyte father=255;\nbyte lrec=0;\nbyte win=255;\nbyte j=0;\nbyte m=0;\n\nstart: if\n::  atomic {j==0;ch_1_in!((0)+(0)*10+(0*10*10));j = j+1;}  goto start; \n\n::  atomic {j==1;ch_2_in!((0)+(0)*10+(0*10*10));j = j+1;}  goto start; \n\n:: j==2; goto wait; \n\nfi;\nwait: if\n:: ch_0_out?m; goto got_msg; \n\n::  d_step {lrec==2 && win==0;leaders_num = leaders_num+1;}  goto leader; \n\n:: lrec==2 && win!=0; goto lost; \n\nfi;\ngot_msg: if\n:: ((m)/(10*10))==1; goto ldr_msg; \n\n:: ((m)/(10*10))==0; goto tok_msg; \n\nfi;\nldr_msg: if\n::  d_step {lrec==0;j = 0;}  goto ldr_to_all; \n\n:: lrec>0; goto l2; \n\nfi;\nldr_to_all: if\n::  atomic {j==0;ch_1_in!((0)+((((m)%(10*10))/10))*10+(1*10*10));j = j+1;}  goto ldr_to_all; \n\n::  atomic {j==1;ch_2_in!((0)+((((m)%(10*10))/10))*10+(1*10*10));j = j+1;}  goto ldr_to_all; \n\n:: j==2; goto l2; \n\nfi;\nl2: if\n::  d_step {lrec = lrec+1;win = (((m)%(10*10))/10);}  goto wait; \n\nfi;\ntok_msg: if\n::  d_step {(((m)%(10*10))/10)<caw;caw = (((m)%(10*10))/10);rec = 0;father = ((m)%10);j = 0;}  goto reinicialize; \n\n::  d_step {(((m)%(10*10))/10)==caw;rec = rec+1;}  goto same; \n\n:: (((m)%(10*10))/10)>caw; goto wait; \n\nfi;\nreinicialize: if\n::  atomic {j==0;ch_1_in!((0)+(caw)*10+(0*10*10));j = j+1;}  goto reinicialize; \n\n::  atomic {j==1;ch_2_in!((0)+(caw)*10+(0*10*10));j = j+1;}  goto reinicialize; \n\n:: j==2; goto wait; \n\nfi;\nsame: if\n:: rec<2; goto wait; \n\n:: rec==2; goto all; \n\nfi;\nall: if\n::  atomic {caw!=0 && father==0;ch_0_in!((0)+(caw)*10+(0*10*10));}  goto wait; \n\n::  atomic {caw!=0 && father==1;ch_1_in!((0)+(caw)*10+(0*10*10));}  goto wait; \n\n::  atomic {caw!=0 && father==2;ch_2_in!((0)+(caw)*10+(0*10*10));}  goto wait; \n\n::  atomic {caw!=0 && father==3;ch_3_in!((0)+(caw)*10+(0*10*10));}  goto wait; \n\n::  d_step {caw==0;j = 0;}  goto become_leader; \n\nfi;\nbecome_leader: if\n::  atomic {j==0;ch_1_in!((0)+(0)*10+(1*10*10));j = j+1;}  goto become_leader; \n\n::  atomic {j==1;ch_2_in!((0)+(0)*10+(1*10*10));j = j+1;}  goto become_leader; \n\n:: j==2; goto wait; \n\nfi;\nleader: \nlost: \n false; }\n\nactive proctype Node_1() { \nbyte caw=1;\nbyte rec=0;\nbyte father=255;\nbyte lrec=0;\nbyte win=255;\nbyte j=0;\nbyte m=0;\n\nstart: if\n::  atomic {j==0;ch_0_in!((1)+(1)*10+(0*10*10));j = j+1;}  goto start; \n\n::  atomic {j==1;ch_2_in!((1)+(1)*10+(0*10*10));j = j+1;}  goto start; \n\n:: j==2; goto wait; \n\nfi;\nwait: if\n:: ch_1_out?m; goto got_msg; \n\n::  d_step {lrec==2 && win==1;leaders_num = leaders_num+1;}  goto leader; \n\n:: lrec==2 && win!=1; goto lost; \n\nfi;\ngot_msg: if\n:: ((m)/(10*10))==1; goto ldr_msg; \n\n:: ((m)/(10*10))==0; goto tok_msg; \n\nfi;\nldr_msg: if\n::  d_step {lrec==0;j = 0;}  goto ldr_to_all; \n\n:: lrec>0; goto l2; \n\nfi;\nldr_to_all: if\n::  atomic {j==0;ch_0_in!((1)+((((m)%(10*10))/10))*10+(1*10*10));j = j+1;}  goto ldr_to_all; \n\n::  atomic {j==1;ch_2_in!((1)+((((m)%(10*10))/10))*10+(1*10*10));j = j+1;}  goto ldr_to_all; \n\n:: j==2; goto l2; \n\nfi;\nl2: if\n::  d_step {lrec = lrec+1;win = (((m)%(10*10))/10);}  goto wait; \n\nfi;\ntok_msg: if\n::  d_step {(((m)%(10*10))/10)<caw;caw = (((m)%(10*10))/10);rec = 0;father = ((m)%10);j = 0;}  goto reinicialize; \n\n::  d_step {(((m)%(10*10))/10)==caw;rec = rec+1;}  goto same; \n\n:: (((m)%(10*10))/10)>caw; goto wait; \n\nfi;\nreinicialize: if\n::  atomic {j==0;ch_0_in!((1)+(caw)*10+(0*10*10));j = j+1;}  goto reinicialize; \n\n::  atomic {j==1;ch_2_in!((1)+(caw)*10+(0*10*10));j = j+1;}  goto reinicialize; \n\n:: j==2; goto wait; \n\nfi;\nsame: if\n:: rec<2; goto wait; \n\n:: rec==2; goto all; \n\nfi;\nall: if\n::  atomic {caw!=1 && father==0;ch_0_in!((1)+(caw)*10+(0*10*10));}  goto wait; \n\n::  atomic {caw!=1 && father==1;ch_1_in!((1)+(caw)*10+(0*10*10));}  goto wait; \n\n::  atomic {caw!=1 && father==2;ch_2_in!((1)+(caw)*10+(0*10*10));}  goto wait; \n\n::  atomic {caw!=1 && father==3;ch_3_in!((1)+(caw)*10+(0*10*10));}  goto wait; \n\n::  d_step {caw==1;j = 0;}  goto become_leader; \n\nfi;\nbecome_leader: if\n::  atomic {j==0;ch_0_in!((1)+(1)*10+(1*10*10));j = j+1;}  goto become_leader; \n\n::  atomic {j==1;ch_2_in!((1)+(1)*10+(1*10*10));j = j+1;}  goto become_leader; \n\n:: j==2; goto wait; \n\nfi;\nleader: \nlost: \n false; }\n\nactive proctype Node_2() { \nbyte caw=2;\nbyte rec=0;\nbyte father=255;\nbyte lrec=0;\nbyte win=255;\nbyte j=0;\nbyte m=0;\n\nstart: if\n::  atomic {j==0;ch_1_in!((2)+(2)*10+(0*10*10));j = j+1;}  goto start; \n\n::  atomic {j==1;ch_0_in!((2)+(2)*10+(0*10*10));j = j+1;}  goto start; \n\n::  atomic {j==2;ch_3_in!((2)+(2)*10+(0*10*10));j = j+1;}  goto start; \n\n:: j==3; goto wait; \n\nfi;\nwait: if\n:: ch_2_out?m; goto got_msg; \n\n::  d_step {lrec==3 && win==2;leaders_num = leaders_num+1;}  goto leader; \n\n:: lrec==3 && win!=2; goto lost; \n\nfi;\ngot_msg: if\n:: ((m)/(10*10))==1; goto ldr_msg; \n\n:: ((m)/(10*10))==0; goto tok_msg; \n\nfi;\nldr_msg: if\n::  d_step {lrec==0;j = 0;}  goto ldr_to_all; \n\n:: lrec>0; goto l2; \n\nfi;\nldr_to_all: if\n::  atomic {j==0;ch_1_in!((2)+((((m)%(10*10))/10))*10+(1*10*10));j = j+1;}  goto ldr_to_all; \n\n::  atomic {j==1;ch_0_in!((2)+((((m)%(10*10))/10))*10+(1*10*10));j = j+1;}  goto ldr_to_all; \n\n::  atomic {j==2;ch_3_in!((2)+((((m)%(10*10))/10))*10+(1*10*10));j = j+1;}  goto ldr_to_all; \n\n:: j==3; goto l2; \n\nfi;\nl2: if\n::  d_step {lrec = lrec+1;win = (((m)%(10*10))/10);}  goto wait; \n\nfi;\ntok_msg: if\n::  d_step {(((m)%(10*10))/10)<caw;caw = (((m)%(10*10))/10);rec = 0;father = ((m)%10);j = 0;}  goto reinicialize; \n\n::  d_step {(((m)%(10*10))/10)==caw;rec = rec+1;}  goto same; \n\n:: (((m)%(10*10))/10)>caw; goto wait; \n\nfi;\nreinicialize: if\n::  atomic {j==0;ch_1_in!((2)+(caw)*10+(0*10*10));j = j+1;}  goto reinicialize; \n\n::  atomic {j==1;ch_0_in!((2)+(caw)*10+(0*10*10));j = j+1;}  goto reinicialize; \n\n::  atomic {j==2;ch_3_in!((2)+(caw)*10+(0*10*10));j = j+1;}  goto reinicialize; \n\n:: j==3; goto wait; \n\nfi;\nsame: if\n:: rec<3; goto wait; \n\n:: rec==3; goto all; \n\nfi;\nall: if\n::  atomic {caw!=2 && father==0;ch_0_in!((2)+(caw)*10+(0*10*10));}  goto wait; \n\n::  atomic {caw!=2 && father==1;ch_1_in!((2)+(caw)*10+(0*10*10));}  goto wait; \n\n::  atomic {caw!=2 && father==2;ch_2_in!((2)+(caw)*10+(0*10*10));}  goto wait; \n\n::  atomic {caw!=2 && father==3;ch_3_in!((2)+(caw)*10+(0*10*10));}  goto wait; \n\n::  d_step {caw==2;j = 0;}  goto become_leader; \n\nfi;\nbecome_leader: if\n::  atomic {j==0;ch_1_in!((2)+(2)*10+(1*10*10));j = j+1;}  goto become_leader; \n\n::  atomic {j==1;ch_0_in!((2)+(2)*10+(1*10*10));j = j+1;}  goto become_leader; \n\n::  atomic {j==2;ch_3_in!((2)+(2)*10+(1*10*10));j = j+1;}  goto become_leader; \n\n:: j==3; goto wait; \n\nfi;\nleader: \nlost: \n false; }\n\nactive proctype Node_3() { \nbyte caw=3;\nbyte rec=0;\nbyte father=255;\nbyte lrec=0;\nbyte win=255;\nbyte j=0;\nbyte m=0;\n\nstart: if\n::  atomic {j==0;ch_2_in!((3)+(3)*10+(0*10*10));j = j+1;}  goto start; \n\n:: j==1; goto wait; \n\nfi;\nwait: if\n:: ch_3_out?m; goto got_msg; \n\n::  d_step {lrec==1 && win==3;leaders_num = leaders_num+1;}  goto leader; \n\n:: lrec==1 && win!=3; goto lost; \n\nfi;\ngot_msg: if\n:: ((m)/(10*10))==1; goto ldr_msg; \n\n:: ((m)/(10*10))==0; goto tok_msg; \n\nfi;\nldr_msg: if\n::  d_step {lrec==0;j = 0;}  goto ldr_to_all; \n\n:: lrec>0; goto l2; \n\nfi;\nldr_to_all: if\n::  atomic {j==0;ch_2_in!((3)+((((m)%(10*10))/10))*10+(1*10*10));j = j+1;}  goto ldr_to_all; \n\n:: j==1; goto l2; \n\nfi;\nl2: if\n::  d_step {lrec = lrec+1;win = (((m)%(10*10))/10);}  goto wait; \n\nfi;\ntok_msg: if\n::  d_step {(((m)%(10*10))/10)<caw;caw = (((m)%(10*10))/10);rec = 0;father = ((m)%10);j = 0;}  goto reinicialize; \n\n::  d_step {(((m)%(10*10))/10)==caw;rec = rec+1;}  goto same; \n\n:: (((m)%(10*10))/10)>caw; goto wait; \n\nfi;\nreinicialize: if\n::  atomic {j==0;ch_2_in!((3)+(caw)*10+(0*10*10));j = j+1;}  goto reinicialize; \n\n:: j==1; goto wait; \n\nfi;\nsame: if\n:: rec<1; goto wait; \n\n:: rec==1; goto all; \n\nfi;\nall: if\n::  atomic {caw!=3 && father==0;ch_0_in!((3)+(caw)*10+(0*10*10));}  goto wait; \n\n::  atomic {caw!=3 && father==1;ch_1_in!((3)+(caw)*10+(0*10*10));}  goto wait; \n\n::  atomic {caw!=3 && father==2;ch_2_in!((3)+(caw)*10+(0*10*10));}  goto wait; \n\n::  atomic {caw!=3 && father==3;ch_3_in!((3)+(caw)*10+(0*10*10));}  goto wait; \n\n::  d_step {caw==3;j = 0;}  goto become_leader; \n\nfi;\nbecome_leader: if\n::  atomic {j==0;ch_2_in!((3)+(3)*10+(1*10*10));j = j+1;}  goto become_leader; \n\n:: j==1; goto wait; \n\nfi;\nleader: \nlost: \n false; }\n\nactive proctype chnlnel_ch_0() { \nbyte buf[2];\nbyte buf_act=0;\n\nq: if\n::  atomic { ! (buf_act==2);ch_0_in?buf[buf_act];buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==0);ch_0_out!buf[0];buf[0] = buf[1];buf[1] = 0;buf_act = buf_act-1;}  goto q; \n\nfi;\n}\n\nactive proctype chnlnel_ch_1() { \nbyte buf[2];\nbyte buf_act=0;\n\nq: if\n::  atomic { ! (buf_act==2);ch_1_in?buf[buf_act];buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==0);ch_1_out!buf[0];buf[0] = buf[1];buf[1] = 0;buf_act = buf_act-1;}  goto q; \n\nfi;\n}\n\nactive proctype chnlnel_ch_2() { \nbyte buf[2];\nbyte buf_act=0;\n\nq: if\n::  atomic { ! (buf_act==2);ch_2_in?buf[buf_act];buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==0);ch_2_out!buf[0];buf[0] = buf[1];buf[1] = 0;buf_act = buf_act-1;}  goto q; \n\nfi;\n}\n\nactive proctype chnlnel_ch_3() { \nbyte buf[2];\nbyte buf_act=0;\n\nq: if\n::  atomic { ! (buf_act==2);ch_3_in?buf[buf_act];buf_act = buf_act+1;}  goto q; \n\n::  atomic { ! (buf_act==0);ch_3_out!buf[0];buf[0] = buf[1];buf[1] = 0;buf_act = buf_act-1;}  goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "This is model of the \"FireWire\" high performance serial\n    bus defined in the IEEE-1394 Standard. The bus involves n nodes\n    (addressable entities that run their own part of the protocol) connected by\n    a serial line. On each node the IEEE-1394 protocol consists of three stacke\n    layers: the transaction layer, the link layer, and th physical layer. The\n    protocol implemented by the link layer is designed to transmit data packets\n    over an unreliable medium to a specific node or to all nodes (broadcast).\n    The transmission can be performed synchronously or\n    asynchronously.\n\nParameters:"}, {"role": "assistant", "content": "chan LDreq_0 =[0] of {int};\nchan LDres_0 =[0] of {int};\nchan LDcon_0 =[0] of {int};\nchan LDind_0 =[0] of {int};\nchan TX_0 =[0] of {int};\nchan PDreq_0 =[0] of {int};\nchan PDind_0 =[0] of {int};\nchan PAreq_0 =[0] of {int};\nchan PAcon_0 =[0] of {int};\nchan PCind_0 =[0] of {int};\nchan TDreq_0 =[0] of {int};\nchan LDreq_1 =[0] of {int};\nchan LDres_1 =[0] of {int};\nchan LDcon_1 =[0] of {int};\nchan LDind_1 =[0] of {int};\nchan TX_1 =[0] of {int};\nchan PDreq_1 =[0] of {int};\nchan PDind_1 =[0] of {int};\nchan PAreq_1 =[0] of {int};\nchan PAcon_1 =[0] of {int};\nchan PCind_1 =[0] of {int};\nchan TDreq_1 =[0] of {int};\n\nactive proctype Transreq_0() { \nbyte m=0;\n\nidle: if\n:: LDind_0?m; goto got_msg; \n\nfi;\ngot_msg: if\n::  atomic {m==101;LDres_0!100;}  goto idle; \n\n:: TX_0?0; goto concatenated_tr; \n\n::  goto split_tr; \n\nfi;\nconcatenated_tr: if\n:: LDres_0!102; goto idle; \n\nfi;\nsplit_tr: if\n:: LDres_0!107; goto idle; \n\nfi;\n}\n\nactive proctype Transres_0() { \nbyte dest=0;\nbyte m=0;\n\nidle: if\n:: TDreq_0?dest; goto got_req; \n\nfi;\ngot_req: if\n:: TX_0!0; goto q; \n\n::  goto q; \n\nfi;\nq: if\n:: LDreq_0!dest; goto wait_ack; \n\nfi;\nwait_ack: if\n:: LDcon_0?m; goto wait_q; \n\nfi;\nwait_q: if\n:: m==124 && dest==2; goto idle; \n\n:: m==105 && dest<2; goto idle; \n\n:: m==106 && dest<2; goto idle; \n\nfi;\n}\n\nactive proctype Link_0() { \nint buf=-1;\nbyte dest=0;\nbyte m=0;\nbyte m2=0;\nbyte data=0;\n\nlink0: if\n:: LDreq_0?buf; goto link0r; \n\n:: PAcon_0?m; goto link0a; \n\n:: PDind_0?m; goto link0i; \n\nfi;\nlink0r: if\n:: PAreq_0!108; goto link0; \n\nfi;\nlink0a: if\n:: m==111; goto link0; \n\n::  d_step {m==110;dest = buf;}  goto link2req; \n\nfi;\nlink0i: if\n:: m!=119; goto link0; \n\n:: m==119; goto link4; \n\nfi;\nlink2req: if\n:: PCind_0?0; goto q1; \n\nfi;\nq1: if\n:: PDreq_0!119; goto s1; \n\nfi;\ns1: if\n:: PCind_0?0; goto q2; \n\nfi;\nq2: if\n:: PDreq_0!118; goto s2; \n\nfi;\ns2: if\n:: PCind_0?0; goto q3; \n\nfi;\nq3: if\n:: PDreq_0!dest; goto s3; \n\nfi;\ns3: if\n:: PCind_0?0; goto q4; \n\nfi;\nq4: if\n:: PDreq_0!114; goto s4; \n\nfi;\ns4: if\n:: PCind_0?0; goto q5; \n\nfi;\nq5: if\n:: PDreq_0!116; goto s5; \n\nfi;\ns5: if\n:: PCind_0?0; goto q6; \n\nfi;\nq6: if\n:: PDreq_0!120; goto s6; \n\nfi;\ns6: if\n::  atomic {dest==2;LDcon_0!124;buf = -1;}  goto link0; \n\n:: dest<2; goto link3; \n\nfi;\nlink3: if\n:: PDind_0?m; goto link3q; \n\nfi;\nlink3q: if\n:: m==121; goto link3; \n\n::  atomic {m==122;LDcon_0!106;}  goto link0; \n\n:: m==119; goto link3A; \n\n::  atomic {m!=122 && m!=121 && m!=119;LDcon_0!106;dest = 2;}  goto linkWSA; \n\nfi;\nlink3A: if\n:: PDind_0?m; goto link3Aq; \n\nfi;\nlink3Aq: if\n::  atomic {m==119 || m==120 || m==122;LDcon_0!106;dest = 2;}  goto linkWSA; \n\n::  ! (m==119 || m==120 || m==122); goto link3RE; \n\nfi;\nlink3RE: if\n:: PDind_0?m2; goto link3REq1; \n\nfi;\nlink3REq1: if\n::  atomic {m==112 && (m2==121 || m2==120);LDcon_0!105;}  goto link3REq2; \n\n::  atomic { ! (m==112 && (m2==121 || m2==120));LDcon_0!106;}  goto link3REq2; \n\nfi;\nlink3REq2: if\n:: m2==122; goto link0; \n\n::  d_step {m2!=122;dest = 2;}  goto linkWSA; \n\nfi;\nlinkWSA: if\n:: PDind_0?m; goto linkWSAq; \n\n::  atomic {dest==0;PAcon_0?m;}  goto linkWSAa1; \n\nfi;\nlinkWSAq: if\n:: m!=122; goto linkWSA; \n\n:: m==122; goto link0; \n\nfi;\nlinkWSAa1: if\n::  atomic {m==110;PCind_0?0;}  goto linkWSAa2; \n\nfi;\nlinkWSAa2: if\n:: PDreq_0!120; goto link0; \n\nfi;\nlink4: if\n:: PDind_0?m; goto link4q; \n\nfi;\nlink4q: if\n:: m==122; goto link0; \n\n::  d_step {m==119 || m==120 || m==122;dest = 2;}  goto linkWSA; \n\n:: m!=122 &&  ! (m==119 || m==120 || m==122); goto link4DH; \n\nfi;\nlink4DH: if\n:: PDind_0?dest; goto link4DHq; \n\nfi;\nlink4DHq: if\n:: dest==122; goto link0; \n\n::  atomic {dest==0;PAreq_0!109;}  goto link4RH; \n\n:: dest==2; goto link4RH; \n\n::  d_step {dest!=122 && dest!=0 && dest!=2;dest = 2;}  goto linkWSA; \n\nfi;\nlink4RH: if\n:: PDind_0?m; goto link4RHq; \n\nfi;\nlink4RHq: if\n:: m==114; goto link4RD; \n\n:: m!=114; goto linkWSA; \n\nfi;\nlink4RD: if\n:: PDind_0?data; goto link4RDq; \n\nfi;\nlink4RDq: if\n:: data==116 || data==117; goto link4RE; \n\n::  ! (data==116 || data==117); goto linkWSA; \n\nfi;\nlink4RE: if\n:: PDind_0?m; goto link4REq; \n\nfi;\nlink4REq: if\n:: (m==120 || m==121) && dest==0; goto link4DRec; \n\n:: (m==120 || m==121) && dest==2; goto link4BRec; \n\n::  ! (m==120 || m==121); goto linkWSA; \n\nfi;\nlink4DRec: if\n::  atomic {data==116;LDind_0!103;}  goto link4DRecq; \n\n::  atomic {data==117;LDind_0!104;}  goto link4DRecq; \n\nfi;\nlink4BRec: if\n::  atomic {data==116;LDind_0!101;}  goto link0; \n\n:: data!=116; goto link0; \n\nfi;\nlink4DRecq: if\n:: PAcon_0?m; goto link4DRecq2; \n\nfi;\nlink4DRecq2: if\n:: m==110; goto link5; \n\nfi;\nlink5: if\n:: PCind_0?0; goto p1; \n\n:: LDres_0?m; goto link6; \n\nfi;\np1: if\n:: PDreq_0!121; goto link5; \n\nfi;\np2: if\n:: PDreq_0!119; goto p3; \n\nfi;\nlink6: if\n:: PCind_0?0; goto p2; \n\nfi;\np3: if\n:: PCind_0?0; goto p4; \n\nfi;\np4: if\n:: PDreq_0!112; goto p5; \n\nfi;\np5: if\n::  atomic {m==107;PDreq_0!120;}  goto link0; \n\n::  atomic {m!=107;PDreq_0!121;}  goto link7; \n\nfi;\np6: if\n:: PDreq_0!121; goto link7; \n\nfi;\nlink7: if\n:: PCind_0?0; goto p6; \n\n:: LDreq_0?dest; goto link2req; \n\nfi;\n}\n\nactive proctype Transreq_1() { \nbyte m=0;\n\nidle: if\n:: LDind_1?m; goto got_msg; \n\nfi;\ngot_msg: if\n::  atomic {m==101;LDres_1!100;}  goto idle; \n\n:: TX_1?0; goto concatenated_tr; \n\n::  goto split_tr; \n\nfi;\nconcatenated_tr: if\n:: LDres_1!102; goto idle; \n\nfi;\nsplit_tr: if\n:: LDres_1!107; goto idle; \n\nfi;\n}\n\nactive proctype Transres_1() { \nbyte dest=0;\nbyte m=0;\n\nidle: if\n:: TDreq_1?dest; goto got_req; \n\nfi;\ngot_req: if\n:: TX_1!0; goto q; \n\n::  goto q; \n\nfi;\nq: if\n:: LDreq_1!dest; goto wait_ack; \n\nfi;\nwait_ack: if\n:: LDcon_1?m; goto wait_q; \n\nfi;\nwait_q: if\n:: m==124 && dest==2; goto idle; \n\n:: m==105 && dest<2; goto idle; \n\n:: m==106 && dest<2; goto idle; \n\nfi;\n}\n\nactive proctype Link_1() { \nint buf=-1;\nbyte dest=0;\nbyte m=0;\nbyte m2=0;\nbyte data=0;\n\nlink0: if\n:: LDreq_1?buf; goto link0r; \n\n:: PAcon_1?m; goto link0a; \n\n:: PDind_1?m; goto link0i; \n\nfi;\nlink0r: if\n:: PAreq_1!108; goto link0; \n\nfi;\nlink0a: if\n:: m==111; goto link0; \n\n::  d_step {m==110;dest = buf;}  goto link2req; \n\nfi;\nlink0i: if\n:: m!=119; goto link0; \n\n:: m==119; goto link4; \n\nfi;\nlink2req: if\n:: PCind_1?0; goto q1; \n\nfi;\nq1: if\n:: PDreq_1!119; goto s1; \n\nfi;\ns1: if\n:: PCind_1?0; goto q2; \n\nfi;\nq2: if\n:: PDreq_1!118; goto s2; \n\nfi;\ns2: if\n:: PCind_1?0; goto q3; \n\nfi;\nq3: if\n:: PDreq_1!dest; goto s3; \n\nfi;\ns3: if\n:: PCind_1?0; goto q4; \n\nfi;\nq4: if\n:: PDreq_1!114; goto s4; \n\nfi;\ns4: if\n:: PCind_1?0; goto q5; \n\nfi;\nq5: if\n:: PDreq_1!116; goto s5; \n\nfi;\ns5: if\n:: PCind_1?0; goto q6; \n\nfi;\nq6: if\n:: PDreq_1!120; goto s6; \n\nfi;\ns6: if\n::  atomic {dest==2;LDcon_1!124;buf = -1;}  goto link0; \n\n:: dest<2; goto link3; \n\nfi;\nlink3: if\n:: PDind_1?m; goto link3q; \n\nfi;\nlink3q: if\n:: m==121; goto link3; \n\n::  atomic {m==122;LDcon_1!106;}  goto link0; \n\n:: m==119; goto link3A; \n\n::  atomic {m!=122 && m!=121 && m!=119;LDcon_1!106;dest = 2;}  goto linkWSA; \n\nfi;\nlink3A: if\n:: PDind_1?m; goto link3Aq; \n\nfi;\nlink3Aq: if\n::  atomic {m==119 || m==120 || m==122;LDcon_1!106;dest = 2;}  goto linkWSA; \n\n::  ! (m==119 || m==120 || m==122); goto link3RE; \n\nfi;\nlink3RE: if\n:: PDind_1?m2; goto link3REq1; \n\nfi;\nlink3REq1: if\n::  atomic {m==112 && (m2==121 || m2==120);LDcon_1!105;}  goto link3REq2; \n\n::  atomic { ! (m==112 && (m2==121 || m2==120));LDcon_1!106;}  goto link3REq2; \n\nfi;\nlink3REq2: if\n:: m2==122; goto link0; \n\n::  d_step {m2!=122;dest = 2;}  goto linkWSA; \n\nfi;\nlinkWSA: if\n:: PDind_1?m; goto linkWSAq; \n\n::  atomic {dest==1;PAcon_1?m;}  goto linkWSAa1; \n\nfi;\nlinkWSAq: if\n:: m!=122; goto linkWSA; \n\n:: m==122; goto link0; \n\nfi;\nlinkWSAa1: if\n::  atomic {m==110;PCind_1?0;}  goto linkWSAa2; \n\nfi;\nlinkWSAa2: if\n:: PDreq_1!120; goto link0; \n\nfi;\nlink4: if\n:: PDind_1?m; goto link4q; \n\nfi;\nlink4q: if\n:: m==122; goto link0; \n\n::  d_step {m==119 || m==120 || m==122;dest = 2;}  goto linkWSA; \n\n:: m!=122 &&  ! (m==119 || m==120 || m==122); goto link4DH; \n\nfi;\nlink4DH: if\n:: PDind_1?dest; goto link4DHq; \n\nfi;\nlink4DHq: if\n:: dest==122; goto link0; \n\n::  atomic {dest==1;PAreq_1!109;}  goto link4RH; \n\n:: dest==2; goto link4RH; \n\n::  d_step {dest!=122 && dest!=1 && dest!=2;dest = 2;}  goto linkWSA; \n\nfi;\nlink4RH: if\n:: PDind_1?m; goto link4RHq; \n\nfi;\nlink4RHq: if\n:: m==114; goto link4RD; \n\n:: m!=114; goto linkWSA; \n\nfi;\nlink4RD: if\n:: PDind_1?data; goto link4RDq; \n\nfi;\nlink4RDq: if\n:: data==116 || data==117; goto link4RE; \n\n::  ! (data==116 || data==117); goto linkWSA; \n\nfi;\nlink4RE: if\n:: PDind_1?m; goto link4REq; \n\nfi;\nlink4REq: if\n:: (m==120 || m==121) && dest==1; goto link4DRec; \n\n:: (m==120 || m==121) && dest==2; goto link4BRec; \n\n::  ! (m==120 || m==121); goto linkWSA; \n\nfi;\nlink4DRec: if\n::  atomic {data==116;LDind_1!103;}  goto link4DRecq; \n\n::  atomic {data==117;LDind_1!104;}  goto link4DRecq; \n\nfi;\nlink4BRec: if\n::  atomic {data==116;LDind_1!101;}  goto link0; \n\n:: data!=116; goto link0; \n\nfi;\nlink4DRecq: if\n:: PAcon_1?m; goto link4DRecq2; \n\nfi;\nlink4DRecq2: if\n:: m==110; goto link5; \n\nfi;\nlink5: if\n:: PCind_1?0; goto p1; \n\n:: LDres_1?m; goto link6; \n\nfi;\np1: if\n:: PDreq_1!121; goto link5; \n\nfi;\np2: if\n:: PDreq_1!119; goto p3; \n\nfi;\nlink6: if\n:: PCind_1?0; goto p2; \n\nfi;\np3: if\n:: PCind_1?0; goto p4; \n\nfi;\np4: if\n:: PDreq_1!112; goto p5; \n\nfi;\np5: if\n::  atomic {m==107;PDreq_1!120;}  goto link0; \n\n::  atomic {m!=107;PDreq_1!121;}  goto link7; \n\nfi;\np6: if\n:: PDreq_1!121; goto link7; \n\nfi;\nlink7: if\n:: PCind_1?0; goto p6; \n\n:: LDreq_1?dest; goto link2req; \n\nfi;\n}\n\nactive proctype Bus() { \nbyte t[2];\nbyte destfault[2];\nbyte next[2];\nbyte i=0;\nbyte j=0;\nbyte m=0;\nbyte busy=0;\n\nidle: if\n::  ! (t[0]==0 && t[1]==0); goto arbresgab; \n\n::  atomic {PAreq_0?m;i = 0;}  goto idleq; \n\n::  atomic {PAreq_1?m;i = 1;}  goto idleq; \n\nfi;\narbresgab: if\n::  d_step {t[0] = 0;t[1] = 0;}  goto idle; \n\nfi;\nidleq: if\n::  atomic {i==0 && t[i]==1;PAcon_0!111;}  goto idle; \n\n::  atomic {i==1 && t[i]==1;PAcon_1!111;}  goto idle; \n\n::  atomic {i==0 && t[i]==0;PAcon_0!110;t[i] = 1;busy = i;}  goto bus_busy; \n\n::  atomic {i==1 && t[i]==0;PAcon_1!110;t[i] = 1;busy = i;}  goto bus_busy; \n\nfi;\nbus_busy: if\n::  atomic {PAreq_0?m;i = 0;}  goto busyq; \n\n::  atomic {PAreq_1?m;i = 1;}  goto busyq; \n\n::  atomic {busy==0;PCind_0!0;}  goto get_next_packet; \n\n::  atomic {busy==1;PCind_1!0;}  goto get_next_packet; \n\n::  d_step {busy==2 && next[0]==0 && next[1]==0;j = 0;}  goto sub_action_gab; \n\n::  d_step {busy==2 &&  ! (next[0]==0 && next[1]==0);j = 0;}  goto resolve; \n\nfi;\nbusyq: if\n::  atomic {m==108 && i==0;PAcon_0!111;}  goto bus_busy; \n\n::  atomic {m==108 && i==1;PAcon_1!111;}  goto bus_busy; \n\n::  d_step {m==109;next[i] = 1;}  goto bus_busy; \n\nfi;\nsub_action_gab: if\n::  atomic {0==j;PDind_0!122;j = j+1;}  goto sub_action_gab; \n\n::  atomic {1==j;PDind_1!122;j = j+1;}  goto sub_action_gab; \n\n:: j==2; goto idle; \n\nfi;\nget_next_packet: if\n::  atomic {busy==0;PDreq_0?m;j = 0;}  goto distribute; \n\n::  atomic {busy==1;PDreq_1?m;j = 0;}  goto distribute; \n\nfi;\nresolve: if\n::  d_step {j<2 && next[j]==0;j = j+1;}  goto resolve; \n\n::  atomic {0==j && next[j]==1;PAcon_0!110;}  goto resolveq; \n\n::  atomic {1==j && next[j]==1;PAcon_1!110;}  goto resolveq; \n\n:: j==2; goto resolve2; \n\nfi;\nresolveq: if\n::  atomic {0==j;PCind_0!0;j = j+1;}  goto resolve; \n\n::  atomic {1==j;PCind_1!0;j = j+1;}  goto resolve; \n\nfi;\nresolve2: if\n::  atomic {PDreq_0?m;j = 0;}  goto resolve2q; \n\n::  atomic {PDreq_1?m;j = 1;}  goto resolve2q; \n\nfi;\nresolve2q: if\n::  ! ((next[0]==0 && next[1]==0) || (next[0]+next[1]==1)) && m!=120; goto resolve; \n\n::  d_step { ! ((next[0]==0 && next[1]==0) || (next[0]+next[1]==1)) && m==120;next[j] = 0;}  goto resolve; \n\n::  d_step {(next[0]+next[1]==1) && m==120;next[j] = 0;j = 0;}  goto sub_action_gab; \n\n::  d_step {(next[0]+next[1]==1) && m!=120;busy = j;next[j] = 0;j = 0;}  goto distribute; \n\nfi;\ndistribute: if\n::  d_step {j==busy;j = j+1;}  goto distribute; \n\n::  atomic {0==j;PAreq_0?m;}  goto distributeq; \n\n::  atomic {1==j;PAreq_1?m;}  goto distributeq; \n\n::  atomic {0==j &&  ! (m==114 && destfault[j]==1);PDind_0!m;j = j+1;}  goto distribute; \n\n::  atomic {1==j &&  ! (m==114 && destfault[j]==1);PDind_1!m;j = j+1;}  goto distribute; \n\n::  atomic {0==j && m==116;PDind_0!m;}  goto data_dummy; \n\n::  atomic {1==j && m==116;PDind_1!m;}  goto data_dummy; \n\n::  atomic {0==j && m==116;PDind_0!117;j = j+1;}  goto distribute; \n\n::  atomic {1==j && m==116;PDind_1!117;j = j+1;}  goto distribute; \n\n::  atomic {0==j && m==114;PDind_0!115;j = j+1;}  goto distribute; \n\n::  atomic {1==j && m==114;PDind_1!115;j = j+1;}  goto distribute; \n\n::  atomic {0==j && m==112;PDind_0!113;j = j+1;}  goto distribute; \n\n::  atomic {1==j && m==112;PDind_1!113;j = j+1;}  goto distribute; \n\n::  d_step {j!=busy && j<2 && m<100;destfault[j] = 1;i = 0;}  goto dest_cor; \n\n::  d_step {j!=busy && j<2 && m<100;destfault[j] = 1;i = 1;}  goto dest_cor; \n\n:: j==2 && m!=120; goto bus_busy; \n\n::  d_step {j==2 && m==120;busy = 2;}  goto bus_busy; \n\nfi;\ndistributeq: if\n::  atomic {m==108 && j==0;PAcon_0!111;}  goto distribute; \n\n::  atomic {m==108 && j==1;PAcon_1!111;}  goto distribute; \n\n::  d_step {m==109;next[j] = 1;}  goto distribute; \n\nfi;\ndest_cor: if\n::  atomic {0==j;PDind_0!i;j = j+1;}  goto distribute; \n\n::  atomic {1==j;PDind_1!i;j = j+1;}  goto distribute; \n\nfi;\ndata_dummy: if\n::  atomic {0==j;PDind_0!123;j = j+1;}  goto distribute; \n\n::  atomic {1==j;PDind_1!123;j = j+1;}  goto distribute; \n\nfi;\n}\n\nactive proctype Application_0() { \n\nq: if\n:: TDreq_0!1; goto r; \n\nfi;\nr: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "This is model of the \"FireWire\" high performance serial\n    bus defined in the IEEE-1394 Standard. The bus involves n nodes\n    (addressable entities that run their own part of the protocol) connected by\n    a serial line. On each node the IEEE-1394 protocol consists of three stacke\n    layers: the transaction layer, the link layer, and th physical layer. The\n    protocol implemented by the link layer is designed to transmit data packets\n    over an unreliable medium to a specific node or to all nodes (broadcast).\n    The transmission can be performed synchronously or\n    asynchronously.\n\nParameters:"}, {"role": "assistant", "content": "chan LDreq_0 =[0] of {int};\nchan LDres_0 =[0] of {int};\nchan LDcon_0 =[0] of {int};\nchan LDind_0 =[0] of {int};\nchan TX_0 =[0] of {int};\nchan PDreq_0 =[0] of {int};\nchan PDind_0 =[0] of {int};\nchan PAreq_0 =[0] of {int};\nchan PAcon_0 =[0] of {int};\nchan PCind_0 =[0] of {int};\nchan TDreq_0 =[0] of {int};\nchan LDreq_1 =[0] of {int};\nchan LDres_1 =[0] of {int};\nchan LDcon_1 =[0] of {int};\nchan LDind_1 =[0] of {int};\nchan TX_1 =[0] of {int};\nchan PDreq_1 =[0] of {int};\nchan PDind_1 =[0] of {int};\nchan PAreq_1 =[0] of {int};\nchan PAcon_1 =[0] of {int};\nchan PCind_1 =[0] of {int};\nchan TDreq_1 =[0] of {int};\n\nactive proctype Transreq_0() { \nbyte m=0;\n\nidle: if\n:: LDind_0?m; goto got_msg; \n\nfi;\ngot_msg: if\n::  atomic {m==101;LDres_0!100;}  goto idle; \n\n:: TX_0?0; goto concatenated_tr; \n\n::  goto split_tr; \n\nfi;\nconcatenated_tr: if\n:: LDres_0!102; goto idle; \n\nfi;\nsplit_tr: if\n:: LDres_0!107; goto idle; \n\nfi;\n}\n\nactive proctype Transres_0() { \nbyte dest=0;\nbyte m=0;\n\nidle: if\n:: TDreq_0?dest; goto got_req; \n\nfi;\ngot_req: if\n:: TX_0!0; goto q; \n\n::  goto q; \n\nfi;\nq: if\n:: LDreq_0!dest; goto wait_ack; \n\nfi;\nwait_ack: if\n:: LDcon_0?m; goto wait_q; \n\nfi;\nwait_q: if\n:: m==124 && dest==2; goto idle; \n\n:: m==105 && dest<2; goto idle; \n\n:: m==106 && dest<2; goto idle; \n\nfi;\n}\n\nactive proctype Link_0() { \nint buf=-1;\nbyte dest=0;\nbyte m=0;\nbyte m2=0;\nbyte data=0;\n\nlink0: if\n:: LDreq_0?buf; goto link0r; \n\n:: PAcon_0?m; goto link0a; \n\n:: PDind_0?m; goto link0i; \n\nfi;\nlink0r: if\n:: PAreq_0!108; goto link0; \n\nfi;\nlink0a: if\n:: m==111; goto link0; \n\n::  d_step {m==110;dest = buf;}  goto link2req; \n\nfi;\nlink0i: if\n:: m!=119; goto link0; \n\n:: m==119; goto link4; \n\nfi;\nlink2req: if\n:: PCind_0?0; goto q1; \n\nfi;\nq1: if\n:: PDreq_0!119; goto s1; \n\nfi;\ns1: if\n:: PCind_0?0; goto q2; \n\nfi;\nq2: if\n:: PDreq_0!118; goto s2; \n\nfi;\ns2: if\n:: PCind_0?0; goto q3; \n\nfi;\nq3: if\n:: PDreq_0!dest; goto s3; \n\nfi;\ns3: if\n:: PCind_0?0; goto q4; \n\nfi;\nq4: if\n:: PDreq_0!114; goto s4; \n\nfi;\ns4: if\n:: PCind_0?0; goto q5; \n\nfi;\nq5: if\n:: PDreq_0!116; goto s5; \n\nfi;\ns5: if\n:: PCind_0?0; goto q6; \n\nfi;\nq6: if\n:: PDreq_0!120; goto s6; \n\nfi;\ns6: if\n::  atomic {dest==2;LDcon_0!124;buf = -1;}  goto link0; \n\n:: dest<2; goto link3; \n\nfi;\nlink3: if\n:: PDind_0?m; goto link3q; \n\nfi;\nlink3q: if\n:: m==121; goto link3; \n\n::  atomic {m==122;LDcon_0!106;}  goto link0; \n\n:: m==119; goto link3A; \n\n::  atomic {m!=122 && m!=121 && m!=119;LDcon_0!106;dest = 2;}  goto linkWSA; \n\nfi;\nlink3A: if\n:: PDind_0?m; goto link3Aq; \n\nfi;\nlink3Aq: if\n::  atomic {m==119 || m==120 || m==122;LDcon_0!106;dest = 2;}  goto linkWSA; \n\n::  ! (m==119 || m==120 || m==122); goto link3RE; \n\nfi;\nlink3RE: if\n:: PDind_0?m2; goto link3REq1; \n\nfi;\nlink3REq1: if\n::  atomic {m==112 && (m2==121 || m2==120);LDcon_0!105;}  goto link3REq2; \n\n::  atomic { ! (m==112 && (m2==121 || m2==120));LDcon_0!106;}  goto link3REq2; \n\nfi;\nlink3REq2: if\n:: m2==122; goto link0; \n\n::  d_step {m2!=122;dest = 2;}  goto linkWSA; \n\nfi;\nlinkWSA: if\n:: PDind_0?m; goto linkWSAq; \n\n::  atomic {dest==0;PAcon_0?m;}  goto linkWSAa1; \n\nfi;\nlinkWSAq: if\n:: m!=122; goto linkWSA; \n\n:: m==122; goto link0; \n\nfi;\nlinkWSAa1: if\n::  atomic {m==110;PCind_0?0;}  goto linkWSAa2; \n\nfi;\nlinkWSAa2: if\n:: PDreq_0!120; goto link0; \n\nfi;\nlink4: if\n:: PDind_0?m; goto link4q; \n\nfi;\nlink4q: if\n:: m==122; goto link0; \n\n::  d_step {m==119 || m==120 || m==122;dest = 2;}  goto linkWSA; \n\n:: m!=122 &&  ! (m==119 || m==120 || m==122); goto link4DH; \n\nfi;\nlink4DH: if\n:: PDind_0?dest; goto link4DHq; \n\nfi;\nlink4DHq: if\n:: dest==122; goto link0; \n\n::  atomic {dest==0;PAreq_0!109;}  goto link4RH; \n\n:: dest==2; goto link4RH; \n\n::  d_step {dest!=122 && dest!=0 && dest!=2;dest = 2;}  goto linkWSA; \n\nfi;\nlink4RH: if\n:: PDind_0?m; goto link4RHq; \n\nfi;\nlink4RHq: if\n:: m==114; goto link4RD; \n\n:: m!=114; goto linkWSA; \n\nfi;\nlink4RD: if\n:: PDind_0?data; goto link4RDq; \n\nfi;\nlink4RDq: if\n:: data==116 || data==117; goto link4RE; \n\n::  ! (data==116 || data==117); goto linkWSA; \n\nfi;\nlink4RE: if\n:: PDind_0?m; goto link4REq; \n\nfi;\nlink4REq: if\n:: (m==120 || m==121) && dest==0; goto link4DRec; \n\n:: (m==120 || m==121) && dest==2; goto link4BRec; \n\n::  ! (m==120 || m==121); goto linkWSA; \n\nfi;\nlink4DRec: if\n::  atomic {data==116;LDind_0!103;}  goto link4DRecq; \n\n::  atomic {data==117;LDind_0!104;}  goto link4DRecq; \n\nfi;\nlink4BRec: if\n::  atomic {data==116;LDind_0!101;}  goto link0; \n\n:: data!=116; goto link0; \n\nfi;\nlink4DRecq: if\n:: PAcon_0?m; goto link4DRecq2; \n\nfi;\nlink4DRecq2: if\n:: m==110; goto link5; \n\nfi;\nlink5: if\n:: PCind_0?0; goto p1; \n\n:: LDres_0?m; goto link6; \n\nfi;\np1: if\n:: PDreq_0!121; goto link5; \n\nfi;\np2: if\n:: PDreq_0!119; goto p3; \n\nfi;\nlink6: if\n:: PCind_0?0; goto p2; \n\nfi;\np3: if\n:: PCind_0?0; goto p4; \n\nfi;\np4: if\n:: PDreq_0!112; goto p5; \n\nfi;\np5: if\n::  atomic {m==107;PDreq_0!120;}  goto link0; \n\n::  atomic {m!=107;PDreq_0!121;}  goto link7; \n\nfi;\np6: if\n:: PDreq_0!121; goto link7; \n\nfi;\nlink7: if\n:: PCind_0?0; goto p6; \n\n:: LDreq_0?dest; goto link2req; \n\nfi;\n}\n\nactive proctype Transreq_1() { \nbyte m=0;\n\nidle: if\n:: LDind_1?m; goto got_msg; \n\nfi;\ngot_msg: if\n::  atomic {m==101;LDres_1!100;}  goto idle; \n\n:: TX_1?0; goto concatenated_tr; \n\n::  goto split_tr; \n\nfi;\nconcatenated_tr: if\n:: LDres_1!102; goto idle; \n\nfi;\nsplit_tr: if\n:: LDres_1!107; goto idle; \n\nfi;\n}\n\nactive proctype Transres_1() { \nbyte dest=0;\nbyte m=0;\n\nidle: if\n:: TDreq_1?dest; goto got_req; \n\nfi;\ngot_req: if\n:: TX_1!0; goto q; \n\n::  goto q; \n\nfi;\nq: if\n:: LDreq_1!dest; goto wait_ack; \n\nfi;\nwait_ack: if\n:: LDcon_1?m; goto wait_q; \n\nfi;\nwait_q: if\n:: m==124 && dest==2; goto idle; \n\n:: m==105 && dest<2; goto idle; \n\n:: m==106 && dest<2; goto idle; \n\nfi;\n}\n\nactive proctype Link_1() { \nint buf=-1;\nbyte dest=0;\nbyte m=0;\nbyte m2=0;\nbyte data=0;\n\nlink0: if\n:: LDreq_1?buf; goto link0r; \n\n:: PAcon_1?m; goto link0a; \n\n:: PDind_1?m; goto link0i; \n\nfi;\nlink0r: if\n:: PAreq_1!108; goto link0; \n\nfi;\nlink0a: if\n:: m==111; goto link0; \n\n::  d_step {m==110;dest = buf;}  goto link2req; \n\nfi;\nlink0i: if\n:: m!=119; goto link0; \n\n:: m==119; goto link4; \n\nfi;\nlink2req: if\n:: PCind_1?0; goto q1; \n\nfi;\nq1: if\n:: PDreq_1!119; goto s1; \n\nfi;\ns1: if\n:: PCind_1?0; goto q2; \n\nfi;\nq2: if\n:: PDreq_1!118; goto s2; \n\nfi;\ns2: if\n:: PCind_1?0; goto q3; \n\nfi;\nq3: if\n:: PDreq_1!dest; goto s3; \n\nfi;\ns3: if\n:: PCind_1?0; goto q4; \n\nfi;\nq4: if\n:: PDreq_1!114; goto s4; \n\nfi;\ns4: if\n:: PCind_1?0; goto q5; \n\nfi;\nq5: if\n:: PDreq_1!116; goto s5; \n\nfi;\ns5: if\n:: PCind_1?0; goto q6; \n\nfi;\nq6: if\n:: PDreq_1!120; goto s6; \n\nfi;\ns6: if\n::  atomic {dest==2;LDcon_1!124;buf = -1;}  goto link0; \n\n:: dest<2; goto link3; \n\nfi;\nlink3: if\n:: PDind_1?m; goto link3q; \n\nfi;\nlink3q: if\n:: m==121; goto link3; \n\n::  atomic {m==122;LDcon_1!106;}  goto link0; \n\n:: m==119; goto link3A; \n\n::  atomic {m!=122 && m!=121 && m!=119;LDcon_1!106;dest = 2;}  goto linkWSA; \n\nfi;\nlink3A: if\n:: PDind_1?m; goto link3Aq; \n\nfi;\nlink3Aq: if\n::  atomic {m==119 || m==120 || m==122;LDcon_1!106;dest = 2;}  goto linkWSA; \n\n::  ! (m==119 || m==120 || m==122); goto link3RE; \n\nfi;\nlink3RE: if\n:: PDind_1?m2; goto link3REq1; \n\nfi;\nlink3REq1: if\n::  atomic {m==112 && (m2==121 || m2==120);LDcon_1!105;}  goto link3REq2; \n\n::  atomic { ! (m==112 && (m2==121 || m2==120));LDcon_1!106;}  goto link3REq2; \n\nfi;\nlink3REq2: if\n:: m2==122; goto link0; \n\n::  d_step {m2!=122;dest = 2;}  goto linkWSA; \n\nfi;\nlinkWSA: if\n:: PDind_1?m; goto linkWSAq; \n\n::  atomic {dest==1;PAcon_1?m;}  goto linkWSAa1; \n\nfi;\nlinkWSAq: if\n:: m!=122; goto linkWSA; \n\n:: m==122; goto link0; \n\nfi;\nlinkWSAa1: if\n::  atomic {m==110;PCind_1?0;}  goto linkWSAa2; \n\nfi;\nlinkWSAa2: if\n:: PDreq_1!120; goto link0; \n\nfi;\nlink4: if\n:: PDind_1?m; goto link4q; \n\nfi;\nlink4q: if\n:: m==122; goto link0; \n\n::  d_step {m==119 || m==120 || m==122;dest = 2;}  goto linkWSA; \n\n:: m!=122 &&  ! (m==119 || m==120 || m==122); goto link4DH; \n\nfi;\nlink4DH: if\n:: PDind_1?dest; goto link4DHq; \n\nfi;\nlink4DHq: if\n:: dest==122; goto link0; \n\n::  atomic {dest==1;PAreq_1!109;}  goto link4RH; \n\n:: dest==2; goto link4RH; \n\n::  d_step {dest!=122 && dest!=1 && dest!=2;dest = 2;}  goto linkWSA; \n\nfi;\nlink4RH: if\n:: PDind_1?m; goto link4RHq; \n\nfi;\nlink4RHq: if\n:: m==114; goto link4RD; \n\n:: m!=114; goto linkWSA; \n\nfi;\nlink4RD: if\n:: PDind_1?data; goto link4RDq; \n\nfi;\nlink4RDq: if\n:: data==116 || data==117; goto link4RE; \n\n::  ! (data==116 || data==117); goto linkWSA; \n\nfi;\nlink4RE: if\n:: PDind_1?m; goto link4REq; \n\nfi;\nlink4REq: if\n:: (m==120 || m==121) && dest==1; goto link4DRec; \n\n:: (m==120 || m==121) && dest==2; goto link4BRec; \n\n::  ! (m==120 || m==121); goto linkWSA; \n\nfi;\nlink4DRec: if\n::  atomic {data==116;LDind_1!103;}  goto link4DRecq; \n\n::  atomic {data==117;LDind_1!104;}  goto link4DRecq; \n\nfi;\nlink4BRec: if\n::  atomic {data==116;LDind_1!101;}  goto link0; \n\n:: data!=116; goto link0; \n\nfi;\nlink4DRecq: if\n:: PAcon_1?m; goto link4DRecq2; \n\nfi;\nlink4DRecq2: if\n:: m==110; goto link5; \n\nfi;\nlink5: if\n:: PCind_1?0; goto p1; \n\n:: LDres_1?m; goto link6; \n\nfi;\np1: if\n:: PDreq_1!121; goto link5; \n\nfi;\np2: if\n:: PDreq_1!119; goto p3; \n\nfi;\nlink6: if\n:: PCind_1?0; goto p2; \n\nfi;\np3: if\n:: PCind_1?0; goto p4; \n\nfi;\np4: if\n:: PDreq_1!112; goto p5; \n\nfi;\np5: if\n::  atomic {m==107;PDreq_1!120;}  goto link0; \n\n::  atomic {m!=107;PDreq_1!121;}  goto link7; \n\nfi;\np6: if\n:: PDreq_1!121; goto link7; \n\nfi;\nlink7: if\n:: PCind_1?0; goto p6; \n\n:: LDreq_1?dest; goto link2req; \n\nfi;\n}\n\nactive proctype Bus() { \nbyte t[2];\nbyte destfault[2];\nbyte next[2];\nbyte i=0;\nbyte j=0;\nbyte m=0;\nbyte busy=0;\n\nidle: if\n::  ! (t[0]==0 && t[1]==0); goto arbresgab; \n\n::  atomic {PAreq_0?m;i = 0;}  goto idleq; \n\n::  atomic {PAreq_1?m;i = 1;}  goto idleq; \n\nfi;\narbresgab: if\n::  d_step {t[0] = 0;t[1] = 0;}  goto idle; \n\nfi;\nidleq: if\n::  atomic {i==0 && t[i]==1;PAcon_0!111;}  goto idle; \n\n::  atomic {i==1 && t[i]==1;PAcon_1!111;}  goto idle; \n\n::  atomic {i==0 && t[i]==0;PAcon_0!110;t[i] = 1;busy = i;}  goto bus_busy; \n\n::  atomic {i==1 && t[i]==0;PAcon_1!110;t[i] = 1;busy = i;}  goto bus_busy; \n\nfi;\nbus_busy: if\n::  atomic {PAreq_0?m;i = 0;}  goto busyq; \n\n::  atomic {PAreq_1?m;i = 1;}  goto busyq; \n\n::  atomic {busy==0;PCind_0!0;}  goto get_next_packet; \n\n::  atomic {busy==1;PCind_1!0;}  goto get_next_packet; \n\n::  d_step {busy==2 && next[0]==0 && next[1]==0;j = 0;}  goto sub_action_gab; \n\n::  d_step {busy==2 &&  ! (next[0]==0 && next[1]==0);j = 0;}  goto resolve; \n\nfi;\nbusyq: if\n::  atomic {m==108 && i==0;PAcon_0!111;}  goto bus_busy; \n\n::  atomic {m==108 && i==1;PAcon_1!111;}  goto bus_busy; \n\n::  d_step {m==109;next[i] = 1;}  goto bus_busy; \n\nfi;\nsub_action_gab: if\n::  atomic {0==j;PDind_0!122;j = j+1;}  goto sub_action_gab; \n\n::  atomic {1==j;PDind_1!122;j = j+1;}  goto sub_action_gab; \n\n:: j==2; goto idle; \n\nfi;\nget_next_packet: if\n::  atomic {busy==0;PDreq_0?m;j = 0;}  goto distribute; \n\n::  atomic {busy==1;PDreq_1?m;j = 0;}  goto distribute; \n\nfi;\nresolve: if\n::  d_step {j<2 && next[j]==0;j = j+1;}  goto resolve; \n\n::  atomic {0==j && next[j]==1;PAcon_0!110;}  goto resolveq; \n\n::  atomic {1==j && next[j]==1;PAcon_1!110;}  goto resolveq; \n\n:: j==2; goto resolve2; \n\nfi;\nresolveq: if\n::  atomic {0==j;PCind_0!0;j = j+1;}  goto resolve; \n\n::  atomic {1==j;PCind_1!0;j = j+1;}  goto resolve; \n\nfi;\nresolve2: if\n::  atomic {PDreq_0?m;j = 0;}  goto resolve2q; \n\n::  atomic {PDreq_1?m;j = 1;}  goto resolve2q; \n\nfi;\nresolve2q: if\n::  ! ((next[0]==0 && next[1]==0) || (next[0]+next[1]==1)) && m!=120; goto resolve; \n\n::  d_step { ! ((next[0]==0 && next[1]==0) || (next[0]+next[1]==1)) && m==120;next[j] = 0;}  goto resolve; \n\n::  d_step {(next[0]+next[1]==1) && m==120;next[j] = 0;j = 0;}  goto sub_action_gab; \n\n::  d_step {(next[0]+next[1]==1) && m!=120;busy = j;next[j] = 0;j = 0;}  goto distribute; \n\nfi;\ndistribute: if\n::  d_step {j==busy;j = j+1;}  goto distribute; \n\n::  atomic {0==j;PAreq_0?m;}  goto distributeq; \n\n::  atomic {1==j;PAreq_1?m;}  goto distributeq; \n\n::  atomic {0==j &&  ! (m==114 && destfault[j]==1);PDind_0!m;j = j+1;}  goto distribute; \n\n::  atomic {1==j &&  ! (m==114 && destfault[j]==1);PDind_1!m;j = j+1;}  goto distribute; \n\n::  atomic {0==j && m==116;PDind_0!m;}  goto data_dummy; \n\n::  atomic {1==j && m==116;PDind_1!m;}  goto data_dummy; \n\n::  atomic {0==j && m==116;PDind_0!117;j = j+1;}  goto distribute; \n\n::  atomic {1==j && m==116;PDind_1!117;j = j+1;}  goto distribute; \n\n::  atomic {0==j && m==114;PDind_0!115;j = j+1;}  goto distribute; \n\n::  atomic {1==j && m==114;PDind_1!115;j = j+1;}  goto distribute; \n\n::  atomic {0==j && m==112;PDind_0!113;j = j+1;}  goto distribute; \n\n::  atomic {1==j && m==112;PDind_1!113;j = j+1;}  goto distribute; \n\n::  d_step {j!=busy && j<2 && m<100;destfault[j] = 1;i = 0;}  goto dest_cor; \n\n::  d_step {j!=busy && j<2 && m<100;destfault[j] = 1;i = 1;}  goto dest_cor; \n\n:: j==2 && m!=120; goto bus_busy; \n\n::  d_step {j==2 && m==120;busy = 2;}  goto bus_busy; \n\nfi;\ndistributeq: if\n::  atomic {m==108 && j==0;PAcon_0!111;}  goto distribute; \n\n::  atomic {m==108 && j==1;PAcon_1!111;}  goto distribute; \n\n::  d_step {m==109;next[j] = 1;}  goto distribute; \n\nfi;\ndest_cor: if\n::  atomic {0==j;PDind_0!i;j = j+1;}  goto distribute; \n\n::  atomic {1==j;PDind_1!i;j = j+1;}  goto distribute; \n\nfi;\ndata_dummy: if\n::  atomic {0==j;PDind_0!123;j = j+1;}  goto distribute; \n\n::  atomic {1==j;PDind_1!123;j = j+1;}  goto distribute; \n\nfi;\n}\n\nactive proctype Application_0() { \n\nq: if\n:: TDreq_0!1; goto r; \n\nfi;\nr: \n false; }\n\nactive proctype Application_1() { \n\nq: if\n:: TDreq_1!0; goto r; \n\nfi;\nr: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "This is model of the \"FireWire\" high performance serial\n    bus defined in the IEEE-1394 Standard. The bus involves n nodes\n    (addressable entities that run their own part of the protocol) connected by\n    a serial line. On each node the IEEE-1394 protocol consists of three stacke\n    layers: the transaction layer, the link layer, and th physical layer. The\n    protocol implemented by the link layer is designed to transmit data packets\n    over an unreliable medium to a specific node or to all nodes (broadcast).\n    The transmission can be performed synchronously or\n    asynchronously.\n\nParameters:"}, {"role": "assistant", "content": "chan LDreq_0 =[0] of {int};\nchan LDres_0 =[0] of {int};\nchan LDcon_0 =[0] of {int};\nchan LDind_0 =[0] of {int};\nchan TX_0 =[0] of {int};\nchan PDreq_0 =[0] of {int};\nchan PDind_0 =[0] of {int};\nchan PAreq_0 =[0] of {int};\nchan PAcon_0 =[0] of {int};\nchan PCind_0 =[0] of {int};\nchan TDreq_0 =[0] of {int};\nchan LDreq_1 =[0] of {int};\nchan LDres_1 =[0] of {int};\nchan LDcon_1 =[0] of {int};\nchan LDind_1 =[0] of {int};\nchan TX_1 =[0] of {int};\nchan PDreq_1 =[0] of {int};\nchan PDind_1 =[0] of {int};\nchan PAreq_1 =[0] of {int};\nchan PAcon_1 =[0] of {int};\nchan PCind_1 =[0] of {int};\nchan TDreq_1 =[0] of {int};\n\nactive proctype Transreq_0() { \nbyte m=0;\n\nidle: if\n:: LDind_0?m; goto got_msg; \n\nfi;\ngot_msg: if\n::  atomic {m==101;LDres_0!100;}  goto idle; \n\n:: TX_0?0; goto concatenated_tr; \n\n::  goto split_tr; \n\nfi;\nconcatenated_tr: if\n:: LDres_0!102; goto idle; \n\nfi;\nsplit_tr: if\n:: LDres_0!107; goto idle; \n\nfi;\n}\n\nactive proctype Transres_0() { \nbyte dest=0;\nbyte m=0;\n\nidle: if\n:: TDreq_0?dest; goto got_req; \n\nfi;\ngot_req: if\n:: TX_0!0; goto q; \n\n::  goto q; \n\nfi;\nq: if\n:: LDreq_0!dest; goto wait_ack; \n\nfi;\nwait_ack: if\n:: LDcon_0?m; goto wait_q; \n\nfi;\nwait_q: if\n:: m==124 && dest==2; goto idle; \n\n:: m==105 && dest<2; goto idle; \n\n:: m==106 && dest<2; goto idle; \n\nfi;\n}\n\nactive proctype Link_0() { \nint buf=-1;\nbyte dest=0;\nbyte m=0;\nbyte m2=0;\nbyte data=0;\n\nlink0: if\n:: LDreq_0?buf; goto link0r; \n\n:: PAcon_0?m; goto link0a; \n\n:: PDind_0?m; goto link0i; \n\nfi;\nlink0r: if\n:: PAreq_0!108; goto link0; \n\nfi;\nlink0a: if\n:: m==111; goto link0; \n\n::  d_step {m==110;dest = buf;}  goto link2req; \n\nfi;\nlink0i: if\n:: m!=119; goto link0; \n\n:: m==119; goto link4; \n\nfi;\nlink2req: if\n:: PCind_0?0; goto q1; \n\nfi;\nq1: if\n:: PDreq_0!119; goto s1; \n\nfi;\ns1: if\n:: PCind_0?0; goto q2; \n\nfi;\nq2: if\n:: PDreq_0!118; goto s2; \n\nfi;\ns2: if\n:: PCind_0?0; goto q3; \n\nfi;\nq3: if\n:: PDreq_0!dest; goto s3; \n\nfi;\ns3: if\n:: PCind_0?0; goto q4; \n\nfi;\nq4: if\n:: PDreq_0!114; goto s4; \n\nfi;\ns4: if\n:: PCind_0?0; goto q5; \n\nfi;\nq5: if\n:: PDreq_0!116; goto s5; \n\nfi;\ns5: if\n:: PCind_0?0; goto q6; \n\nfi;\nq6: if\n:: PDreq_0!120; goto s6; \n\nfi;\ns6: if\n::  atomic {dest==2;LDcon_0!124;buf = -1;}  goto link0; \n\n:: dest<2; goto link3; \n\nfi;\nlink3: if\n:: PDind_0?m; goto link3q; \n\nfi;\nlink3q: if\n:: m==121; goto link3; \n\n::  atomic {m==122;LDcon_0!106;}  goto link0; \n\n:: m==119; goto link3A; \n\n::  atomic {m!=122 && m!=121 && m!=119;LDcon_0!106;dest = 2;}  goto linkWSA; \n\nfi;\nlink3A: if\n:: PDind_0?m; goto link3Aq; \n\nfi;\nlink3Aq: if\n::  atomic {m==119 || m==120 || m==122;LDcon_0!106;dest = 2;}  goto linkWSA; \n\n::  ! (m==119 || m==120 || m==122); goto link3RE; \n\nfi;\nlink3RE: if\n:: PDind_0?m2; goto link3REq1; \n\nfi;\nlink3REq1: if\n::  atomic {m==112 && (m2==121 || m2==120);LDcon_0!105;}  goto link3REq2; \n\n::  atomic { ! (m==112 && (m2==121 || m2==120));LDcon_0!106;}  goto link3REq2; \n\nfi;\nlink3REq2: if\n:: m2==122; goto link0; \n\n::  d_step {m2!=122;dest = 2;}  goto linkWSA; \n\nfi;\nlinkWSA: if\n:: PDind_0?m; goto linkWSAq; \n\n::  atomic {dest==0;PAcon_0?m;}  goto linkWSAa1; \n\nfi;\nlinkWSAq: if\n:: m!=122; goto linkWSA; \n\n:: m==122; goto link0; \n\nfi;\nlinkWSAa1: if\n::  atomic {m==110;PCind_0?0;}  goto linkWSAa2; \n\nfi;\nlinkWSAa2: if\n:: PDreq_0!120; goto link0; \n\nfi;\nlink4: if\n:: PDind_0?m; goto link4q; \n\nfi;\nlink4q: if\n:: m==122; goto link0; \n\n::  d_step {m==119 || m==120 || m==122;dest = 2;}  goto linkWSA; \n\n:: m!=122 &&  ! (m==119 || m==120 || m==122); goto link4DH; \n\nfi;\nlink4DH: if\n:: PDind_0?dest; goto link4DHq; \n\nfi;\nlink4DHq: if\n:: dest==122; goto link0; \n\n::  atomic {dest==0;PAreq_0!109;}  goto link4RH; \n\n:: dest==2; goto link4RH; \n\n::  d_step {dest!=122 && dest!=0 && dest!=2;dest = 2;}  goto linkWSA; \n\nfi;\nlink4RH: if\n:: PDind_0?m; goto link4RHq; \n\nfi;\nlink4RHq: if\n:: m==114; goto link4RD; \n\n:: m!=114; goto linkWSA; \n\nfi;\nlink4RD: if\n:: PDind_0?data; goto link4RDq; \n\nfi;\nlink4RDq: if\n:: data==116 || data==117; goto link4RE; \n\n::  ! (data==116 || data==117); goto linkWSA; \n\nfi;\nlink4RE: if\n:: PDind_0?m; goto link4REq; \n\nfi;\nlink4REq: if\n:: (m==120 || m==121) && dest==0; goto link4DRec; \n\n:: (m==120 || m==121) && dest==2; goto link4BRec; \n\n::  ! (m==120 || m==121); goto linkWSA; \n\nfi;\nlink4DRec: if\n::  atomic {data==116;LDind_0!103;}  goto link4DRecq; \n\n::  atomic {data==117;LDind_0!104;}  goto link4DRecq; \n\nfi;\nlink4BRec: if\n::  atomic {data==116;LDind_0!101;}  goto link0; \n\n:: data!=116; goto link0; \n\nfi;\nlink4DRecq: if\n:: PAcon_0?m; goto link4DRecq2; \n\nfi;\nlink4DRecq2: if\n:: m==110; goto link5; \n\nfi;\nlink5: if\n:: PCind_0?0; goto p1; \n\n:: LDres_0?m; goto link6; \n\nfi;\np1: if\n:: PDreq_0!121; goto link5; \n\nfi;\np2: if\n:: PDreq_0!119; goto p3; \n\nfi;\nlink6: if\n:: PCind_0?0; goto p2; \n\nfi;\np3: if\n:: PCind_0?0; goto p4; \n\nfi;\np4: if\n:: PDreq_0!112; goto p5; \n\nfi;\np5: if\n::  atomic {m==107;PDreq_0!120;}  goto link0; \n\n::  atomic {m!=107;PDreq_0!121;}  goto link7; \n\nfi;\np6: if\n:: PDreq_0!121; goto link7; \n\nfi;\nlink7: if\n:: PCind_0?0; goto p6; \n\n:: LDreq_0?dest; goto link2req; \n\nfi;\n}\n\nactive proctype Transreq_1() { \nbyte m=0;\n\nidle: if\n:: LDind_1?m; goto got_msg; \n\nfi;\ngot_msg: if\n::  atomic {m==101;LDres_1!100;}  goto idle; \n\n:: TX_1?0; goto concatenated_tr; \n\n::  goto split_tr; \n\nfi;\nconcatenated_tr: if\n:: LDres_1!102; goto idle; \n\nfi;\nsplit_tr: if\n:: LDres_1!107; goto idle; \n\nfi;\n}\n\nactive proctype Transres_1() { \nbyte dest=0;\nbyte m=0;\n\nidle: if\n:: TDreq_1?dest; goto got_req; \n\nfi;\ngot_req: if\n:: TX_1!0; goto q; \n\n::  goto q; \n\nfi;\nq: if\n:: LDreq_1!dest; goto wait_ack; \n\nfi;\nwait_ack: if\n:: LDcon_1?m; goto wait_q; \n\nfi;\nwait_q: if\n:: m==124 && dest==2; goto idle; \n\n:: m==105 && dest<2; goto idle; \n\n:: m==106 && dest<2; goto idle; \n\nfi;\n}\n\nactive proctype Link_1() { \nint buf=-1;\nbyte dest=0;\nbyte m=0;\nbyte m2=0;\nbyte data=0;\n\nlink0: if\n:: LDreq_1?buf; goto link0r; \n\n:: PAcon_1?m; goto link0a; \n\n:: PDind_1?m; goto link0i; \n\nfi;\nlink0r: if\n:: PAreq_1!108; goto link0; \n\nfi;\nlink0a: if\n:: m==111; goto link0; \n\n::  d_step {m==110;dest = buf;}  goto link2req; \n\nfi;\nlink0i: if\n:: m!=119; goto link0; \n\n:: m==119; goto link4; \n\nfi;\nlink2req: if\n:: PCind_1?0; goto q1; \n\nfi;\nq1: if\n:: PDreq_1!119; goto s1; \n\nfi;\ns1: if\n:: PCind_1?0; goto q2; \n\nfi;\nq2: if\n:: PDreq_1!118; goto s2; \n\nfi;\ns2: if\n:: PCind_1?0; goto q3; \n\nfi;\nq3: if\n:: PDreq_1!dest; goto s3; \n\nfi;\ns3: if\n:: PCind_1?0; goto q4; \n\nfi;\nq4: if\n:: PDreq_1!114; goto s4; \n\nfi;\ns4: if\n:: PCind_1?0; goto q5; \n\nfi;\nq5: if\n:: PDreq_1!116; goto s5; \n\nfi;\ns5: if\n:: PCind_1?0; goto q6; \n\nfi;\nq6: if\n:: PDreq_1!120; goto s6; \n\nfi;\ns6: if\n::  atomic {dest==2;LDcon_1!124;buf = -1;}  goto link0; \n\n:: dest<2; goto link3; \n\nfi;\nlink3: if\n:: PDind_1?m; goto link3q; \n\nfi;\nlink3q: if\n:: m==121; goto link3; \n\n::  atomic {m==122;LDcon_1!106;}  goto link0; \n\n:: m==119; goto link3A; \n\n::  atomic {m!=122 && m!=121 && m!=119;LDcon_1!106;dest = 2;}  goto linkWSA; \n\nfi;\nlink3A: if\n:: PDind_1?m; goto link3Aq; \n\nfi;\nlink3Aq: if\n::  atomic {m==119 || m==120 || m==122;LDcon_1!106;dest = 2;}  goto linkWSA; \n\n::  ! (m==119 || m==120 || m==122); goto link3RE; \n\nfi;\nlink3RE: if\n:: PDind_1?m2; goto link3REq1; \n\nfi;\nlink3REq1: if\n::  atomic {m==112 && (m2==121 || m2==120);LDcon_1!105;}  goto link3REq2; \n\n::  atomic { ! (m==112 && (m2==121 || m2==120));LDcon_1!106;}  goto link3REq2; \n\nfi;\nlink3REq2: if\n:: m2==122; goto link0; \n\n::  d_step {m2!=122;dest = 2;}  goto linkWSA; \n\nfi;\nlinkWSA: if\n:: PDind_1?m; goto linkWSAq; \n\n::  atomic {dest==1;PAcon_1?m;}  goto linkWSAa1; \n\nfi;\nlinkWSAq: if\n:: m!=122; goto linkWSA; \n\n:: m==122; goto link0; \n\nfi;\nlinkWSAa1: if\n::  atomic {m==110;PCind_1?0;}  goto linkWSAa2; \n\nfi;\nlinkWSAa2: if\n:: PDreq_1!120; goto link0; \n\nfi;\nlink4: if\n:: PDind_1?m; goto link4q; \n\nfi;\nlink4q: if\n:: m==122; goto link0; \n\n::  d_step {m==119 || m==120 || m==122;dest = 2;}  goto linkWSA; \n\n:: m!=122 &&  ! (m==119 || m==120 || m==122); goto link4DH; \n\nfi;\nlink4DH: if\n:: PDind_1?dest; goto link4DHq; \n\nfi;\nlink4DHq: if\n:: dest==122; goto link0; \n\n::  atomic {dest==1;PAreq_1!109;}  goto link4RH; \n\n:: dest==2; goto link4RH; \n\n::  d_step {dest!=122 && dest!=1 && dest!=2;dest = 2;}  goto linkWSA; \n\nfi;\nlink4RH: if\n:: PDind_1?m; goto link4RHq; \n\nfi;\nlink4RHq: if\n:: m==114; goto link4RD; \n\n:: m!=114; goto linkWSA; \n\nfi;\nlink4RD: if\n:: PDind_1?data; goto link4RDq; \n\nfi;\nlink4RDq: if\n:: data==116 || data==117; goto link4RE; \n\n::  ! (data==116 || data==117); goto linkWSA; \n\nfi;\nlink4RE: if\n:: PDind_1?m; goto link4REq; \n\nfi;\nlink4REq: if\n:: (m==120 || m==121) && dest==1; goto link4DRec; \n\n:: (m==120 || m==121) && dest==2; goto link4BRec; \n\n::  ! (m==120 || m==121); goto linkWSA; \n\nfi;\nlink4DRec: if\n::  atomic {data==116;LDind_1!103;}  goto link4DRecq; \n\n::  atomic {data==117;LDind_1!104;}  goto link4DRecq; \n\nfi;\nlink4BRec: if\n::  atomic {data==116;LDind_1!101;}  goto link0; \n\n:: data!=116; goto link0; \n\nfi;\nlink4DRecq: if\n:: PAcon_1?m; goto link4DRecq2; \n\nfi;\nlink4DRecq2: if\n:: m==110; goto link5; \n\nfi;\nlink5: if\n:: PCind_1?0; goto p1; \n\n:: LDres_1?m; goto link6; \n\nfi;\np1: if\n:: PDreq_1!121; goto link5; \n\nfi;\np2: if\n:: PDreq_1!119; goto p3; \n\nfi;\nlink6: if\n:: PCind_1?0; goto p2; \n\nfi;\np3: if\n:: PCind_1?0; goto p4; \n\nfi;\np4: if\n:: PDreq_1!112; goto p5; \n\nfi;\np5: if\n::  atomic {m==107;PDreq_1!120;}  goto link0; \n\n::  atomic {m!=107;PDreq_1!121;}  goto link7; \n\nfi;\np6: if\n:: PDreq_1!121; goto link7; \n\nfi;\nlink7: if\n:: PCind_1?0; goto p6; \n\n:: LDreq_1?dest; goto link2req; \n\nfi;\n}\n\nactive proctype Bus() { \nbyte t[2];\nbyte destfault[2];\nbyte next[2];\nbyte i=0;\nbyte j=0;\nbyte m=0;\nbyte busy=0;\n\nidle: if\n::  ! (t[0]==0 && t[1]==0); goto arbresgab; \n\n::  atomic {PAreq_0?m;i = 0;}  goto idleq; \n\n::  atomic {PAreq_1?m;i = 1;}  goto idleq; \n\nfi;\narbresgab: if\n::  d_step {t[0] = 0;t[1] = 0;}  goto idle; \n\nfi;\nidleq: if\n::  atomic {i==0 && t[i]==1;PAcon_0!111;}  goto idle; \n\n::  atomic {i==1 && t[i]==1;PAcon_1!111;}  goto idle; \n\n::  atomic {i==0 && t[i]==0;PAcon_0!110;t[i] = 1;busy = i;}  goto bus_busy; \n\n::  atomic {i==1 && t[i]==0;PAcon_1!110;t[i] = 1;busy = i;}  goto bus_busy; \n\nfi;\nbus_busy: if\n::  atomic {PAreq_0?m;i = 0;}  goto busyq; \n\n::  atomic {PAreq_1?m;i = 1;}  goto busyq; \n\n::  atomic {busy==0;PCind_0!0;}  goto get_next_packet; \n\n::  atomic {busy==1;PCind_1!0;}  goto get_next_packet; \n\n::  d_step {busy==2 && next[0]==0 && next[1]==0;j = 0;}  goto sub_action_gab; \n\n::  d_step {busy==2 &&  ! (next[0]==0 && next[1]==0);j = 0;}  goto resolve; \n\nfi;\nbusyq: if\n::  atomic {m==108 && i==0;PAcon_0!111;}  goto bus_busy; \n\n::  atomic {m==108 && i==1;PAcon_1!111;}  goto bus_busy; \n\n::  d_step {m==109;next[i] = 1;}  goto bus_busy; \n\nfi;\nsub_action_gab: if\n::  atomic {0==j;PDind_0!122;j = j+1;}  goto sub_action_gab; \n\n::  atomic {1==j;PDind_1!122;j = j+1;}  goto sub_action_gab; \n\n:: j==2; goto idle; \n\nfi;\nget_next_packet: if\n::  atomic {busy==0;PDreq_0?m;j = 0;}  goto distribute; \n\n::  atomic {busy==1;PDreq_1?m;j = 0;}  goto distribute; \n\nfi;\nresolve: if\n::  d_step {j<2 && next[j]==0;j = j+1;}  goto resolve; \n\n::  atomic {0==j && next[j]==1;PAcon_0!110;}  goto resolveq; \n\n::  atomic {1==j && next[j]==1;PAcon_1!110;}  goto resolveq; \n\n:: j==2; goto resolve2; \n\nfi;\nresolveq: if\n::  atomic {0==j;PCind_0!0;j = j+1;}  goto resolve; \n\n::  atomic {1==j;PCind_1!0;j = j+1;}  goto resolve; \n\nfi;\nresolve2: if\n::  atomic {PDreq_0?m;j = 0;}  goto resolve2q; \n\n::  atomic {PDreq_1?m;j = 1;}  goto resolve2q; \n\nfi;\nresolve2q: if\n::  ! ((next[0]==0 && next[1]==0) || (next[0]+next[1]==1)) && m!=120; goto resolve; \n\n::  d_step { ! ((next[0]==0 && next[1]==0) || (next[0]+next[1]==1)) && m==120;next[j] = 0;}  goto resolve; \n\n::  d_step {(next[0]+next[1]==1) && m==120;next[j] = 0;j = 0;}  goto sub_action_gab; \n\n::  d_step {(next[0]+next[1]==1) && m!=120;busy = j;next[j] = 0;j = 0;}  goto distribute; \n\nfi;\ndistribute: if\n::  d_step {j==busy;j = j+1;}  goto distribute; \n\n::  atomic {0==j;PAreq_0?m;}  goto distributeq; \n\n::  atomic {1==j;PAreq_1?m;}  goto distributeq; \n\n::  atomic {0==j &&  ! (m==114 && destfault[j]==1);PDind_0!m;j = j+1;}  goto distribute; \n\n::  atomic {1==j &&  ! (m==114 && destfault[j]==1);PDind_1!m;j = j+1;}  goto distribute; \n\n::  atomic {0==j && m==116;PDind_0!m;}  goto data_dummy; \n\n::  atomic {1==j && m==116;PDind_1!m;}  goto data_dummy; \n\n::  atomic {0==j && m==116;PDind_0!117;j = j+1;}  goto distribute; \n\n::  atomic {1==j && m==116;PDind_1!117;j = j+1;}  goto distribute; \n\n::  atomic {0==j && m==114;PDind_0!115;j = j+1;}  goto distribute; \n\n::  atomic {1==j && m==114;PDind_1!115;j = j+1;}  goto distribute; \n\n::  atomic {0==j && m==112;PDind_0!113;j = j+1;}  goto distribute; \n\n::  atomic {1==j && m==112;PDind_1!113;j = j+1;}  goto distribute; \n\n::  d_step {j!=busy && j<2 && m<100;destfault[j] = 1;i = 0;}  goto dest_cor; \n\n::  d_step {j!=busy && j<2 && m<100;destfault[j] = 1;i = 1;}  goto dest_cor; \n\n:: j==2 && m!=120; goto bus_busy; \n\n::  d_step {j==2 && m==120;busy = 2;}  goto bus_busy; \n\nfi;\ndistributeq: if\n::  atomic {m==108 && j==0;PAcon_0!111;}  goto distribute; \n\n::  atomic {m==108 && j==1;PAcon_1!111;}  goto distribute; \n\n::  d_step {m==109;next[j] = 1;}  goto distribute; \n\nfi;\ndest_cor: if\n::  atomic {0==j;PDind_0!i;j = j+1;}  goto distribute; \n\n::  atomic {1==j;PDind_1!i;j = j+1;}  goto distribute; \n\nfi;\ndata_dummy: if\n::  atomic {0==j;PDind_0!123;j = j+1;}  goto distribute; \n\n::  atomic {1==j;PDind_1!123;j = j+1;}  goto distribute; \n\nfi;\n}\n\nactive proctype Application() { \nbyte i=0;\n\nq: if\n:: i = 0; goto r; \n\n:: i = 1; goto r; \n\n:: i = 2; goto r; \n\nfi;\nr: if\n::  atomic {i!=0;TDreq_0!i;}  goto q; \n\n::  atomic {i!=1;TDreq_1!i;}  goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "This is model of the \"FireWire\" high performance serial\n    bus defined in the IEEE-1394 Standard. The bus involves n nodes\n    (addressable entities that run their own part of the protocol) connected by\n    a serial line. On each node the IEEE-1394 protocol consists of three stacke\n    layers: the transaction layer, the link layer, and th physical layer. The\n    protocol implemented by the link layer is designed to transmit data packets\n    over an unreliable medium to a specific node or to all nodes (broadcast).\n    The transmission can be performed synchronously or\n    asynchronously.\n\nParameters:"}, {"role": "assistant", "content": "chan LDreq_0 =[0] of {int};\nchan LDres_0 =[0] of {int};\nchan LDcon_0 =[0] of {int};\nchan LDind_0 =[0] of {int};\nchan TX_0 =[0] of {int};\nchan PDreq_0 =[0] of {int};\nchan PDind_0 =[0] of {int};\nchan PAreq_0 =[0] of {int};\nchan PAcon_0 =[0] of {int};\nchan PCind_0 =[0] of {int};\nchan TDreq_0 =[0] of {int};\nchan LDreq_1 =[0] of {int};\nchan LDres_1 =[0] of {int};\nchan LDcon_1 =[0] of {int};\nchan LDind_1 =[0] of {int};\nchan TX_1 =[0] of {int};\nchan PDreq_1 =[0] of {int};\nchan PDind_1 =[0] of {int};\nchan PAreq_1 =[0] of {int};\nchan PAcon_1 =[0] of {int};\nchan PCind_1 =[0] of {int};\nchan TDreq_1 =[0] of {int};\nchan LDreq_2 =[0] of {int};\nchan LDres_2 =[0] of {int};\nchan LDcon_2 =[0] of {int};\nchan LDind_2 =[0] of {int};\nchan TX_2 =[0] of {int};\nchan PDreq_2 =[0] of {int};\nchan PDind_2 =[0] of {int};\nchan PAreq_2 =[0] of {int};\nchan PAcon_2 =[0] of {int};\nchan PCind_2 =[0] of {int};\nchan TDreq_2 =[0] of {int};\n\nactive proctype Transreq_0() { \nbyte m=0;\n\nidle: if\n:: LDind_0?m; goto got_msg; \n\nfi;\ngot_msg: if\n::  atomic {m==101;LDres_0!100;}  goto idle; \n\n:: TX_0?0; goto concatenated_tr; \n\n::  goto split_tr; \n\nfi;\nconcatenated_tr: if\n:: LDres_0!102; goto idle; \n\nfi;\nsplit_tr: if\n:: LDres_0!107; goto idle; \n\nfi;\n}\n\nactive proctype Transres_0() { \nbyte dest=0;\nbyte m=0;\n\nidle: if\n:: TDreq_0?dest; goto got_req; \n\nfi;\ngot_req: if\n:: TX_0!0; goto q; \n\n::  goto q; \n\nfi;\nq: if\n:: LDreq_0!dest; goto wait_ack; \n\nfi;\nwait_ack: if\n:: LDcon_0?m; goto wait_q; \n\nfi;\nwait_q: if\n:: m==124 && dest==3; goto idle; \n\n:: m==105 && dest<3; goto idle; \n\n:: m==106 && dest<3; goto idle; \n\nfi;\n}\n\nactive proctype Link_0() { \nint buf=-1;\nbyte dest=0;\nbyte m=0;\nbyte m2=0;\nbyte data=0;\n\nlink0: if\n:: LDreq_0?buf; goto link0r; \n\n:: PAcon_0?m; goto link0a; \n\n:: PDind_0?m; goto link0i; \n\nfi;\nlink0r: if\n:: PAreq_0!108; goto link0; \n\nfi;\nlink0a: if\n:: m==111; goto link0; \n\n::  d_step {m==110;dest = buf;}  goto link2req; \n\nfi;\nlink0i: if\n:: m!=119; goto link0; \n\n:: m==119; goto link4; \n\nfi;\nlink2req: if\n:: PCind_0?0; goto q1; \n\nfi;\nq1: if\n:: PDreq_0!119; goto s1; \n\nfi;\ns1: if\n:: PCind_0?0; goto q2; \n\nfi;\nq2: if\n:: PDreq_0!118; goto s2; \n\nfi;\ns2: if\n:: PCind_0?0; goto q3; \n\nfi;\nq3: if\n:: PDreq_0!dest; goto s3; \n\nfi;\ns3: if\n:: PCind_0?0; goto q4; \n\nfi;\nq4: if\n:: PDreq_0!114; goto s4; \n\nfi;\ns4: if\n:: PCind_0?0; goto q5; \n\nfi;\nq5: if\n:: PDreq_0!116; goto s5; \n\nfi;\ns5: if\n:: PCind_0?0; goto q6; \n\nfi;\nq6: if\n:: PDreq_0!120; goto s6; \n\nfi;\ns6: if\n::  atomic {dest==3;LDcon_0!124;buf = -1;}  goto link0; \n\n:: dest<3; goto link3; \n\nfi;\nlink3: if\n:: PDind_0?m; goto link3q; \n\nfi;\nlink3q: if\n:: m==121; goto link3; \n\n::  atomic {m==122;LDcon_0!106;}  goto link0; \n\n:: m==119; goto link3A; \n\n::  atomic {m!=122 && m!=121 && m!=119;LDcon_0!106;dest = 3;}  goto linkWSA; \n\nfi;\nlink3A: if\n:: PDind_0?m; goto link3Aq; \n\nfi;\nlink3Aq: if\n::  atomic {m==119 || m==120 || m==122;LDcon_0!106;dest = 3;}  goto linkWSA; \n\n::  ! (m==119 || m==120 || m==122); goto link3RE; \n\nfi;\nlink3RE: if\n:: PDind_0?m2; goto link3REq1; \n\nfi;\nlink3REq1: if\n::  atomic {m==112 && (m2==121 || m2==120);LDcon_0!105;}  goto link3REq2; \n\n::  atomic { ! (m==112 && (m2==121 || m2==120));LDcon_0!106;}  goto link3REq2; \n\nfi;\nlink3REq2: if\n:: m2==122; goto link0; \n\n::  d_step {m2!=122;dest = 3;}  goto linkWSA; \n\nfi;\nlinkWSA: if\n:: PDind_0?m; goto linkWSAq; \n\n::  atomic {dest==0;PAcon_0?m;}  goto linkWSAa1; \n\nfi;\nlinkWSAq: if\n:: m!=122; goto linkWSA; \n\n:: m==122; goto link0; \n\nfi;\nlinkWSAa1: if\n::  atomic {m==110;PCind_0?0;}  goto linkWSAa2; \n\nfi;\nlinkWSAa2: if\n:: PDreq_0!120; goto link0; \n\nfi;\nlink4: if\n:: PDind_0?m; goto link4q; \n\nfi;\nlink4q: if\n:: m==122; goto link0; \n\n::  d_step {m==119 || m==120 || m==122;dest = 3;}  goto linkWSA; \n\n:: m!=122 &&  ! (m==119 || m==120 || m==122); goto link4DH; \n\nfi;\nlink4DH: if\n:: PDind_0?dest; goto link4DHq; \n\nfi;\nlink4DHq: if\n:: dest==122; goto link0; \n\n::  atomic {dest==0;PAreq_0!109;}  goto link4RH; \n\n:: dest==3; goto link4RH; \n\n::  d_step {dest!=122 && dest!=0 && dest!=3;dest = 3;}  goto linkWSA; \n\nfi;\nlink4RH: if\n:: PDind_0?m; goto link4RHq; \n\nfi;\nlink4RHq: if\n:: m==114; goto link4RD; \n\n:: m!=114; goto linkWSA; \n\nfi;\nlink4RD: if\n:: PDind_0?data; goto link4RDq; \n\nfi;\nlink4RDq: if\n:: data==116 || data==117; goto link4RE; \n\n::  ! (data==116 || data==117); goto linkWSA; \n\nfi;\nlink4RE: if\n:: PDind_0?m; goto link4REq; \n\nfi;\nlink4REq: if\n:: (m==120 || m==121) && dest==0; goto link4DRec; \n\n:: (m==120 || m==121) && dest==3; goto link4BRec; \n\n::  ! (m==120 || m==121); goto linkWSA; \n\nfi;\nlink4DRec: if\n::  atomic {data==116;LDind_0!103;}  goto link4DRecq; \n\n::  atomic {data==117;LDind_0!104;}  goto link4DRecq; \n\nfi;\nlink4BRec: if\n::  atomic {data==116;LDind_0!101;}  goto link0; \n\n:: data!=116; goto link0; \n\nfi;\nlink4DRecq: if\n:: PAcon_0?m; goto link4DRecq2; \n\nfi;\nlink4DRecq2: if\n:: m==110; goto link5; \n\nfi;\nlink5: if\n:: PCind_0?0; goto p1; \n\n:: LDres_0?m; goto link6; \n\nfi;\np1: if\n:: PDreq_0!121; goto link5; \n\nfi;\np2: if\n:: PDreq_0!119; goto p3; \n\nfi;\nlink6: if\n:: PCind_0?0; goto p2; \n\nfi;\np3: if\n:: PCind_0?0; goto p4; \n\nfi;\np4: if\n:: PDreq_0!112; goto p5; \n\nfi;\np5: if\n::  atomic {m==107;PDreq_0!120;}  goto link0; \n\n::  atomic {m!=107;PDreq_0!121;}  goto link7; \n\nfi;\np6: if\n:: PDreq_0!121; goto link7; \n\nfi;\nlink7: if\n:: PCind_0?0; goto p6; \n\n:: LDreq_0?dest; goto link2req; \n\nfi;\n}\n\nactive proctype Transreq_1() { \nbyte m=0;\n\nidle: if\n:: LDind_1?m; goto got_msg; \n\nfi;\ngot_msg: if\n::  atomic {m==101;LDres_1!100;}  goto idle; \n\n:: TX_1?0; goto concatenated_tr; \n\n::  goto split_tr; \n\nfi;\nconcatenated_tr: if\n:: LDres_1!102; goto idle; \n\nfi;\nsplit_tr: if\n:: LDres_1!107; goto idle; \n\nfi;\n}\n\nactive proctype Transres_1() { \nbyte dest=0;\nbyte m=0;\n\nidle: if\n:: TDreq_1?dest; goto got_req; \n\nfi;\ngot_req: if\n:: TX_1!0; goto q; \n\n::  goto q; \n\nfi;\nq: if\n:: LDreq_1!dest; goto wait_ack; \n\nfi;\nwait_ack: if\n:: LDcon_1?m; goto wait_q; \n\nfi;\nwait_q: if\n:: m==124 && dest==3; goto idle; \n\n:: m==105 && dest<3; goto idle; \n\n:: m==106 && dest<3; goto idle; \n\nfi;\n}\n\nactive proctype Link_1() { \nint buf=-1;\nbyte dest=0;\nbyte m=0;\nbyte m2=0;\nbyte data=0;\n\nlink0: if\n:: LDreq_1?buf; goto link0r; \n\n:: PAcon_1?m; goto link0a; \n\n:: PDind_1?m; goto link0i; \n\nfi;\nlink0r: if\n:: PAreq_1!108; goto link0; \n\nfi;\nlink0a: if\n:: m==111; goto link0; \n\n::  d_step {m==110;dest = buf;}  goto link2req; \n\nfi;\nlink0i: if\n:: m!=119; goto link0; \n\n:: m==119; goto link4; \n\nfi;\nlink2req: if\n:: PCind_1?0; goto q1; \n\nfi;\nq1: if\n:: PDreq_1!119; goto s1; \n\nfi;\ns1: if\n:: PCind_1?0; goto q2; \n\nfi;\nq2: if\n:: PDreq_1!118; goto s2; \n\nfi;\ns2: if\n:: PCind_1?0; goto q3; \n\nfi;\nq3: if\n:: PDreq_1!dest; goto s3; \n\nfi;\ns3: if\n:: PCind_1?0; goto q4; \n\nfi;\nq4: if\n:: PDreq_1!114; goto s4; \n\nfi;\ns4: if\n:: PCind_1?0; goto q5; \n\nfi;\nq5: if\n:: PDreq_1!116; goto s5; \n\nfi;\ns5: if\n:: PCind_1?0; goto q6; \n\nfi;\nq6: if\n:: PDreq_1!120; goto s6; \n\nfi;\ns6: if\n::  atomic {dest==3;LDcon_1!124;buf = -1;}  goto link0; \n\n:: dest<3; goto link3; \n\nfi;\nlink3: if\n:: PDind_1?m; goto link3q; \n\nfi;\nlink3q: if\n:: m==121; goto link3; \n\n::  atomic {m==122;LDcon_1!106;}  goto link0; \n\n:: m==119; goto link3A; \n\n::  atomic {m!=122 && m!=121 && m!=119;LDcon_1!106;dest = 3;}  goto linkWSA; \n\nfi;\nlink3A: if\n:: PDind_1?m; goto link3Aq; \n\nfi;\nlink3Aq: if\n::  atomic {m==119 || m==120 || m==122;LDcon_1!106;dest = 3;}  goto linkWSA; \n\n::  ! (m==119 || m==120 || m==122); goto link3RE; \n\nfi;\nlink3RE: if\n:: PDind_1?m2; goto link3REq1; \n\nfi;\nlink3REq1: if\n::  atomic {m==112 && (m2==121 || m2==120);LDcon_1!105;}  goto link3REq2; \n\n::  atomic { ! (m==112 && (m2==121 || m2==120));LDcon_1!106;}  goto link3REq2; \n\nfi;\nlink3REq2: if\n:: m2==122; goto link0; \n\n::  d_step {m2!=122;dest = 3;}  goto linkWSA; \n\nfi;\nlinkWSA: if\n:: PDind_1?m; goto linkWSAq; \n\n::  atomic {dest==1;PAcon_1?m;}  goto linkWSAa1; \n\nfi;\nlinkWSAq: if\n:: m!=122; goto linkWSA; \n\n:: m==122; goto link0; \n\nfi;\nlinkWSAa1: if\n::  atomic {m==110;PCind_1?0;}  goto linkWSAa2; \n\nfi;\nlinkWSAa2: if\n:: PDreq_1!120; goto link0; \n\nfi;\nlink4: if\n:: PDind_1?m; goto link4q; \n\nfi;\nlink4q: if\n:: m==122; goto link0; \n\n::  d_step {m==119 || m==120 || m==122;dest = 3;}  goto linkWSA; \n\n:: m!=122 &&  ! (m==119 || m==120 || m==122); goto link4DH; \n\nfi;\nlink4DH: if\n:: PDind_1?dest; goto link4DHq; \n\nfi;\nlink4DHq: if\n:: dest==122; goto link0; \n\n::  atomic {dest==1;PAreq_1!109;}  goto link4RH; \n\n:: dest==3; goto link4RH; \n\n::  d_step {dest!=122 && dest!=1 && dest!=3;dest = 3;}  goto linkWSA; \n\nfi;\nlink4RH: if\n:: PDind_1?m; goto link4RHq; \n\nfi;\nlink4RHq: if\n:: m==114; goto link4RD; \n\n:: m!=114; goto linkWSA; \n\nfi;\nlink4RD: if\n:: PDind_1?data; goto link4RDq; \n\nfi;\nlink4RDq: if\n:: data==116 || data==117; goto link4RE; \n\n::  ! (data==116 || data==117); goto linkWSA; \n\nfi;\nlink4RE: if\n:: PDind_1?m; goto link4REq; \n\nfi;\nlink4REq: if\n:: (m==120 || m==121) && dest==1; goto link4DRec; \n\n:: (m==120 || m==121) && dest==3; goto link4BRec; \n\n::  ! (m==120 || m==121); goto linkWSA; \n\nfi;\nlink4DRec: if\n::  atomic {data==116;LDind_1!103;}  goto link4DRecq; \n\n::  atomic {data==117;LDind_1!104;}  goto link4DRecq; \n\nfi;\nlink4BRec: if\n::  atomic {data==116;LDind_1!101;}  goto link0; \n\n:: data!=116; goto link0; \n\nfi;\nlink4DRecq: if\n:: PAcon_1?m; goto link4DRecq2; \n\nfi;\nlink4DRecq2: if\n:: m==110; goto link5; \n\nfi;\nlink5: if\n:: PCind_1?0; goto p1; \n\n:: LDres_1?m; goto link6; \n\nfi;\np1: if\n:: PDreq_1!121; goto link5; \n\nfi;\np2: if\n:: PDreq_1!119; goto p3; \n\nfi;\nlink6: if\n:: PCind_1?0; goto p2; \n\nfi;\np3: if\n:: PCind_1?0; goto p4; \n\nfi;\np4: if\n:: PDreq_1!112; goto p5; \n\nfi;\np5: if\n::  atomic {m==107;PDreq_1!120;}  goto link0; \n\n::  atomic {m!=107;PDreq_1!121;}  goto link7; \n\nfi;\np6: if\n:: PDreq_1!121; goto link7; \n\nfi;\nlink7: if\n:: PCind_1?0; goto p6; \n\n:: LDreq_1?dest; goto link2req; \n\nfi;\n}\n\nactive proctype Transreq_2() { \nbyte m=0;\n\nidle: if\n:: LDind_2?m; goto got_msg; \n\nfi;\ngot_msg: if\n::  atomic {m==101;LDres_2!100;}  goto idle; \n\n:: TX_2?0; goto concatenated_tr; \n\n::  goto split_tr; \n\nfi;\nconcatenated_tr: if\n:: LDres_2!102; goto idle; \n\nfi;\nsplit_tr: if\n:: LDres_2!107; goto idle; \n\nfi;\n}\n\nactive proctype Transres_2() { \nbyte dest=0;\nbyte m=0;\n\nidle: if\n:: TDreq_2?dest; goto got_req; \n\nfi;\ngot_req: if\n:: TX_2!0; goto q; \n\n::  goto q; \n\nfi;\nq: if\n:: LDreq_2!dest; goto wait_ack; \n\nfi;\nwait_ack: if\n:: LDcon_2?m; goto wait_q; \n\nfi;\nwait_q: if\n:: m==124 && dest==3; goto idle; \n\n:: m==105 && dest<3; goto idle; \n\n:: m==106 && dest<3; goto idle; \n\nfi;\n}\n\nactive proctype Link_2() { \nint buf=-1;\nbyte dest=0;\nbyte m=0;\nbyte m2=0;\nbyte data=0;\n\nlink0: if\n:: LDreq_2?buf; goto link0r; \n\n:: PAcon_2?m; goto link0a; \n\n:: PDind_2?m; goto link0i; \n\nfi;\nlink0r: if\n:: PAreq_2!108; goto link0; \n\nfi;\nlink0a: if\n:: m==111; goto link0; \n\n::  d_step {m==110;dest = buf;}  goto link2req; \n\nfi;\nlink0i: if\n:: m!=119; goto link0; \n\n:: m==119; goto link4; \n\nfi;\nlink2req: if\n:: PCind_2?0; goto q1; \n\nfi;\nq1: if\n:: PDreq_2!119; goto s1; \n\nfi;\ns1: if\n:: PCind_2?0; goto q2; \n\nfi;\nq2: if\n:: PDreq_2!118; goto s2; \n\nfi;\ns2: if\n:: PCind_2?0; goto q3; \n\nfi;\nq3: if\n:: PDreq_2!dest; goto s3; \n\nfi;\ns3: if\n:: PCind_2?0; goto q4; \n\nfi;\nq4: if\n:: PDreq_2!114; goto s4; \n\nfi;\ns4: if\n:: PCind_2?0; goto q5; \n\nfi;\nq5: if\n:: PDreq_2!116; goto s5; \n\nfi;\ns5: if\n:: PCind_2?0; goto q6; \n\nfi;\nq6: if\n:: PDreq_2!120; goto s6; \n\nfi;\ns6: if\n::  atomic {dest==3;LDcon_2!124;buf = -1;}  goto link0; \n\n:: dest<3; goto link3; \n\nfi;\nlink3: if\n:: PDind_2?m; goto link3q; \n\nfi;\nlink3q: if\n:: m==121; goto link3; \n\n::  atomic {m==122;LDcon_2!106;}  goto link0; \n\n:: m==119; goto link3A; \n\n::  atomic {m!=122 && m!=121 && m!=119;LDcon_2!106;dest = 3;}  goto linkWSA; \n\nfi;\nlink3A: if\n:: PDind_2?m; goto link3Aq; \n\nfi;\nlink3Aq: if\n::  atomic {m==119 || m==120 || m==122;LDcon_2!106;dest = 3;}  goto linkWSA; \n\n::  ! (m==119 || m==120 || m==122); goto link3RE; \n\nfi;\nlink3RE: if\n:: PDind_2?m2; goto link3REq1; \n\nfi;\nlink3REq1: if\n::  atomic {m==112 && (m2==121 || m2==120);LDcon_2!105;}  goto link3REq2; \n\n::  atomic { ! (m==112 && (m2==121 || m2==120));LDcon_2!106;}  goto link3REq2; \n\nfi;\nlink3REq2: if\n:: m2==122; goto link0; \n\n::  d_step {m2!=122;dest = 3;}  goto linkWSA; \n\nfi;\nlinkWSA: if\n:: PDind_2?m; goto linkWSAq; \n\n::  atomic {dest==2;PAcon_2?m;}  goto linkWSAa1; \n\nfi;\nlinkWSAq: if\n:: m!=122; goto linkWSA; \n\n:: m==122; goto link0; \n\nfi;\nlinkWSAa1: if\n::  atomic {m==110;PCind_2?0;}  goto linkWSAa2; \n\nfi;\nlinkWSAa2: if\n:: PDreq_2!120; goto link0; \n\nfi;\nlink4: if\n:: PDind_2?m; goto link4q; \n\nfi;\nlink4q: if\n:: m==122; goto link0; \n\n::  d_step {m==119 || m==120 || m==122;dest = 3;}  goto linkWSA; \n\n:: m!=122 &&  ! (m==119 || m==120 || m==122); goto link4DH; \n\nfi;\nlink4DH: if\n:: PDind_2?dest; goto link4DHq; \n\nfi;\nlink4DHq: if\n:: dest==122; goto link0; \n\n::  atomic {dest==2;PAreq_2!109;}  goto link4RH; \n\n:: dest==3; goto link4RH; \n\n::  d_step {dest!=122 && dest!=2 && dest!=3;dest = 3;}  goto linkWSA; \n\nfi;\nlink4RH: if\n:: PDind_2?m; goto link4RHq; \n\nfi;\nlink4RHq: if\n:: m==114; goto link4RD; \n\n:: m!=114; goto linkWSA; \n\nfi;\nlink4RD: if\n:: PDind_2?data; goto link4RDq; \n\nfi;\nlink4RDq: if\n:: data==116 || data==117; goto link4RE; \n\n::  ! (data==116 || data==117); goto linkWSA; \n\nfi;\nlink4RE: if\n:: PDind_2?m; goto link4REq; \n\nfi;\nlink4REq: if\n:: (m==120 || m==121) && dest==2; goto link4DRec; \n\n:: (m==120 || m==121) && dest==3; goto link4BRec; \n\n::  ! (m==120 || m==121); goto linkWSA; \n\nfi;\nlink4DRec: if\n::  atomic {data==116;LDind_2!103;}  goto link4DRecq; \n\n::  atomic {data==117;LDind_2!104;}  goto link4DRecq; \n\nfi;\nlink4BRec: if\n::  atomic {data==116;LDind_2!101;}  goto link0; \n\n:: data!=116; goto link0; \n\nfi;\nlink4DRecq: if\n:: PAcon_2?m; goto link4DRecq2; \n\nfi;\nlink4DRecq2: if\n:: m==110; goto link5; \n\nfi;\nlink5: if\n:: PCind_2?0; goto p1; \n\n:: LDres_2?m; goto link6; \n\nfi;\np1: if\n:: PDreq_2!121; goto link5; \n\nfi;\np2: if\n:: PDreq_2!119; goto p3; \n\nfi;\nlink6: if\n:: PCind_2?0; goto p2; \n\nfi;\np3: if\n:: PCind_2?0; goto p4; \n\nfi;\np4: if\n:: PDreq_2!112; goto p5; \n\nfi;\np5: if\n::  atomic {m==107;PDreq_2!120;}  goto link0; \n\n::  atomic {m!=107;PDreq_2!121;}  goto link7; \n\nfi;\np6: if\n:: PDreq_2!121; goto link7; \n\nfi;\nlink7: if\n:: PCind_2?0; goto p6; \n\n:: LDreq_2?dest; goto link2req; \n\nfi;\n}\n\nactive proctype Bus() { \nbyte t[3];\nbyte destfault[3];\nbyte next[3];\nbyte i=0;\nbyte j=0;\nbyte m=0;\nbyte busy=0;\n\nidle: if\n::  ! (t[0]==0 && t[1]==0 && t[2]==0); goto arbresgab; \n\n::  atomic {PAreq_0?m;i = 0;}  goto idleq; \n\n::  atomic {PAreq_1?m;i = 1;}  goto idleq; \n\n::  atomic {PAreq_2?m;i = 2;}  goto idleq; \n\nfi;\narbresgab: if\n::  d_step {t[0] = 0;t[1] = 0;t[2] = 0;}  goto idle; \n\nfi;\nidleq: if\n::  atomic {i==0 && t[i]==1;PAcon_0!111;}  goto idle; \n\n::  atomic {i==1 && t[i]==1;PAcon_1!111;}  goto idle; \n\n::  atomic {i==2 && t[i]==1;PAcon_2!111;}  goto idle; \n\n::  atomic {i==0 && t[i]==0;PAcon_0!110;t[i] = 1;busy = i;}  goto bus_busy; \n\n::  atomic {i==1 && t[i]==0;PAcon_1!110;t[i] = 1;busy = i;}  goto bus_busy; \n\n::  atomic {i==2 && t[i]==0;PAcon_2!110;t[i] = 1;busy = i;}  goto bus_busy; \n\nfi;\nbus_busy: if\n::  atomic {PAreq_0?m;i = 0;}  goto busyq; \n\n::  atomic {PAreq_1?m;i = 1;}  goto busyq; \n\n::  atomic {PAreq_2?m;i = 2;}  goto busyq; \n\n::  atomic {busy==0;PCind_0!0;}  goto get_next_packet; \n\n::  atomic {busy==1;PCind_1!0;}  goto get_next_packet; \n\n::  atomic {busy==2;PCind_2!0;}  goto get_next_packet; \n\n::  d_step {busy==3 && next[0]==0 && next[1]==0 && next[2]==0;j = 0;}  goto sub_action_gab; \n\n::  d_step {busy==3 &&  ! (next[0]==0 && next[1]==0 && next[2]==0);j = 0;}  goto resolve; \n\nfi;\nbusyq: if\n::  atomic {m==108 && i==0;PAcon_0!111;}  goto bus_busy; \n\n::  atomic {m==108 && i==1;PAcon_1!111;}  goto bus_busy; \n\n::  atomic {m==108 && i==2;PAcon_2!111;}  goto bus_busy; \n\n::  d_step {m==109;next[i] = 1;}  goto bus_busy; \n\nfi;\nsub_action_gab: if\n::  atomic {0==j;PDind_0!122;j = j+1;}  goto sub_action_gab; \n\n::  atomic {1==j;PDind_1!122;j = j+1;}  goto sub_action_gab; \n\n::  atomic {2==j;PDind_2!122;j = j+1;}  goto sub_action_gab; \n\n:: j==3; goto idle; \n\nfi;\nget_next_packet: if\n::  atomic {busy==0;PDreq_0?m;j = 0;}  goto distribute; \n\n::  atomic {busy==1;PDreq_1?m;j = 0;}  goto distribute; \n\n::  atomic {busy==2;PDreq_2?m;j = 0;}  goto distribute; \n\nfi;\nresolve: if\n::  d_step {j<3 && next[j]==0;j = j+1;}  goto resolve; \n\n::  atomic {0==j && next[j]==1;PAcon_0!110;}  goto resolveq; \n\n::  atomic {1==j && next[j]==1;PAcon_1!110;}  goto resolveq; \n\n::  atomic {2==j && next[j]==1;PAcon_2!110;}  goto resolveq; \n\n:: j==3; goto resolve2; \n\nfi;\nresolveq: if\n::  atomic {0==j;PCind_0!0;j = j+1;}  goto resolve; \n\n::  atomic {1==j;PCind_1!0;j = j+1;}  goto resolve; \n\n::  atomic {2==j;PCind_2!0;j = j+1;}  goto resolve; \n\nfi;\nresolve2: if\n::  atomic {PDreq_0?m;j = 0;}  goto resolve2q; \n\n::  atomic {PDreq_1?m;j = 1;}  goto resolve2q; \n\n::  atomic {PDreq_2?m;j = 2;}  goto resolve2q; \n\nfi;\nresolve2q: if\n::  ! ((next[0]==0 && next[1]==0 && next[2]==0) || (next[0]+next[1]+next[2]==1)) && m!=120; goto resolve; \n\n::  d_step { ! ((next[0]==0 && next[1]==0 && next[2]==0) || (next[0]+next[1]+next[2]==1)) && m==120;next[j] = 0;}  goto resolve; \n\n::  d_step {(next[0]+next[1]+next[2]==1) && m==120;next[j] = 0;j = 0;}  goto sub_action_gab; \n\n::  d_step {(next[0]+next[1]+next[2]==1) && m!=120;busy = j;next[j] = 0;j = 0;}  goto distribute; \n\nfi;\ndistribute: if\n::  d_step {j==busy;j = j+1;}  goto distribute; \n\n::  atomic {0==j;PAreq_0?m;}  goto distributeq; \n\n::  atomic {1==j;PAreq_1?m;}  goto distributeq; \n\n::  atomic {2==j;PAreq_2?m;}  goto distributeq; \n\n::  atomic {0==j &&  ! (m==114 && destfault[j]==1);PDind_0!m;j = j+1;}  goto distribute; \n\n::  atomic {1==j &&  ! (m==114 && destfault[j]==1);PDind_1!m;j = j+1;}  goto distribute; \n\n::  atomic {2==j &&  ! (m==114 && destfault[j]==1);PDind_2!m;j = j+1;}  goto distribute; \n\n::  atomic {0==j && m==116;PDind_0!m;}  goto data_dummy; \n\n::  atomic {1==j && m==116;PDind_1!m;}  goto data_dummy; \n\n::  atomic {2==j && m==116;PDind_2!m;}  goto data_dummy; \n\n::  atomic {0==j && m==116;PDind_0!117;j = j+1;}  goto distribute; \n\n::  atomic {1==j && m==116;PDind_1!117;j = j+1;}  goto distribute; \n\n::  atomic {2==j && m==116;PDind_2!117;j = j+1;}  goto distribute; \n\n::  atomic {0==j && m==114;PDind_0!115;j = j+1;}  goto distribute; \n\n::  atomic {1==j && m==114;PDind_1!115;j = j+1;}  goto distribute; \n\n::  atomic {2==j && m==114;PDind_2!115;j = j+1;}  goto distribute; \n\n::  atomic {0==j && m==112;PDind_0!113;j = j+1;}  goto distribute; \n\n::  atomic {1==j && m==112;PDind_1!113;j = j+1;}  goto distribute; \n\n::  atomic {2==j && m==112;PDind_2!113;j = j+1;}  goto distribute; \n\n::  d_step {j!=busy && j<3 && m<100;destfault[j] = 1;i = 0;}  goto dest_cor; \n\n::  d_step {j!=busy && j<3 && m<100;destfault[j] = 1;i = 1;}  goto dest_cor; \n\n::  d_step {j!=busy && j<3 && m<100;destfault[j] = 1;i = 2;}  goto dest_cor; \n\n:: j==3 && m!=120; goto bus_busy; \n\n::  d_step {j==3 && m==120;busy = 3;}  goto bus_busy; \n\nfi;\ndistributeq: if\n::  atomic {m==108 && j==0;PAcon_0!111;}  goto distribute; \n\n::  atomic {m==108 && j==1;PAcon_1!111;}  goto distribute; \n\n::  atomic {m==108 && j==2;PAcon_2!111;}  goto distribute; \n\n::  d_step {m==109;next[j] = 1;}  goto distribute; \n\nfi;\ndest_cor: if\n::  atomic {0==j;PDind_0!i;j = j+1;}  goto distribute; \n\n::  atomic {1==j;PDind_1!i;j = j+1;}  goto distribute; \n\n::  atomic {2==j;PDind_2!i;j = j+1;}  goto distribute; \n\nfi;\ndata_dummy: if\n::  atomic {0==j;PDind_0!123;j = j+1;}  goto distribute; \n\n::  atomic {1==j;PDind_1!123;j = j+1;}  goto distribute; \n\n::  atomic {2==j;PDind_2!123;j = j+1;}  goto distribute; \n\nfi;\n}\n\nactive proctype Application_0() { \n\nq: if\n:: TDreq_0!1; goto r; \n\nfi;\nr: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "This is model of the \"FireWire\" high performance serial\n    bus defined in the IEEE-1394 Standard. The bus involves n nodes\n    (addressable entities that run their own part of the protocol) connected by\n    a serial line. On each node the IEEE-1394 protocol consists of three stacke\n    layers: the transaction layer, the link layer, and th physical layer. The\n    protocol implemented by the link layer is designed to transmit data packets\n    over an unreliable medium to a specific node or to all nodes (broadcast).\n    The transmission can be performed synchronously or\n    asynchronously.\n\nParameters:"}, {"role": "assistant", "content": "chan LDreq_0 =[0] of {int};\nchan LDres_0 =[0] of {int};\nchan LDcon_0 =[0] of {int};\nchan LDind_0 =[0] of {int};\nchan TX_0 =[0] of {int};\nchan PDreq_0 =[0] of {int};\nchan PDind_0 =[0] of {int};\nchan PAreq_0 =[0] of {int};\nchan PAcon_0 =[0] of {int};\nchan PCind_0 =[0] of {int};\nchan TDreq_0 =[0] of {int};\nchan LDreq_1 =[0] of {int};\nchan LDres_1 =[0] of {int};\nchan LDcon_1 =[0] of {int};\nchan LDind_1 =[0] of {int};\nchan TX_1 =[0] of {int};\nchan PDreq_1 =[0] of {int};\nchan PDind_1 =[0] of {int};\nchan PAreq_1 =[0] of {int};\nchan PAcon_1 =[0] of {int};\nchan PCind_1 =[0] of {int};\nchan TDreq_1 =[0] of {int};\nchan LDreq_2 =[0] of {int};\nchan LDres_2 =[0] of {int};\nchan LDcon_2 =[0] of {int};\nchan LDind_2 =[0] of {int};\nchan TX_2 =[0] of {int};\nchan PDreq_2 =[0] of {int};\nchan PDind_2 =[0] of {int};\nchan PAreq_2 =[0] of {int};\nchan PAcon_2 =[0] of {int};\nchan PCind_2 =[0] of {int};\nchan TDreq_2 =[0] of {int};\n\nactive proctype Transreq_0() { \nbyte m=0;\n\nidle: if\n:: LDind_0?m; goto got_msg; \n\nfi;\ngot_msg: if\n::  atomic {m==101;LDres_0!100;}  goto idle; \n\n:: TX_0?0; goto concatenated_tr; \n\n::  goto split_tr; \n\nfi;\nconcatenated_tr: if\n:: LDres_0!102; goto idle; \n\nfi;\nsplit_tr: if\n:: LDres_0!107; goto idle; \n\nfi;\n}\n\nactive proctype Transres_0() { \nbyte dest=0;\nbyte m=0;\n\nidle: if\n:: TDreq_0?dest; goto got_req; \n\nfi;\ngot_req: if\n:: TX_0!0; goto q; \n\n::  goto q; \n\nfi;\nq: if\n:: LDreq_0!dest; goto wait_ack; \n\nfi;\nwait_ack: if\n:: LDcon_0?m; goto wait_q; \n\nfi;\nwait_q: if\n:: m==124 && dest==3; goto idle; \n\n:: m==105 && dest<3; goto idle; \n\n:: m==106 && dest<3; goto idle; \n\nfi;\n}\n\nactive proctype Link_0() { \nint buf=-1;\nbyte dest=0;\nbyte m=0;\nbyte m2=0;\nbyte data=0;\n\nlink0: if\n:: LDreq_0?buf; goto link0r; \n\n:: PAcon_0?m; goto link0a; \n\n:: PDind_0?m; goto link0i; \n\nfi;\nlink0r: if\n:: PAreq_0!108; goto link0; \n\nfi;\nlink0a: if\n:: m==111; goto link0; \n\n::  d_step {m==110;dest = buf;}  goto link2req; \n\nfi;\nlink0i: if\n:: m!=119; goto link0; \n\n:: m==119; goto link4; \n\nfi;\nlink2req: if\n:: PCind_0?0; goto q1; \n\nfi;\nq1: if\n:: PDreq_0!119; goto s1; \n\nfi;\ns1: if\n:: PCind_0?0; goto q2; \n\nfi;\nq2: if\n:: PDreq_0!118; goto s2; \n\nfi;\ns2: if\n:: PCind_0?0; goto q3; \n\nfi;\nq3: if\n:: PDreq_0!dest; goto s3; \n\nfi;\ns3: if\n:: PCind_0?0; goto q4; \n\nfi;\nq4: if\n:: PDreq_0!114; goto s4; \n\nfi;\ns4: if\n:: PCind_0?0; goto q5; \n\nfi;\nq5: if\n:: PDreq_0!116; goto s5; \n\nfi;\ns5: if\n:: PCind_0?0; goto q6; \n\nfi;\nq6: if\n:: PDreq_0!120; goto s6; \n\nfi;\ns6: if\n::  atomic {dest==3;LDcon_0!124;buf = -1;}  goto link0; \n\n:: dest<3; goto link3; \n\nfi;\nlink3: if\n:: PDind_0?m; goto link3q; \n\nfi;\nlink3q: if\n:: m==121; goto link3; \n\n::  atomic {m==122;LDcon_0!106;}  goto link0; \n\n:: m==119; goto link3A; \n\n::  atomic {m!=122 && m!=121 && m!=119;LDcon_0!106;dest = 3;}  goto linkWSA; \n\nfi;\nlink3A: if\n:: PDind_0?m; goto link3Aq; \n\nfi;\nlink3Aq: if\n::  atomic {m==119 || m==120 || m==122;LDcon_0!106;dest = 3;}  goto linkWSA; \n\n::  ! (m==119 || m==120 || m==122); goto link3RE; \n\nfi;\nlink3RE: if\n:: PDind_0?m2; goto link3REq1; \n\nfi;\nlink3REq1: if\n::  atomic {m==112 && (m2==121 || m2==120);LDcon_0!105;}  goto link3REq2; \n\n::  atomic { ! (m==112 && (m2==121 || m2==120));LDcon_0!106;}  goto link3REq2; \n\nfi;\nlink3REq2: if\n:: m2==122; goto link0; \n\n::  d_step {m2!=122;dest = 3;}  goto linkWSA; \n\nfi;\nlinkWSA: if\n:: PDind_0?m; goto linkWSAq; \n\n::  atomic {dest==0;PAcon_0?m;}  goto linkWSAa1; \n\nfi;\nlinkWSAq: if\n:: m!=122; goto linkWSA; \n\n:: m==122; goto link0; \n\nfi;\nlinkWSAa1: if\n::  atomic {m==110;PCind_0?0;}  goto linkWSAa2; \n\nfi;\nlinkWSAa2: if\n:: PDreq_0!120; goto link0; \n\nfi;\nlink4: if\n:: PDind_0?m; goto link4q; \n\nfi;\nlink4q: if\n:: m==122; goto link0; \n\n::  d_step {m==119 || m==120 || m==122;dest = 3;}  goto linkWSA; \n\n:: m!=122 &&  ! (m==119 || m==120 || m==122); goto link4DH; \n\nfi;\nlink4DH: if\n:: PDind_0?dest; goto link4DHq; \n\nfi;\nlink4DHq: if\n:: dest==122; goto link0; \n\n::  atomic {dest==0;PAreq_0!109;}  goto link4RH; \n\n:: dest==3; goto link4RH; \n\n::  d_step {dest!=122 && dest!=0 && dest!=3;dest = 3;}  goto linkWSA; \n\nfi;\nlink4RH: if\n:: PDind_0?m; goto link4RHq; \n\nfi;\nlink4RHq: if\n:: m==114; goto link4RD; \n\n:: m!=114; goto linkWSA; \n\nfi;\nlink4RD: if\n:: PDind_0?data; goto link4RDq; \n\nfi;\nlink4RDq: if\n:: data==116 || data==117; goto link4RE; \n\n::  ! (data==116 || data==117); goto linkWSA; \n\nfi;\nlink4RE: if\n:: PDind_0?m; goto link4REq; \n\nfi;\nlink4REq: if\n:: (m==120 || m==121) && dest==0; goto link4DRec; \n\n:: (m==120 || m==121) && dest==3; goto link4BRec; \n\n::  ! (m==120 || m==121); goto linkWSA; \n\nfi;\nlink4DRec: if\n::  atomic {data==116;LDind_0!103;}  goto link4DRecq; \n\n::  atomic {data==117;LDind_0!104;}  goto link4DRecq; \n\nfi;\nlink4BRec: if\n::  atomic {data==116;LDind_0!101;}  goto link0; \n\n:: data!=116; goto link0; \n\nfi;\nlink4DRecq: if\n:: PAcon_0?m; goto link4DRecq2; \n\nfi;\nlink4DRecq2: if\n:: m==110; goto link5; \n\nfi;\nlink5: if\n:: PCind_0?0; goto p1; \n\n:: LDres_0?m; goto link6; \n\nfi;\np1: if\n:: PDreq_0!121; goto link5; \n\nfi;\np2: if\n:: PDreq_0!119; goto p3; \n\nfi;\nlink6: if\n:: PCind_0?0; goto p2; \n\nfi;\np3: if\n:: PCind_0?0; goto p4; \n\nfi;\np4: if\n:: PDreq_0!112; goto p5; \n\nfi;\np5: if\n::  atomic {m==107;PDreq_0!120;}  goto link0; \n\n::  atomic {m!=107;PDreq_0!121;}  goto link7; \n\nfi;\np6: if\n:: PDreq_0!121; goto link7; \n\nfi;\nlink7: if\n:: PCind_0?0; goto p6; \n\n:: LDreq_0?dest; goto link2req; \n\nfi;\n}\n\nactive proctype Transreq_1() { \nbyte m=0;\n\nidle: if\n:: LDind_1?m; goto got_msg; \n\nfi;\ngot_msg: if\n::  atomic {m==101;LDres_1!100;}  goto idle; \n\n:: TX_1?0; goto concatenated_tr; \n\n::  goto split_tr; \n\nfi;\nconcatenated_tr: if\n:: LDres_1!102; goto idle; \n\nfi;\nsplit_tr: if\n:: LDres_1!107; goto idle; \n\nfi;\n}\n\nactive proctype Transres_1() { \nbyte dest=0;\nbyte m=0;\n\nidle: if\n:: TDreq_1?dest; goto got_req; \n\nfi;\ngot_req: if\n:: TX_1!0; goto q; \n\n::  goto q; \n\nfi;\nq: if\n:: LDreq_1!dest; goto wait_ack; \n\nfi;\nwait_ack: if\n:: LDcon_1?m; goto wait_q; \n\nfi;\nwait_q: if\n:: m==124 && dest==3; goto idle; \n\n:: m==105 && dest<3; goto idle; \n\n:: m==106 && dest<3; goto idle; \n\nfi;\n}\n\nactive proctype Link_1() { \nint buf=-1;\nbyte dest=0;\nbyte m=0;\nbyte m2=0;\nbyte data=0;\n\nlink0: if\n:: LDreq_1?buf; goto link0r; \n\n:: PAcon_1?m; goto link0a; \n\n:: PDind_1?m; goto link0i; \n\nfi;\nlink0r: if\n:: PAreq_1!108; goto link0; \n\nfi;\nlink0a: if\n:: m==111; goto link0; \n\n::  d_step {m==110;dest = buf;}  goto link2req; \n\nfi;\nlink0i: if\n:: m!=119; goto link0; \n\n:: m==119; goto link4; \n\nfi;\nlink2req: if\n:: PCind_1?0; goto q1; \n\nfi;\nq1: if\n:: PDreq_1!119; goto s1; \n\nfi;\ns1: if\n:: PCind_1?0; goto q2; \n\nfi;\nq2: if\n:: PDreq_1!118; goto s2; \n\nfi;\ns2: if\n:: PCind_1?0; goto q3; \n\nfi;\nq3: if\n:: PDreq_1!dest; goto s3; \n\nfi;\ns3: if\n:: PCind_1?0; goto q4; \n\nfi;\nq4: if\n:: PDreq_1!114; goto s4; \n\nfi;\ns4: if\n:: PCind_1?0; goto q5; \n\nfi;\nq5: if\n:: PDreq_1!116; goto s5; \n\nfi;\ns5: if\n:: PCind_1?0; goto q6; \n\nfi;\nq6: if\n:: PDreq_1!120; goto s6; \n\nfi;\ns6: if\n::  atomic {dest==3;LDcon_1!124;buf = -1;}  goto link0; \n\n:: dest<3; goto link3; \n\nfi;\nlink3: if\n:: PDind_1?m; goto link3q; \n\nfi;\nlink3q: if\n:: m==121; goto link3; \n\n::  atomic {m==122;LDcon_1!106;}  goto link0; \n\n:: m==119; goto link3A; \n\n::  atomic {m!=122 && m!=121 && m!=119;LDcon_1!106;dest = 3;}  goto linkWSA; \n\nfi;\nlink3A: if\n:: PDind_1?m; goto link3Aq; \n\nfi;\nlink3Aq: if\n::  atomic {m==119 || m==120 || m==122;LDcon_1!106;dest = 3;}  goto linkWSA; \n\n::  ! (m==119 || m==120 || m==122); goto link3RE; \n\nfi;\nlink3RE: if\n:: PDind_1?m2; goto link3REq1; \n\nfi;\nlink3REq1: if\n::  atomic {m==112 && (m2==121 || m2==120);LDcon_1!105;}  goto link3REq2; \n\n::  atomic { ! (m==112 && (m2==121 || m2==120));LDcon_1!106;}  goto link3REq2; \n\nfi;\nlink3REq2: if\n:: m2==122; goto link0; \n\n::  d_step {m2!=122;dest = 3;}  goto linkWSA; \n\nfi;\nlinkWSA: if\n:: PDind_1?m; goto linkWSAq; \n\n::  atomic {dest==1;PAcon_1?m;}  goto linkWSAa1; \n\nfi;\nlinkWSAq: if\n:: m!=122; goto linkWSA; \n\n:: m==122; goto link0; \n\nfi;\nlinkWSAa1: if\n::  atomic {m==110;PCind_1?0;}  goto linkWSAa2; \n\nfi;\nlinkWSAa2: if\n:: PDreq_1!120; goto link0; \n\nfi;\nlink4: if\n:: PDind_1?m; goto link4q; \n\nfi;\nlink4q: if\n:: m==122; goto link0; \n\n::  d_step {m==119 || m==120 || m==122;dest = 3;}  goto linkWSA; \n\n:: m!=122 &&  ! (m==119 || m==120 || m==122); goto link4DH; \n\nfi;\nlink4DH: if\n:: PDind_1?dest; goto link4DHq; \n\nfi;\nlink4DHq: if\n:: dest==122; goto link0; \n\n::  atomic {dest==1;PAreq_1!109;}  goto link4RH; \n\n:: dest==3; goto link4RH; \n\n::  d_step {dest!=122 && dest!=1 && dest!=3;dest = 3;}  goto linkWSA; \n\nfi;\nlink4RH: if\n:: PDind_1?m; goto link4RHq; \n\nfi;\nlink4RHq: if\n:: m==114; goto link4RD; \n\n:: m!=114; goto linkWSA; \n\nfi;\nlink4RD: if\n:: PDind_1?data; goto link4RDq; \n\nfi;\nlink4RDq: if\n:: data==116 || data==117; goto link4RE; \n\n::  ! (data==116 || data==117); goto linkWSA; \n\nfi;\nlink4RE: if\n:: PDind_1?m; goto link4REq; \n\nfi;\nlink4REq: if\n:: (m==120 || m==121) && dest==1; goto link4DRec; \n\n:: (m==120 || m==121) && dest==3; goto link4BRec; \n\n::  ! (m==120 || m==121); goto linkWSA; \n\nfi;\nlink4DRec: if\n::  atomic {data==116;LDind_1!103;}  goto link4DRecq; \n\n::  atomic {data==117;LDind_1!104;}  goto link4DRecq; \n\nfi;\nlink4BRec: if\n::  atomic {data==116;LDind_1!101;}  goto link0; \n\n:: data!=116; goto link0; \n\nfi;\nlink4DRecq: if\n:: PAcon_1?m; goto link4DRecq2; \n\nfi;\nlink4DRecq2: if\n:: m==110; goto link5; \n\nfi;\nlink5: if\n:: PCind_1?0; goto p1; \n\n:: LDres_1?m; goto link6; \n\nfi;\np1: if\n:: PDreq_1!121; goto link5; \n\nfi;\np2: if\n:: PDreq_1!119; goto p3; \n\nfi;\nlink6: if\n:: PCind_1?0; goto p2; \n\nfi;\np3: if\n:: PCind_1?0; goto p4; \n\nfi;\np4: if\n:: PDreq_1!112; goto p5; \n\nfi;\np5: if\n::  atomic {m==107;PDreq_1!120;}  goto link0; \n\n::  atomic {m!=107;PDreq_1!121;}  goto link7; \n\nfi;\np6: if\n:: PDreq_1!121; goto link7; \n\nfi;\nlink7: if\n:: PCind_1?0; goto p6; \n\n:: LDreq_1?dest; goto link2req; \n\nfi;\n}\n\nactive proctype Transreq_2() { \nbyte m=0;\n\nidle: if\n:: LDind_2?m; goto got_msg; \n\nfi;\ngot_msg: if\n::  atomic {m==101;LDres_2!100;}  goto idle; \n\n:: TX_2?0; goto concatenated_tr; \n\n::  goto split_tr; \n\nfi;\nconcatenated_tr: if\n:: LDres_2!102; goto idle; \n\nfi;\nsplit_tr: if\n:: LDres_2!107; goto idle; \n\nfi;\n}\n\nactive proctype Transres_2() { \nbyte dest=0;\nbyte m=0;\n\nidle: if\n:: TDreq_2?dest; goto got_req; \n\nfi;\ngot_req: if\n:: TX_2!0; goto q; \n\n::  goto q; \n\nfi;\nq: if\n:: LDreq_2!dest; goto wait_ack; \n\nfi;\nwait_ack: if\n:: LDcon_2?m; goto wait_q; \n\nfi;\nwait_q: if\n:: m==124 && dest==3; goto idle; \n\n:: m==105 && dest<3; goto idle; \n\n:: m==106 && dest<3; goto idle; \n\nfi;\n}\n\nactive proctype Link_2() { \nint buf=-1;\nbyte dest=0;\nbyte m=0;\nbyte m2=0;\nbyte data=0;\n\nlink0: if\n:: LDreq_2?buf; goto link0r; \n\n:: PAcon_2?m; goto link0a; \n\n:: PDind_2?m; goto link0i; \n\nfi;\nlink0r: if\n:: PAreq_2!108; goto link0; \n\nfi;\nlink0a: if\n:: m==111; goto link0; \n\n::  d_step {m==110;dest = buf;}  goto link2req; \n\nfi;\nlink0i: if\n:: m!=119; goto link0; \n\n:: m==119; goto link4; \n\nfi;\nlink2req: if\n:: PCind_2?0; goto q1; \n\nfi;\nq1: if\n:: PDreq_2!119; goto s1; \n\nfi;\ns1: if\n:: PCind_2?0; goto q2; \n\nfi;\nq2: if\n:: PDreq_2!118; goto s2; \n\nfi;\ns2: if\n:: PCind_2?0; goto q3; \n\nfi;\nq3: if\n:: PDreq_2!dest; goto s3; \n\nfi;\ns3: if\n:: PCind_2?0; goto q4; \n\nfi;\nq4: if\n:: PDreq_2!114; goto s4; \n\nfi;\ns4: if\n:: PCind_2?0; goto q5; \n\nfi;\nq5: if\n:: PDreq_2!116; goto s5; \n\nfi;\ns5: if\n:: PCind_2?0; goto q6; \n\nfi;\nq6: if\n:: PDreq_2!120; goto s6; \n\nfi;\ns6: if\n::  atomic {dest==3;LDcon_2!124;buf = -1;}  goto link0; \n\n:: dest<3; goto link3; \n\nfi;\nlink3: if\n:: PDind_2?m; goto link3q; \n\nfi;\nlink3q: if\n:: m==121; goto link3; \n\n::  atomic {m==122;LDcon_2!106;}  goto link0; \n\n:: m==119; goto link3A; \n\n::  atomic {m!=122 && m!=121 && m!=119;LDcon_2!106;dest = 3;}  goto linkWSA; \n\nfi;\nlink3A: if\n:: PDind_2?m; goto link3Aq; \n\nfi;\nlink3Aq: if\n::  atomic {m==119 || m==120 || m==122;LDcon_2!106;dest = 3;}  goto linkWSA; \n\n::  ! (m==119 || m==120 || m==122); goto link3RE; \n\nfi;\nlink3RE: if\n:: PDind_2?m2; goto link3REq1; \n\nfi;\nlink3REq1: if\n::  atomic {m==112 && (m2==121 || m2==120);LDcon_2!105;}  goto link3REq2; \n\n::  atomic { ! (m==112 && (m2==121 || m2==120));LDcon_2!106;}  goto link3REq2; \n\nfi;\nlink3REq2: if\n:: m2==122; goto link0; \n\n::  d_step {m2!=122;dest = 3;}  goto linkWSA; \n\nfi;\nlinkWSA: if\n:: PDind_2?m; goto linkWSAq; \n\n::  atomic {dest==2;PAcon_2?m;}  goto linkWSAa1; \n\nfi;\nlinkWSAq: if\n:: m!=122; goto linkWSA; \n\n:: m==122; goto link0; \n\nfi;\nlinkWSAa1: if\n::  atomic {m==110;PCind_2?0;}  goto linkWSAa2; \n\nfi;\nlinkWSAa2: if\n:: PDreq_2!120; goto link0; \n\nfi;\nlink4: if\n:: PDind_2?m; goto link4q; \n\nfi;\nlink4q: if\n:: m==122; goto link0; \n\n::  d_step {m==119 || m==120 || m==122;dest = 3;}  goto linkWSA; \n\n:: m!=122 &&  ! (m==119 || m==120 || m==122); goto link4DH; \n\nfi;\nlink4DH: if\n:: PDind_2?dest; goto link4DHq; \n\nfi;\nlink4DHq: if\n:: dest==122; goto link0; \n\n::  atomic {dest==2;PAreq_2!109;}  goto link4RH; \n\n:: dest==3; goto link4RH; \n\n::  d_step {dest!=122 && dest!=2 && dest!=3;dest = 3;}  goto linkWSA; \n\nfi;\nlink4RH: if\n:: PDind_2?m; goto link4RHq; \n\nfi;\nlink4RHq: if\n:: m==114; goto link4RD; \n\n:: m!=114; goto linkWSA; \n\nfi;\nlink4RD: if\n:: PDind_2?data; goto link4RDq; \n\nfi;\nlink4RDq: if\n:: data==116 || data==117; goto link4RE; \n\n::  ! (data==116 || data==117); goto linkWSA; \n\nfi;\nlink4RE: if\n:: PDind_2?m; goto link4REq; \n\nfi;\nlink4REq: if\n:: (m==120 || m==121) && dest==2; goto link4DRec; \n\n:: (m==120 || m==121) && dest==3; goto link4BRec; \n\n::  ! (m==120 || m==121); goto linkWSA; \n\nfi;\nlink4DRec: if\n::  atomic {data==116;LDind_2!103;}  goto link4DRecq; \n\n::  atomic {data==117;LDind_2!104;}  goto link4DRecq; \n\nfi;\nlink4BRec: if\n::  atomic {data==116;LDind_2!101;}  goto link0; \n\n:: data!=116; goto link0; \n\nfi;\nlink4DRecq: if\n:: PAcon_2?m; goto link4DRecq2; \n\nfi;\nlink4DRecq2: if\n:: m==110; goto link5; \n\nfi;\nlink5: if\n:: PCind_2?0; goto p1; \n\n:: LDres_2?m; goto link6; \n\nfi;\np1: if\n:: PDreq_2!121; goto link5; \n\nfi;\np2: if\n:: PDreq_2!119; goto p3; \n\nfi;\nlink6: if\n:: PCind_2?0; goto p2; \n\nfi;\np3: if\n:: PCind_2?0; goto p4; \n\nfi;\np4: if\n:: PDreq_2!112; goto p5; \n\nfi;\np5: if\n::  atomic {m==107;PDreq_2!120;}  goto link0; \n\n::  atomic {m!=107;PDreq_2!121;}  goto link7; \n\nfi;\np6: if\n:: PDreq_2!121; goto link7; \n\nfi;\nlink7: if\n:: PCind_2?0; goto p6; \n\n:: LDreq_2?dest; goto link2req; \n\nfi;\n}\n\nactive proctype Bus() { \nbyte t[3];\nbyte destfault[3];\nbyte next[3];\nbyte i=0;\nbyte j=0;\nbyte m=0;\nbyte busy=0;\n\nidle: if\n::  ! (t[0]==0 && t[1]==0 && t[2]==0); goto arbresgab; \n\n::  atomic {PAreq_0?m;i = 0;}  goto idleq; \n\n::  atomic {PAreq_1?m;i = 1;}  goto idleq; \n\n::  atomic {PAreq_2?m;i = 2;}  goto idleq; \n\nfi;\narbresgab: if\n::  d_step {t[0] = 0;t[1] = 0;t[2] = 0;}  goto idle; \n\nfi;\nidleq: if\n::  atomic {i==0 && t[i]==1;PAcon_0!111;}  goto idle; \n\n::  atomic {i==1 && t[i]==1;PAcon_1!111;}  goto idle; \n\n::  atomic {i==2 && t[i]==1;PAcon_2!111;}  goto idle; \n\n::  atomic {i==0 && t[i]==0;PAcon_0!110;t[i] = 1;busy = i;}  goto bus_busy; \n\n::  atomic {i==1 && t[i]==0;PAcon_1!110;t[i] = 1;busy = i;}  goto bus_busy; \n\n::  atomic {i==2 && t[i]==0;PAcon_2!110;t[i] = 1;busy = i;}  goto bus_busy; \n\nfi;\nbus_busy: if\n::  atomic {PAreq_0?m;i = 0;}  goto busyq; \n\n::  atomic {PAreq_1?m;i = 1;}  goto busyq; \n\n::  atomic {PAreq_2?m;i = 2;}  goto busyq; \n\n::  atomic {busy==0;PCind_0!0;}  goto get_next_packet; \n\n::  atomic {busy==1;PCind_1!0;}  goto get_next_packet; \n\n::  atomic {busy==2;PCind_2!0;}  goto get_next_packet; \n\n::  d_step {busy==3 && next[0]==0 && next[1]==0 && next[2]==0;j = 0;}  goto sub_action_gab; \n\n::  d_step {busy==3 &&  ! (next[0]==0 && next[1]==0 && next[2]==0);j = 0;}  goto resolve; \n\nfi;\nbusyq: if\n::  atomic {m==108 && i==0;PAcon_0!111;}  goto bus_busy; \n\n::  atomic {m==108 && i==1;PAcon_1!111;}  goto bus_busy; \n\n::  atomic {m==108 && i==2;PAcon_2!111;}  goto bus_busy; \n\n::  d_step {m==109;next[i] = 1;}  goto bus_busy; \n\nfi;\nsub_action_gab: if\n::  atomic {0==j;PDind_0!122;j = j+1;}  goto sub_action_gab; \n\n::  atomic {1==j;PDind_1!122;j = j+1;}  goto sub_action_gab; \n\n::  atomic {2==j;PDind_2!122;j = j+1;}  goto sub_action_gab; \n\n:: j==3; goto idle; \n\nfi;\nget_next_packet: if\n::  atomic {busy==0;PDreq_0?m;j = 0;}  goto distribute; \n\n::  atomic {busy==1;PDreq_1?m;j = 0;}  goto distribute; \n\n::  atomic {busy==2;PDreq_2?m;j = 0;}  goto distribute; \n\nfi;\nresolve: if\n::  d_step {j<3 && next[j]==0;j = j+1;}  goto resolve; \n\n::  atomic {0==j && next[j]==1;PAcon_0!110;}  goto resolveq; \n\n::  atomic {1==j && next[j]==1;PAcon_1!110;}  goto resolveq; \n\n::  atomic {2==j && next[j]==1;PAcon_2!110;}  goto resolveq; \n\n:: j==3; goto resolve2; \n\nfi;\nresolveq: if\n::  atomic {0==j;PCind_0!0;j = j+1;}  goto resolve; \n\n::  atomic {1==j;PCind_1!0;j = j+1;}  goto resolve; \n\n::  atomic {2==j;PCind_2!0;j = j+1;}  goto resolve; \n\nfi;\nresolve2: if\n::  atomic {PDreq_0?m;j = 0;}  goto resolve2q; \n\n::  atomic {PDreq_1?m;j = 1;}  goto resolve2q; \n\n::  atomic {PDreq_2?m;j = 2;}  goto resolve2q; \n\nfi;\nresolve2q: if\n::  ! ((next[0]==0 && next[1]==0 && next[2]==0) || (next[0]+next[1]+next[2]==1)) && m!=120; goto resolve; \n\n::  d_step { ! ((next[0]==0 && next[1]==0 && next[2]==0) || (next[0]+next[1]+next[2]==1)) && m==120;next[j] = 0;}  goto resolve; \n\n::  d_step {(next[0]+next[1]+next[2]==1) && m==120;next[j] = 0;j = 0;}  goto sub_action_gab; \n\n::  d_step {(next[0]+next[1]+next[2]==1) && m!=120;busy = j;next[j] = 0;j = 0;}  goto distribute; \n\nfi;\ndistribute: if\n::  d_step {j==busy;j = j+1;}  goto distribute; \n\n::  atomic {0==j;PAreq_0?m;}  goto distributeq; \n\n::  atomic {1==j;PAreq_1?m;}  goto distributeq; \n\n::  atomic {2==j;PAreq_2?m;}  goto distributeq; \n\n::  atomic {0==j &&  ! (m==114 && destfault[j]==1);PDind_0!m;j = j+1;}  goto distribute; \n\n::  atomic {1==j &&  ! (m==114 && destfault[j]==1);PDind_1!m;j = j+1;}  goto distribute; \n\n::  atomic {2==j &&  ! (m==114 && destfault[j]==1);PDind_2!m;j = j+1;}  goto distribute; \n\n::  atomic {0==j && m==116;PDind_0!m;}  goto data_dummy; \n\n::  atomic {1==j && m==116;PDind_1!m;}  goto data_dummy; \n\n::  atomic {2==j && m==116;PDind_2!m;}  goto data_dummy; \n\n::  atomic {0==j && m==116;PDind_0!117;j = j+1;}  goto distribute; \n\n::  atomic {1==j && m==116;PDind_1!117;j = j+1;}  goto distribute; \n\n::  atomic {2==j && m==116;PDind_2!117;j = j+1;}  goto distribute; \n\n::  atomic {0==j && m==114;PDind_0!115;j = j+1;}  goto distribute; \n\n::  atomic {1==j && m==114;PDind_1!115;j = j+1;}  goto distribute; \n\n::  atomic {2==j && m==114;PDind_2!115;j = j+1;}  goto distribute; \n\n::  atomic {0==j && m==112;PDind_0!113;j = j+1;}  goto distribute; \n\n::  atomic {1==j && m==112;PDind_1!113;j = j+1;}  goto distribute; \n\n::  atomic {2==j && m==112;PDind_2!113;j = j+1;}  goto distribute; \n\n::  d_step {j!=busy && j<3 && m<100;destfault[j] = 1;i = 0;}  goto dest_cor; \n\n::  d_step {j!=busy && j<3 && m<100;destfault[j] = 1;i = 1;}  goto dest_cor; \n\n::  d_step {j!=busy && j<3 && m<100;destfault[j] = 1;i = 2;}  goto dest_cor; \n\n:: j==3 && m!=120; goto bus_busy; \n\n::  d_step {j==3 && m==120;busy = 3;}  goto bus_busy; \n\nfi;\ndistributeq: if\n::  atomic {m==108 && j==0;PAcon_0!111;}  goto distribute; \n\n::  atomic {m==108 && j==1;PAcon_1!111;}  goto distribute; \n\n::  atomic {m==108 && j==2;PAcon_2!111;}  goto distribute; \n\n::  d_step {m==109;next[j] = 1;}  goto distribute; \n\nfi;\ndest_cor: if\n::  atomic {0==j;PDind_0!i;j = j+1;}  goto distribute; \n\n::  atomic {1==j;PDind_1!i;j = j+1;}  goto distribute; \n\n::  atomic {2==j;PDind_2!i;j = j+1;}  goto distribute; \n\nfi;\ndata_dummy: if\n::  atomic {0==j;PDind_0!123;j = j+1;}  goto distribute; \n\n::  atomic {1==j;PDind_1!123;j = j+1;}  goto distribute; \n\n::  atomic {2==j;PDind_2!123;j = j+1;}  goto distribute; \n\nfi;\n}\n\nactive proctype Application_0() { \n\nq: if\n:: TDreq_0!1; goto r; \n\nfi;\nr: \n false; }\n\nactive proctype Application_1() { \n\nq: if\n:: TDreq_1!2; goto r; \n\nfi;\nr: \n false; }\n\nactive proctype Application_2() { \n\nq: if\n:: TDreq_2!0; goto r; \n\nfi;\nr: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "This is model of the \"FireWire\" high performance serial\n    bus defined in the IEEE-1394 Standard. The bus involves n nodes\n    (addressable entities that run their own part of the protocol) connected by\n    a serial line. On each node the IEEE-1394 protocol consists of three stacke\n    layers: the transaction layer, the link layer, and th physical layer. The\n    protocol implemented by the link layer is designed to transmit data packets\n    over an unreliable medium to a specific node or to all nodes (broadcast).\n    The transmission can be performed synchronously or\n    asynchronously.\n\nParameters:"}, {"role": "assistant", "content": "chan LDreq_0 =[0] of {int};\nchan LDres_0 =[0] of {int};\nchan LDcon_0 =[0] of {int};\nchan LDind_0 =[0] of {int};\nchan TX_0 =[0] of {int};\nchan PDreq_0 =[0] of {int};\nchan PDind_0 =[0] of {int};\nchan PAreq_0 =[0] of {int};\nchan PAcon_0 =[0] of {int};\nchan PCind_0 =[0] of {int};\nchan TDreq_0 =[0] of {int};\nchan LDreq_1 =[0] of {int};\nchan LDres_1 =[0] of {int};\nchan LDcon_1 =[0] of {int};\nchan LDind_1 =[0] of {int};\nchan TX_1 =[0] of {int};\nchan PDreq_1 =[0] of {int};\nchan PDind_1 =[0] of {int};\nchan PAreq_1 =[0] of {int};\nchan PAcon_1 =[0] of {int};\nchan PCind_1 =[0] of {int};\nchan TDreq_1 =[0] of {int};\nchan LDreq_2 =[0] of {int};\nchan LDres_2 =[0] of {int};\nchan LDcon_2 =[0] of {int};\nchan LDind_2 =[0] of {int};\nchan TX_2 =[0] of {int};\nchan PDreq_2 =[0] of {int};\nchan PDind_2 =[0] of {int};\nchan PAreq_2 =[0] of {int};\nchan PAcon_2 =[0] of {int};\nchan PCind_2 =[0] of {int};\nchan TDreq_2 =[0] of {int};\n\nactive proctype Transreq_0() { \nbyte m=0;\n\nidle: if\n:: LDind_0?m; goto got_msg; \n\nfi;\ngot_msg: if\n::  atomic {m==101;LDres_0!100;}  goto idle; \n\n:: TX_0?0; goto concatenated_tr; \n\n::  goto split_tr; \n\nfi;\nconcatenated_tr: if\n:: LDres_0!102; goto idle; \n\nfi;\nsplit_tr: if\n:: LDres_0!107; goto idle; \n\nfi;\n}\n\nactive proctype Transres_0() { \nbyte dest=0;\nbyte m=0;\n\nidle: if\n:: TDreq_0?dest; goto got_req; \n\nfi;\ngot_req: if\n:: TX_0!0; goto q; \n\n::  goto q; \n\nfi;\nq: if\n:: LDreq_0!dest; goto wait_ack; \n\nfi;\nwait_ack: if\n:: LDcon_0?m; goto wait_q; \n\nfi;\nwait_q: if\n:: m==124 && dest==3; goto idle; \n\n:: m==105 && dest<3; goto idle; \n\n:: m==106 && dest<3; goto idle; \n\nfi;\n}\n\nactive proctype Link_0() { \nint buf=-1;\nbyte dest=0;\nbyte m=0;\nbyte m2=0;\nbyte data=0;\n\nlink0: if\n:: LDreq_0?buf; goto link0r; \n\n:: PAcon_0?m; goto link0a; \n\n:: PDind_0?m; goto link0i; \n\nfi;\nlink0r: if\n:: PAreq_0!108; goto link0; \n\nfi;\nlink0a: if\n:: m==111; goto link0; \n\n::  d_step {m==110;dest = buf;}  goto link2req; \n\nfi;\nlink0i: if\n:: m!=119; goto link0; \n\n:: m==119; goto link4; \n\nfi;\nlink2req: if\n:: PCind_0?0; goto q1; \n\nfi;\nq1: if\n:: PDreq_0!119; goto s1; \n\nfi;\ns1: if\n:: PCind_0?0; goto q2; \n\nfi;\nq2: if\n:: PDreq_0!118; goto s2; \n\nfi;\ns2: if\n:: PCind_0?0; goto q3; \n\nfi;\nq3: if\n:: PDreq_0!dest; goto s3; \n\nfi;\ns3: if\n:: PCind_0?0; goto q4; \n\nfi;\nq4: if\n:: PDreq_0!114; goto s4; \n\nfi;\ns4: if\n:: PCind_0?0; goto q5; \n\nfi;\nq5: if\n:: PDreq_0!116; goto s5; \n\nfi;\ns5: if\n:: PCind_0?0; goto q6; \n\nfi;\nq6: if\n:: PDreq_0!120; goto s6; \n\nfi;\ns6: if\n::  atomic {dest==3;LDcon_0!124;buf = -1;}  goto link0; \n\n:: dest<3; goto link3; \n\nfi;\nlink3: if\n:: PDind_0?m; goto link3q; \n\nfi;\nlink3q: if\n:: m==121; goto link3; \n\n::  atomic {m==122;LDcon_0!106;}  goto link0; \n\n:: m==119; goto link3A; \n\n::  atomic {m!=122 && m!=121 && m!=119;LDcon_0!106;dest = 3;}  goto linkWSA; \n\nfi;\nlink3A: if\n:: PDind_0?m; goto link3Aq; \n\nfi;\nlink3Aq: if\n::  atomic {m==119 || m==120 || m==122;LDcon_0!106;dest = 3;}  goto linkWSA; \n\n::  ! (m==119 || m==120 || m==122); goto link3RE; \n\nfi;\nlink3RE: if\n:: PDind_0?m2; goto link3REq1; \n\nfi;\nlink3REq1: if\n::  atomic {m==112 && (m2==121 || m2==120);LDcon_0!105;}  goto link3REq2; \n\n::  atomic { ! (m==112 && (m2==121 || m2==120));LDcon_0!106;}  goto link3REq2; \n\nfi;\nlink3REq2: if\n:: m2==122; goto link0; \n\n::  d_step {m2!=122;dest = 3;}  goto linkWSA; \n\nfi;\nlinkWSA: if\n:: PDind_0?m; goto linkWSAq; \n\n::  atomic {dest==0;PAcon_0?m;}  goto linkWSAa1; \n\nfi;\nlinkWSAq: if\n:: m!=122; goto linkWSA; \n\n:: m==122; goto link0; \n\nfi;\nlinkWSAa1: if\n::  atomic {m==110;PCind_0?0;}  goto linkWSAa2; \n\nfi;\nlinkWSAa2: if\n:: PDreq_0!120; goto link0; \n\nfi;\nlink4: if\n:: PDind_0?m; goto link4q; \n\nfi;\nlink4q: if\n:: m==122; goto link0; \n\n::  d_step {m==119 || m==120 || m==122;dest = 3;}  goto linkWSA; \n\n:: m!=122 &&  ! (m==119 || m==120 || m==122); goto link4DH; \n\nfi;\nlink4DH: if\n:: PDind_0?dest; goto link4DHq; \n\nfi;\nlink4DHq: if\n:: dest==122; goto link0; \n\n::  atomic {dest==0;PAreq_0!109;}  goto link4RH; \n\n:: dest==3; goto link4RH; \n\n::  d_step {dest!=122 && dest!=0 && dest!=3;dest = 3;}  goto linkWSA; \n\nfi;\nlink4RH: if\n:: PDind_0?m; goto link4RHq; \n\nfi;\nlink4RHq: if\n:: m==114; goto link4RD; \n\n:: m!=114; goto linkWSA; \n\nfi;\nlink4RD: if\n:: PDind_0?data; goto link4RDq; \n\nfi;\nlink4RDq: if\n:: data==116 || data==117; goto link4RE; \n\n::  ! (data==116 || data==117); goto linkWSA; \n\nfi;\nlink4RE: if\n:: PDind_0?m; goto link4REq; \n\nfi;\nlink4REq: if\n:: (m==120 || m==121) && dest==0; goto link4DRec; \n\n:: (m==120 || m==121) && dest==3; goto link4BRec; \n\n::  ! (m==120 || m==121); goto linkWSA; \n\nfi;\nlink4DRec: if\n::  atomic {data==116;LDind_0!103;}  goto link4DRecq; \n\n::  atomic {data==117;LDind_0!104;}  goto link4DRecq; \n\nfi;\nlink4BRec: if\n::  atomic {data==116;LDind_0!101;}  goto link0; \n\n:: data!=116; goto link0; \n\nfi;\nlink4DRecq: if\n:: PAcon_0?m; goto link4DRecq2; \n\nfi;\nlink4DRecq2: if\n:: m==110; goto link5; \n\nfi;\nlink5: if\n:: PCind_0?0; goto p1; \n\n:: LDres_0?m; goto link6; \n\nfi;\np1: if\n:: PDreq_0!121; goto link5; \n\nfi;\np2: if\n:: PDreq_0!119; goto p3; \n\nfi;\nlink6: if\n:: PCind_0?0; goto p2; \n\nfi;\np3: if\n:: PCind_0?0; goto p4; \n\nfi;\np4: if\n:: PDreq_0!112; goto p5; \n\nfi;\np5: if\n::  atomic {m==107;PDreq_0!120;}  goto link0; \n\n::  atomic {m!=107;PDreq_0!121;}  goto link7; \n\nfi;\np6: if\n:: PDreq_0!121; goto link7; \n\nfi;\nlink7: if\n:: PCind_0?0; goto p6; \n\n:: LDreq_0?dest; goto link2req; \n\nfi;\n}\n\nactive proctype Transreq_1() { \nbyte m=0;\n\nidle: if\n:: LDind_1?m; goto got_msg; \n\nfi;\ngot_msg: if\n::  atomic {m==101;LDres_1!100;}  goto idle; \n\n:: TX_1?0; goto concatenated_tr; \n\n::  goto split_tr; \n\nfi;\nconcatenated_tr: if\n:: LDres_1!102; goto idle; \n\nfi;\nsplit_tr: if\n:: LDres_1!107; goto idle; \n\nfi;\n}\n\nactive proctype Transres_1() { \nbyte dest=0;\nbyte m=0;\n\nidle: if\n:: TDreq_1?dest; goto got_req; \n\nfi;\ngot_req: if\n:: TX_1!0; goto q; \n\n::  goto q; \n\nfi;\nq: if\n:: LDreq_1!dest; goto wait_ack; \n\nfi;\nwait_ack: if\n:: LDcon_1?m; goto wait_q; \n\nfi;\nwait_q: if\n:: m==124 && dest==3; goto idle; \n\n:: m==105 && dest<3; goto idle; \n\n:: m==106 && dest<3; goto idle; \n\nfi;\n}\n\nactive proctype Link_1() { \nint buf=-1;\nbyte dest=0;\nbyte m=0;\nbyte m2=0;\nbyte data=0;\n\nlink0: if\n:: LDreq_1?buf; goto link0r; \n\n:: PAcon_1?m; goto link0a; \n\n:: PDind_1?m; goto link0i; \n\nfi;\nlink0r: if\n:: PAreq_1!108; goto link0; \n\nfi;\nlink0a: if\n:: m==111; goto link0; \n\n::  d_step {m==110;dest = buf;}  goto link2req; \n\nfi;\nlink0i: if\n:: m!=119; goto link0; \n\n:: m==119; goto link4; \n\nfi;\nlink2req: if\n:: PCind_1?0; goto q1; \n\nfi;\nq1: if\n:: PDreq_1!119; goto s1; \n\nfi;\ns1: if\n:: PCind_1?0; goto q2; \n\nfi;\nq2: if\n:: PDreq_1!118; goto s2; \n\nfi;\ns2: if\n:: PCind_1?0; goto q3; \n\nfi;\nq3: if\n:: PDreq_1!dest; goto s3; \n\nfi;\ns3: if\n:: PCind_1?0; goto q4; \n\nfi;\nq4: if\n:: PDreq_1!114; goto s4; \n\nfi;\ns4: if\n:: PCind_1?0; goto q5; \n\nfi;\nq5: if\n:: PDreq_1!116; goto s5; \n\nfi;\ns5: if\n:: PCind_1?0; goto q6; \n\nfi;\nq6: if\n:: PDreq_1!120; goto s6; \n\nfi;\ns6: if\n::  atomic {dest==3;LDcon_1!124;buf = -1;}  goto link0; \n\n:: dest<3; goto link3; \n\nfi;\nlink3: if\n:: PDind_1?m; goto link3q; \n\nfi;\nlink3q: if\n:: m==121; goto link3; \n\n::  atomic {m==122;LDcon_1!106;}  goto link0; \n\n:: m==119; goto link3A; \n\n::  atomic {m!=122 && m!=121 && m!=119;LDcon_1!106;dest = 3;}  goto linkWSA; \n\nfi;\nlink3A: if\n:: PDind_1?m; goto link3Aq; \n\nfi;\nlink3Aq: if\n::  atomic {m==119 || m==120 || m==122;LDcon_1!106;dest = 3;}  goto linkWSA; \n\n::  ! (m==119 || m==120 || m==122); goto link3RE; \n\nfi;\nlink3RE: if\n:: PDind_1?m2; goto link3REq1; \n\nfi;\nlink3REq1: if\n::  atomic {m==112 && (m2==121 || m2==120);LDcon_1!105;}  goto link3REq2; \n\n::  atomic { ! (m==112 && (m2==121 || m2==120));LDcon_1!106;}  goto link3REq2; \n\nfi;\nlink3REq2: if\n:: m2==122; goto link0; \n\n::  d_step {m2!=122;dest = 3;}  goto linkWSA; \n\nfi;\nlinkWSA: if\n:: PDind_1?m; goto linkWSAq; \n\n::  atomic {dest==1;PAcon_1?m;}  goto linkWSAa1; \n\nfi;\nlinkWSAq: if\n:: m!=122; goto linkWSA; \n\n:: m==122; goto link0; \n\nfi;\nlinkWSAa1: if\n::  atomic {m==110;PCind_1?0;}  goto linkWSAa2; \n\nfi;\nlinkWSAa2: if\n:: PDreq_1!120; goto link0; \n\nfi;\nlink4: if\n:: PDind_1?m; goto link4q; \n\nfi;\nlink4q: if\n:: m==122; goto link0; \n\n::  d_step {m==119 || m==120 || m==122;dest = 3;}  goto linkWSA; \n\n:: m!=122 &&  ! (m==119 || m==120 || m==122); goto link4DH; \n\nfi;\nlink4DH: if\n:: PDind_1?dest; goto link4DHq; \n\nfi;\nlink4DHq: if\n:: dest==122; goto link0; \n\n::  atomic {dest==1;PAreq_1!109;}  goto link4RH; \n\n:: dest==3; goto link4RH; \n\n::  d_step {dest!=122 && dest!=1 && dest!=3;dest = 3;}  goto linkWSA; \n\nfi;\nlink4RH: if\n:: PDind_1?m; goto link4RHq; \n\nfi;\nlink4RHq: if\n:: m==114; goto link4RD; \n\n:: m!=114; goto linkWSA; \n\nfi;\nlink4RD: if\n:: PDind_1?data; goto link4RDq; \n\nfi;\nlink4RDq: if\n:: data==116 || data==117; goto link4RE; \n\n::  ! (data==116 || data==117); goto linkWSA; \n\nfi;\nlink4RE: if\n:: PDind_1?m; goto link4REq; \n\nfi;\nlink4REq: if\n:: (m==120 || m==121) && dest==1; goto link4DRec; \n\n:: (m==120 || m==121) && dest==3; goto link4BRec; \n\n::  ! (m==120 || m==121); goto linkWSA; \n\nfi;\nlink4DRec: if\n::  atomic {data==116;LDind_1!103;}  goto link4DRecq; \n\n::  atomic {data==117;LDind_1!104;}  goto link4DRecq; \n\nfi;\nlink4BRec: if\n::  atomic {data==116;LDind_1!101;}  goto link0; \n\n:: data!=116; goto link0; \n\nfi;\nlink4DRecq: if\n:: PAcon_1?m; goto link4DRecq2; \n\nfi;\nlink4DRecq2: if\n:: m==110; goto link5; \n\nfi;\nlink5: if\n:: PCind_1?0; goto p1; \n\n:: LDres_1?m; goto link6; \n\nfi;\np1: if\n:: PDreq_1!121; goto link5; \n\nfi;\np2: if\n:: PDreq_1!119; goto p3; \n\nfi;\nlink6: if\n:: PCind_1?0; goto p2; \n\nfi;\np3: if\n:: PCind_1?0; goto p4; \n\nfi;\np4: if\n:: PDreq_1!112; goto p5; \n\nfi;\np5: if\n::  atomic {m==107;PDreq_1!120;}  goto link0; \n\n::  atomic {m!=107;PDreq_1!121;}  goto link7; \n\nfi;\np6: if\n:: PDreq_1!121; goto link7; \n\nfi;\nlink7: if\n:: PCind_1?0; goto p6; \n\n:: LDreq_1?dest; goto link2req; \n\nfi;\n}\n\nactive proctype Transreq_2() { \nbyte m=0;\n\nidle: if\n:: LDind_2?m; goto got_msg; \n\nfi;\ngot_msg: if\n::  atomic {m==101;LDres_2!100;}  goto idle; \n\n:: TX_2?0; goto concatenated_tr; \n\n::  goto split_tr; \n\nfi;\nconcatenated_tr: if\n:: LDres_2!102; goto idle; \n\nfi;\nsplit_tr: if\n:: LDres_2!107; goto idle; \n\nfi;\n}\n\nactive proctype Transres_2() { \nbyte dest=0;\nbyte m=0;\n\nidle: if\n:: TDreq_2?dest; goto got_req; \n\nfi;\ngot_req: if\n:: TX_2!0; goto q; \n\n::  goto q; \n\nfi;\nq: if\n:: LDreq_2!dest; goto wait_ack; \n\nfi;\nwait_ack: if\n:: LDcon_2?m; goto wait_q; \n\nfi;\nwait_q: if\n:: m==124 && dest==3; goto idle; \n\n:: m==105 && dest<3; goto idle; \n\n:: m==106 && dest<3; goto idle; \n\nfi;\n}\n\nactive proctype Link_2() { \nint buf=-1;\nbyte dest=0;\nbyte m=0;\nbyte m2=0;\nbyte data=0;\n\nlink0: if\n:: LDreq_2?buf; goto link0r; \n\n:: PAcon_2?m; goto link0a; \n\n:: PDind_2?m; goto link0i; \n\nfi;\nlink0r: if\n:: PAreq_2!108; goto link0; \n\nfi;\nlink0a: if\n:: m==111; goto link0; \n\n::  d_step {m==110;dest = buf;}  goto link2req; \n\nfi;\nlink0i: if\n:: m!=119; goto link0; \n\n:: m==119; goto link4; \n\nfi;\nlink2req: if\n:: PCind_2?0; goto q1; \n\nfi;\nq1: if\n:: PDreq_2!119; goto s1; \n\nfi;\ns1: if\n:: PCind_2?0; goto q2; \n\nfi;\nq2: if\n:: PDreq_2!118; goto s2; \n\nfi;\ns2: if\n:: PCind_2?0; goto q3; \n\nfi;\nq3: if\n:: PDreq_2!dest; goto s3; \n\nfi;\ns3: if\n:: PCind_2?0; goto q4; \n\nfi;\nq4: if\n:: PDreq_2!114; goto s4; \n\nfi;\ns4: if\n:: PCind_2?0; goto q5; \n\nfi;\nq5: if\n:: PDreq_2!116; goto s5; \n\nfi;\ns5: if\n:: PCind_2?0; goto q6; \n\nfi;\nq6: if\n:: PDreq_2!120; goto s6; \n\nfi;\ns6: if\n::  atomic {dest==3;LDcon_2!124;buf = -1;}  goto link0; \n\n:: dest<3; goto link3; \n\nfi;\nlink3: if\n:: PDind_2?m; goto link3q; \n\nfi;\nlink3q: if\n:: m==121; goto link3; \n\n::  atomic {m==122;LDcon_2!106;}  goto link0; \n\n:: m==119; goto link3A; \n\n::  atomic {m!=122 && m!=121 && m!=119;LDcon_2!106;dest = 3;}  goto linkWSA; \n\nfi;\nlink3A: if\n:: PDind_2?m; goto link3Aq; \n\nfi;\nlink3Aq: if\n::  atomic {m==119 || m==120 || m==122;LDcon_2!106;dest = 3;}  goto linkWSA; \n\n::  ! (m==119 || m==120 || m==122); goto link3RE; \n\nfi;\nlink3RE: if\n:: PDind_2?m2; goto link3REq1; \n\nfi;\nlink3REq1: if\n::  atomic {m==112 && (m2==121 || m2==120);LDcon_2!105;}  goto link3REq2; \n\n::  atomic { ! (m==112 && (m2==121 || m2==120));LDcon_2!106;}  goto link3REq2; \n\nfi;\nlink3REq2: if\n:: m2==122; goto link0; \n\n::  d_step {m2!=122;dest = 3;}  goto linkWSA; \n\nfi;\nlinkWSA: if\n:: PDind_2?m; goto linkWSAq; \n\n::  atomic {dest==2;PAcon_2?m;}  goto linkWSAa1; \n\nfi;\nlinkWSAq: if\n:: m!=122; goto linkWSA; \n\n:: m==122; goto link0; \n\nfi;\nlinkWSAa1: if\n::  atomic {m==110;PCind_2?0;}  goto linkWSAa2; \n\nfi;\nlinkWSAa2: if\n:: PDreq_2!120; goto link0; \n\nfi;\nlink4: if\n:: PDind_2?m; goto link4q; \n\nfi;\nlink4q: if\n:: m==122; goto link0; \n\n::  d_step {m==119 || m==120 || m==122;dest = 3;}  goto linkWSA; \n\n:: m!=122 &&  ! (m==119 || m==120 || m==122); goto link4DH; \n\nfi;\nlink4DH: if\n:: PDind_2?dest; goto link4DHq; \n\nfi;\nlink4DHq: if\n:: dest==122; goto link0; \n\n::  atomic {dest==2;PAreq_2!109;}  goto link4RH; \n\n:: dest==3; goto link4RH; \n\n::  d_step {dest!=122 && dest!=2 && dest!=3;dest = 3;}  goto linkWSA; \n\nfi;\nlink4RH: if\n:: PDind_2?m; goto link4RHq; \n\nfi;\nlink4RHq: if\n:: m==114; goto link4RD; \n\n:: m!=114; goto linkWSA; \n\nfi;\nlink4RD: if\n:: PDind_2?data; goto link4RDq; \n\nfi;\nlink4RDq: if\n:: data==116 || data==117; goto link4RE; \n\n::  ! (data==116 || data==117); goto linkWSA; \n\nfi;\nlink4RE: if\n:: PDind_2?m; goto link4REq; \n\nfi;\nlink4REq: if\n:: (m==120 || m==121) && dest==2; goto link4DRec; \n\n:: (m==120 || m==121) && dest==3; goto link4BRec; \n\n::  ! (m==120 || m==121); goto linkWSA; \n\nfi;\nlink4DRec: if\n::  atomic {data==116;LDind_2!103;}  goto link4DRecq; \n\n::  atomic {data==117;LDind_2!104;}  goto link4DRecq; \n\nfi;\nlink4BRec: if\n::  atomic {data==116;LDind_2!101;}  goto link0; \n\n:: data!=116; goto link0; \n\nfi;\nlink4DRecq: if\n:: PAcon_2?m; goto link4DRecq2; \n\nfi;\nlink4DRecq2: if\n:: m==110; goto link5; \n\nfi;\nlink5: if\n:: PCind_2?0; goto p1; \n\n:: LDres_2?m; goto link6; \n\nfi;\np1: if\n:: PDreq_2!121; goto link5; \n\nfi;\np2: if\n:: PDreq_2!119; goto p3; \n\nfi;\nlink6: if\n:: PCind_2?0; goto p2; \n\nfi;\np3: if\n:: PCind_2?0; goto p4; \n\nfi;\np4: if\n:: PDreq_2!112; goto p5; \n\nfi;\np5: if\n::  atomic {m==107;PDreq_2!120;}  goto link0; \n\n::  atomic {m!=107;PDreq_2!121;}  goto link7; \n\nfi;\np6: if\n:: PDreq_2!121; goto link7; \n\nfi;\nlink7: if\n:: PCind_2?0; goto p6; \n\n:: LDreq_2?dest; goto link2req; \n\nfi;\n}\n\nactive proctype Bus() { \nbyte t[3];\nbyte destfault[3];\nbyte next[3];\nbyte i=0;\nbyte j=0;\nbyte m=0;\nbyte busy=0;\n\nidle: if\n::  ! (t[0]==0 && t[1]==0 && t[2]==0); goto arbresgab; \n\n::  atomic {PAreq_0?m;i = 0;}  goto idleq; \n\n::  atomic {PAreq_1?m;i = 1;}  goto idleq; \n\n::  atomic {PAreq_2?m;i = 2;}  goto idleq; \n\nfi;\narbresgab: if\n::  d_step {t[0] = 0;t[1] = 0;t[2] = 0;}  goto idle; \n\nfi;\nidleq: if\n::  atomic {i==0 && t[i]==1;PAcon_0!111;}  goto idle; \n\n::  atomic {i==1 && t[i]==1;PAcon_1!111;}  goto idle; \n\n::  atomic {i==2 && t[i]==1;PAcon_2!111;}  goto idle; \n\n::  atomic {i==0 && t[i]==0;PAcon_0!110;t[i] = 1;busy = i;}  goto bus_busy; \n\n::  atomic {i==1 && t[i]==0;PAcon_1!110;t[i] = 1;busy = i;}  goto bus_busy; \n\n::  atomic {i==2 && t[i]==0;PAcon_2!110;t[i] = 1;busy = i;}  goto bus_busy; \n\nfi;\nbus_busy: if\n::  atomic {PAreq_0?m;i = 0;}  goto busyq; \n\n::  atomic {PAreq_1?m;i = 1;}  goto busyq; \n\n::  atomic {PAreq_2?m;i = 2;}  goto busyq; \n\n::  atomic {busy==0;PCind_0!0;}  goto get_next_packet; \n\n::  atomic {busy==1;PCind_1!0;}  goto get_next_packet; \n\n::  atomic {busy==2;PCind_2!0;}  goto get_next_packet; \n\n::  d_step {busy==3 && next[0]==0 && next[1]==0 && next[2]==0;j = 0;}  goto sub_action_gab; \n\n::  d_step {busy==3 &&  ! (next[0]==0 && next[1]==0 && next[2]==0);j = 0;}  goto resolve; \n\nfi;\nbusyq: if\n::  atomic {m==108 && i==0;PAcon_0!111;}  goto bus_busy; \n\n::  atomic {m==108 && i==1;PAcon_1!111;}  goto bus_busy; \n\n::  atomic {m==108 && i==2;PAcon_2!111;}  goto bus_busy; \n\n::  d_step {m==109;next[i] = 1;}  goto bus_busy; \n\nfi;\nsub_action_gab: if\n::  atomic {0==j;PDind_0!122;j = j+1;}  goto sub_action_gab; \n\n::  atomic {1==j;PDind_1!122;j = j+1;}  goto sub_action_gab; \n\n::  atomic {2==j;PDind_2!122;j = j+1;}  goto sub_action_gab; \n\n:: j==3; goto idle; \n\nfi;\nget_next_packet: if\n::  atomic {busy==0;PDreq_0?m;j = 0;}  goto distribute; \n\n::  atomic {busy==1;PDreq_1?m;j = 0;}  goto distribute; \n\n::  atomic {busy==2;PDreq_2?m;j = 0;}  goto distribute; \n\nfi;\nresolve: if\n::  d_step {j<3 && next[j]==0;j = j+1;}  goto resolve; \n\n::  atomic {0==j && next[j]==1;PAcon_0!110;}  goto resolveq; \n\n::  atomic {1==j && next[j]==1;PAcon_1!110;}  goto resolveq; \n\n::  atomic {2==j && next[j]==1;PAcon_2!110;}  goto resolveq; \n\n:: j==3; goto resolve2; \n\nfi;\nresolveq: if\n::  atomic {0==j;PCind_0!0;j = j+1;}  goto resolve; \n\n::  atomic {1==j;PCind_1!0;j = j+1;}  goto resolve; \n\n::  atomic {2==j;PCind_2!0;j = j+1;}  goto resolve; \n\nfi;\nresolve2: if\n::  atomic {PDreq_0?m;j = 0;}  goto resolve2q; \n\n::  atomic {PDreq_1?m;j = 1;}  goto resolve2q; \n\n::  atomic {PDreq_2?m;j = 2;}  goto resolve2q; \n\nfi;\nresolve2q: if\n::  ! ((next[0]==0 && next[1]==0 && next[2]==0) || (next[0]+next[1]+next[2]==1)) && m!=120; goto resolve; \n\n::  d_step { ! ((next[0]==0 && next[1]==0 && next[2]==0) || (next[0]+next[1]+next[2]==1)) && m==120;next[j] = 0;}  goto resolve; \n\n::  d_step {(next[0]+next[1]+next[2]==1) && m==120;next[j] = 0;j = 0;}  goto sub_action_gab; \n\n::  d_step {(next[0]+next[1]+next[2]==1) && m!=120;busy = j;next[j] = 0;j = 0;}  goto distribute; \n\nfi;\ndistribute: if\n::  d_step {j==busy;j = j+1;}  goto distribute; \n\n::  atomic {0==j;PAreq_0?m;}  goto distributeq; \n\n::  atomic {1==j;PAreq_1?m;}  goto distributeq; \n\n::  atomic {2==j;PAreq_2?m;}  goto distributeq; \n\n::  atomic {0==j &&  ! (m==114 && destfault[j]==1);PDind_0!m;j = j+1;}  goto distribute; \n\n::  atomic {1==j &&  ! (m==114 && destfault[j]==1);PDind_1!m;j = j+1;}  goto distribute; \n\n::  atomic {2==j &&  ! (m==114 && destfault[j]==1);PDind_2!m;j = j+1;}  goto distribute; \n\n::  atomic {0==j && m==116;PDind_0!m;}  goto data_dummy; \n\n::  atomic {1==j && m==116;PDind_1!m;}  goto data_dummy; \n\n::  atomic {2==j && m==116;PDind_2!m;}  goto data_dummy; \n\n::  atomic {0==j && m==116;PDind_0!117;j = j+1;}  goto distribute; \n\n::  atomic {1==j && m==116;PDind_1!117;j = j+1;}  goto distribute; \n\n::  atomic {2==j && m==116;PDind_2!117;j = j+1;}  goto distribute; \n\n::  atomic {0==j && m==114;PDind_0!115;j = j+1;}  goto distribute; \n\n::  atomic {1==j && m==114;PDind_1!115;j = j+1;}  goto distribute; \n\n::  atomic {2==j && m==114;PDind_2!115;j = j+1;}  goto distribute; \n\n::  atomic {0==j && m==112;PDind_0!113;j = j+1;}  goto distribute; \n\n::  atomic {1==j && m==112;PDind_1!113;j = j+1;}  goto distribute; \n\n::  atomic {2==j && m==112;PDind_2!113;j = j+1;}  goto distribute; \n\n::  d_step {j!=busy && j<3 && m<100;destfault[j] = 1;i = 0;}  goto dest_cor; \n\n::  d_step {j!=busy && j<3 && m<100;destfault[j] = 1;i = 1;}  goto dest_cor; \n\n::  d_step {j!=busy && j<3 && m<100;destfault[j] = 1;i = 2;}  goto dest_cor; \n\n:: j==3 && m!=120; goto bus_busy; \n\n::  d_step {j==3 && m==120;busy = 3;}  goto bus_busy; \n\nfi;\ndistributeq: if\n::  atomic {m==108 && j==0;PAcon_0!111;}  goto distribute; \n\n::  atomic {m==108 && j==1;PAcon_1!111;}  goto distribute; \n\n::  atomic {m==108 && j==2;PAcon_2!111;}  goto distribute; \n\n::  d_step {m==109;next[j] = 1;}  goto distribute; \n\nfi;\ndest_cor: if\n::  atomic {0==j;PDind_0!i;j = j+1;}  goto distribute; \n\n::  atomic {1==j;PDind_1!i;j = j+1;}  goto distribute; \n\n::  atomic {2==j;PDind_2!i;j = j+1;}  goto distribute; \n\nfi;\ndata_dummy: if\n::  atomic {0==j;PDind_0!123;j = j+1;}  goto distribute; \n\n::  atomic {1==j;PDind_1!123;j = j+1;}  goto distribute; \n\n::  atomic {2==j;PDind_2!123;j = j+1;}  goto distribute; \n\nfi;\n}\n\nactive proctype Application() { \nbyte i=0;\n\nq: if\n:: i = 0; goto r; \n\n:: i = 1; goto r; \n\n:: i = 2; goto r; \n\n:: i = 3; goto r; \n\nfi;\nr: if\n::  atomic {i!=0;TDreq_0!i;}  goto q; \n\n::  atomic {i!=1;TDreq_1!i;}  goto q; \n\n::  atomic {i!=2;TDreq_2!i;}  goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually.\n\n    This model is a discrete time simulation of the Fischer's real time\n    mutual exclusion protocol.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte id=0;\nbyte t[3];\n\n\ninit { \n d_step { \nt[0] =255; t[1] =255; t[2] =255; }\natomic { \nrun Timer();\nrun P_0();\nrun P_1();\nrun P_2();\n} }\n\nproctype Timer() { \n\nq: if\n::  d_step {t[0]!=0 && t[1]!=0 && t[2]!=0;t[0] = (t[0]-1)|((t[0]==255)*255);t[1] = (t[1]-1)|((t[1]==255)*255);t[2] = (t[2]-1)|((t[2]==255)*255);}  goto q; \n\nfi;\n}\n\nproctype P_0() { \n\nNCS: if\n::  d_step {id==0;t[0] = 2;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[0] = 3;id = 0+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[0]==0;t[0] = 255;}  goto wait; \n\n:: t[0]==255 && id==0+1; goto CS; \n\n:: id!=0+1 && t[0]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}\n\nproctype P_1() { \n\nNCS: if\n::  d_step {id==0;t[1] = 2;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[1] = 3;id = 1+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[1]==0;t[1] = 255;}  goto wait; \n\n:: t[1]==255 && id==1+1; goto CS; \n\n:: id!=1+1 && t[1]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}\n\nproctype P_2() { \n\nNCS: if\n::  d_step {id==0;t[2] = 2;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[2] = 3;id = 2+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[2]==0;t[2] = 255;}  goto wait; \n\n:: t[2]==255 && id==2+1; goto CS; \n\n:: id!=2+1 && t[2]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually.\n\n    This model is a discrete time simulation of the Fischer's real time\n    mutual exclusion protocol.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte id=0;\nbyte t[4];\n\n\ninit { \n d_step { \nt[0] =255; t[1] =255; t[2] =255; t[3] =255; }\natomic { \nrun Timer();\nrun P_0();\nrun P_1();\nrun P_2();\nrun P_3();\n} }\n\nproctype Timer() { \n\nq: if\n::  d_step {t[0]!=0 && t[1]!=0 && t[2]!=0 && t[3]!=0;t[0] = (t[0]-1)|((t[0]==255)*255);t[1] = (t[1]-1)|((t[1]==255)*255);t[2] = (t[2]-1)|((t[2]==255)*255);t[3] = (t[3]-1)|((t[3]==255)*255);}  goto q; \n\nfi;\n}\n\nproctype P_0() { \n\nNCS: if\n::  d_step {id==0;t[0] = 3;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[0] = 3;id = 0+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[0]==0;t[0] = 255;}  goto wait; \n\n:: t[0]==255 && id==0+1; goto CS; \n\n:: id!=0+1 && t[0]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}\n\nproctype P_1() { \n\nNCS: if\n::  d_step {id==0;t[1] = 3;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[1] = 3;id = 1+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[1]==0;t[1] = 255;}  goto wait; \n\n:: t[1]==255 && id==1+1; goto CS; \n\n:: id!=1+1 && t[1]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}\n\nproctype P_2() { \n\nNCS: if\n::  d_step {id==0;t[2] = 3;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[2] = 3;id = 2+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[2]==0;t[2] = 255;}  goto wait; \n\n:: t[2]==255 && id==2+1; goto CS; \n\n:: id!=2+1 && t[2]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}\n\nproctype P_3() { \n\nNCS: if\n::  d_step {id==0;t[3] = 3;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[3] = 3;id = 3+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[3]==0;t[3] = 255;}  goto wait; \n\n:: t[3]==255 && id==3+1; goto CS; \n\n:: id!=3+1 && t[3]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually.\n\n    This model is a discrete time simulation of the Fischer's real time\n    mutual exclusion protocol.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte id=0;\nbyte t[6];\n\n\ninit { \n d_step { \nt[0] =255; t[1] =255; t[2] =255; t[3] =255; t[4] =255; t[5] =255; }\natomic { \nrun Timer();\nrun P_0();\nrun P_1();\nrun P_2();\nrun P_3();\nrun P_4();\nrun P_5();\n} }\n\nproctype Timer() { \n\nq: if\n::  d_step {t[0]!=0 && t[1]!=0 && t[2]!=0 && t[3]!=0 && t[4]!=0 && t[5]!=0;t[0] = (t[0]-1)|((t[0]==255)*255);t[1] = (t[1]-1)|((t[1]==255)*255);t[2] = (t[2]-1)|((t[2]==255)*255);t[3] = (t[3]-1)|((t[3]==255)*255);t[4] = (t[4]-1)|((t[4]==255)*255);t[5] = (t[5]-1)|((t[5]==255)*255);}  goto q; \n\nfi;\n}\n\nproctype P_0() { \n\nNCS: if\n::  d_step {id==0;t[0] = 3;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[0] = 3;id = 0+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[0]==0;t[0] = 255;}  goto wait; \n\n:: t[0]==255 && id==0+1; goto CS; \n\n:: id!=0+1 && t[0]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}\n\nproctype P_1() { \n\nNCS: if\n::  d_step {id==0;t[1] = 3;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[1] = 3;id = 1+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[1]==0;t[1] = 255;}  goto wait; \n\n:: t[1]==255 && id==1+1; goto CS; \n\n:: id!=1+1 && t[1]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}\n\nproctype P_2() { \n\nNCS: if\n::  d_step {id==0;t[2] = 3;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[2] = 3;id = 2+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[2]==0;t[2] = 255;}  goto wait; \n\n:: t[2]==255 && id==2+1; goto CS; \n\n:: id!=2+1 && t[2]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}\n\nproctype P_3() { \n\nNCS: if\n::  d_step {id==0;t[3] = 3;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[3] = 3;id = 3+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[3]==0;t[3] = 255;}  goto wait; \n\n:: t[3]==255 && id==3+1; goto CS; \n\n:: id!=3+1 && t[3]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}\n\nproctype P_4() { \n\nNCS: if\n::  d_step {id==0;t[4] = 3;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[4] = 3;id = 4+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[4]==0;t[4] = 255;}  goto wait; \n\n:: t[4]==255 && id==4+1; goto CS; \n\n:: id!=4+1 && t[4]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}\n\nproctype P_5() { \n\nNCS: if\n::  d_step {id==0;t[5] = 3;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[5] = 3;id = 5+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[5]==0;t[5] = 255;}  goto wait; \n\n:: t[5]==255 && id==5+1; goto CS; \n\n:: id!=5+1 && t[5]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually.\n\n    This model is a discrete time simulation of the Fischer's real time\n    mutual exclusion protocol.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte id=0;\nbyte t[7];\n\n\ninit { \n d_step { \nt[0] =255; t[1] =255; t[2] =255; t[3] =255; t[4] =255; t[5] =255; t[6] =255; }\natomic { \nrun Timer();\nrun P_0();\nrun P_1();\nrun P_2();\nrun P_3();\nrun P_4();\nrun P_5();\nrun P_6();\n} }\n\nproctype Timer() { \n\nq: if\n::  d_step {t[0]!=0 && t[1]!=0 && t[2]!=0 && t[3]!=0 && t[4]!=0 && t[5]!=0 && t[6]!=0;t[0] = (t[0]-1)|((t[0]==255)*255);t[1] = (t[1]-1)|((t[1]==255)*255);t[2] = (t[2]-1)|((t[2]==255)*255);t[3] = (t[3]-1)|((t[3]==255)*255);t[4] = (t[4]-1)|((t[4]==255)*255);t[5] = (t[5]-1)|((t[5]==255)*255);t[6] = (t[6]-1)|((t[6]==255)*255);}  goto q; \n\nfi;\n}\n\nproctype P_0() { \n\nNCS: if\n::  d_step {id==0;t[0] = 2;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[0] = 3;id = 0+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[0]==0;t[0] = 255;}  goto wait; \n\n:: t[0]==255 && id==0+1; goto CS; \n\n:: id!=0+1 && t[0]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}\n\nproctype P_1() { \n\nNCS: if\n::  d_step {id==0;t[1] = 2;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[1] = 3;id = 1+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[1]==0;t[1] = 255;}  goto wait; \n\n:: t[1]==255 && id==1+1; goto CS; \n\n:: id!=1+1 && t[1]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}\n\nproctype P_2() { \n\nNCS: if\n::  d_step {id==0;t[2] = 2;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[2] = 3;id = 2+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[2]==0;t[2] = 255;}  goto wait; \n\n:: t[2]==255 && id==2+1; goto CS; \n\n:: id!=2+1 && t[2]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}\n\nproctype P_3() { \n\nNCS: if\n::  d_step {id==0;t[3] = 2;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[3] = 3;id = 3+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[3]==0;t[3] = 255;}  goto wait; \n\n:: t[3]==255 && id==3+1; goto CS; \n\n:: id!=3+1 && t[3]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}\n\nproctype P_4() { \n\nNCS: if\n::  d_step {id==0;t[4] = 2;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[4] = 3;id = 4+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[4]==0;t[4] = 255;}  goto wait; \n\n:: t[4]==255 && id==4+1; goto CS; \n\n:: id!=4+1 && t[4]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}\n\nproctype P_5() { \n\nNCS: if\n::  d_step {id==0;t[5] = 2;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[5] = 3;id = 5+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[5]==0;t[5] = 255;}  goto wait; \n\n:: t[5]==255 && id==5+1; goto CS; \n\n:: id!=5+1 && t[5]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}\n\nproctype P_6() { \n\nNCS: if\n::  d_step {id==0;t[6] = 2;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[6] = 3;id = 6+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[6]==0;t[6] = 255;}  goto wait; \n\n:: t[6]==255 && id==6+1; goto CS; \n\n:: id!=6+1 && t[6]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually.\n\n    This model is a discrete time simulation of the Fischer's real time\n    mutual exclusion protocol.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte id=0;\nbyte t[7];\n\n\ninit { \n d_step { \nt[0] =255; t[1] =255; t[2] =255; t[3] =255; t[4] =255; t[5] =255; t[6] =255; }\natomic { \nrun Timer();\nrun P_0();\nrun P_1();\nrun P_2();\nrun P_3();\nrun P_4();\nrun P_5();\nrun P_6();\n} }\n\nproctype Timer() { \n\nq: if\n::  d_step {t[0]!=0 && t[1]!=0 && t[2]!=0 && t[3]!=0 && t[4]!=0 && t[5]!=0 && t[6]!=0;t[0] = (t[0]-1)|((t[0]==255)*255);t[1] = (t[1]-1)|((t[1]==255)*255);t[2] = (t[2]-1)|((t[2]==255)*255);t[3] = (t[3]-1)|((t[3]==255)*255);t[4] = (t[4]-1)|((t[4]==255)*255);t[5] = (t[5]-1)|((t[5]==255)*255);t[6] = (t[6]-1)|((t[6]==255)*255);}  goto q; \n\nfi;\n}\n\nproctype P_0() { \n\nNCS: if\n::  d_step {id==0;t[0] = 4;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[0] = 4;id = 0+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[0]==0;t[0] = 255;}  goto wait; \n\n:: t[0]==255 && id==0+1; goto CS; \n\n:: id!=0+1 && t[0]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}\n\nproctype P_1() { \n\nNCS: if\n::  d_step {id==0;t[1] = 4;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[1] = 4;id = 1+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[1]==0;t[1] = 255;}  goto wait; \n\n:: t[1]==255 && id==1+1; goto CS; \n\n:: id!=1+1 && t[1]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}\n\nproctype P_2() { \n\nNCS: if\n::  d_step {id==0;t[2] = 4;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[2] = 4;id = 2+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[2]==0;t[2] = 255;}  goto wait; \n\n:: t[2]==255 && id==2+1; goto CS; \n\n:: id!=2+1 && t[2]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}\n\nproctype P_3() { \n\nNCS: if\n::  d_step {id==0;t[3] = 4;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[3] = 4;id = 3+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[3]==0;t[3] = 255;}  goto wait; \n\n:: t[3]==255 && id==3+1; goto CS; \n\n:: id!=3+1 && t[3]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}\n\nproctype P_4() { \n\nNCS: if\n::  d_step {id==0;t[4] = 4;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[4] = 4;id = 4+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[4]==0;t[4] = 255;}  goto wait; \n\n:: t[4]==255 && id==4+1; goto CS; \n\n:: id!=4+1 && t[4]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}\n\nproctype P_5() { \n\nNCS: if\n::  d_step {id==0;t[5] = 4;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[5] = 4;id = 5+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[5]==0;t[5] = 255;}  goto wait; \n\n:: t[5]==255 && id==5+1; goto CS; \n\n:: id!=5+1 && t[5]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}\n\nproctype P_6() { \n\nNCS: if\n::  d_step {id==0;t[6] = 4;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[6] = 4;id = 6+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[6]==0;t[6] = 255;}  goto wait; \n\n:: t[6]==255 && id==6+1; goto CS; \n\n:: id!=6+1 && t[6]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually.\n\n    This model is a discrete time simulation of the Fischer's real time\n    mutual exclusion protocol.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte id=0;\nbyte t[8];\n\n\ninit { \n d_step { \nt[0] =255; t[1] =255; t[2] =255; t[3] =255; t[4] =255; t[5] =255; t[6] =255; t[7] =255; }\natomic { \nrun Timer();\nrun P_0();\nrun P_1();\nrun P_2();\nrun P_3();\nrun P_4();\nrun P_5();\nrun P_6();\nrun P_7();\n} }\n\nproctype Timer() { \n\nq: if\n::  d_step {t[0]!=0 && t[1]!=0 && t[2]!=0 && t[3]!=0 && t[4]!=0 && t[5]!=0 && t[6]!=0 && t[7]!=0;t[0] = (t[0]-1)|((t[0]==255)*255);t[1] = (t[1]-1)|((t[1]==255)*255);t[2] = (t[2]-1)|((t[2]==255)*255);t[3] = (t[3]-1)|((t[3]==255)*255);t[4] = (t[4]-1)|((t[4]==255)*255);t[5] = (t[5]-1)|((t[5]==255)*255);t[6] = (t[6]-1)|((t[6]==255)*255);t[7] = (t[7]-1)|((t[7]==255)*255);}  goto q; \n\nfi;\n}\n\nproctype P_0() { \n\nNCS: if\n::  d_step {id==0;t[0] = 2;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[0] = 3;id = 0+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[0]==0;t[0] = 255;}  goto wait; \n\n:: t[0]==255 && id==0+1; goto CS; \n\n:: id!=0+1 && t[0]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}\n\nproctype P_1() { \n\nNCS: if\n::  d_step {id==0;t[1] = 2;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[1] = 3;id = 1+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[1]==0;t[1] = 255;}  goto wait; \n\n:: t[1]==255 && id==1+1; goto CS; \n\n:: id!=1+1 && t[1]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}\n\nproctype P_2() { \n\nNCS: if\n::  d_step {id==0;t[2] = 2;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[2] = 3;id = 2+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[2]==0;t[2] = 255;}  goto wait; \n\n:: t[2]==255 && id==2+1; goto CS; \n\n:: id!=2+1 && t[2]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}\n\nproctype P_3() { \n\nNCS: if\n::  d_step {id==0;t[3] = 2;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[3] = 3;id = 3+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[3]==0;t[3] = 255;}  goto wait; \n\n:: t[3]==255 && id==3+1; goto CS; \n\n:: id!=3+1 && t[3]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}\n\nproctype P_4() { \n\nNCS: if\n::  d_step {id==0;t[4] = 2;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[4] = 3;id = 4+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[4]==0;t[4] = 255;}  goto wait; \n\n:: t[4]==255 && id==4+1; goto CS; \n\n:: id!=4+1 && t[4]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}\n\nproctype P_5() { \n\nNCS: if\n::  d_step {id==0;t[5] = 2;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[5] = 3;id = 5+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[5]==0;t[5] = 255;}  goto wait; \n\n:: t[5]==255 && id==5+1; goto CS; \n\n:: id!=5+1 && t[5]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}\n\nproctype P_6() { \n\nNCS: if\n::  d_step {id==0;t[6] = 2;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[6] = 3;id = 6+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[6]==0;t[6] = 255;}  goto wait; \n\n:: t[6]==255 && id==6+1; goto CS; \n\n:: id!=6+1 && t[6]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}\n\nproctype P_7() { \n\nNCS: if\n::  d_step {id==0;t[7] = 2;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[7] = 3;id = 7+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[7]==0;t[7] = 255;}  goto wait; \n\n:: t[7]==255 && id==7+1; goto CS; \n\n:: id!=7+1 && t[7]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually.\n\n    This model is a discrete time simulation of the Fischer's real time\n    mutual exclusion protocol.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte id=0;\nbyte t[8];\n\n\ninit { \n d_step { \nt[0] =255; t[1] =255; t[2] =255; t[3] =255; t[4] =255; t[5] =255; t[6] =255; t[7] =255; }\natomic { \nrun Timer();\nrun P_0();\nrun P_1();\nrun P_2();\nrun P_3();\nrun P_4();\nrun P_5();\nrun P_6();\nrun P_7();\n} }\n\nproctype Timer() { \n\nq: if\n::  d_step {t[0]!=0 && t[1]!=0 && t[2]!=0 && t[3]!=0 && t[4]!=0 && t[5]!=0 && t[6]!=0 && t[7]!=0;t[0] = (t[0]-1)|((t[0]==255)*255);t[1] = (t[1]-1)|((t[1]==255)*255);t[2] = (t[2]-1)|((t[2]==255)*255);t[3] = (t[3]-1)|((t[3]==255)*255);t[4] = (t[4]-1)|((t[4]==255)*255);t[5] = (t[5]-1)|((t[5]==255)*255);t[6] = (t[6]-1)|((t[6]==255)*255);t[7] = (t[7]-1)|((t[7]==255)*255);}  goto q; \n\nfi;\n}\n\nproctype P_0() { \n\nNCS: if\n::  d_step {id==0;t[0] = 3;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[0] = 3;id = 0+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[0]==0;t[0] = 255;}  goto wait; \n\n:: t[0]==255 && id==0+1; goto CS; \n\n:: id!=0+1 && t[0]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}\n\nproctype P_1() { \n\nNCS: if\n::  d_step {id==0;t[1] = 3;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[1] = 3;id = 1+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[1]==0;t[1] = 255;}  goto wait; \n\n:: t[1]==255 && id==1+1; goto CS; \n\n:: id!=1+1 && t[1]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}\n\nproctype P_2() { \n\nNCS: if\n::  d_step {id==0;t[2] = 3;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[2] = 3;id = 2+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[2]==0;t[2] = 255;}  goto wait; \n\n:: t[2]==255 && id==2+1; goto CS; \n\n:: id!=2+1 && t[2]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}\n\nproctype P_3() { \n\nNCS: if\n::  d_step {id==0;t[3] = 3;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[3] = 3;id = 3+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[3]==0;t[3] = 255;}  goto wait; \n\n:: t[3]==255 && id==3+1; goto CS; \n\n:: id!=3+1 && t[3]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}\n\nproctype P_4() { \n\nNCS: if\n::  d_step {id==0;t[4] = 3;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[4] = 3;id = 4+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[4]==0;t[4] = 255;}  goto wait; \n\n:: t[4]==255 && id==4+1; goto CS; \n\n:: id!=4+1 && t[4]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}\n\nproctype P_5() { \n\nNCS: if\n::  d_step {id==0;t[5] = 3;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[5] = 3;id = 5+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[5]==0;t[5] = 255;}  goto wait; \n\n:: t[5]==255 && id==5+1; goto CS; \n\n:: id!=5+1 && t[5]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}\n\nproctype P_6() { \n\nNCS: if\n::  d_step {id==0;t[6] = 3;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[6] = 3;id = 6+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[6]==0;t[6] = 255;}  goto wait; \n\n:: t[6]==255 && id==6+1; goto CS; \n\n:: id!=6+1 && t[6]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}\n\nproctype P_7() { \n\nNCS: if\n::  d_step {id==0;t[7] = 3;}  goto try; \n\nfi;\ntry: if\n::  d_step {t[7] = 3;id = 7+1;}  goto wait; \n\nfi;\nwait: if\n::  d_step {t[7]==0;t[7] = 255;}  goto wait; \n\n:: t[7]==255 && id==7+1; goto CS; \n\n:: id!=7+1 && t[7]==255; goto NCS; \n\nfi;\nCS: if\n:: id = 0; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The Toads And Frogs Puzzle is also known under the names\n    of Hares and Tortoise and Sheep and Goats, Traffic Jam, or Black and White\n    stones. This is 2D variant of the puzzle. It takes place on NxM board.\nToads move righward and downward; toads move leftward and upward.\nEvery move is either a Slide to the nearby square or a Jump over one position,\n    which is allowed only if the latter is occupied by a fellow of a different\n    kind. In any case, no two animals are allowed in the same square.\nThe goal is to switch positions of toads and frogs.\n\nParameters:\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte a[17];\nbyte x=0;\nbyte y=8;\n\n\ninit { \n d_step { \na[0] =1; a[1] =1; a[2] =1; a[3] =1; a[4] =1; a[5] =1; a[6] =1; a[7] =1; a[8] =0; a[9] =2; a[10] =2; a[11] =2; a[12] =2; a[13] =2; a[14] =2; a[15] =2; a[16] =2; }\natomic { \nrun Toad();\nrun Frog();\nrun Check();\n} }\n\nproctype Toad() { \n\nq: if\n::  d_step {x>0 && a[((y)*1+x-1)]==1;a[((y)*1+x)] = 1;a[((y)*1+x-1)] = 0;x = x-1;}  goto q; \n\n::  d_step {y>0 && a[((y-1)*1+x)]==1;a[((y)*1+x)] = 1;a[((y-1)*1+x)] = 0;y = y-1;}  goto q; \n\n::  d_step {x>1 && a[((y)*1+x-1)]==2 && a[((y)*1+x-2)]==1;a[((y)*1+x)] = 1;a[((y)*1+x-2)] = 0;x = x-2;}  goto q; \n\n::  d_step {y>1 && a[((y-1)*1+x)]==2 && a[((y-2)*1+x)]==1;a[((y)*1+x)] = 1;a[((y-2)*1+x)] = 0;y = y-2;}  goto q; \n\nfi;\n}\n\nproctype Frog() { \n\nq: if\n::  d_step {x<1-1 && a[((y)*1+x+1)]==2;a[((y)*1+x)] = 2;a[((y)*1+x+1)] = 0;x = x+1;}  goto q; \n\n::  d_step {y<17-1 && a[((y+1)*1+x)]==2;a[((y)*1+x)] = 2;a[((y+1)*1+x)] = 0;y = y+1;}  goto q; \n\n::  d_step {x<1-2 && a[((y)*1+x+1)]==1 && a[((y)*1+x+2)]==2;a[((y)*1+x)] = 2;a[((y)*1+x+2)] = 0;x = x+2;}  goto q; \n\n::  d_step {y<17-2 && a[((y+1)*1+x)]==1 && a[((y+2)*1+x)]==2;a[((y)*1+x)] = 2;a[((y+2)*1+x)] = 0;y = y+2;}  goto q; \n\nfi;\n}\n\nproctype Check() { \n\nnot_done: if\n:: a[0]==2 && a[1]==2 && a[2]==2 && a[3]==2 && a[4]==2 && a[5]==2 && a[6]==2 && a[7]==2 && a[9]==1 && a[10]==1 && a[11]==1 && a[12]==1 && a[13]==1 && a[14]==1 && a[15]==1 && a[16]==1; goto done; \n\nfi;\ndone: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The Toads And Frogs Puzzle is also known under the names\n    of Hares and Tortoise and Sheep and Goats, Traffic Jam, or Black and White\n    stones. This is 2D variant of the puzzle. It takes place on NxM board.\nToads move righward and downward; toads move leftward and upward.\nEvery move is either a Slide to the nearby square or a Jump over one position,\n    which is allowed only if the latter is occupied by a fellow of a different\n    kind. In any case, no two animals are allowed in the same square.\nThe goal is to switch positions of toads and frogs.\n\nParameters:\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte a[15];\nbyte x=2;\nbyte y=1;\n\n\ninit { \n d_step { \na[0] =1; a[1] =1; a[2] =1; a[3] =1; a[4] =1; a[5] =1; a[6] =1; a[7] =0; a[8] =2; a[9] =2; a[10] =2; a[11] =2; a[12] =2; a[13] =2; a[14] =2; }\natomic { \nrun Toad();\nrun Frog();\nrun Check();\n} }\n\nproctype Toad() { \n\nq: if\n::  d_step {x>0 && a[((y)*5+x-1)]==1;a[((y)*5+x)] = 1;a[((y)*5+x-1)] = 0;x = x-1;}  goto q; \n\n::  d_step {y>0 && a[((y-1)*5+x)]==1;a[((y)*5+x)] = 1;a[((y-1)*5+x)] = 0;y = y-1;}  goto q; \n\n::  d_step {x>1 && a[((y)*5+x-1)]==2 && a[((y)*5+x-2)]==1;a[((y)*5+x)] = 1;a[((y)*5+x-2)] = 0;x = x-2;}  goto q; \n\n::  d_step {y>1 && a[((y-1)*5+x)]==2 && a[((y-2)*5+x)]==1;a[((y)*5+x)] = 1;a[((y-2)*5+x)] = 0;y = y-2;}  goto q; \n\nfi;\n}\n\nproctype Frog() { \n\nq: if\n::  d_step {x<5-1 && a[((y)*5+x+1)]==2;a[((y)*5+x)] = 2;a[((y)*5+x+1)] = 0;x = x+1;}  goto q; \n\n::  d_step {y<3-1 && a[((y+1)*5+x)]==2;a[((y)*5+x)] = 2;a[((y+1)*5+x)] = 0;y = y+1;}  goto q; \n\n::  d_step {x<5-2 && a[((y)*5+x+1)]==1 && a[((y)*5+x+2)]==2;a[((y)*5+x)] = 2;a[((y)*5+x+2)] = 0;x = x+2;}  goto q; \n\n::  d_step {y<3-2 && a[((y+1)*5+x)]==1 && a[((y+2)*5+x)]==2;a[((y)*5+x)] = 2;a[((y+2)*5+x)] = 0;y = y+2;}  goto q; \n\nfi;\n}\n\nproctype Check() { \n\nnot_done: if\n:: a[0]==2 && a[1]==2 && a[2]==2 && a[3]==2 && a[4]==2 && a[5]==2 && a[6]==2 && a[8]==1 && a[9]==1 && a[10]==1 && a[11]==1 && a[12]==1 && a[13]==1 && a[14]==1; goto done; \n\nfi;\ndone: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The Toads And Frogs Puzzle is also known under the names\n    of Hares and Tortoise and Sheep and Goats, Traffic Jam, or Black and White\n    stones. This is 2D variant of the puzzle. It takes place on NxM board.\nToads move righward and downward; toads move leftward and upward.\nEvery move is either a Slide to the nearby square or a Jump over one position,\n    which is allowed only if the latter is occupied by a fellow of a different\n    kind. In any case, no two animals are allowed in the same square.\nThe goal is to switch positions of toads and frogs.\n\nParameters:\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte a[31];\nbyte x=0;\nbyte y=15;\n\n\ninit { \n d_step { \na[0] =1; a[1] =1; a[2] =1; a[3] =1; a[4] =1; a[5] =1; a[6] =1; a[7] =1; a[8] =1; a[9] =1; a[10] =1; a[11] =1; a[12] =1; a[13] =1; a[14] =1; a[15] =0; a[16] =2; a[17] =2; a[18] =2; a[19] =2; a[20] =2; a[21] =2; a[22] =2; a[23] =2; a[24] =2; a[25] =2; a[26] =2; a[27] =2; a[28] =2; a[29] =2; a[30] =2; }\natomic { \nrun Toad();\nrun Frog();\nrun Check();\n} }\n\nproctype Toad() { \n\nq: if\n::  d_step {x>0 && a[((y)*1+x-1)]==1;a[((y)*1+x)] = 1;a[((y)*1+x-1)] = 0;x = x-1;}  goto q; \n\n::  d_step {y>0 && a[((y-1)*1+x)]==1;a[((y)*1+x)] = 1;a[((y-1)*1+x)] = 0;y = y-1;}  goto q; \n\n::  d_step {x>1 && a[((y)*1+x-1)]==2 && a[((y)*1+x-2)]==1;a[((y)*1+x)] = 1;a[((y)*1+x-2)] = 0;x = x-2;}  goto q; \n\n::  d_step {y>1 && a[((y-1)*1+x)]==2 && a[((y-2)*1+x)]==1;a[((y)*1+x)] = 1;a[((y-2)*1+x)] = 0;y = y-2;}  goto q; \n\nfi;\n}\n\nproctype Frog() { \n\nq: if\n::  d_step {x<1-1 && a[((y)*1+x+1)]==2;a[((y)*1+x)] = 2;a[((y)*1+x+1)] = 0;x = x+1;}  goto q; \n\n::  d_step {y<31-1 && a[((y+1)*1+x)]==2;a[((y)*1+x)] = 2;a[((y+1)*1+x)] = 0;y = y+1;}  goto q; \n\n::  d_step {x<1-2 && a[((y)*1+x+1)]==1 && a[((y)*1+x+2)]==2;a[((y)*1+x)] = 2;a[((y)*1+x+2)] = 0;x = x+2;}  goto q; \n\n::  d_step {y<31-2 && a[((y+1)*1+x)]==1 && a[((y+2)*1+x)]==2;a[((y)*1+x)] = 2;a[((y+2)*1+x)] = 0;y = y+2;}  goto q; \n\nfi;\n}\n\nproctype Check() { \n\nnot_done: if\n:: a[0]==2 && a[1]==2 && a[2]==2 && a[3]==2 && a[4]==2 && a[5]==2 && a[6]==2 && a[7]==2 && a[8]==2 && a[9]==2 && a[10]==2 && a[11]==2 && a[12]==2 && a[13]==2 && a[14]==2 && a[16]==1 && a[17]==1 && a[18]==1 && a[19]==1 && a[20]==1 && a[21]==1 && a[22]==1 && a[23]==1 && a[24]==1 && a[25]==1 && a[26]==1 && a[27]==1 && a[28]==1 && a[29]==1 && a[30]==1; goto done; \n\nfi;\ndone: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The Toads And Frogs Puzzle is also known under the names\n    of Hares and Tortoise and Sheep and Goats, Traffic Jam, or Black and White\n    stones. This is 2D variant of the puzzle. It takes place on NxM board.\nToads move righward and downward; toads move leftward and upward.\nEvery move is either a Slide to the nearby square or a Jump over one position,\n    which is allowed only if the latter is occupied by a fellow of a different\n    kind. In any case, no two animals are allowed in the same square.\nThe goal is to switch positions of toads and frogs.\n\nParameters:\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte a[25];\nbyte x=2;\nbyte y=2;\n\n\ninit { \n d_step { \na[0] =1; a[1] =1; a[2] =1; a[3] =1; a[4] =1; a[5] =1; a[6] =1; a[7] =1; a[8] =1; a[9] =1; a[10] =1; a[11] =1; a[12] =0; a[13] =2; a[14] =2; a[15] =2; a[16] =2; a[17] =2; a[18] =2; a[19] =2; a[20] =2; a[21] =2; a[22] =2; a[23] =2; a[24] =2; }\natomic { \nrun Toad();\nrun Frog();\nrun Check();\n} }\n\nproctype Toad() { \n\nq: if\n::  d_step {x>0 && a[((y)*5+x-1)]==1;a[((y)*5+x)] = 1;a[((y)*5+x-1)] = 0;x = x-1;}  goto q; \n\n::  d_step {y>0 && a[((y-1)*5+x)]==1;a[((y)*5+x)] = 1;a[((y-1)*5+x)] = 0;y = y-1;}  goto q; \n\n::  d_step {x>1 && a[((y)*5+x-1)]==2 && a[((y)*5+x-2)]==1;a[((y)*5+x)] = 1;a[((y)*5+x-2)] = 0;x = x-2;}  goto q; \n\n::  d_step {y>1 && a[((y-1)*5+x)]==2 && a[((y-2)*5+x)]==1;a[((y)*5+x)] = 1;a[((y-2)*5+x)] = 0;y = y-2;}  goto q; \n\nfi;\n}\n\nproctype Frog() { \n\nq: if\n::  d_step {x<5-1 && a[((y)*5+x+1)]==2;a[((y)*5+x)] = 2;a[((y)*5+x+1)] = 0;x = x+1;}  goto q; \n\n::  d_step {y<5-1 && a[((y+1)*5+x)]==2;a[((y)*5+x)] = 2;a[((y+1)*5+x)] = 0;y = y+1;}  goto q; \n\n::  d_step {x<5-2 && a[((y)*5+x+1)]==1 && a[((y)*5+x+2)]==2;a[((y)*5+x)] = 2;a[((y)*5+x+2)] = 0;x = x+2;}  goto q; \n\n::  d_step {y<5-2 && a[((y+1)*5+x)]==1 && a[((y+2)*5+x)]==2;a[((y)*5+x)] = 2;a[((y+2)*5+x)] = 0;y = y+2;}  goto q; \n\nfi;\n}\n\nproctype Check() { \n\nnot_done: if\n:: a[0]==2 && a[1]==2 && a[2]==2 && a[3]==2 && a[4]==2 && a[5]==2 && a[6]==2 && a[7]==2 && a[8]==2 && a[9]==2 && a[10]==2 && a[11]==2 && a[13]==1 && a[14]==1 && a[15]==1 && a[16]==1 && a[17]==1 && a[18]==1 && a[19]==1 && a[20]==1 && a[21]==1 && a[22]==1 && a[23]==1 && a[24]==1; goto done; \n\nfi;\ndone: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The Toads And Frogs Puzzle is also known under the names\n    of Hares and Tortoise and Sheep and Goats, Traffic Jam, or Black and White\n    stones. This is 2D variant of the puzzle. It takes place on NxM board.\nToads move righward and downward; toads move leftward and upward.\nEvery move is either a Slide to the nearby square or a Jump over one position,\n    which is allowed only if the latter is occupied by a fellow of a different\n    kind. In any case, no two animals are allowed in the same square.\nThe goal is to switch positions of toads and frogs.\n\nParameters:\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte a[30];\nbyte x=2;\nbyte y=2;\n\n\ninit { \n d_step { \na[0] =1; a[1] =1; a[2] =1; a[3] =1; a[4] =1; a[5] =1; a[6] =1; a[7] =1; a[8] =1; a[9] =1; a[10] =1; a[11] =1; a[12] =1; a[13] =1; a[14] =0; a[15] =2; a[16] =2; a[17] =2; a[18] =2; a[19] =2; a[20] =2; a[21] =2; a[22] =2; a[23] =2; a[24] =2; a[25] =2; a[26] =2; a[27] =2; a[28] =2; }\natomic { \nrun Toad();\nrun Frog();\nrun Check();\n} }\n\nproctype Toad() { \n\nq: if\n::  d_step {x>0 && a[((y)*6+x-1)]==1;a[((y)*6+x)] = 1;a[((y)*6+x-1)] = 0;x = x-1;}  goto q; \n\n::  d_step {y>0 && a[((y-1)*6+x)]==1;a[((y)*6+x)] = 1;a[((y-1)*6+x)] = 0;y = y-1;}  goto q; \n\n::  d_step {x>1 && a[((y)*6+x-1)]==2 && a[((y)*6+x-2)]==1;a[((y)*6+x)] = 1;a[((y)*6+x-2)] = 0;x = x-2;}  goto q; \n\n::  d_step {y>1 && a[((y-1)*6+x)]==2 && a[((y-2)*6+x)]==1;a[((y)*6+x)] = 1;a[((y-2)*6+x)] = 0;y = y-2;}  goto q; \n\nfi;\n}\n\nproctype Frog() { \n\nq: if\n::  d_step {x<6-1 && a[((y)*6+x+1)]==2;a[((y)*6+x)] = 2;a[((y)*6+x+1)] = 0;x = x+1;}  goto q; \n\n::  d_step {y<5-1 && a[((y+1)*6+x)]==2;a[((y)*6+x)] = 2;a[((y+1)*6+x)] = 0;y = y+1;}  goto q; \n\n::  d_step {x<6-2 && a[((y)*6+x+1)]==1 && a[((y)*6+x+2)]==2;a[((y)*6+x)] = 2;a[((y)*6+x+2)] = 0;x = x+2;}  goto q; \n\n::  d_step {y<5-2 && a[((y+1)*6+x)]==1 && a[((y+2)*6+x)]==2;a[((y)*6+x)] = 2;a[((y+2)*6+x)] = 0;y = y+2;}  goto q; \n\nfi;\n}\n\nproctype Check() { \n\nnot_done: if\n:: a[0]==2 && a[1]==2 && a[2]==2 && a[3]==2 && a[4]==2 && a[5]==2 && a[6]==2 && a[7]==2 && a[8]==2 && a[9]==2 && a[10]==2 && a[11]==2 && a[12]==2 && a[13]==2 && a[15]==1 && a[16]==1 && a[18]==1 && a[19]==1 && a[20]==1 && a[21]==1 && a[22]==1 && a[23]==1 && a[24]==1 && a[25]==1 && a[26]==1 && a[27]==1 && a[28]==1 && a[29]==1; goto done; \n\nfi;\ndone: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The gear controller is a component in the real-time\n   embedded system that operates in a modern vehicle. The gear-requests from\n   the driver are delivered over a communication network to the gear\n   controller. The controller implements the actual gear change by actuating\n   the lower level components of the system, such as the clutch, the engine and\n   the gear-box.\n\nParameters:\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte tGB=255;\nbyte tC=255;\nbyte tE=255;\nbyte tGC=255;\nint toGear=0;\nint currentGear=0;\n\nchan OpenClutch =[0] of {int};\nchan CloseClutch =[0] of {int};\nchan ClutchIsOpen =[0] of {int};\nchan ClutchIsClosed =[0] of {int};\nchan ReqSet =[0] of {int};\nchan ReqNeu =[0] of {int};\nchan GearSet =[0] of {int};\nchan GearNeu =[0] of {int};\nchan ReqSpeed =[0] of {int};\nchan ReqTorque =[0] of {int};\nchan ReqZeroTorque =[0] of {int};\nchan TorqueZero =[0] of {int};\nchan SpeedSet =[0] of {int};\nchan ReqNewGear =[0] of {int};\nchan NewGear =[0] of {int};\n\nactive proctype Clutch() { \n\nclosed: if\n::  atomic {OpenClutch?0;tC = 3;}  goto opening; \n\nfi;\nopening: if\n::  atomic {tC<=1;ClutchIsOpen!0;tC = 255;}  goto open; \n\n::  d_step {tC==0;tC = 255;}  goto error_open; \n\nfi;\nopen: if\n::  atomic {CloseClutch?0;tC = 3;}  goto closing; \n\nfi;\nclosing: if\n::  atomic {tC<=1;ClutchIsClosed!0;tC = 255;}  goto closed; \n\n::  d_step {tC==0;tC = 255;}  goto error_close; \n\nfi;\nerror_open: \nerror_close: \n false; }\n\nactive proctype GearBox() { \n\nneutral: if\n::  atomic {ReqSet?0;tGB = 6;}  goto closing; \n\nfi;\nclosing: if\n::  d_step {tGB==0;tGB = 255;}  goto error_idle; \n\n::  atomic {tGB<=4;GearSet!0;tGB = 255;}  goto idle; \n\nfi;\nidle: if\n::  atomic {ReqNeu?0;tGB = 4;}  goto opening; \n\nfi;\nopening: if\n::  d_step {tGB==0;tGB = 255;}  goto error_neu; \n\n::  atomic {tGB<=2;GearNeu!0;tGB = 255;}  goto neutral; \n\nfi;\nerror_idle: \nerror_neu: \n false; }\n\nactive proctype Engine() { \n\ninitial: if\n::  atomic {ReqSpeed?0;tE = 4;}  goto find_speed; \n\nfi;\ntorque: if\n::  atomic {ReqZeroTorque?0;tE = 8;}  goto dec_torque; \n\nfi;\ndec_torque: if\n:: tE==0; goto clutch_open; \n\n::  atomic {tE<=5;TorqueZero!0;tE = 255;}  goto zero; \n\nfi;\nclutch_close: if\n::  d_step {tE==0;tE = 255;}  goto error_speed; \n\n::  atomic {tE<17;ReqTorque?0;tE = 255;}  goto torque; \n\nfi;\nclutch_open: if\n:: toGear==0; goto initial; \n\n::  d_step {toGear!=0;tE = 18;}  goto clutch_close; \n\nfi;\nspeed: if\n::  d_step {tE==0;tE = 255;}  goto error_speed; \n\n::  atomic {tE>0;ReqTorque?0;tE = 255;}  goto torque; \n\nfi;\nfind_speed: if\n:: tE==0; goto clutch_open; \n\n::  atomic {tE<=3;SpeedSet!0;tE = 10;}  goto speed; \n\nfi;\nzero: if\n:: toGear==0; goto initial; \n\n::  atomic {toGear!=0;ReqSpeed?0;tE = 4;}  goto find_speed; \n\nfi;\nerror_speed: \n false; }\n\nactive proctype Interface() { \n\ngear: if\n::  atomic {currentGear<5;ReqNewGear!1;}  goto go_up; \n\n::  atomic {currentGear>-1;ReqNewGear!-1;}  goto go_down; \n\nfi;\ngo_up: if\n::  atomic {NewGear?0;currentGear = currentGear+1;}  goto gear; \n\nfi;\ngo_down: if\n::  atomic {NewGear?0;currentGear = currentGear-1;}  goto gear; \n\nfi;\n}\n\nactive proctype GearControl() { \nint dir=0;\n\ngear: if\n::  atomic {ReqNewGear?dir;toGear = toGear+dir;}  goto initiate; \n\nfi;\ninitiate: if\n::  atomic {currentGear!=0;ReqZeroTorque!0;tGC = 5;}  goto check_torque; \n\n:: currentGear==0; goto req_sync_speed; \n\nfi;\ncheck_torque: if\n::  atomic {tGC>0;TorqueZero?0;}  goto req_neu_gear; \n\n::  atomic {tGC==0;OpenClutch!0;tGC = 4;}  goto check_clutch2; \n\nfi;\nreq_neu_gear: if\n::  atomic {ReqNeu!0;tGC = 5;}  goto check_gear_neu; \n\nfi;\ncheck_gear_neu: if\n:: GearNeu?0; goto req_sync_speed; \n\n::  d_step {tGC==0;tGC = 255;}  goto gneu_error; \n\nfi;\nclutch_open2: if\n::  atomic {ReqNeu!0;tGC = 5;}  goto check_gear_neu2; \n\nfi;\ncheck_gear_neu2: if\n::  d_step {tGC==0;tGC = 255;}  goto gneu_error; \n\n::  atomic {GearNeu?0;tGC = 0;}  goto req_set_gear2; \n\nfi;\nreq_sync_speed: if\n:: toGear==0; goto gear_chnlged; \n\n::  atomic {toGear!=0;ReqSpeed!0;tGC = 3;}  goto check_sync_speed; \n\nfi;\ncheck_clutch: if\n:: tGC==0; goto copen_error; \n\n::  atomic {ClutchIsOpen?0;tGC = 0;}  goto clutch_open; \n\nfi;\nreq_set_gear2: if\n::  atomic {toGear!=0;ReqSet!0;tGC = 7;}  goto check_gear_set2; \n\n::  atomic {toGear==0;CloseClutch!0;tGC = 4;}  goto check_clutch_closed2; \n\nfi;\ncheck_sync_speed: if\n::  atomic {tGC>0;SpeedSet?0;}  goto req_set_gear; \n\n::  atomic {tGC==0;OpenClutch!0;tGC = 4;}  goto check_clutch; \n\nfi;\nreq_set_gear: if\n::  atomic {ReqSet!0;tGC = 7;}  goto check_gear_set1; \n\nfi;\nclutch_open: if\n::  atomic {ReqSet!0;tGC = 7;}  goto check_gear_set2; \n\nfi;\ncheck_gear_set1: if\n::  atomic {GearSet?0;tGC = 0;}  goto req_torque; \n\n::  d_step {tGC==0;tGC = 255;}  goto gset_error; \n\nfi;\ncheck_gear_set2: if\n::  d_step {tGC==0;tGC = 255;}  goto gset_error; \n\n::  atomic {GearSet?0;tGC = 0;}  goto clutch_close; \n\nfi;\nreq_torque: if\n:: ReqTorque!0; goto gear_chnlged; \n\nfi;\ncheck_clutch_closed: if\n::  atomic {ClutchIsClosed?0;tGC = 0;}  goto req_torque; \n\n::  d_step {tGC==0;tGC = 255;}  goto cclose_error; \n\nfi;\nclutch_close: if\n::  atomic {CloseClutch!0;tGC = 4;}  goto check_clutch_closed; \n\nfi;\ngear_chnlged: if\n::  atomic {NewGear!0;tGC = 255;}  goto gear; \n\nfi;\ncheck_clutch_closed2: if\n::  d_step {tGC==0;tGC = 255;}  goto cclose_error; \n\n::  atomic {ClutchIsClosed?0;tGC = 0;}  goto gear_chnlged; \n\nfi;\ncheck_clutch2: if\n::  d_step {tGC==0;tGC = 255;}  goto copen_error; \n\n::  atomic {ClutchIsOpen?0;tGC = 0;}  goto clutch_open2; \n\nfi;\ncopen_error: \ngneu_error: \ngset_error: \ncclose_error: \n false; }\n\nactive proctype Timer() { \n\nq: if\n::  d_step {tGB!=0 && tC!=0 && tE!=0 && tGC!=0;tGB = (tGB-1)|((tGB==255)*255);tC = (tC-1)|((tC==255)*255);tE = (tE-1)|((tE==255)*255);tGC = (tGC-1)|((tGC==255)*255);}  goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The gear controller is a component in the real-time\n   embedded system that operates in a modern vehicle. The gear-requests from\n   the driver are delivered over a communication network to the gear\n   controller. The controller implements the actual gear change by actuating\n   the lower level components of the system, such as the clutch, the engine and\n   the gear-box.\n\nParameters:\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte tGB=255;\nbyte tC=255;\nbyte tE=255;\nbyte tGC=255;\nint toGear=0;\nint currentGear=0;\n\nchan OpenClutch =[0] of {int};\nchan CloseClutch =[0] of {int};\nchan ClutchIsOpen =[0] of {int};\nchan ClutchIsClosed =[0] of {int};\nchan ReqSet =[0] of {int};\nchan ReqNeu =[0] of {int};\nchan GearSet =[0] of {int};\nchan GearNeu =[0] of {int};\nchan ReqSpeed =[0] of {int};\nchan ReqTorque =[0] of {int};\nchan ReqZeroTorque =[0] of {int};\nchan TorqueZero =[0] of {int};\nchan SpeedSet =[0] of {int};\nchan ReqNewGear =[0] of {int};\nchan NewGear =[0] of {int};\n\nactive proctype Clutch() { \n\nclosed: if\n::  atomic {OpenClutch?0;tC = 3;}  goto opening; \n\nfi;\nopening: if\n::  atomic {tC<=1;ClutchIsOpen!0;tC = 255;}  goto open; \n\n::  d_step {tC==0;tC = 255;}  goto error_open; \n\nfi;\nopen: if\n::  atomic {CloseClutch?0;tC = 3;}  goto closing; \n\nfi;\nclosing: if\n::  atomic {tC<=1;ClutchIsClosed!0;tC = 255;}  goto closed; \n\n::  d_step {tC==0;tC = 255;}  goto error_close; \n\nfi;\nerror_open: \nerror_close: \n false; }\n\nactive proctype GearBox() { \n\nneutral: if\n::  atomic {ReqSet?0;tGB = 6;}  goto closing; \n\nfi;\nclosing: if\n::  d_step {tGB==0;tGB = 255;}  goto error_idle; \n\n::  atomic {tGB<=4;GearSet!0;tGB = 255;}  goto idle; \n\nfi;\nidle: if\n::  atomic {ReqNeu?0;tGB = 4;}  goto opening; \n\nfi;\nopening: if\n::  d_step {tGB==0;tGB = 255;}  goto error_neu; \n\n::  atomic {tGB<=2;GearNeu!0;tGB = 255;}  goto neutral; \n\nfi;\nerror_idle: \nerror_neu: \n false; }\n\nactive proctype Engine() { \n\ninitial: if\n::  atomic {ReqSpeed?0;tE = 4;}  goto find_speed; \n\nfi;\ntorque: if\n::  atomic {ReqZeroTorque?0;tE = 8;}  goto dec_torque; \n\nfi;\ndec_torque: if\n:: tE==0; goto clutch_open; \n\n::  atomic {tE<=5;TorqueZero!0;tE = 255;}  goto zero; \n\nfi;\nclutch_close: if\n::  d_step {tE==0;tE = 255;}  goto error_speed; \n\n::  atomic {tE<17;ReqTorque?0;tE = 255;}  goto torque; \n\nfi;\nclutch_open: if\n:: toGear==0; goto initial; \n\n::  d_step {toGear!=0;tE = 18;}  goto clutch_close; \n\nfi;\nspeed: if\n::  d_step {tE==0;tE = 255;}  goto error_speed; \n\n::  atomic {tE>0;ReqTorque?0;tE = 255;}  goto torque; \n\nfi;\nfind_speed: if\n:: tE==0; goto clutch_open; \n\n::  atomic {tE<=3;SpeedSet!0;tE = 10;}  goto speed; \n\nfi;\nzero: if\n:: toGear==0; goto initial; \n\n::  atomic {toGear!=0;ReqSpeed?0;tE = 4;}  goto find_speed; \n\nfi;\nerror_speed: \n false; }\n\nactive proctype Interface() { \n\ngear: if\n::  atomic {currentGear<30;ReqNewGear!1;}  goto go_up; \n\n::  atomic {currentGear>-1;ReqNewGear!-1;}  goto go_down; \n\nfi;\ngo_up: if\n::  atomic {NewGear?0;currentGear = currentGear+1;}  goto gear; \n\nfi;\ngo_down: if\n::  atomic {NewGear?0;currentGear = currentGear-1;}  goto gear; \n\nfi;\n}\n\nactive proctype GearControl() { \nint dir=0;\n\ngear: if\n::  atomic {ReqNewGear?dir;toGear = toGear+dir;}  goto initiate; \n\nfi;\ninitiate: if\n::  atomic {currentGear!=0;ReqZeroTorque!0;tGC = 5;}  goto check_torque; \n\n:: currentGear==0; goto req_sync_speed; \n\nfi;\ncheck_torque: if\n::  atomic {tGC>0;TorqueZero?0;}  goto req_neu_gear; \n\n::  atomic {tGC==0;OpenClutch!0;tGC = 4;}  goto check_clutch2; \n\nfi;\nreq_neu_gear: if\n::  atomic {ReqNeu!0;tGC = 5;}  goto check_gear_neu; \n\nfi;\ncheck_gear_neu: if\n:: GearNeu?0; goto req_sync_speed; \n\n::  d_step {tGC==0;tGC = 255;}  goto gneu_error; \n\nfi;\nclutch_open2: if\n::  atomic {ReqNeu!0;tGC = 5;}  goto check_gear_neu2; \n\nfi;\ncheck_gear_neu2: if\n::  d_step {tGC==0;tGC = 255;}  goto gneu_error; \n\n::  atomic {GearNeu?0;tGC = 0;}  goto req_set_gear2; \n\nfi;\nreq_sync_speed: if\n:: toGear==0; goto gear_chnlged; \n\n::  atomic {toGear!=0;ReqSpeed!0;tGC = 3;}  goto check_sync_speed; \n\nfi;\ncheck_clutch: if\n:: tGC==0; goto copen_error; \n\n::  atomic {ClutchIsOpen?0;tGC = 0;}  goto clutch_open; \n\nfi;\nreq_set_gear2: if\n::  atomic {toGear!=0;ReqSet!0;tGC = 7;}  goto check_gear_set2; \n\n::  atomic {toGear==0;CloseClutch!0;tGC = 4;}  goto check_clutch_closed2; \n\nfi;\ncheck_sync_speed: if\n::  atomic {tGC>0;SpeedSet?0;}  goto req_set_gear; \n\n::  atomic {tGC==0;OpenClutch!0;tGC = 4;}  goto check_clutch; \n\nfi;\nreq_set_gear: if\n::  atomic {ReqSet!0;tGC = 7;}  goto check_gear_set1; \n\nfi;\nclutch_open: if\n::  atomic {ReqSet!0;tGC = 7;}  goto check_gear_set2; \n\nfi;\ncheck_gear_set1: if\n::  atomic {GearSet?0;tGC = 0;}  goto req_torque; \n\n::  d_step {tGC==0;tGC = 255;}  goto gset_error; \n\nfi;\ncheck_gear_set2: if\n::  d_step {tGC==0;tGC = 255;}  goto gset_error; \n\n::  atomic {GearSet?0;tGC = 0;}  goto clutch_close; \n\nfi;\nreq_torque: if\n:: ReqTorque!0; goto gear_chnlged; \n\nfi;\ncheck_clutch_closed: if\n::  atomic {ClutchIsClosed?0;tGC = 0;}  goto req_torque; \n\n::  d_step {tGC==0;tGC = 255;}  goto cclose_error; \n\nfi;\nclutch_close: if\n::  atomic {CloseClutch!0;tGC = 4;}  goto check_clutch_closed; \n\nfi;\ngear_chnlged: if\n::  atomic {NewGear!0;tGC = 255;}  goto gear; \n\nfi;\ncheck_clutch_closed2: if\n::  d_step {tGC==0;tGC = 255;}  goto cclose_error; \n\n::  atomic {ClutchIsClosed?0;tGC = 0;}  goto gear_chnlged; \n\nfi;\ncheck_clutch2: if\n::  d_step {tGC==0;tGC = 255;}  goto copen_error; \n\n::  atomic {ClutchIsOpen?0;tGC = 0;}  goto clutch_open2; \n\nfi;\ncopen_error: \ngneu_error: \ngset_error: \ncclose_error: \n false; }\n\nactive proctype Timer() { \n\nq: if\n::  d_step {tGB!=0 && tC!=0 && tE!=0 && tGC!=0;tGB = (tGB-1)|((tGB==255)*255);tC = (tC-1)|((tC==255)*255);tE = (tE-1)|((tE==255)*255);tGC = (tGC-1)|((tGC==255)*255);}  goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The Tower of Hanoi (sometimes referred to as the Tower of\n    Brahma or the End of the World Puzzle) was invented by the French\n    mathematician, Edouard Lucas, in 1883. He was inspired by a legend that\n    tells of a Hindu temple where the pyramid puzzle might have been used for\n    the mental discipline of young priests. Legend says that at the beginning\n    of time the priests in the temple were given a stack of 64 gold disks, each\n    one a little smaller than the one beneath it. Their assignment was to\n    transfer the 64 disks from one of the three poles to another, with one\n    important proviso that a large disk could never be placed on top of a\n    smaller one. The priests worked very efficiently, day and night. When they\n    finished their work, the myth said, the temple would crumble into dust and\n    the world would vanish.\n\nParameters:\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte a[9];\nbyte a_act=9;\nbyte b[9];\nbyte b_act=1;\nbyte c[9];\nbyte c_act=1;\n\n\ninit { \n d_step { \na[0] =100; a[1] =8-0; a[2] =8-1; a[3] =8-2; a[4] =8-3; a[5] =8-4; a[6] =8-5; a[7] =8-6; a[8] =8-7; b[0] =100; b[1] =0; b[2] =0; b[3] =0; b[4] =0; b[5] =0; b[6] =0; b[7] =0; b[8] =0; c[0] =100; c[1] =0; c[2] =0; c[3] =0; c[4] =0; c[5] =0; c[6] =0; c[7] =0; c[8] =0; }\natomic { \nrun AtoB();\nrun AtoC();\nrun BtoA();\nrun BtoC();\nrun CtoA();\nrun CtoB();\n} }\n\nproctype AtoB() { \n\nq: if\n::  d_step {a[a_act-1]<b[b_act-1];b[b_act] = a[a_act-1];b_act = b_act+1;a[a_act-1] = 0;a_act = a_act-1;}  goto q; \n\nfi;\n}\n\nproctype AtoC() { \n\nq: if\n::  d_step {a[a_act-1]<c[c_act-1];c[c_act] = a[a_act-1];c_act = c_act+1;a[a_act-1] = 0;a_act = a_act-1;}  goto q; \n\nfi;\n}\n\nproctype BtoA() { \n\nq: if\n::  d_step {b[b_act-1]<a[a_act-1];a[a_act] = b[b_act-1];a_act = a_act+1;b[b_act-1] = 0;b_act = b_act-1;}  goto q; \n\nfi;\n}\n\nproctype BtoC() { \n\nq: if\n::  d_step {b[b_act-1]<c[c_act-1];c[c_act] = b[b_act-1];c_act = c_act+1;b[b_act-1] = 0;b_act = b_act-1;}  goto q; \n\nfi;\n}\n\nproctype CtoA() { \n\nq: if\n::  d_step {c[c_act-1]<a[a_act-1];a[a_act] = c[c_act-1];a_act = a_act+1;c[c_act-1] = 0;c_act = c_act-1;}  goto q; \n\nfi;\n}\n\nproctype CtoB() { \n\nq: if\n::  d_step {c[c_act-1]<b[b_act-1];b[b_act] = c[c_act-1];b_act = b_act+1;c[c_act-1] = 0;c_act = c_act-1;}  goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The Tower of Hanoi (sometimes referred to as the Tower of\n    Brahma or the End of the World Puzzle) was invented by the French\n    mathematician, Edouard Lucas, in 1883. He was inspired by a legend that\n    tells of a Hindu temple where the pyramid puzzle might have been used for\n    the mental discipline of young priests. Legend says that at the beginning\n    of time the priests in the temple were given a stack of 64 gold disks, each\n    one a little smaller than the one beneath it. Their assignment was to\n    transfer the 64 disks from one of the three poles to another, with one\n    important proviso that a large disk could never be placed on top of a\n    smaller one. The priests worked very efficiently, day and night. When they\n    finished their work, the myth said, the temple would crumble into dust and\n    the world would vanish.\n\nParameters:\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte a[13];\nbyte a_act=13;\nbyte b[13];\nbyte b_act=1;\nbyte c[13];\nbyte c_act=1;\n\n\ninit { \n d_step { \na[0] =100; a[1] =12-0; a[2] =12-1; a[3] =12-2; a[4] =12-3; a[5] =12-4; a[6] =12-5; a[7] =12-6; a[8] =12-7; a[9] =12-8; a[10] =12-9; a[11] =12-10; a[12] =12-11; b[0] =100; b[1] =0; b[2] =0; b[3] =0; b[4] =0; b[5] =0; b[6] =0; b[7] =0; b[8] =0; b[9] =0; b[10] =0; b[11] =0; b[12] =0; c[0] =100; c[1] =0; c[2] =0; c[3] =0; c[4] =0; c[5] =0; c[6] =0; c[7] =0; c[8] =0; c[9] =0; c[10] =0; c[11] =0; c[12] =0; }\natomic { \nrun AtoB();\nrun AtoC();\nrun BtoA();\nrun BtoC();\nrun CtoA();\nrun CtoB();\n} }\n\nproctype AtoB() { \n\nq: if\n::  d_step {a[a_act-1]<b[b_act-1];b[b_act] = a[a_act-1];b_act = b_act+1;a[a_act-1] = 0;a_act = a_act-1;}  goto q; \n\nfi;\n}\n\nproctype AtoC() { \n\nq: if\n::  d_step {a[a_act-1]<c[c_act-1];c[c_act] = a[a_act-1];c_act = c_act+1;a[a_act-1] = 0;a_act = a_act-1;}  goto q; \n\nfi;\n}\n\nproctype BtoA() { \n\nq: if\n::  d_step {b[b_act-1]<a[a_act-1];a[a_act] = b[b_act-1];a_act = a_act+1;b[b_act-1] = 0;b_act = b_act-1;}  goto q; \n\nfi;\n}\n\nproctype BtoC() { \n\nq: if\n::  d_step {b[b_act-1]<c[c_act-1];c[c_act] = b[b_act-1];c_act = c_act+1;b[b_act-1] = 0;b_act = b_act-1;}  goto q; \n\nfi;\n}\n\nproctype CtoA() { \n\nq: if\n::  d_step {c[c_act-1]<a[a_act-1];a[a_act] = c[c_act-1];a_act = a_act+1;c[c_act-1] = 0;c_act = c_act-1;}  goto q; \n\nfi;\n}\n\nproctype CtoB() { \n\nq: if\n::  d_step {c[c_act-1]<b[b_act-1];b[b_act] = c[c_act-1];b_act = b_act+1;c[c_act-1] = 0;c_act = c_act-1;}  goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The Tower of Hanoi (sometimes referred to as the Tower of\n    Brahma or the End of the World Puzzle) was invented by the French\n    mathematician, Edouard Lucas, in 1883. He was inspired by a legend that\n    tells of a Hindu temple where the pyramid puzzle might have been used for\n    the mental discipline of young priests. Legend says that at the beginning\n    of time the priests in the temple were given a stack of 64 gold disks, each\n    one a little smaller than the one beneath it. Their assignment was to\n    transfer the 64 disks from one of the three poles to another, with one\n    important proviso that a large disk could never be placed on top of a\n    smaller one. The priests worked very efficiently, day and night. When they\n    finished their work, the myth said, the temple would crumble into dust and\n    the world would vanish.\n\nParameters:\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte a[16];\nbyte a_act=16;\nbyte b[16];\nbyte b_act=1;\nbyte c[16];\nbyte c_act=1;\n\n\ninit { \n d_step { \na[0] =100; a[1] =15-0; a[2] =15-1; a[3] =15-2; a[4] =15-3; a[5] =15-4; a[6] =15-5; a[7] =15-6; a[8] =15-7; a[9] =15-8; a[10] =15-9; a[11] =15-10; a[12] =15-11; a[13] =15-12; a[14] =15-13; a[15] =15-14; b[0] =100; b[1] =0; b[2] =0; b[3] =0; b[4] =0; b[5] =0; b[6] =0; b[7] =0; b[8] =0; b[9] =0; b[10] =0; b[11] =0; b[12] =0; b[13] =0; b[14] =0; b[15] =0; c[0] =100; c[1] =0; c[2] =0; c[3] =0; c[4] =0; c[5] =0; c[6] =0; c[7] =0; c[8] =0; c[9] =0; c[10] =0; c[11] =0; c[12] =0; c[13] =0; c[14] =0; c[15] =0; }\natomic { \nrun AtoB();\nrun AtoC();\nrun BtoA();\nrun BtoC();\nrun CtoA();\nrun CtoB();\n} }\n\nproctype AtoB() { \n\nq: if\n::  d_step {a[a_act-1]<b[b_act-1];b[b_act] = a[a_act-1];b_act = b_act+1;a[a_act-1] = 0;a_act = a_act-1;}  goto q; \n\nfi;\n}\n\nproctype AtoC() { \n\nq: if\n::  d_step {a[a_act-1]<c[c_act-1];c[c_act] = a[a_act-1];c_act = c_act+1;a[a_act-1] = 0;a_act = a_act-1;}  goto q; \n\nfi;\n}\n\nproctype BtoA() { \n\nq: if\n::  d_step {b[b_act-1]<a[a_act-1];a[a_act] = b[b_act-1];a_act = a_act+1;b[b_act-1] = 0;b_act = b_act-1;}  goto q; \n\nfi;\n}\n\nproctype BtoC() { \n\nq: if\n::  d_step {b[b_act-1]<c[c_act-1];c[c_act] = b[b_act-1];c_act = c_act+1;b[b_act-1] = 0;b_act = b_act-1;}  goto q; \n\nfi;\n}\n\nproctype CtoA() { \n\nq: if\n::  d_step {c[c_act-1]<a[a_act-1];a[a_act] = c[c_act-1];a_act = a_act+1;c[c_act-1] = 0;c_act = c_act-1;}  goto q; \n\nfi;\n}\n\nproctype CtoB() { \n\nq: if\n::  d_step {c[c_act-1]<b[b_act-1];b[b_act] = c[c_act-1];b_act = b_act+1;c[c_act-1] = 0;c_act = c_act-1;}  goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The Tower of Hanoi (sometimes referred to as the Tower of\n    Brahma or the End of the World Puzzle) was invented by the French\n    mathematician, Edouard Lucas, in 1883. He was inspired by a legend that\n    tells of a Hindu temple where the pyramid puzzle might have been used for\n    the mental discipline of young priests. Legend says that at the beginning\n    of time the priests in the temple were given a stack of 64 gold disks, each\n    one a little smaller than the one beneath it. Their assignment was to\n    transfer the 64 disks from one of the three poles to another, with one\n    important proviso that a large disk could never be placed on top of a\n    smaller one. The priests worked very efficiently, day and night. When they\n    finished their work, the myth said, the temple would crumble into dust and\n    the world would vanish.\n\nParameters:\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte a[18];\nbyte a_act=18;\nbyte b[18];\nbyte b_act=1;\nbyte c[18];\nbyte c_act=1;\n\n\ninit { \n d_step { \na[0] =100; a[1] =17-0; a[2] =17-1; a[3] =17-2; a[4] =17-3; a[5] =17-4; a[6] =17-5; a[7] =17-6; a[8] =17-7; a[9] =17-8; a[10] =17-9; a[11] =17-10; a[12] =17-11; a[13] =17-12; a[14] =17-13; a[15] =17-14; a[16] =17-15; a[17] =17-16; b[0] =100; b[1] =0; b[2] =0; b[3] =0; b[4] =0; b[5] =0; b[6] =0; b[7] =0; b[8] =0; b[9] =0; b[10] =0; b[11] =0; b[12] =0; b[13] =0; b[14] =0; b[15] =0; b[16] =0; b[17] =0; c[0] =100; c[1] =0; c[2] =0; c[3] =0; c[4] =0; c[5] =0; c[6] =0; c[7] =0; c[8] =0; c[9] =0; c[10] =0; c[11] =0; c[12] =0; c[13] =0; c[14] =0; c[15] =0; c[16] =0; c[17] =0; }\natomic { \nrun AtoB();\nrun AtoC();\nrun BtoA();\nrun BtoC();\nrun CtoA();\nrun CtoB();\n} }\n\nproctype AtoB() { \n\nq: if\n::  d_step {a[a_act-1]<b[b_act-1];b[b_act] = a[a_act-1];b_act = b_act+1;a[a_act-1] = 0;a_act = a_act-1;}  goto q; \n\nfi;\n}\n\nproctype AtoC() { \n\nq: if\n::  d_step {a[a_act-1]<c[c_act-1];c[c_act] = a[a_act-1];c_act = c_act+1;a[a_act-1] = 0;a_act = a_act-1;}  goto q; \n\nfi;\n}\n\nproctype BtoA() { \n\nq: if\n::  d_step {b[b_act-1]<a[a_act-1];a[a_act] = b[b_act-1];a_act = a_act+1;b[b_act-1] = 0;b_act = b_act-1;}  goto q; \n\nfi;\n}\n\nproctype BtoC() { \n\nq: if\n::  d_step {b[b_act-1]<c[c_act-1];c[c_act] = b[b_act-1];c_act = c_act+1;b[b_act-1] = 0;b_act = b_act-1;}  goto q; \n\nfi;\n}\n\nproctype CtoA() { \n\nq: if\n::  d_step {c[c_act-1]<a[a_act-1];a[a_act] = c[c_act-1];a_act = a_act+1;c[c_act-1] = 0;c_act = c_act-1;}  goto q; \n\nfi;\n}\n\nproctype CtoB() { \n\nq: if\n::  d_step {c[c_act-1]<b[b_act-1];b[b_act] = c[c_act-1];b_act = b_act+1;c[c_act-1] = 0;c_act = c_act-1;}  goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The i-protocol is a part of protocol stack; its purpose\n    is to ensure ordered reliable duplex communication between sites. At its\n    lower interface it assumes unreliable (lossy) packet-based FIFO\n    connectivity. To its upper interface it provides reliable packet-based FIFO\n    connectivity. A distinguished feature of the i-protocol is the rather\n    sophisticated manner in which it attempts to minimize control-messages and\n    retransmission overhead.\n\nParameters:\n\n\n\nAtomic propositions:\n, , \n\nProperties to verify:"}, {"role": "assistant", "content": "chan Get =[0] of {int};\nchan Put =[0] of {int};\nchan SAck =[0] of {int};\nchan SNak =[0] of {int};\nchan SData =[0] of {int};\nchan RAck =[0] of {int};\nchan RNak =[0] of {int};\nchan RData =[0] of {int};\nchan RCorrData =[0] of {int};\nchan Timeout =[0] of {int};\n\nactive proctype Timer() { \n\ntick: if\n:: Timeout!0; goto tick; \n\nfi;\n}\n\nactive proctype Producer() { \nbyte message=0;\n\nwait: if\n::  goto produce; \n\nfi;\nproduce: if\n::  atomic {Get!message;message = (message+1)%3;}  goto wait; \n\nfi;\n}\n\nactive proctype Consumer() { \nbyte message=0;\n\nwait: if\n:: Put?message; goto consume; \n\nfi;\nconsume: if\n::  goto wait; \n\nfi;\n}\n\nactive proctype Medium() { \nbyte value=0;\n\nwait: if\n:: SData?value; goto data; \n\n:: RAck?value; goto ack; \n\n:: RNak?value; goto nak; \n\nfi;\ndata: if\n:: RData!value; goto dataOk; \n\n:: RCorrData!value; goto wait; \n\n::  goto wait; \n\nfi;\nack: if\n:: SAck!value; goto ackOk; \n\n::  goto wait; \n\nfi;\nnak: if\n:: SNak!value; goto nakOk; \n\n::  goto wait; \n\nfi;\ndataOk: if\n::  goto wait; \n\nfi;\nackOk: if\n::  goto wait; \n\nfi;\nnakOk: if\n::  goto wait; \n\nfi;\n}\n\nactive proctype Sender() { \nbyte sendseq=1;\nbyte rack=0;\nbyte value=0;\n\nwait: if\n:: SAck?value; goto ack; \n\n:: SNak?value; goto nak; \n\n:: Timeout?0; goto timeisout; \n\n::  atomic {(rack+2)%3>sendseq;Get?value;}  goto data; \n\nfi;\ndata: if\n::  atomic {SData!sendseq;sendseq = (sendseq+1)%3;}  goto wait; \n\nfi;\nack: if\n::  d_step {(rack<sendseq && rack<value && value<sendseq) || (rack>sendseq && sendseq<value && value<rack);rack = value;}  goto wait; \n\n:: (rack>=sendseq || rack>=value || value>=sendseq) && (rack<=sendseq || sendseq>=value || value>=rack); goto wait; \n\nfi;\nnak: if\n::  atomic {(rack<sendseq && rack<value && value<sendseq) || (rack>sendseq && sendseq<value && value<rack);SData!value;}  goto wait; \n\n:: (rack>=sendseq || rack>=value || value>=sendseq) && (rack<=sendseq || sendseq>=value || value>=rack); goto wait; \n\nfi;\ntimeisout: if\n::  atomic {(rack+1)%3!=sendseq;SData!(rack+1)%3;}  goto wait; \n\n:: (rack+1)%3==sendseq; goto wait; \n\nfi;\n}\n\nactive proctype Receiver() { \nbyte i=0;\nbyte value=0;\nbyte sent=0;\nbyte recseq=0;\nbyte lack=0;\nbyte recbuf[3];\nbyte nakd[3];\n\nwait: if\n:: RData?value; goto data; \n\n:: RCorrData?value; goto corr_data; \n\n::  atomic {Timeout?0;i = 0;}  goto on_timeisout; \n\nfi;\ndata: if\n::  d_step {value!=(recseq+1)%3;recbuf[value] = 1;i = (recseq+1)%3;}  goto send_naks; \n\n::  atomic {value==(recseq+1)%3;Put!value;recseq = (recseq+1)%3;sent = (sent+1)%3;}  goto put_data; \n\nfi;\nput_data: if\n::  atomic {sent==2/2;RAck!recseq;lack = recseq;sent = 0;}  goto put_data; \n\n::  atomic {sent!=2/2 && recbuf[(recseq+1)%3]==1;Put!(recseq+1)%3;recseq = (recseq+1)%3;recbuf[recseq] = 0;}  goto put_data; \n\n:: sent!=2/2 && recbuf[(recseq+1)%3]==0; goto wait; \n\nfi;\nsend_naks: if\n::  d_step {i!=value && nakd[i]==1;i = (i+1)%3;}  goto send_naks; \n\n::  atomic {i!=value && nakd[i]==0;RNak!i;nakd[i] = 1;i = (i+1)%3;}  goto send_naks; \n\n:: i==value; goto wait; \n\nfi;\ncorr_data: if\n::  atomic {nakd[value]==0;RNak!value;}  goto wait; \n\n:: nakd[value]==1; goto wait; \n\nfi;\non_timeisout: if\n::  d_step {i<3;nakd[i] = 0;i = i+1;}  goto on_timeisout; \n\n::  atomic {i==3;RNak!(recseq+1)%3;nakd[(recseq+1)%3] = 1;}  goto timeisout_ack; \n\nfi;\ntimeisout_ack: if\n:: RAck!lack; goto wait; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The i-protocol is a part of protocol stack; its purpose\n    is to ensure ordered reliable duplex communication between sites. At its\n    lower interface it assumes unreliable (lossy) packet-based FIFO\n    connectivity. To its upper interface it provides reliable packet-based FIFO\n    connectivity. A distinguished feature of the i-protocol is the rather\n    sophisticated manner in which it attempts to minimize control-messages and\n    retransmission overhead.\n\nParameters:\n\n\n\nAtomic propositions:\n, , \n\nProperties to verify:"}, {"role": "assistant", "content": "chan Get =[0] of {int};\nchan Put =[0] of {int};\nchan SAck =[0] of {int};\nchan SNak =[0] of {int};\nchan SData =[0] of {int};\nchan RAck =[0] of {int};\nchan RNak =[0] of {int};\nchan RData =[0] of {int};\nchan RCorrData =[0] of {int};\nchan Timeout =[0] of {int};\n\nactive proctype Timer() { \n\ntick: if\n:: Timeout!0; goto tick; \n\nfi;\n}\n\nactive proctype Producer() { \nbyte message=0;\n\nwait: if\n::  goto produce; \n\nfi;\nproduce: if\n::  atomic {Get!message;message = (message+1)%4;}  goto wait; \n\nfi;\n}\n\nactive proctype Consumer() { \nbyte message=0;\n\nwait: if\n:: Put?message; goto consume; \n\nfi;\nconsume: if\n::  goto wait; \n\nfi;\n}\n\nactive proctype Medium() { \nbyte value=0;\n\nwait: if\n:: SData?value; goto data; \n\n:: RAck?value; goto ack; \n\n:: RNak?value; goto nak; \n\nfi;\ndata: if\n:: RData!value; goto dataOk; \n\n:: RCorrData!value; goto wait; \n\n::  goto wait; \n\nfi;\nack: if\n:: SAck!value; goto ackOk; \n\n::  goto wait; \n\nfi;\nnak: if\n:: SNak!value; goto nakOk; \n\n::  goto wait; \n\nfi;\ndataOk: if\n::  goto wait; \n\nfi;\nackOk: if\n::  goto wait; \n\nfi;\nnakOk: if\n::  goto wait; \n\nfi;\n}\n\nactive proctype Sender() { \nbyte sendseq=1;\nbyte rack=0;\nbyte value=0;\n\nwait: if\n:: SAck?value; goto ack; \n\n:: SNak?value; goto nak; \n\n:: Timeout?0; goto timeisout; \n\n::  atomic {(rack+2)%4>sendseq;Get?value;}  goto data; \n\nfi;\ndata: if\n::  atomic {SData!sendseq;sendseq = (sendseq+1)%4;}  goto wait; \n\nfi;\nack: if\n::  d_step {(rack<sendseq && rack<value && value<sendseq) || (rack>sendseq && sendseq<value && value<rack);rack = value;}  goto wait; \n\n:: (rack>=sendseq || rack>=value || value>=sendseq) && (rack<=sendseq || sendseq>=value || value>=rack); goto wait; \n\nfi;\nnak: if\n::  atomic {(rack<sendseq && rack<value && value<sendseq) || (rack>sendseq && sendseq<value && value<rack);SData!value;}  goto wait; \n\n:: (rack>=sendseq || rack>=value || value>=sendseq) && (rack<=sendseq || sendseq>=value || value>=rack); goto wait; \n\nfi;\ntimeisout: if\n::  atomic {(rack+1)%4!=sendseq;SData!(rack+1)%4;}  goto wait; \n\n:: (rack+1)%4==sendseq; goto wait; \n\nfi;\n}\n\nactive proctype Receiver() { \nbyte i=0;\nbyte value=0;\nbyte sent=0;\nbyte recseq=0;\nbyte lack=0;\nbyte recbuf[4];\nbyte nakd[4];\n\nwait: if\n:: RData?value; goto data; \n\n:: RCorrData?value; goto corr_data; \n\n::  atomic {Timeout?0;i = 0;}  goto on_timeisout; \n\nfi;\ndata: if\n::  d_step {value!=(recseq+1)%4;recbuf[value] = 1;i = (recseq+1)%4;}  goto send_naks; \n\n::  atomic {value==(recseq+1)%4;Put!value;recseq = (recseq+1)%4;sent = (sent+1)%4;}  goto put_data; \n\nfi;\nput_data: if\n::  atomic {sent==2/2;RAck!recseq;lack = recseq;sent = 0;}  goto put_data; \n\n::  atomic {sent!=2/2 && recbuf[(recseq+1)%4]==1;Put!(recseq+1)%4;recseq = (recseq+1)%4;recbuf[recseq] = 0;}  goto put_data; \n\n:: sent!=2/2 && recbuf[(recseq+1)%4]==0; goto wait; \n\nfi;\nsend_naks: if\n::  d_step {i!=value && nakd[i]==1;i = (i+1)%4;}  goto send_naks; \n\n::  atomic {i!=value && nakd[i]==0;RNak!i;nakd[i] = 1;i = (i+1)%4;}  goto send_naks; \n\n:: i==value; goto wait; \n\nfi;\ncorr_data: if\n::  atomic {nakd[value]==0;RNak!value;}  goto wait; \n\n:: nakd[value]==1; goto wait; \n\nfi;\non_timeisout: if\n::  d_step {i<4;nakd[i] = 0;i = i+1;}  goto on_timeisout; \n\n::  atomic {i==4;RNak!(recseq+1)%4;nakd[(recseq+1)%4] = 1;}  goto timeisout_ack; \n\nfi;\ntimeisout_ack: if\n:: RAck!lack; goto wait; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The i-protocol is a part of protocol stack; its purpose\n    is to ensure ordered reliable duplex communication between sites. At its\n    lower interface it assumes unreliable (lossy) packet-based FIFO\n    connectivity. To its upper interface it provides reliable packet-based FIFO\n    connectivity. A distinguished feature of the i-protocol is the rather\n    sophisticated manner in which it attempts to minimize control-messages and\n    retransmission overhead.\n\nParameters:\n\n\n\nAtomic propositions:\n, , \n\nProperties to verify:"}, {"role": "assistant", "content": "chan Get =[0] of {int};\nchan Put =[0] of {int};\nchan SAck =[0] of {int};\nchan SNak =[0] of {int};\nchan SData =[0] of {int};\nchan RAck =[0] of {int};\nchan RNak =[0] of {int};\nchan RData =[0] of {int};\nchan RCorrData =[0] of {int};\nchan Timeout =[0] of {int};\n\nactive proctype Timer() { \n\ntick: if\n:: Timeout!0; goto tick; \n\nfi;\n}\n\nactive proctype Producer() { \nbyte message=0;\n\nwait: if\n::  goto produce; \n\nfi;\nproduce: if\n::  atomic {Get!message;message = (message+1)%6;}  goto wait; \n\nfi;\n}\n\nactive proctype Consumer() { \nbyte message=0;\n\nwait: if\n:: Put?message; goto consume; \n\nfi;\nconsume: if\n::  goto wait; \n\nfi;\n}\n\nactive proctype Medium() { \nbyte value=0;\n\nwait: if\n:: SData?value; goto data; \n\n:: RAck?value; goto ack; \n\n:: RNak?value; goto nak; \n\nfi;\ndata: if\n:: RData!value; goto dataOk; \n\n:: RCorrData!value; goto wait; \n\n::  goto wait; \n\nfi;\nack: if\n:: SAck!value; goto ackOk; \n\n::  goto wait; \n\nfi;\nnak: if\n:: SNak!value; goto nakOk; \n\n::  goto wait; \n\nfi;\ndataOk: if\n::  goto wait; \n\nfi;\nackOk: if\n::  goto wait; \n\nfi;\nnakOk: if\n::  goto wait; \n\nfi;\n}\n\nactive proctype Sender() { \nbyte sendseq=1;\nbyte rack=0;\nbyte value=0;\n\nwait: if\n:: SAck?value; goto ack; \n\n:: SNak?value; goto nak; \n\n:: Timeout?0; goto timeisout; \n\n::  atomic {(rack+3)%6>sendseq;Get?value;}  goto data; \n\nfi;\ndata: if\n::  atomic {SData!sendseq;sendseq = (sendseq+1)%6;}  goto wait; \n\nfi;\nack: if\n::  d_step {(rack<sendseq && rack<value && value<sendseq) || (rack>sendseq && sendseq<value && value<rack);rack = value;}  goto wait; \n\n:: (rack>=sendseq || rack>=value || value>=sendseq) && (rack<=sendseq || sendseq>=value || value>=rack); goto wait; \n\nfi;\nnak: if\n::  atomic {(rack<sendseq && rack<value && value<sendseq) || (rack>sendseq && sendseq<value && value<rack);SData!value;}  goto wait; \n\n:: (rack>=sendseq || rack>=value || value>=sendseq) && (rack<=sendseq || sendseq>=value || value>=rack); goto wait; \n\nfi;\ntimeisout: if\n::  atomic {(rack+1)%6!=sendseq;SData!(rack+1)%6;}  goto wait; \n\n:: (rack+1)%6==sendseq; goto wait; \n\nfi;\n}\n\nactive proctype Receiver() { \nbyte i=0;\nbyte value=0;\nbyte sent=0;\nbyte recseq=0;\nbyte lack=0;\nbyte recbuf[6];\nbyte nakd[6];\n\nwait: if\n:: RData?value; goto data; \n\n:: RCorrData?value; goto corr_data; \n\n::  atomic {Timeout?0;i = 0;}  goto on_timeisout; \n\nfi;\ndata: if\n::  d_step {value!=(recseq+1)%6;recbuf[value] = 1;i = (recseq+1)%6;}  goto send_naks; \n\n::  atomic {value==(recseq+1)%6;Put!value;recseq = (recseq+1)%6;sent = (sent+1)%6;}  goto put_data; \n\nfi;\nput_data: if\n::  atomic {sent==3/2;RAck!recseq;lack = recseq;sent = 0;}  goto put_data; \n\n::  atomic {sent!=3/2 && recbuf[(recseq+1)%6]==1;Put!(recseq+1)%6;recseq = (recseq+1)%6;recbuf[recseq] = 0;}  goto put_data; \n\n:: sent!=3/2 && recbuf[(recseq+1)%6]==0; goto wait; \n\nfi;\nsend_naks: if\n::  d_step {i!=value && nakd[i]==1;i = (i+1)%6;}  goto send_naks; \n\n::  atomic {i!=value && nakd[i]==0;RNak!i;nakd[i] = 1;i = (i+1)%6;}  goto send_naks; \n\n:: i==value; goto wait; \n\nfi;\ncorr_data: if\n::  atomic {nakd[value]==0;RNak!value;}  goto wait; \n\n:: nakd[value]==1; goto wait; \n\nfi;\non_timeisout: if\n::  d_step {i<6;nakd[i] = 0;i = i+1;}  goto on_timeisout; \n\n::  atomic {i==6;RNak!(recseq+1)%6;nakd[(recseq+1)%6] = 1;}  goto timeisout_ack; \n\nfi;\ntimeisout_ack: if\n:: RAck!lack; goto wait; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The i-protocol is a part of protocol stack; its purpose\n    is to ensure ordered reliable duplex communication between sites. At its\n    lower interface it assumes unreliable (lossy) packet-based FIFO\n    connectivity. To its upper interface it provides reliable packet-based FIFO\n    connectivity. A distinguished feature of the i-protocol is the rather\n    sophisticated manner in which it attempts to minimize control-messages and\n    retransmission overhead.\n\nParameters:\n\n\n\nAtomic propositions:\n, , \n\nProperties to verify:"}, {"role": "assistant", "content": "chan Get =[0] of {int};\nchan Put =[0] of {int};\nchan SAck =[0] of {int};\nchan SNak =[0] of {int};\nchan SData =[0] of {int};\nchan RAck =[0] of {int};\nchan RNak =[0] of {int};\nchan RData =[0] of {int};\nchan RCorrData =[0] of {int};\nchan Timeout =[0] of {int};\n\nactive proctype Timer() { \n\ntick: if\n:: Timeout!0; goto tick; \n\nfi;\n}\n\nactive proctype Producer() { \nbyte message=0;\n\nwait: if\n::  goto produce; \n\nfi;\nproduce: if\n::  atomic {Get!message;message = (message+1)%8;}  goto wait; \n\nfi;\n}\n\nactive proctype Consumer() { \nbyte message=0;\n\nwait: if\n:: Put?message; goto consume; \n\nfi;\nconsume: if\n::  goto wait; \n\nfi;\n}\n\nactive proctype Medium() { \nbyte value=0;\n\nwait: if\n:: SData?value; goto data; \n\n:: RAck?value; goto ack; \n\n:: RNak?value; goto nak; \n\nfi;\ndata: if\n:: RData!value; goto dataOk; \n\n:: RCorrData!value; goto wait; \n\n::  goto wait; \n\nfi;\nack: if\n:: SAck!value; goto ackOk; \n\n::  goto wait; \n\nfi;\nnak: if\n:: SNak!value; goto nakOk; \n\n::  goto wait; \n\nfi;\ndataOk: if\n::  goto wait; \n\nfi;\nackOk: if\n::  goto wait; \n\nfi;\nnakOk: if\n::  goto wait; \n\nfi;\n}\n\nactive proctype Sender() { \nbyte sendseq=1;\nbyte rack=0;\nbyte value=0;\n\nwait: if\n:: SAck?value; goto ack; \n\n:: SNak?value; goto nak; \n\n:: Timeout?0; goto timeisout; \n\n::  atomic {(rack+4)%8>sendseq;Get?value;}  goto data; \n\nfi;\ndata: if\n::  atomic {SData!sendseq;sendseq = (sendseq+1)%8;}  goto wait; \n\nfi;\nack: if\n::  d_step {(rack<sendseq && rack<value && value<sendseq) || (rack>sendseq && sendseq<value && value<rack);rack = value;}  goto wait; \n\n:: (rack>=sendseq || rack>=value || value>=sendseq) && (rack<=sendseq || sendseq>=value || value>=rack); goto wait; \n\nfi;\nnak: if\n::  atomic {(rack<sendseq && rack<value && value<sendseq) || (rack>sendseq && sendseq<value && value<rack);SData!value;}  goto wait; \n\n:: (rack>=sendseq || rack>=value || value>=sendseq) && (rack<=sendseq || sendseq>=value || value>=rack); goto wait; \n\nfi;\ntimeisout: if\n::  atomic {(rack+1)%8!=sendseq;SData!(rack+1)%8;}  goto wait; \n\n:: (rack+1)%8==sendseq; goto wait; \n\nfi;\n}\n\nactive proctype Receiver() { \nbyte i=0;\nbyte value=0;\nbyte sent=0;\nbyte recseq=0;\nbyte lack=0;\nbyte recbuf[8];\nbyte nakd[8];\n\nwait: if\n:: RData?value; goto data; \n\n:: RCorrData?value; goto corr_data; \n\n::  atomic {Timeout?0;i = 0;}  goto on_timeisout; \n\nfi;\ndata: if\n::  d_step {value!=(recseq+1)%8;recbuf[value] = 1;i = (recseq+1)%8;}  goto send_naks; \n\n::  atomic {value==(recseq+1)%8;Put!value;recseq = (recseq+1)%8;sent = (sent+1)%8;}  goto put_data; \n\nfi;\nput_data: if\n::  atomic {sent==4/2;RAck!recseq;lack = recseq;sent = 0;}  goto put_data; \n\n::  atomic {sent!=4/2 && recbuf[(recseq+1)%8]==1;Put!(recseq+1)%8;recseq = (recseq+1)%8;recbuf[recseq] = 0;}  goto put_data; \n\n:: sent!=4/2 && recbuf[(recseq+1)%8]==0; goto wait; \n\nfi;\nsend_naks: if\n::  d_step {i!=value && nakd[i]==1;i = (i+1)%8;}  goto send_naks; \n\n::  atomic {i!=value && nakd[i]==0;RNak!i;nakd[i] = 1;i = (i+1)%8;}  goto send_naks; \n\n:: i==value; goto wait; \n\nfi;\ncorr_data: if\n::  atomic {nakd[value]==0;RNak!value;}  goto wait; \n\n:: nakd[value]==1; goto wait; \n\nfi;\non_timeisout: if\n::  d_step {i<8;nakd[i] = 0;i = i+1;}  goto on_timeisout; \n\n::  atomic {i==8;RNak!(recseq+1)%8;nakd[(recseq+1)%8] = 1;}  goto timeisout_ack; \n\nfi;\ntimeisout_ack: if\n:: RAck!lack; goto wait; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The i-protocol is a part of protocol stack; its purpose\n    is to ensure ordered reliable duplex communication between sites. At its\n    lower interface it assumes unreliable (lossy) packet-based FIFO\n    connectivity. To its upper interface it provides reliable packet-based FIFO\n    connectivity. A distinguished feature of the i-protocol is the rather\n    sophisticated manner in which it attempts to minimize control-messages and\n    retransmission overhead.\n\nParameters:\n\n\n\nAtomic propositions:\n, , \n\nProperties to verify:"}, {"role": "assistant", "content": "chan Get =[0] of {int};\nchan Put =[0] of {int};\nchan SAck =[0] of {int};\nchan SNak =[0] of {int};\nchan SData =[0] of {int};\nchan RAck =[0] of {int};\nchan RNak =[0] of {int};\nchan RData =[0] of {int};\nchan RCorrData =[0] of {int};\nchan Timeout =[0] of {int};\n\nactive proctype Timer() { \n\ntick: if\n:: Timeout!0; goto tick; \n\nfi;\n}\n\nactive proctype Producer() { \nbyte message=0;\n\nwait: if\n::  goto produce; \n\nfi;\nproduce: if\n::  atomic {Get!message;message = (message+1)%10;}  goto wait; \n\nfi;\n}\n\nactive proctype Consumer() { \nbyte message=0;\n\nwait: if\n:: Put?message; goto consume; \n\nfi;\nconsume: if\n::  goto wait; \n\nfi;\n}\n\nactive proctype Medium() { \nbyte value=0;\n\nwait: if\n:: SData?value; goto data; \n\n:: RAck?value; goto ack; \n\n:: RNak?value; goto nak; \n\nfi;\ndata: if\n:: RData!value; goto dataOk; \n\n:: RCorrData!value; goto wait; \n\n::  goto wait; \n\nfi;\nack: if\n:: SAck!value; goto ackOk; \n\n::  goto wait; \n\nfi;\nnak: if\n:: SNak!value; goto nakOk; \n\n::  goto wait; \n\nfi;\ndataOk: if\n::  goto wait; \n\nfi;\nackOk: if\n::  goto wait; \n\nfi;\nnakOk: if\n::  goto wait; \n\nfi;\n}\n\nactive proctype Sender() { \nbyte sendseq=1;\nbyte rack=0;\nbyte value=0;\n\nwait: if\n:: SAck?value; goto ack; \n\n:: SNak?value; goto nak; \n\n:: Timeout?0; goto timeisout; \n\n::  atomic {(rack+5)%10>sendseq;Get?value;}  goto data; \n\nfi;\ndata: if\n::  atomic {SData!sendseq;sendseq = (sendseq+1)%10;}  goto wait; \n\nfi;\nack: if\n::  d_step {(rack<sendseq && rack<value && value<sendseq) || (rack>sendseq && sendseq<value && value<rack);rack = value;}  goto wait; \n\n:: (rack>=sendseq || rack>=value || value>=sendseq) && (rack<=sendseq || sendseq>=value || value>=rack); goto wait; \n\nfi;\nnak: if\n::  atomic {(rack<sendseq && rack<value && value<sendseq) || (rack>sendseq && sendseq<value && value<rack);SData!value;}  goto wait; \n\n:: (rack>=sendseq || rack>=value || value>=sendseq) && (rack<=sendseq || sendseq>=value || value>=rack); goto wait; \n\nfi;\ntimeisout: if\n::  atomic {(rack+1)%10!=sendseq;SData!(rack+1)%10;}  goto wait; \n\n:: (rack+1)%10==sendseq; goto wait; \n\nfi;\n}\n\nactive proctype Receiver() { \nbyte i=0;\nbyte value=0;\nbyte sent=0;\nbyte recseq=0;\nbyte lack=0;\nbyte recbuf[10];\nbyte nakd[10];\n\nwait: if\n:: RData?value; goto data; \n\n:: RCorrData?value; goto corr_data; \n\n::  atomic {Timeout?0;i = 0;}  goto on_timeisout; \n\nfi;\ndata: if\n::  d_step {value!=(recseq+1)%10;recbuf[value] = 1;i = (recseq+1)%10;}  goto send_naks; \n\n::  atomic {value==(recseq+1)%10;Put!value;recseq = (recseq+1)%10;sent = (sent+1)%10;}  goto put_data; \n\nfi;\nput_data: if\n::  atomic {sent==5/2;RAck!recseq;lack = recseq;sent = 0;}  goto put_data; \n\n::  atomic {sent!=5/2 && recbuf[(recseq+1)%10]==1;Put!(recseq+1)%10;recseq = (recseq+1)%10;recbuf[recseq] = 0;}  goto put_data; \n\n:: sent!=5/2 && recbuf[(recseq+1)%10]==0; goto wait; \n\nfi;\nsend_naks: if\n::  d_step {i!=value && nakd[i]==1;i = (i+1)%10;}  goto send_naks; \n\n::  atomic {i!=value && nakd[i]==0;RNak!i;nakd[i] = 1;i = (i+1)%10;}  goto send_naks; \n\n:: i==value; goto wait; \n\nfi;\ncorr_data: if\n::  atomic {nakd[value]==0;RNak!value;}  goto wait; \n\n:: nakd[value]==1; goto wait; \n\nfi;\non_timeisout: if\n::  d_step {i<10;nakd[i] = 0;i = i+1;}  goto on_timeisout; \n\n::  atomic {i==10;RNak!(recseq+1)%10;nakd[(recseq+1)%10] = 1;}  goto timeisout_ack; \n\nfi;\ntimeisout_ack: if\n:: RAck!lack; goto wait; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The i-protocol is a part of protocol stack; its purpose\n    is to ensure ordered reliable duplex communication between sites. At its\n    lower interface it assumes unreliable (lossy) packet-based FIFO\n    connectivity. To its upper interface it provides reliable packet-based FIFO\n    connectivity. A distinguished feature of the i-protocol is the rather\n    sophisticated manner in which it attempts to minimize control-messages and\n    retransmission overhead.\n\nParameters:\n\n\n\nAtomic propositions:\n, , \n\nProperties to verify:"}, {"role": "assistant", "content": "chan Get =[0] of {int};\nchan Put =[0] of {int};\nchan SAck =[0] of {int};\nchan SNak =[0] of {int};\nchan SData =[0] of {int};\nchan RAck =[0] of {int};\nchan RNak =[0] of {int};\nchan RData =[0] of {int};\nchan RCorrData =[0] of {int};\nchan Timeout =[0] of {int};\n\nactive proctype Timer() { \n\ntick: if\n:: Timeout!0; goto tick; \n\nfi;\n}\n\nactive proctype Producer() { \nbyte message=0;\n\nwait: if\n::  goto produce; \n\nfi;\nproduce: if\n::  atomic {Get!message;message = (message+1)%10;}  goto wait; \n\nfi;\n}\n\nactive proctype Consumer() { \nbyte message=0;\n\nwait: if\n:: Put?message; goto consume; \n\nfi;\nconsume: if\n::  goto wait; \n\nfi;\n}\n\nactive proctype Medium() { \nbyte value=0;\n\nwait: if\n:: SData?value; goto data; \n\n:: RAck?value; goto ack; \n\n:: RNak?value; goto nak; \n\nfi;\ndata: if\n:: RData!value; goto dataOk; \n\n:: RCorrData!value; goto wait; \n\n::  goto wait; \n\nfi;\nack: if\n:: SAck!value; goto ackOk; \n\n::  goto wait; \n\nfi;\nnak: if\n:: SNak!value; goto nakOk; \n\n::  goto wait; \n\nfi;\ndataOk: if\n::  goto wait; \n\nfi;\nackOk: if\n::  goto wait; \n\nfi;\nnakOk: if\n::  goto wait; \n\nfi;\n}\n\nactive proctype Sender() { \nbyte sendseq=1;\nbyte rack=0;\nbyte value=0;\n\nwait: if\n:: SAck?value; goto ack; \n\n:: SNak?value; goto nak; \n\n:: Timeout?0; goto timeisout; \n\n::  atomic {(rack+3)%10>sendseq;Get?value;}  goto data; \n\nfi;\ndata: if\n::  atomic {SData!sendseq;sendseq = (sendseq+1)%10;}  goto wait; \n\nfi;\nack: if\n::  d_step {(rack<sendseq && rack<value && value<sendseq) || (rack>sendseq && sendseq<value && value<rack);rack = value;}  goto wait; \n\n:: (rack>=sendseq || rack>=value || value>=sendseq) && (rack<=sendseq || sendseq>=value || value>=rack); goto wait; \n\nfi;\nnak: if\n::  atomic {(rack<sendseq && rack<value && value<sendseq) || (rack>sendseq && sendseq<value && value<rack);SData!value;}  goto wait; \n\n:: (rack>=sendseq || rack>=value || value>=sendseq) && (rack<=sendseq || sendseq>=value || value>=rack); goto wait; \n\nfi;\ntimeisout: if\n::  atomic {(rack+1)%10!=sendseq;SData!(rack+1)%10;}  goto wait; \n\n:: (rack+1)%10==sendseq; goto wait; \n\nfi;\n}\n\nactive proctype Receiver() { \nbyte i=0;\nbyte value=0;\nbyte sent=0;\nbyte recseq=0;\nbyte lack=0;\nbyte recbuf[10];\nbyte nakd[10];\n\nwait: if\n:: RData?value; goto data; \n\n:: RCorrData?value; goto corr_data; \n\n::  atomic {Timeout?0;i = 0;}  goto on_timeisout; \n\nfi;\ndata: if\n::  d_step {value!=(recseq+1)%10;recbuf[value] = 1;i = (recseq+1)%10;}  goto send_naks; \n\n::  atomic {value==(recseq+1)%10;Put!value;recseq = (recseq+1)%10;sent = (sent+1)%10;}  goto put_data; \n\nfi;\nput_data: if\n::  atomic {sent==3/2;RAck!recseq;lack = recseq;sent = 0;}  goto put_data; \n\n::  atomic {sent!=3/2 && recbuf[(recseq+1)%10]==1;Put!(recseq+1)%10;recseq = (recseq+1)%10;recbuf[recseq] = 0;}  goto put_data; \n\n:: sent!=3/2 && recbuf[(recseq+1)%10]==0; goto wait; \n\nfi;\nsend_naks: if\n::  d_step {i!=value && nakd[i]==1;i = (i+1)%10;}  goto send_naks; \n\n::  atomic {i!=value && nakd[i]==0;RNak!i;nakd[i] = 1;i = (i+1)%10;}  goto send_naks; \n\n:: i==value; goto wait; \n\nfi;\ncorr_data: if\n::  atomic {nakd[value]==0;RNak!value;}  goto wait; \n\n:: nakd[value]==1; goto wait; \n\nfi;\non_timeisout: if\n::  d_step {i<10;nakd[i] = 0;i = i+1;}  goto on_timeisout; \n\n::  atomic {i==10;RNak!(recseq+1)%10;nakd[(recseq+1)%10] = 1;}  goto timeisout_ack; \n\nfi;\ntimeisout_ack: if\n:: RAck!lack; goto wait; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The i-protocol is a part of protocol stack; its purpose\n    is to ensure ordered reliable duplex communication between sites. At its\n    lower interface it assumes unreliable (lossy) packet-based FIFO\n    connectivity. To its upper interface it provides reliable packet-based FIFO\n    connectivity. A distinguished feature of the i-protocol is the rather\n    sophisticated manner in which it attempts to minimize control-messages and\n    retransmission overhead.\n\nParameters:\n\n\n\nAtomic propositions:\n, , \n\nProperties to verify:"}, {"role": "assistant", "content": "chan Get =[0] of {int};\nchan Put =[0] of {int};\nchan SAck =[0] of {int};\nchan SNak =[0] of {int};\nchan SData =[0] of {int};\nchan RAck =[0] of {int};\nchan RNak =[0] of {int};\nchan RData =[0] of {int};\nchan RCorrData =[0] of {int};\nchan Timeout =[0] of {int};\n\nactive proctype Timer() { \n\ntick: if\n:: Timeout!0; goto tick; \n\nfi;\n}\n\nactive proctype Producer() { \nbyte message=0;\n\nwait: if\n::  goto produce; \n\nfi;\nproduce: if\n::  atomic {Get!message;message = (message+1)%12;}  goto wait; \n\nfi;\n}\n\nactive proctype Consumer() { \nbyte message=0;\n\nwait: if\n:: Put?message; goto consume; \n\nfi;\nconsume: if\n::  goto wait; \n\nfi;\n}\n\nactive proctype Medium() { \nbyte value=0;\n\nwait: if\n:: SData?value; goto data; \n\n:: RAck?value; goto ack; \n\n:: RNak?value; goto nak; \n\nfi;\ndata: if\n:: RData!value; goto dataOk; \n\n:: RCorrData!value; goto wait; \n\n::  goto wait; \n\nfi;\nack: if\n:: SAck!value; goto ackOk; \n\n::  goto wait; \n\nfi;\nnak: if\n:: SNak!value; goto nakOk; \n\n::  goto wait; \n\nfi;\ndataOk: if\n::  goto wait; \n\nfi;\nackOk: if\n::  goto wait; \n\nfi;\nnakOk: if\n::  goto wait; \n\nfi;\n}\n\nactive proctype Sender() { \nbyte sendseq=1;\nbyte rack=0;\nbyte value=0;\n\nwait: if\n:: SAck?value; goto ack; \n\n:: SNak?value; goto nak; \n\n:: Timeout?0; goto timeisout; \n\n::  atomic {(rack+4)%12>sendseq;Get?value;}  goto data; \n\nfi;\ndata: if\n::  atomic {SData!sendseq;sendseq = (sendseq+1)%12;}  goto wait; \n\nfi;\nack: if\n::  d_step {(rack<sendseq && rack<value && value<sendseq) || (rack>sendseq && sendseq<value && value<rack);rack = value;}  goto wait; \n\n:: (rack>=sendseq || rack>=value || value>=sendseq) && (rack<=sendseq || sendseq>=value || value>=rack); goto wait; \n\nfi;\nnak: if\n::  atomic {(rack<sendseq && rack<value && value<sendseq) || (rack>sendseq && sendseq<value && value<rack);SData!value;}  goto wait; \n\n:: (rack>=sendseq || rack>=value || value>=sendseq) && (rack<=sendseq || sendseq>=value || value>=rack); goto wait; \n\nfi;\ntimeisout: if\n::  atomic {(rack+1)%12!=sendseq;SData!(rack+1)%12;}  goto wait; \n\n:: (rack+1)%12==sendseq; goto wait; \n\nfi;\n}\n\nactive proctype Receiver() { \nbyte i=0;\nbyte value=0;\nbyte sent=0;\nbyte recseq=0;\nbyte lack=0;\nbyte recbuf[12];\nbyte nakd[12];\n\nwait: if\n:: RData?value; goto data; \n\n:: RCorrData?value; goto corr_data; \n\n::  atomic {Timeout?0;i = 0;}  goto on_timeisout; \n\nfi;\ndata: if\n::  d_step {value!=(recseq+1)%12;recbuf[value] = 1;i = (recseq+1)%12;}  goto send_naks; \n\n::  atomic {value==(recseq+1)%12;Put!value;recseq = (recseq+1)%12;sent = (sent+1)%12;}  goto put_data; \n\nfi;\nput_data: if\n::  atomic {sent==4/2;RAck!recseq;lack = recseq;sent = 0;}  goto put_data; \n\n::  atomic {sent!=4/2 && recbuf[(recseq+1)%12]==1;Put!(recseq+1)%12;recseq = (recseq+1)%12;recbuf[recseq] = 0;}  goto put_data; \n\n:: sent!=4/2 && recbuf[(recseq+1)%12]==0; goto wait; \n\nfi;\nsend_naks: if\n::  d_step {i!=value && nakd[i]==1;i = (i+1)%12;}  goto send_naks; \n\n::  atomic {i!=value && nakd[i]==0;RNak!i;nakd[i] = 1;i = (i+1)%12;}  goto send_naks; \n\n:: i==value; goto wait; \n\nfi;\ncorr_data: if\n::  atomic {nakd[value]==0;RNak!value;}  goto wait; \n\n:: nakd[value]==1; goto wait; \n\nfi;\non_timeisout: if\n::  d_step {i<12;nakd[i] = 0;i = i+1;}  goto on_timeisout; \n\n::  atomic {i==12;RNak!(recseq+1)%12;nakd[(recseq+1)%12] = 1;}  goto timeisout_ack; \n\nfi;\ntimeisout_ack: if\n:: RAck!lack; goto wait; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The Krebs cycle is a series of chemical reactions of\n    central importance in all living cells that utilize oxygen as part of\n    cellular respiration. In these aerobic organisms, the citric acid cycle is\n    a metabolic pathway that forms part of the break down of carbohydrates,\n    fats and proteins into carbon dioxide and water in order to generate\n    energy. It is the second of three metabolic pathways that are involved in\n    fuel molecule catabolism and ATP production. This model is a scheduling problem\n    inspired by the Krebs cycle.\n\nParameters:\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte glukosa=2;\nbyte ATP=4;\nbyte ADP=4;\nbyte NADp=12;\nbyte NADH=2;\nbyte puryvat=0;\nbyte acetyl_co_a=0;\nbyte O2=15;\nbyte CO2=0;\nbyte Hp=10;\nbyte H20=10;\nbyte energy=0;\n\nchan electrons =[0] of {int};\n\nactive proctype glykoza() { \n\nq: if\n::  d_step {glukosa>=1 && ATP>=2 && ADP>=2 && NADp>=2;glukosa = glukosa-1;ADP = ADP-2;ATP = ATP+2;NADp = NADp-2;NADH = NADH+2;puryvat = puryvat+2;Hp = Hp+2;H20 = H20+2;}  goto q; \n\nfi;\n}\n\nactive proctype puryvat_oxyd() { \n\nq: if\n::  d_step {puryvat>=1 && NADp>=1;puryvat = puryvat-1;NADp = NADp-1;acetyl_co_a = acetyl_co_a+1;NADH = NADH+1;CO2 = CO2+1;}  goto q; \n\nfi;\n}\n\nactive proctype krebs_0() { \n\noxalacetrat: if\n::  d_step {acetyl_co_a>=1 && H20>=1;acetyl_co_a = acetyl_co_a-1;H20 = H20-1;}  goto citrat; \n\nfi;\ncitrat: if\n::  goto isocitrat; \n\nfi;\nisocitrat: if\n::  d_step {NADp>=1;NADp = NADp-1;NADH = NADH+1;Hp = Hp+1;CO2 = CO2+1;}  goto oxoglutarat2; \n\nfi;\noxoglutarat2: if\n::  d_step {NADp>=1;NADH = NADH+1;CO2 = CO2+1;}  goto fumarat; \n\nfi;\nfumarat: if\n::  d_step {H20>=1;H20 = H20-1;}  goto malat; \n\nfi;\nmalat: if\n::  d_step {NADp>=1;NADp = NADp-1;NADH = NADH+1;}  goto oxalacetrat; \n\nfi;\nsukcynyl_coa: \nsukcynyl: \n false; }\n\nactive proctype glykolyza() { \n\nq: if\n::  atomic {NADH>=1 && O2>=1 && Hp>=2;electrons!0;NADH = NADH-1;NADp = NADp+1;O2 = O2-1;Hp = Hp-2;H20 = H20+1;}  goto q; \n\nfi;\n}\n\nactive proctype ETS() { \n\nq: if\n::  atomic {ADP>=2;electrons?0;ADP = ADP-2;ATP = ATP+2;}  goto q; \n\nfi;\n}\n\nactive proctype rest_of_cell() { \n\nq: if\n::  d_step {ATP>=1;ATP = ATP-1;ADP = ADP+1;energy = energy+1;}  goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The Krebs cycle is a series of chemical reactions of\n    central importance in all living cells that utilize oxygen as part of\n    cellular respiration. In these aerobic organisms, the citric acid cycle is\n    a metabolic pathway that forms part of the break down of carbohydrates,\n    fats and proteins into carbon dioxide and water in order to generate\n    energy. It is the second of three metabolic pathways that are involved in\n    fuel molecule catabolism and ATP production. This model is a scheduling problem\n    inspired by the Krebs cycle.\n\nParameters:\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte glukosa=3;\nbyte ATP=4;\nbyte ADP=4;\nbyte NADp=12;\nbyte NADH=2;\nbyte puryvat=0;\nbyte acetyl_co_a=0;\nbyte O2=15;\nbyte CO2=0;\nbyte Hp=10;\nbyte H20=10;\nbyte energy=0;\n\nchan electrons =[0] of {int};\n\nactive proctype glykoza() { \n\nq: if\n::  d_step {glukosa>=1 && ATP>=2 && ADP>=2 && NADp>=2;glukosa = glukosa-1;ADP = ADP-2;ATP = ATP+2;NADp = NADp-2;NADH = NADH+2;puryvat = puryvat+2;Hp = Hp+2;H20 = H20+2;}  goto q; \n\nfi;\n}\n\nactive proctype puryvat_oxyd() { \n\nq: if\n::  d_step {puryvat>=1 && NADp>=1;puryvat = puryvat-1;NADp = NADp-1;acetyl_co_a = acetyl_co_a+1;NADH = NADH+1;CO2 = CO2+1;}  goto q; \n\nfi;\n}\n\nactive proctype krebs_0() { \n\noxalacetrat: if\n::  d_step {acetyl_co_a>=1 && H20>=1;acetyl_co_a = acetyl_co_a-1;H20 = H20-1;}  goto citrat; \n\nfi;\ncitrat: if\n::  goto isocitrat; \n\nfi;\nisocitrat: if\n::  d_step {NADp>=1;NADp = NADp-1;NADH = NADH+1;Hp = Hp+1;CO2 = CO2+1;}  goto oxoglutarat2; \n\nfi;\noxoglutarat2: if\n::  d_step {NADp>=1;NADH = NADH+1;CO2 = CO2+1;}  goto fumarat; \n\nfi;\nfumarat: if\n::  d_step {H20>=1;H20 = H20-1;}  goto malat; \n\nfi;\nmalat: if\n::  d_step {NADp>=1;NADp = NADp-1;NADH = NADH+1;}  goto oxalacetrat; \n\nfi;\nsukcynyl_coa: \nsukcynyl: \n false; }\n\nactive proctype krebs_1() { \n\noxalacetrat: if\n::  d_step {acetyl_co_a>=1 && H20>=1;acetyl_co_a = acetyl_co_a-1;H20 = H20-1;}  goto citrat; \n\nfi;\ncitrat: if\n::  goto isocitrat; \n\nfi;\nisocitrat: if\n::  d_step {NADp>=1;NADp = NADp-1;NADH = NADH+1;Hp = Hp+1;CO2 = CO2+1;}  goto oxoglutarat2; \n\nfi;\noxoglutarat2: if\n::  d_step {NADp>=1;NADH = NADH+1;CO2 = CO2+1;}  goto fumarat; \n\nfi;\nfumarat: if\n::  d_step {H20>=1;H20 = H20-1;}  goto malat; \n\nfi;\nmalat: if\n::  d_step {NADp>=1;NADp = NADp-1;NADH = NADH+1;}  goto oxalacetrat; \n\nfi;\nsukcynyl_coa: \nsukcynyl: \n false; }\n\nactive proctype glykolyza() { \n\nq: if\n::  atomic {NADH>=1 && O2>=1 && Hp>=2;electrons!0;NADH = NADH-1;NADp = NADp+1;O2 = O2-1;Hp = Hp-2;H20 = H20+1;}  goto q; \n\nfi;\n}\n\nactive proctype ETS() { \n\nq: if\n::  atomic {ADP>=2;electrons?0;ADP = ADP-2;ATP = ATP+2;}  goto q; \n\nfi;\n}\n\nactive proctype rest_of_cell() { \n\nq: if\n::  d_step {ATP>=1;ATP = ATP-1;ADP = ADP+1;energy = energy+1;}  goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The Krebs cycle is a series of chemical reactions of\n    central importance in all living cells that utilize oxygen as part of\n    cellular respiration. In these aerobic organisms, the citric acid cycle is\n    a metabolic pathway that forms part of the break down of carbohydrates,\n    fats and proteins into carbon dioxide and water in order to generate\n    energy. It is the second of three metabolic pathways that are involved in\n    fuel molecule catabolism and ATP production. This model is a scheduling problem\n    inspired by the Krebs cycle.\n\nParameters:\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte glukosa=10;\nbyte ATP=4;\nbyte ADP=4;\nbyte NADp=12;\nbyte NADH=2;\nbyte puryvat=0;\nbyte acetyl_co_a=0;\nbyte O2=15;\nbyte CO2=0;\nbyte Hp=10;\nbyte H20=10;\nbyte energy=0;\n\nchan electrons =[0] of {int};\n\nactive proctype glykoza() { \n\nq: if\n::  d_step {glukosa>=1 && ATP>=2 && ADP>=2 && NADp>=2;glukosa = glukosa-1;ADP = ADP-2;ATP = ATP+2;NADp = NADp-2;NADH = NADH+2;puryvat = puryvat+2;Hp = Hp+2;H20 = H20+2;}  goto q; \n\nfi;\n}\n\nactive proctype puryvat_oxyd() { \n\nq: if\n::  d_step {puryvat>=1 && NADp>=1;puryvat = puryvat-1;NADp = NADp-1;acetyl_co_a = acetyl_co_a+1;NADH = NADH+1;CO2 = CO2+1;}  goto q; \n\nfi;\n}\n\nactive proctype krebs_0() { \n\noxalacetrat: if\n::  d_step {acetyl_co_a>=1 && H20>=1;acetyl_co_a = acetyl_co_a-1;H20 = H20-1;}  goto citrat; \n\nfi;\ncitrat: if\n::  goto isocitrat; \n\nfi;\nisocitrat: if\n::  d_step {NADp>=1;NADp = NADp-1;NADH = NADH+1;Hp = Hp+1;CO2 = CO2+1;}  goto oxoglutarat2; \n\nfi;\noxoglutarat2: if\n::  d_step {NADp>=1;NADH = NADH+1;CO2 = CO2+1;}  goto fumarat; \n\nfi;\nfumarat: if\n::  d_step {H20>=1;H20 = H20-1;}  goto malat; \n\nfi;\nmalat: if\n::  d_step {NADp>=1;NADp = NADp-1;NADH = NADH+1;}  goto oxalacetrat; \n\nfi;\nsukcynyl_coa: \nsukcynyl: \n false; }\n\nactive proctype krebs_1() { \n\noxalacetrat: if\n::  d_step {acetyl_co_a>=1 && H20>=1;acetyl_co_a = acetyl_co_a-1;H20 = H20-1;}  goto citrat; \n\nfi;\ncitrat: if\n::  goto isocitrat; \n\nfi;\nisocitrat: if\n::  d_step {NADp>=1;NADp = NADp-1;NADH = NADH+1;Hp = Hp+1;CO2 = CO2+1;}  goto oxoglutarat2; \n\nfi;\noxoglutarat2: if\n::  d_step {NADp>=1;NADH = NADH+1;CO2 = CO2+1;}  goto fumarat; \n\nfi;\nfumarat: if\n::  d_step {H20>=1;H20 = H20-1;}  goto malat; \n\nfi;\nmalat: if\n::  d_step {NADp>=1;NADp = NADp-1;NADH = NADH+1;}  goto oxalacetrat; \n\nfi;\nsukcynyl_coa: \nsukcynyl: \n false; }\n\nactive proctype glykolyza() { \n\nq: if\n::  atomic {NADH>=1 && O2>=1 && Hp>=2;electrons!0;NADH = NADH-1;NADp = NADp+1;O2 = O2-1;Hp = Hp-2;H20 = H20+1;}  goto q; \n\nfi;\n}\n\nactive proctype ETS() { \n\nq: if\n::  atomic {ADP>=2;electrons?0;ADP = ADP-2;ATP = ATP+2;}  goto q; \n\nfi;\n}\n\nactive proctype rest_of_cell() { \n\nq: if\n::  d_step {ATP>=1;ATP = ATP-1;ADP = ADP+1;energy = energy+1;}  goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The Krebs cycle is a series of chemical reactions of\n    central importance in all living cells that utilize oxygen as part of\n    cellular respiration. In these aerobic organisms, the citric acid cycle is\n    a metabolic pathway that forms part of the break down of carbohydrates,\n    fats and proteins into carbon dioxide and water in order to generate\n    energy. It is the second of three metabolic pathways that are involved in\n    fuel molecule catabolism and ATP production. This model is a scheduling problem\n    inspired by the Krebs cycle.\n\nParameters:\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte glukosa=15;\nbyte ATP=4;\nbyte ADP=4;\nbyte NADp=12;\nbyte NADH=2;\nbyte puryvat=0;\nbyte acetyl_co_a=0;\nbyte O2=15;\nbyte CO2=0;\nbyte Hp=10;\nbyte H20=10;\nbyte energy=0;\n\nchan electrons =[0] of {int};\n\nactive proctype glykoza() { \n\nq: if\n::  d_step {glukosa>=1 && ATP>=2 && ADP>=2 && NADp>=2;glukosa = glukosa-1;ADP = ADP-2;ATP = ATP+2;NADp = NADp-2;NADH = NADH+2;puryvat = puryvat+2;Hp = Hp+2;H20 = H20+2;}  goto q; \n\nfi;\n}\n\nactive proctype puryvat_oxyd() { \n\nq: if\n::  d_step {puryvat>=1 && NADp>=1;puryvat = puryvat-1;NADp = NADp-1;acetyl_co_a = acetyl_co_a+1;NADH = NADH+1;CO2 = CO2+1;}  goto q; \n\nfi;\n}\n\nactive proctype krebs_0() { \n\noxalacetrat: if\n::  d_step {acetyl_co_a>=1 && H20>=1;acetyl_co_a = acetyl_co_a-1;H20 = H20-1;}  goto citrat; \n\nfi;\ncitrat: if\n::  goto isocitrat; \n\nfi;\nisocitrat: if\n::  d_step {NADp>=1;NADp = NADp-1;NADH = NADH+1;Hp = Hp+1;CO2 = CO2+1;}  goto oxoglutarat2; \n\nfi;\noxoglutarat2: if\n::  d_step {NADp>=1;NADH = NADH+1;CO2 = CO2+1;}  goto fumarat; \n\nfi;\nfumarat: if\n::  d_step {H20>=1;H20 = H20-1;}  goto malat; \n\nfi;\nmalat: if\n::  d_step {NADp>=1;NADp = NADp-1;NADH = NADH+1;}  goto oxalacetrat; \n\nfi;\nsukcynyl_coa: \nsukcynyl: \n false; }\n\nactive proctype krebs_1() { \n\noxalacetrat: if\n::  d_step {acetyl_co_a>=1 && H20>=1;acetyl_co_a = acetyl_co_a-1;H20 = H20-1;}  goto citrat; \n\nfi;\ncitrat: if\n::  goto isocitrat; \n\nfi;\nisocitrat: if\n::  d_step {NADp>=1;NADp = NADp-1;NADH = NADH+1;Hp = Hp+1;CO2 = CO2+1;}  goto oxoglutarat2; \n\nfi;\noxoglutarat2: if\n::  d_step {NADp>=1;NADH = NADH+1;CO2 = CO2+1;}  goto fumarat; \n\nfi;\nfumarat: if\n::  d_step {H20>=1;H20 = H20-1;}  goto malat; \n\nfi;\nmalat: if\n::  d_step {NADp>=1;NADp = NADp-1;NADH = NADH+1;}  goto oxalacetrat; \n\nfi;\nsukcynyl_coa: \nsukcynyl: \n false; }\n\nactive proctype krebs_2() { \n\noxalacetrat: if\n::  d_step {acetyl_co_a>=1 && H20>=1;acetyl_co_a = acetyl_co_a-1;H20 = H20-1;}  goto citrat; \n\nfi;\ncitrat: if\n::  goto isocitrat; \n\nfi;\nisocitrat: if\n::  d_step {NADp>=1;NADp = NADp-1;NADH = NADH+1;Hp = Hp+1;CO2 = CO2+1;}  goto oxoglutarat2; \n\nfi;\noxoglutarat2: if\n::  d_step {NADp>=1;NADH = NADH+1;CO2 = CO2+1;}  goto fumarat; \n\nfi;\nfumarat: if\n::  d_step {H20>=1;H20 = H20-1;}  goto malat; \n\nfi;\nmalat: if\n::  d_step {NADp>=1;NADp = NADp-1;NADH = NADH+1;}  goto oxalacetrat; \n\nfi;\nsukcynyl_coa: \nsukcynyl: \n false; }\n\nactive proctype glykolyza() { \n\nq: if\n::  atomic {NADH>=1 && O2>=1 && Hp>=2;electrons!0;NADH = NADH-1;NADp = NADp+1;O2 = O2-1;Hp = Hp-2;H20 = H20+1;}  goto q; \n\nfi;\n}\n\nactive proctype ETS() { \n\nq: if\n::  atomic {ADP>=2;electrons?0;ADP = ADP-2;ATP = ATP+2;}  goto q; \n\nfi;\n}\n\nactive proctype rest_of_cell() { \n\nq: if\n::  d_step {ATP>=1;ATP = ATP-1;ADP = ADP+1;energy = energy+1;}  goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "A mutual exclusion algorithm, which is optimized for a\n    number of read/write operations.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte b[3];\nbyte x=255;\nbyte y=255;\n\n\nactive proctype P_0() { \nbyte j=0;\n\nNCS: if\n:: b[0] = 1; goto q1; \n\nfi;\nCS: if\n:: y = 255; goto e1; \n\nfi;\nq1: if\n:: x = 0; goto q2; \n\nfi;\nq2: if\n::  d_step {y!=255;b[0] = 0;}  goto q22; \n\n:: y==255; goto p; \n\nfi;\nq22: if\n:: y==255; goto NCS; \n\nfi;\np: if\n:: y = 0; goto q3; \n\nfi;\nq3: if\n:: x==0; goto CS; \n\n::  d_step {x!=0;b[0] = 0;j = 0;}  goto q4; \n\nfi;\nq4: if\n::  d_step {j<3 && b[j]==0;j = j+1;}  goto q4; \n\n:: j==3; goto q5; \n\nfi;\nq5: if\n:: y==0; goto CS; \n\n:: y==255; goto NCS; \n\nfi;\ne1: if\n:: b[0] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte j=0;\n\nNCS: if\n:: b[1] = 1; goto q1; \n\nfi;\nCS: if\n:: y = 255; goto e1; \n\nfi;\nq1: if\n:: x = 1; goto q2; \n\nfi;\nq2: if\n::  d_step {y!=255;b[1] = 0;}  goto q22; \n\n:: y==255; goto p; \n\nfi;\nq22: if\n:: y==255; goto NCS; \n\nfi;\np: if\n:: y = 1; goto q3; \n\nfi;\nq3: if\n:: x==1; goto CS; \n\n::  d_step {x!=1;b[1] = 0;j = 0;}  goto q4; \n\nfi;\nq4: if\n::  d_step {j<3 && b[j]==0;j = j+1;}  goto q4; \n\n:: j==3; goto q5; \n\nfi;\nq5: if\n:: y==1; goto CS; \n\n:: y==255; goto NCS; \n\nfi;\ne1: if\n:: b[1] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte j=0;\n\nNCS: if\n:: b[2] = 1; goto q1; \n\nfi;\nCS: if\n:: y = 255; goto e1; \n\nfi;\nq1: if\n:: x = 2; goto q2; \n\nfi;\nq2: if\n::  d_step {y!=255;b[2] = 0;}  goto q22; \n\n:: y==255; goto p; \n\nfi;\nq22: if\n:: y==255; goto NCS; \n\nfi;\np: if\n:: y = 2; goto q3; \n\nfi;\nq3: if\n:: x==2; goto CS; \n\n::  d_step {x!=2;b[2] = 0;j = 0;}  goto q4; \n\nfi;\nq4: if\n::  d_step {j<3 && b[j]==0;j = j+1;}  goto q4; \n\n:: j==3; goto q5; \n\nfi;\nq5: if\n:: y==2; goto CS; \n\n:: y==255; goto NCS; \n\nfi;\ne1: if\n:: b[2] = 0; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "A mutual exclusion algorithm, which is optimized for a\n    number of read/write operations.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte b[3];\nbyte x=255;\nbyte y=255;\n\n\nactive proctype P_0() { \nbyte j=0;\n\nNCS: if\n:: b[0] = 1; goto q1; \n\nfi;\nCS: if\n:: y = 255; goto e1; \n\nfi;\nq1: if\n:: x = 0; goto q2; \n\nfi;\nq2: if\n::  d_step {y!=255;b[x] = 0;}  goto q22; \n\n:: y==255; goto p; \n\nfi;\nq22: if\n:: y==255; goto NCS; \n\nfi;\np: if\n:: y = 0; goto q3; \n\nfi;\nq3: if\n:: x==0; goto CS; \n\n::  d_step {x!=0;b[0] = 0;j = 0;}  goto q4; \n\nfi;\nq4: if\n::  d_step {j<3 && b[j]==0;j = j+1;}  goto q4; \n\n:: j==3; goto q5; \n\nfi;\nq5: if\n:: y==0; goto CS; \n\n:: y==255; goto NCS; \n\nfi;\ne1: if\n:: b[0] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte j=0;\n\nNCS: if\n:: b[1] = 1; goto q1; \n\nfi;\nCS: if\n:: y = 255; goto e1; \n\nfi;\nq1: if\n:: x = 1; goto q2; \n\nfi;\nq2: if\n::  d_step {y!=255;b[x] = 0;}  goto q22; \n\n:: y==255; goto p; \n\nfi;\nq22: if\n:: y==255; goto NCS; \n\nfi;\np: if\n:: y = 1; goto q3; \n\nfi;\nq3: if\n:: x==1; goto CS; \n\n::  d_step {x!=1;b[1] = 0;j = 0;}  goto q4; \n\nfi;\nq4: if\n::  d_step {j<3 && b[j]==0;j = j+1;}  goto q4; \n\n:: j==3; goto q5; \n\nfi;\nq5: if\n:: y==1; goto CS; \n\n:: y==255; goto NCS; \n\nfi;\ne1: if\n:: b[1] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte j=0;\n\nNCS: if\n:: b[2] = 1; goto q1; \n\nfi;\nCS: if\n:: y = 255; goto e1; \n\nfi;\nq1: if\n:: x = 2; goto q2; \n\nfi;\nq2: if\n::  d_step {y!=255;b[x] = 0;}  goto q22; \n\n:: y==255; goto p; \n\nfi;\nq22: if\n:: y==255; goto NCS; \n\nfi;\np: if\n:: y = 2; goto q3; \n\nfi;\nq3: if\n:: x==2; goto CS; \n\n::  d_step {x!=2;b[2] = 0;j = 0;}  goto q4; \n\nfi;\nq4: if\n::  d_step {j<3 && b[j]==0;j = j+1;}  goto q4; \n\n:: j==3; goto q5; \n\nfi;\nq5: if\n:: y==2; goto CS; \n\n:: y==255; goto NCS; \n\nfi;\ne1: if\n:: b[2] = 0; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "A mutual exclusion algorithm, which is optimized for a\n    number of read/write operations.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte b[3];\nbyte x=255;\nbyte y=255;\n\n\nactive proctype P_0() { \nbyte j=0;\n\nNCS: if\n:: b[0] = 1; goto q1; \n\nfi;\nCS: if\n:: y = 255; goto e1; \n\nfi;\nq1: if\n:: x = 0; goto q2; \n\nfi;\nq2: if\n::  d_step {y!=255;b[0] = 0;}  goto q22; \n\n:: y==255; goto p; \n\nfi;\nq22: if\n:: y==255; goto NCS; \n\nfi;\np: if\n:: y = 0; goto q3; \n\nfi;\nq3: if\n:: x==0; goto CS; \n\n::  d_step {x!=0;b[0] = 0;j = 0;}  goto q4; \n\nfi;\nq4: if\n::  d_step {j<3 && b[j]==0;j = j+1;}  goto q4; \n\n:: j==3; goto q5; \n\nfi;\nq5: if\n:: y==x; goto CS; \n\n:: y==255; goto NCS; \n\nfi;\ne1: if\n:: b[0] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte j=0;\n\nNCS: if\n:: b[1] = 1; goto q1; \n\nfi;\nCS: if\n:: y = 255; goto e1; \n\nfi;\nq1: if\n:: x = 1; goto q2; \n\nfi;\nq2: if\n::  d_step {y!=255;b[1] = 0;}  goto q22; \n\n:: y==255; goto p; \n\nfi;\nq22: if\n:: y==255; goto NCS; \n\nfi;\np: if\n:: y = 1; goto q3; \n\nfi;\nq3: if\n:: x==1; goto CS; \n\n::  d_step {x!=1;b[1] = 0;j = 0;}  goto q4; \n\nfi;\nq4: if\n::  d_step {j<3 && b[j]==0;j = j+1;}  goto q4; \n\n:: j==3; goto q5; \n\nfi;\nq5: if\n:: y==x; goto CS; \n\n:: y==255; goto NCS; \n\nfi;\ne1: if\n:: b[1] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte j=0;\n\nNCS: if\n:: b[2] = 1; goto q1; \n\nfi;\nCS: if\n:: y = 255; goto e1; \n\nfi;\nq1: if\n:: x = 2; goto q2; \n\nfi;\nq2: if\n::  d_step {y!=255;b[2] = 0;}  goto q22; \n\n:: y==255; goto p; \n\nfi;\nq22: if\n:: y==255; goto NCS; \n\nfi;\np: if\n:: y = 2; goto q3; \n\nfi;\nq3: if\n:: x==2; goto CS; \n\n::  d_step {x!=2;b[2] = 0;j = 0;}  goto q4; \n\nfi;\nq4: if\n::  d_step {j<3 && b[j]==0;j = j+1;}  goto q4; \n\n:: j==3; goto q5; \n\nfi;\nq5: if\n:: y==x; goto CS; \n\n:: y==255; goto NCS; \n\nfi;\ne1: if\n:: b[2] = 0; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "A mutual exclusion algorithm, which is optimized for a\n    number of read/write operations.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte b[4];\nbyte x=255;\nbyte y=255;\n\n\nactive proctype P_0() { \nbyte j=0;\n\nNCS: if\n:: b[0] = 1; goto q1; \n\nfi;\nCS: if\n:: y = 255; goto e1; \n\nfi;\nq1: if\n:: x = 0; goto q2; \n\nfi;\nq2: if\n::  d_step {y!=255;b[0] = 0;}  goto q22; \n\n:: y==255; goto p; \n\nfi;\nq22: if\n:: y==255; goto NCS; \n\nfi;\np: if\n:: y = 0; goto q3; \n\nfi;\nq3: if\n:: x==0; goto CS; \n\n::  d_step {x!=0;b[0] = 0;j = 0;}  goto q4; \n\nfi;\nq4: if\n::  d_step {j<4 && b[j]==0;j = j+1;}  goto q4; \n\n:: j==4; goto q5; \n\nfi;\nq5: if\n:: y==0; goto CS; \n\n:: y==255; goto NCS; \n\nfi;\ne1: if\n:: b[0] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte j=0;\n\nNCS: if\n:: b[1] = 1; goto q1; \n\nfi;\nCS: if\n:: y = 255; goto e1; \n\nfi;\nq1: if\n:: x = 1; goto q2; \n\nfi;\nq2: if\n::  d_step {y!=255;b[1] = 0;}  goto q22; \n\n:: y==255; goto p; \n\nfi;\nq22: if\n:: y==255; goto NCS; \n\nfi;\np: if\n:: y = 1; goto q3; \n\nfi;\nq3: if\n:: x==1; goto CS; \n\n::  d_step {x!=1;b[1] = 0;j = 0;}  goto q4; \n\nfi;\nq4: if\n::  d_step {j<4 && b[j]==0;j = j+1;}  goto q4; \n\n:: j==4; goto q5; \n\nfi;\nq5: if\n:: y==1; goto CS; \n\n:: y==255; goto NCS; \n\nfi;\ne1: if\n:: b[1] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte j=0;\n\nNCS: if\n:: b[2] = 1; goto q1; \n\nfi;\nCS: if\n:: y = 255; goto e1; \n\nfi;\nq1: if\n:: x = 2; goto q2; \n\nfi;\nq2: if\n::  d_step {y!=255;b[2] = 0;}  goto q22; \n\n:: y==255; goto p; \n\nfi;\nq22: if\n:: y==255; goto NCS; \n\nfi;\np: if\n:: y = 2; goto q3; \n\nfi;\nq3: if\n:: x==2; goto CS; \n\n::  d_step {x!=2;b[2] = 0;j = 0;}  goto q4; \n\nfi;\nq4: if\n::  d_step {j<4 && b[j]==0;j = j+1;}  goto q4; \n\n:: j==4; goto q5; \n\nfi;\nq5: if\n:: y==2; goto CS; \n\n:: y==255; goto NCS; \n\nfi;\ne1: if\n:: b[2] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_3() { \nbyte j=0;\n\nNCS: if\n:: b[3] = 1; goto q1; \n\nfi;\nCS: if\n:: y = 255; goto e1; \n\nfi;\nq1: if\n:: x = 3; goto q2; \n\nfi;\nq2: if\n::  d_step {y!=255;b[3] = 0;}  goto q22; \n\n:: y==255; goto p; \n\nfi;\nq22: if\n:: y==255; goto NCS; \n\nfi;\np: if\n:: y = 3; goto q3; \n\nfi;\nq3: if\n:: x==3; goto CS; \n\n::  d_step {x!=3;b[3] = 0;j = 0;}  goto q4; \n\nfi;\nq4: if\n::  d_step {j<4 && b[j]==0;j = j+1;}  goto q4; \n\n:: j==4; goto q5; \n\nfi;\nq5: if\n:: y==3; goto CS; \n\n:: y==255; goto NCS; \n\nfi;\ne1: if\n:: b[3] = 0; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "A mutual exclusion algorithm, which is optimized for a\n    number of read/write operations.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte b[4];\nbyte x=255;\nbyte y=255;\n\n\nactive proctype P_0() { \nbyte j=0;\n\nNCS: if\n:: b[0] = 1; goto q1; \n\nfi;\nCS: if\n:: y = 255; goto e1; \n\nfi;\nq1: if\n:: x = 0; goto q2; \n\nfi;\nq2: if\n::  d_step {y!=255;b[x] = 0;}  goto q22; \n\n:: y==255; goto p; \n\nfi;\nq22: if\n:: y==255; goto NCS; \n\nfi;\np: if\n:: y = 0; goto q3; \n\nfi;\nq3: if\n:: x==0; goto CS; \n\n::  d_step {x!=0;b[0] = 0;j = 0;}  goto q4; \n\nfi;\nq4: if\n::  d_step {j<4 && b[j]==0;j = j+1;}  goto q4; \n\n:: j==4; goto q5; \n\nfi;\nq5: if\n:: y==0; goto CS; \n\n:: y==255; goto NCS; \n\nfi;\ne1: if\n:: b[0] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte j=0;\n\nNCS: if\n:: b[1] = 1; goto q1; \n\nfi;\nCS: if\n:: y = 255; goto e1; \n\nfi;\nq1: if\n:: x = 1; goto q2; \n\nfi;\nq2: if\n::  d_step {y!=255;b[x] = 0;}  goto q22; \n\n:: y==255; goto p; \n\nfi;\nq22: if\n:: y==255; goto NCS; \n\nfi;\np: if\n:: y = 1; goto q3; \n\nfi;\nq3: if\n:: x==1; goto CS; \n\n::  d_step {x!=1;b[1] = 0;j = 0;}  goto q4; \n\nfi;\nq4: if\n::  d_step {j<4 && b[j]==0;j = j+1;}  goto q4; \n\n:: j==4; goto q5; \n\nfi;\nq5: if\n:: y==1; goto CS; \n\n:: y==255; goto NCS; \n\nfi;\ne1: if\n:: b[1] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte j=0;\n\nNCS: if\n:: b[2] = 1; goto q1; \n\nfi;\nCS: if\n:: y = 255; goto e1; \n\nfi;\nq1: if\n:: x = 2; goto q2; \n\nfi;\nq2: if\n::  d_step {y!=255;b[x] = 0;}  goto q22; \n\n:: y==255; goto p; \n\nfi;\nq22: if\n:: y==255; goto NCS; \n\nfi;\np: if\n:: y = 2; goto q3; \n\nfi;\nq3: if\n:: x==2; goto CS; \n\n::  d_step {x!=2;b[2] = 0;j = 0;}  goto q4; \n\nfi;\nq4: if\n::  d_step {j<4 && b[j]==0;j = j+1;}  goto q4; \n\n:: j==4; goto q5; \n\nfi;\nq5: if\n:: y==2; goto CS; \n\n:: y==255; goto NCS; \n\nfi;\ne1: if\n:: b[2] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_3() { \nbyte j=0;\n\nNCS: if\n:: b[3] = 1; goto q1; \n\nfi;\nCS: if\n:: y = 255; goto e1; \n\nfi;\nq1: if\n:: x = 3; goto q2; \n\nfi;\nq2: if\n::  d_step {y!=255;b[x] = 0;}  goto q22; \n\n:: y==255; goto p; \n\nfi;\nq22: if\n:: y==255; goto NCS; \n\nfi;\np: if\n:: y = 3; goto q3; \n\nfi;\nq3: if\n:: x==3; goto CS; \n\n::  d_step {x!=3;b[3] = 0;j = 0;}  goto q4; \n\nfi;\nq4: if\n::  d_step {j<4 && b[j]==0;j = j+1;}  goto q4; \n\n:: j==4; goto q5; \n\nfi;\nq5: if\n:: y==3; goto CS; \n\n:: y==255; goto NCS; \n\nfi;\ne1: if\n:: b[3] = 0; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "A mutual exclusion algorithm, which is optimized for a\n    number of read/write operations.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte b[5];\nbyte x=255;\nbyte y=255;\n\n\nactive proctype P_0() { \nbyte j=0;\n\nNCS: if\n:: b[0] = 1; goto q1; \n\nfi;\nCS: if\n:: y = 255; goto e1; \n\nfi;\nq1: if\n:: x = 0; goto q2; \n\nfi;\nq2: if\n::  d_step {y!=255;b[0] = 0;}  goto q22; \n\n:: y==255; goto p; \n\nfi;\nq22: if\n:: y==255; goto NCS; \n\nfi;\np: if\n:: y = 0; goto q3; \n\nfi;\nq3: if\n:: x==0; goto CS; \n\n::  d_step {x!=0;b[0] = 0;j = 0;}  goto q4; \n\nfi;\nq4: if\n::  d_step {j<5 && b[j]==0;j = j+1;}  goto q4; \n\n:: j==5; goto q5; \n\nfi;\nq5: if\n:: y==0; goto CS; \n\n:: y==255; goto NCS; \n\nfi;\ne1: if\n:: b[0] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte j=0;\n\nNCS: if\n:: b[1] = 1; goto q1; \n\nfi;\nCS: if\n:: y = 255; goto e1; \n\nfi;\nq1: if\n:: x = 1; goto q2; \n\nfi;\nq2: if\n::  d_step {y!=255;b[1] = 0;}  goto q22; \n\n:: y==255; goto p; \n\nfi;\nq22: if\n:: y==255; goto NCS; \n\nfi;\np: if\n:: y = 1; goto q3; \n\nfi;\nq3: if\n:: x==1; goto CS; \n\n::  d_step {x!=1;b[1] = 0;j = 0;}  goto q4; \n\nfi;\nq4: if\n::  d_step {j<5 && b[j]==0;j = j+1;}  goto q4; \n\n:: j==5; goto q5; \n\nfi;\nq5: if\n:: y==1; goto CS; \n\n:: y==255; goto NCS; \n\nfi;\ne1: if\n:: b[1] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte j=0;\n\nNCS: if\n:: b[2] = 1; goto q1; \n\nfi;\nCS: if\n:: y = 255; goto e1; \n\nfi;\nq1: if\n:: x = 2; goto q2; \n\nfi;\nq2: if\n::  d_step {y!=255;b[2] = 0;}  goto q22; \n\n:: y==255; goto p; \n\nfi;\nq22: if\n:: y==255; goto NCS; \n\nfi;\np: if\n:: y = 2; goto q3; \n\nfi;\nq3: if\n:: x==2; goto CS; \n\n::  d_step {x!=2;b[2] = 0;j = 0;}  goto q4; \n\nfi;\nq4: if\n::  d_step {j<5 && b[j]==0;j = j+1;}  goto q4; \n\n:: j==5; goto q5; \n\nfi;\nq5: if\n:: y==2; goto CS; \n\n:: y==255; goto NCS; \n\nfi;\ne1: if\n:: b[2] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_3() { \nbyte j=0;\n\nNCS: if\n:: b[3] = 1; goto q1; \n\nfi;\nCS: if\n:: y = 255; goto e1; \n\nfi;\nq1: if\n:: x = 3; goto q2; \n\nfi;\nq2: if\n::  d_step {y!=255;b[3] = 0;}  goto q22; \n\n:: y==255; goto p; \n\nfi;\nq22: if\n:: y==255; goto NCS; \n\nfi;\np: if\n:: y = 3; goto q3; \n\nfi;\nq3: if\n:: x==3; goto CS; \n\n::  d_step {x!=3;b[3] = 0;j = 0;}  goto q4; \n\nfi;\nq4: if\n::  d_step {j<5 && b[j]==0;j = j+1;}  goto q4; \n\n:: j==5; goto q5; \n\nfi;\nq5: if\n:: y==3; goto CS; \n\n:: y==255; goto NCS; \n\nfi;\ne1: if\n:: b[3] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_4() { \nbyte j=0;\n\nNCS: if\n:: b[4] = 1; goto q1; \n\nfi;\nCS: if\n:: y = 255; goto e1; \n\nfi;\nq1: if\n:: x = 4; goto q2; \n\nfi;\nq2: if\n::  d_step {y!=255;b[4] = 0;}  goto q22; \n\n:: y==255; goto p; \n\nfi;\nq22: if\n:: y==255; goto NCS; \n\nfi;\np: if\n:: y = 4; goto q3; \n\nfi;\nq3: if\n:: x==4; goto CS; \n\n::  d_step {x!=4;b[4] = 0;j = 0;}  goto q4; \n\nfi;\nq4: if\n::  d_step {j<5 && b[j]==0;j = j+1;}  goto q4; \n\n:: j==5; goto q5; \n\nfi;\nq5: if\n:: y==4; goto CS; \n\n:: y==255; goto NCS; \n\nfi;\ne1: if\n:: b[4] = 0; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "A mutual exclusion algorithm, which is optimized for a\n    number of read/write operations.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte b[5];\nbyte x=255;\nbyte y=255;\n\n\nactive proctype P_0() { \nbyte j=0;\n\nNCS: if\n:: b[0] = 1; goto q1; \n\nfi;\nCS: if\n:: y = 255; goto e1; \n\nfi;\nq1: if\n:: x = 0; goto q2; \n\nfi;\nq2: if\n::  d_step {y!=255;b[0] = 0;}  goto q22; \n\n:: y==255; goto p; \n\nfi;\nq22: if\n:: y==255; goto NCS; \n\nfi;\np: if\n:: y = 0; goto q3; \n\nfi;\nq3: if\n:: x==0; goto CS; \n\n::  d_step {x!=0;b[0] = 0;j = 0;}  goto q4; \n\nfi;\nq4: if\n::  d_step {j<5 && b[j]==0;j = j+1;}  goto q4; \n\n:: j==5; goto q5; \n\nfi;\nq5: if\n:: y==x; goto CS; \n\n:: y==255; goto NCS; \n\nfi;\ne1: if\n:: b[0] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte j=0;\n\nNCS: if\n:: b[1] = 1; goto q1; \n\nfi;\nCS: if\n:: y = 255; goto e1; \n\nfi;\nq1: if\n:: x = 1; goto q2; \n\nfi;\nq2: if\n::  d_step {y!=255;b[1] = 0;}  goto q22; \n\n:: y==255; goto p; \n\nfi;\nq22: if\n:: y==255; goto NCS; \n\nfi;\np: if\n:: y = 1; goto q3; \n\nfi;\nq3: if\n:: x==1; goto CS; \n\n::  d_step {x!=1;b[1] = 0;j = 0;}  goto q4; \n\nfi;\nq4: if\n::  d_step {j<5 && b[j]==0;j = j+1;}  goto q4; \n\n:: j==5; goto q5; \n\nfi;\nq5: if\n:: y==x; goto CS; \n\n:: y==255; goto NCS; \n\nfi;\ne1: if\n:: b[1] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte j=0;\n\nNCS: if\n:: b[2] = 1; goto q1; \n\nfi;\nCS: if\n:: y = 255; goto e1; \n\nfi;\nq1: if\n:: x = 2; goto q2; \n\nfi;\nq2: if\n::  d_step {y!=255;b[2] = 0;}  goto q22; \n\n:: y==255; goto p; \n\nfi;\nq22: if\n:: y==255; goto NCS; \n\nfi;\np: if\n:: y = 2; goto q3; \n\nfi;\nq3: if\n:: x==2; goto CS; \n\n::  d_step {x!=2;b[2] = 0;j = 0;}  goto q4; \n\nfi;\nq4: if\n::  d_step {j<5 && b[j]==0;j = j+1;}  goto q4; \n\n:: j==5; goto q5; \n\nfi;\nq5: if\n:: y==x; goto CS; \n\n:: y==255; goto NCS; \n\nfi;\ne1: if\n:: b[2] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_3() { \nbyte j=0;\n\nNCS: if\n:: b[3] = 1; goto q1; \n\nfi;\nCS: if\n:: y = 255; goto e1; \n\nfi;\nq1: if\n:: x = 3; goto q2; \n\nfi;\nq2: if\n::  d_step {y!=255;b[3] = 0;}  goto q22; \n\n:: y==255; goto p; \n\nfi;\nq22: if\n:: y==255; goto NCS; \n\nfi;\np: if\n:: y = 3; goto q3; \n\nfi;\nq3: if\n:: x==3; goto CS; \n\n::  d_step {x!=3;b[3] = 0;j = 0;}  goto q4; \n\nfi;\nq4: if\n::  d_step {j<5 && b[j]==0;j = j+1;}  goto q4; \n\n:: j==5; goto q5; \n\nfi;\nq5: if\n:: y==x; goto CS; \n\n:: y==255; goto NCS; \n\nfi;\ne1: if\n:: b[3] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_4() { \nbyte j=0;\n\nNCS: if\n:: b[4] = 1; goto q1; \n\nfi;\nCS: if\n:: y = 255; goto e1; \n\nfi;\nq1: if\n:: x = 4; goto q2; \n\nfi;\nq2: if\n::  d_step {y!=255;b[4] = 0;}  goto q22; \n\n:: y==255; goto p; \n\nfi;\nq22: if\n:: y==255; goto NCS; \n\nfi;\np: if\n:: y = 4; goto q3; \n\nfi;\nq3: if\n:: x==4; goto CS; \n\n::  d_step {x!=4;b[4] = 0;j = 0;}  goto q4; \n\nfi;\nq4: if\n::  d_step {j<5 && b[j]==0;j = j+1;}  goto q4; \n\n:: j==5; goto q5; \n\nfi;\nq5: if\n:: y==x; goto CS; \n\n:: y==255; goto NCS; \n\nfi;\ne1: if\n:: b[4] = 0; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "A mutual exclusion algorithm. In this case, read and\n    write operations need not be atomic.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "chan read_0 =[0] of {int};\nchan write_0 =[0] of {int};\nchan done_0 =[0] of {int};\nchan read_1 =[0] of {int};\nchan write_1 =[0] of {int};\nchan done_1 =[0] of {int};\nchan read_2 =[0] of {int};\nchan write_2 =[0] of {int};\nchan done_2 =[0] of {int};\n\nactive proctype NonatomicVar_0() { \nbyte x=0;\nbyte v=0;\n\nq: if\n:: read_0!x; goto q; \n\n:: write_0?v; goto r; \n\nfi;\nr: if\n::  atomic {done_0!0;x = v;}  goto q; \n\n:: read_0!0; goto r; \n\n:: read_0!1; goto r; \n\nfi;\n}\n\nactive proctype NonatomicVar_1() { \nbyte x=0;\nbyte v=0;\n\nq: if\n:: read_1!x; goto q; \n\n:: write_1?v; goto r; \n\nfi;\nr: if\n::  atomic {done_1!0;x = v;}  goto q; \n\n:: read_1!0; goto r; \n\n:: read_1!1; goto r; \n\nfi;\n}\n\nactive proctype NonatomicVar_2() { \nbyte x=0;\nbyte v=0;\n\nq: if\n:: read_2!x; goto q; \n\n:: write_2?v; goto r; \n\nfi;\nr: if\n::  atomic {done_2!0;x = v;}  goto q; \n\n:: read_2!0; goto r; \n\n:: read_2!1; goto r; \n\nfi;\n}\n\nactive proctype P_0() { \nbyte i=0;\nbyte v=0;\n\nNCS: if\n:: write_0!1; goto w1; \n\nfi;\nw1: if\n::  atomic {done_0?0;i = 0;}  goto p3; \n\nfi;\np3: if\n::  d_step {i==0;i = 0+1;}  goto p8; \n\n::  atomic {i==0;read_0?v;}  goto p4; \n\n::  atomic {i==1;read_1?v;}  goto p4; \n\n::  atomic {i==2;read_2?v;}  goto p4; \n\nfi;\np8: if\n::  atomic {i==0;read_0?v;}  goto p9; \n\n::  atomic {i==1;read_1?v;}  goto p9; \n\n::  atomic {i==2;read_2?v;}  goto p9; \n\n:: i==3; goto CS; \n\nfi;\np4: if\n::  d_step {v==0;i = i+1;}  goto p3; \n\n:: v==1; goto p5; \n\nfi;\np5: if\n:: v==1; goto p6; \n\n:: v==0; goto NCS; \n\nfi;\np6: if\n:: write_0!0; goto w2; \n\nfi;\np61: if\n::  atomic {i==0;read_0?v;}  goto p5; \n\n::  atomic {i==1;read_1?v;}  goto p5; \n\n::  atomic {i==2;read_2?v;}  goto p5; \n\nfi;\nw2: if\n:: done_0?0; goto p61; \n\nfi;\np9: if\n::  atomic {v==1 && i==0;read_0?v;}  goto p9; \n\n::  atomic {v==1 && i==1;read_1?v;}  goto p9; \n\n::  atomic {v==1 && i==2;read_2?v;}  goto p9; \n\n::  d_step {v==0;i = i+1;}  goto p8; \n\nfi;\nCS: if\n:: write_0!0; goto w3; \n\nfi;\nw3: if\n:: done_0?0; goto NCS; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte i=0;\nbyte v=0;\n\nNCS: if\n:: write_1!1; goto w1; \n\nfi;\nw1: if\n::  atomic {done_1?0;i = 0;}  goto p3; \n\nfi;\np3: if\n::  d_step {i==1;i = 1+1;}  goto p8; \n\n::  atomic {i==0;read_0?v;}  goto p4; \n\n::  atomic {i==1;read_1?v;}  goto p4; \n\n::  atomic {i==2;read_2?v;}  goto p4; \n\nfi;\np8: if\n::  atomic {i==0;read_0?v;}  goto p9; \n\n::  atomic {i==1;read_1?v;}  goto p9; \n\n::  atomic {i==2;read_2?v;}  goto p9; \n\n:: i==3; goto CS; \n\nfi;\np4: if\n::  d_step {v==0;i = i+1;}  goto p3; \n\n:: v==1; goto p5; \n\nfi;\np5: if\n:: v==1; goto p6; \n\n:: v==0; goto NCS; \n\nfi;\np6: if\n:: write_1!0; goto w2; \n\nfi;\np61: if\n::  atomic {i==0;read_0?v;}  goto p5; \n\n::  atomic {i==1;read_1?v;}  goto p5; \n\n::  atomic {i==2;read_2?v;}  goto p5; \n\nfi;\nw2: if\n:: done_1?0; goto p61; \n\nfi;\np9: if\n::  atomic {v==1 && i==0;read_0?v;}  goto p9; \n\n::  atomic {v==1 && i==1;read_1?v;}  goto p9; \n\n::  atomic {v==1 && i==2;read_2?v;}  goto p9; \n\n::  d_step {v==0;i = i+1;}  goto p8; \n\nfi;\nCS: if\n:: write_1!0; goto w3; \n\nfi;\nw3: if\n:: done_1?0; goto NCS; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte i=0;\nbyte v=0;\n\nNCS: if\n:: write_2!1; goto w1; \n\nfi;\nw1: if\n::  atomic {done_2?0;i = 0;}  goto p3; \n\nfi;\np3: if\n::  d_step {i==2;i = 2+1;}  goto p8; \n\n::  atomic {i==0;read_0?v;}  goto p4; \n\n::  atomic {i==1;read_1?v;}  goto p4; \n\n::  atomic {i==2;read_2?v;}  goto p4; \n\nfi;\np8: if\n::  atomic {i==0;read_0?v;}  goto p9; \n\n::  atomic {i==1;read_1?v;}  goto p9; \n\n::  atomic {i==2;read_2?v;}  goto p9; \n\n:: i==3; goto CS; \n\nfi;\np4: if\n::  d_step {v==0;i = i+1;}  goto p3; \n\n:: v==1; goto p5; \n\nfi;\np5: if\n:: v==1; goto p6; \n\n:: v==0; goto NCS; \n\nfi;\np6: if\n:: write_2!0; goto w2; \n\nfi;\np61: if\n::  atomic {i==0;read_0?v;}  goto p5; \n\n::  atomic {i==1;read_1?v;}  goto p5; \n\n::  atomic {i==2;read_2?v;}  goto p5; \n\nfi;\nw2: if\n:: done_2?0; goto p61; \n\nfi;\np9: if\n::  atomic {v==1 && i==0;read_0?v;}  goto p9; \n\n::  atomic {v==1 && i==1;read_1?v;}  goto p9; \n\n::  atomic {v==1 && i==2;read_2?v;}  goto p9; \n\n::  d_step {v==0;i = i+1;}  goto p8; \n\nfi;\nCS: if\n:: write_2!0; goto w3; \n\nfi;\nw3: if\n:: done_2?0; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "A mutual exclusion algorithm. In this case, read and\n    write operations need not be atomic.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "chan read_0 =[0] of {int};\nchan write_0 =[0] of {int};\nchan done_0 =[0] of {int};\nchan read_1 =[0] of {int};\nchan write_1 =[0] of {int};\nchan done_1 =[0] of {int};\nchan read_2 =[0] of {int};\nchan write_2 =[0] of {int};\nchan done_2 =[0] of {int};\n\nactive proctype NonatomicVar_0() { \nbyte x=0;\nbyte v=0;\n\nq: if\n:: read_0!x; goto q; \n\n:: write_0?v; goto r; \n\nfi;\nr: if\n::  atomic {done_0!0;x = v;}  goto q; \n\n:: read_0!0; goto r; \n\n:: read_0!1; goto r; \n\nfi;\n}\n\nactive proctype NonatomicVar_1() { \nbyte x=0;\nbyte v=0;\n\nq: if\n:: read_1!x; goto q; \n\n:: write_1?v; goto r; \n\nfi;\nr: if\n::  atomic {done_1!0;x = v;}  goto q; \n\n:: read_1!0; goto r; \n\n:: read_1!1; goto r; \n\nfi;\n}\n\nactive proctype NonatomicVar_2() { \nbyte x=0;\nbyte v=0;\n\nq: if\n:: read_2!x; goto q; \n\n:: write_2?v; goto r; \n\nfi;\nr: if\n::  atomic {done_2!0;x = v;}  goto q; \n\n:: read_2!0; goto r; \n\n:: read_2!1; goto r; \n\nfi;\n}\n\nactive proctype P_0() { \nbyte i=0;\nbyte v=0;\n\nNCS: if\n:: write_0!1; goto w1; \n\nfi;\nw1: if\n::  atomic {done_0?0;i = 0;}  goto p3; \n\nfi;\np3: if\n::  d_step {i==0;i = 0+1;}  goto p8; \n\n::  atomic {i==0;read_0?v;}  goto p4; \n\n::  atomic {i==1;read_1?v;}  goto p4; \n\n::  atomic {i==2;read_2?v;}  goto p4; \n\nfi;\np8: if\n::  atomic {i==0;read_0?v;}  goto p9; \n\n::  atomic {i==1;read_1?v;}  goto p9; \n\n::  atomic {i==2;read_2?v;}  goto p9; \n\n:: i==3; goto CS; \n\nfi;\np4: if\n::  d_step {v==0;i = i+1;}  goto p3; \n\n:: v==1; goto p5; \n\nfi;\np5: if\n:: v==1; goto p6; \n\n:: v==0; goto NCS; \n\nfi;\np6: if\n:: write_0!1; goto w2; \n\nfi;\np61: if\n::  atomic {i==0;read_0?v;}  goto p5; \n\n::  atomic {i==1;read_1?v;}  goto p5; \n\n::  atomic {i==2;read_2?v;}  goto p5; \n\nfi;\nw2: if\n:: done_0?0; goto p61; \n\nfi;\np9: if\n::  atomic {v==1 && i==0;read_0?v;}  goto p9; \n\n::  atomic {v==1 && i==1;read_1?v;}  goto p9; \n\n::  atomic {v==1 && i==2;read_2?v;}  goto p9; \n\n::  d_step {v==0;i = i+1;}  goto p8; \n\nfi;\nCS: if\n:: write_0!0; goto w3; \n\nfi;\nw3: if\n:: done_0?0; goto NCS; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte i=0;\nbyte v=0;\n\nNCS: if\n:: write_1!1; goto w1; \n\nfi;\nw1: if\n::  atomic {done_1?0;i = 0;}  goto p3; \n\nfi;\np3: if\n::  d_step {i==1;i = 1+1;}  goto p8; \n\n::  atomic {i==0;read_0?v;}  goto p4; \n\n::  atomic {i==1;read_1?v;}  goto p4; \n\n::  atomic {i==2;read_2?v;}  goto p4; \n\nfi;\np8: if\n::  atomic {i==0;read_0?v;}  goto p9; \n\n::  atomic {i==1;read_1?v;}  goto p9; \n\n::  atomic {i==2;read_2?v;}  goto p9; \n\n:: i==3; goto CS; \n\nfi;\np4: if\n::  d_step {v==0;i = i+1;}  goto p3; \n\n:: v==1; goto p5; \n\nfi;\np5: if\n:: v==1; goto p6; \n\n:: v==0; goto NCS; \n\nfi;\np6: if\n:: write_1!1; goto w2; \n\nfi;\np61: if\n::  atomic {i==0;read_0?v;}  goto p5; \n\n::  atomic {i==1;read_1?v;}  goto p5; \n\n::  atomic {i==2;read_2?v;}  goto p5; \n\nfi;\nw2: if\n:: done_1?0; goto p61; \n\nfi;\np9: if\n::  atomic {v==1 && i==0;read_0?v;}  goto p9; \n\n::  atomic {v==1 && i==1;read_1?v;}  goto p9; \n\n::  atomic {v==1 && i==2;read_2?v;}  goto p9; \n\n::  d_step {v==0;i = i+1;}  goto p8; \n\nfi;\nCS: if\n:: write_1!0; goto w3; \n\nfi;\nw3: if\n:: done_1?0; goto NCS; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte i=0;\nbyte v=0;\n\nNCS: if\n:: write_2!1; goto w1; \n\nfi;\nw1: if\n::  atomic {done_2?0;i = 0;}  goto p3; \n\nfi;\np3: if\n::  d_step {i==2;i = 2+1;}  goto p8; \n\n::  atomic {i==0;read_0?v;}  goto p4; \n\n::  atomic {i==1;read_1?v;}  goto p4; \n\n::  atomic {i==2;read_2?v;}  goto p4; \n\nfi;\np8: if\n::  atomic {i==0;read_0?v;}  goto p9; \n\n::  atomic {i==1;read_1?v;}  goto p9; \n\n::  atomic {i==2;read_2?v;}  goto p9; \n\n:: i==3; goto CS; \n\nfi;\np4: if\n::  d_step {v==0;i = i+1;}  goto p3; \n\n:: v==1; goto p5; \n\nfi;\np5: if\n:: v==1; goto p6; \n\n:: v==0; goto NCS; \n\nfi;\np6: if\n:: write_2!1; goto w2; \n\nfi;\np61: if\n::  atomic {i==0;read_0?v;}  goto p5; \n\n::  atomic {i==1;read_1?v;}  goto p5; \n\n::  atomic {i==2;read_2?v;}  goto p5; \n\nfi;\nw2: if\n:: done_2?0; goto p61; \n\nfi;\np9: if\n::  atomic {v==1 && i==0;read_0?v;}  goto p9; \n\n::  atomic {v==1 && i==1;read_1?v;}  goto p9; \n\n::  atomic {v==1 && i==2;read_2?v;}  goto p9; \n\n::  d_step {v==0;i = i+1;}  goto p8; \n\nfi;\nCS: if\n:: write_2!0; goto w3; \n\nfi;\nw3: if\n:: done_2?0; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "A mutual exclusion algorithm. In this case, read and\n    write operations need not be atomic.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "chan read_0 =[0] of {int};\nchan write_0 =[0] of {int};\nchan done_0 =[0] of {int};\nchan read_1 =[0] of {int};\nchan write_1 =[0] of {int};\nchan done_1 =[0] of {int};\nchan read_2 =[0] of {int};\nchan write_2 =[0] of {int};\nchan done_2 =[0] of {int};\n\nactive proctype NonatomicVar_0() { \nbyte x=0;\nbyte v=0;\n\nq: if\n:: read_0!x; goto q; \n\n:: write_0?v; goto r; \n\nfi;\nr: if\n::  atomic {done_0!0;x = v;}  goto q; \n\n:: read_0!0; goto r; \n\n:: read_0!1; goto r; \n\nfi;\n}\n\nactive proctype NonatomicVar_1() { \nbyte x=0;\nbyte v=0;\n\nq: if\n:: read_1!x; goto q; \n\n:: write_1?v; goto r; \n\nfi;\nr: if\n::  atomic {done_1!0;x = v;}  goto q; \n\n:: read_1!0; goto r; \n\n:: read_1!1; goto r; \n\nfi;\n}\n\nactive proctype NonatomicVar_2() { \nbyte x=0;\nbyte v=0;\n\nq: if\n:: read_2!x; goto q; \n\n:: write_2?v; goto r; \n\nfi;\nr: if\n::  atomic {done_2!0;x = v;}  goto q; \n\n:: read_2!0; goto r; \n\n:: read_2!1; goto r; \n\nfi;\n}\n\nactive proctype P_0() { \nbyte i=0;\nbyte v=0;\n\nNCS: if\n:: write_0!1; goto w1; \n\nfi;\nw1: if\n::  atomic {done_0?0;i = 0;}  goto p3; \n\nfi;\np3: if\n::  d_step {i==0;i = 0+1;}  goto p8; \n\n::  atomic {i==0;read_0?v;}  goto p4; \n\n::  atomic {i==1;read_1?v;}  goto p4; \n\n::  atomic {i==2;read_2?v;}  goto p4; \n\nfi;\np8: if\n::  atomic {i==0;read_0?v;}  goto p9; \n\n::  atomic {i==1;read_1?v;}  goto p9; \n\n::  atomic {i==2;read_2?v;}  goto p9; \n\n:: i==3; goto CS; \n\nfi;\np4: if\n::  d_step {v==0;i = i+1;}  goto p3; \n\n:: v==1; goto p5; \n\nfi;\np5: if\n:: v==1; goto p6; \n\n:: v==0; goto NCS; \n\nfi;\np6: if\n:: write_0!0; goto w2; \n\nfi;\np61: if\n::  atomic {i==0;read_0?v;}  goto p5; \n\n::  atomic {i==1;read_1?v;}  goto p5; \n\n::  atomic {i==2;read_2?v;}  goto p5; \n\nfi;\nw2: if\n:: done_0?0; goto p61; \n\nfi;\np9: if\n::  atomic {v==1 && i==0;read_0?v;}  goto p9; \n\n::  atomic {v==1 && i==1;read_1?v;}  goto p9; \n\n::  atomic {v==1 && i==2;read_2?v;}  goto p9; \n\n::  d_step {v==0 || i>0;i = i+1;}  goto p8; \n\nfi;\nCS: if\n:: write_0!0; goto w3; \n\nfi;\nw3: if\n:: done_0?0; goto NCS; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte i=0;\nbyte v=0;\n\nNCS: if\n:: write_1!1; goto w1; \n\nfi;\nw1: if\n::  atomic {done_1?0;i = 0;}  goto p3; \n\nfi;\np3: if\n::  d_step {i==1;i = 1+1;}  goto p8; \n\n::  atomic {i==0;read_0?v;}  goto p4; \n\n::  atomic {i==1;read_1?v;}  goto p4; \n\n::  atomic {i==2;read_2?v;}  goto p4; \n\nfi;\np8: if\n::  atomic {i==0;read_0?v;}  goto p9; \n\n::  atomic {i==1;read_1?v;}  goto p9; \n\n::  atomic {i==2;read_2?v;}  goto p9; \n\n:: i==3; goto CS; \n\nfi;\np4: if\n::  d_step {v==0;i = i+1;}  goto p3; \n\n:: v==1; goto p5; \n\nfi;\np5: if\n:: v==1; goto p6; \n\n:: v==0; goto NCS; \n\nfi;\np6: if\n:: write_1!0; goto w2; \n\nfi;\np61: if\n::  atomic {i==0;read_0?v;}  goto p5; \n\n::  atomic {i==1;read_1?v;}  goto p5; \n\n::  atomic {i==2;read_2?v;}  goto p5; \n\nfi;\nw2: if\n:: done_1?0; goto p61; \n\nfi;\np9: if\n::  atomic {v==1 && i==0;read_0?v;}  goto p9; \n\n::  atomic {v==1 && i==1;read_1?v;}  goto p9; \n\n::  atomic {v==1 && i==2;read_2?v;}  goto p9; \n\n::  d_step {v==0 || i>1;i = i+1;}  goto p8; \n\nfi;\nCS: if\n:: write_1!0; goto w3; \n\nfi;\nw3: if\n:: done_1?0; goto NCS; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte i=0;\nbyte v=0;\n\nNCS: if\n:: write_2!1; goto w1; \n\nfi;\nw1: if\n::  atomic {done_2?0;i = 0;}  goto p3; \n\nfi;\np3: if\n::  d_step {i==2;i = 2+1;}  goto p8; \n\n::  atomic {i==0;read_0?v;}  goto p4; \n\n::  atomic {i==1;read_1?v;}  goto p4; \n\n::  atomic {i==2;read_2?v;}  goto p4; \n\nfi;\np8: if\n::  atomic {i==0;read_0?v;}  goto p9; \n\n::  atomic {i==1;read_1?v;}  goto p9; \n\n::  atomic {i==2;read_2?v;}  goto p9; \n\n:: i==3; goto CS; \n\nfi;\np4: if\n::  d_step {v==0;i = i+1;}  goto p3; \n\n:: v==1; goto p5; \n\nfi;\np5: if\n:: v==1; goto p6; \n\n:: v==0; goto NCS; \n\nfi;\np6: if\n:: write_2!0; goto w2; \n\nfi;\np61: if\n::  atomic {i==0;read_0?v;}  goto p5; \n\n::  atomic {i==1;read_1?v;}  goto p5; \n\n::  atomic {i==2;read_2?v;}  goto p5; \n\nfi;\nw2: if\n:: done_2?0; goto p61; \n\nfi;\np9: if\n::  atomic {v==1 && i==0;read_0?v;}  goto p9; \n\n::  atomic {v==1 && i==1;read_1?v;}  goto p9; \n\n::  atomic {v==1 && i==2;read_2?v;}  goto p9; \n\n::  d_step {v==0 || i>2;i = i+1;}  goto p8; \n\nfi;\nCS: if\n:: write_2!0; goto w3; \n\nfi;\nw3: if\n:: done_2?0; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "A mutual exclusion algorithm. In this case, read and\n    write operations need not be atomic.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "chan read_0 =[0] of {int};\nchan write_0 =[0] of {int};\nchan done_0 =[0] of {int};\nchan read_1 =[0] of {int};\nchan write_1 =[0] of {int};\nchan done_1 =[0] of {int};\nchan read_2 =[0] of {int};\nchan write_2 =[0] of {int};\nchan done_2 =[0] of {int};\nchan read_3 =[0] of {int};\nchan write_3 =[0] of {int};\nchan done_3 =[0] of {int};\n\nactive proctype NonatomicVar_0() { \nbyte x=0;\nbyte v=0;\n\nq: if\n:: read_0!x; goto q; \n\n:: write_0?v; goto r; \n\nfi;\nr: if\n::  atomic {done_0!0;x = v;}  goto q; \n\n:: read_0!0; goto r; \n\n:: read_0!1; goto r; \n\nfi;\n}\n\nactive proctype NonatomicVar_1() { \nbyte x=0;\nbyte v=0;\n\nq: if\n:: read_1!x; goto q; \n\n:: write_1?v; goto r; \n\nfi;\nr: if\n::  atomic {done_1!0;x = v;}  goto q; \n\n:: read_1!0; goto r; \n\n:: read_1!1; goto r; \n\nfi;\n}\n\nactive proctype NonatomicVar_2() { \nbyte x=0;\nbyte v=0;\n\nq: if\n:: read_2!x; goto q; \n\n:: write_2?v; goto r; \n\nfi;\nr: if\n::  atomic {done_2!0;x = v;}  goto q; \n\n:: read_2!0; goto r; \n\n:: read_2!1; goto r; \n\nfi;\n}\n\nactive proctype NonatomicVar_3() { \nbyte x=0;\nbyte v=0;\n\nq: if\n:: read_3!x; goto q; \n\n:: write_3?v; goto r; \n\nfi;\nr: if\n::  atomic {done_3!0;x = v;}  goto q; \n\n:: read_3!0; goto r; \n\n:: read_3!1; goto r; \n\nfi;\n}\n\nactive proctype P_0() { \nbyte i=0;\nbyte v=0;\n\nNCS: if\n:: write_0!1; goto w1; \n\nfi;\nw1: if\n::  atomic {done_0?0;i = 0;}  goto p3; \n\nfi;\np3: if\n::  d_step {i==0;i = 0+1;}  goto p8; \n\n::  atomic {i==0;read_0?v;}  goto p4; \n\n::  atomic {i==1;read_1?v;}  goto p4; \n\n::  atomic {i==2;read_2?v;}  goto p4; \n\n::  atomic {i==3;read_3?v;}  goto p4; \n\nfi;\np8: if\n::  atomic {i==0;read_0?v;}  goto p9; \n\n::  atomic {i==1;read_1?v;}  goto p9; \n\n::  atomic {i==2;read_2?v;}  goto p9; \n\n::  atomic {i==3;read_3?v;}  goto p9; \n\n:: i==4; goto CS; \n\nfi;\np4: if\n::  d_step {v==0;i = i+1;}  goto p3; \n\n:: v==1; goto p5; \n\nfi;\np5: if\n:: v==1; goto p6; \n\n:: v==0; goto NCS; \n\nfi;\np6: if\n:: write_0!0; goto w2; \n\nfi;\np61: if\n::  atomic {i==0;read_0?v;}  goto p5; \n\n::  atomic {i==1;read_1?v;}  goto p5; \n\n::  atomic {i==2;read_2?v;}  goto p5; \n\n::  atomic {i==3;read_3?v;}  goto p5; \n\nfi;\nw2: if\n:: done_0?0; goto p61; \n\nfi;\np9: if\n::  atomic {v==1 && i==0;read_0?v;}  goto p9; \n\n::  atomic {v==1 && i==1;read_1?v;}  goto p9; \n\n::  atomic {v==1 && i==2;read_2?v;}  goto p9; \n\n::  atomic {v==1 && i==3;read_3?v;}  goto p9; \n\n::  d_step {v==0;i = i+1;}  goto p8; \n\nfi;\nCS: if\n:: write_0!0; goto w3; \n\nfi;\nw3: if\n:: done_0?0; goto NCS; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte i=0;\nbyte v=0;\n\nNCS: if\n:: write_1!1; goto w1; \n\nfi;\nw1: if\n::  atomic {done_1?0;i = 0;}  goto p3; \n\nfi;\np3: if\n::  d_step {i==1;i = 1+1;}  goto p8; \n\n::  atomic {i==0;read_0?v;}  goto p4; \n\n::  atomic {i==1;read_1?v;}  goto p4; \n\n::  atomic {i==2;read_2?v;}  goto p4; \n\n::  atomic {i==3;read_3?v;}  goto p4; \n\nfi;\np8: if\n::  atomic {i==0;read_0?v;}  goto p9; \n\n::  atomic {i==1;read_1?v;}  goto p9; \n\n::  atomic {i==2;read_2?v;}  goto p9; \n\n::  atomic {i==3;read_3?v;}  goto p9; \n\n:: i==4; goto CS; \n\nfi;\np4: if\n::  d_step {v==0;i = i+1;}  goto p3; \n\n:: v==1; goto p5; \n\nfi;\np5: if\n:: v==1; goto p6; \n\n:: v==0; goto NCS; \n\nfi;\np6: if\n:: write_1!0; goto w2; \n\nfi;\np61: if\n::  atomic {i==0;read_0?v;}  goto p5; \n\n::  atomic {i==1;read_1?v;}  goto p5; \n\n::  atomic {i==2;read_2?v;}  goto p5; \n\n::  atomic {i==3;read_3?v;}  goto p5; \n\nfi;\nw2: if\n:: done_1?0; goto p61; \n\nfi;\np9: if\n::  atomic {v==1 && i==0;read_0?v;}  goto p9; \n\n::  atomic {v==1 && i==1;read_1?v;}  goto p9; \n\n::  atomic {v==1 && i==2;read_2?v;}  goto p9; \n\n::  atomic {v==1 && i==3;read_3?v;}  goto p9; \n\n::  d_step {v==0;i = i+1;}  goto p8; \n\nfi;\nCS: if\n:: write_1!0; goto w3; \n\nfi;\nw3: if\n:: done_1?0; goto NCS; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte i=0;\nbyte v=0;\n\nNCS: if\n:: write_2!1; goto w1; \n\nfi;\nw1: if\n::  atomic {done_2?0;i = 0;}  goto p3; \n\nfi;\np3: if\n::  d_step {i==2;i = 2+1;}  goto p8; \n\n::  atomic {i==0;read_0?v;}  goto p4; \n\n::  atomic {i==1;read_1?v;}  goto p4; \n\n::  atomic {i==2;read_2?v;}  goto p4; \n\n::  atomic {i==3;read_3?v;}  goto p4; \n\nfi;\np8: if\n::  atomic {i==0;read_0?v;}  goto p9; \n\n::  atomic {i==1;read_1?v;}  goto p9; \n\n::  atomic {i==2;read_2?v;}  goto p9; \n\n::  atomic {i==3;read_3?v;}  goto p9; \n\n:: i==4; goto CS; \n\nfi;\np4: if\n::  d_step {v==0;i = i+1;}  goto p3; \n\n:: v==1; goto p5; \n\nfi;\np5: if\n:: v==1; goto p6; \n\n:: v==0; goto NCS; \n\nfi;\np6: if\n:: write_2!0; goto w2; \n\nfi;\np61: if\n::  atomic {i==0;read_0?v;}  goto p5; \n\n::  atomic {i==1;read_1?v;}  goto p5; \n\n::  atomic {i==2;read_2?v;}  goto p5; \n\n::  atomic {i==3;read_3?v;}  goto p5; \n\nfi;\nw2: if\n:: done_2?0; goto p61; \n\nfi;\np9: if\n::  atomic {v==1 && i==0;read_0?v;}  goto p9; \n\n::  atomic {v==1 && i==1;read_1?v;}  goto p9; \n\n::  atomic {v==1 && i==2;read_2?v;}  goto p9; \n\n::  atomic {v==1 && i==3;read_3?v;}  goto p9; \n\n::  d_step {v==0;i = i+1;}  goto p8; \n\nfi;\nCS: if\n:: write_2!0; goto w3; \n\nfi;\nw3: if\n:: done_2?0; goto NCS; \n\nfi;\n}\n\nactive proctype P_3() { \nbyte i=0;\nbyte v=0;\n\nNCS: if\n:: write_3!1; goto w1; \n\nfi;\nw1: if\n::  atomic {done_3?0;i = 0;}  goto p3; \n\nfi;\np3: if\n::  d_step {i==3;i = 3+1;}  goto p8; \n\n::  atomic {i==0;read_0?v;}  goto p4; \n\n::  atomic {i==1;read_1?v;}  goto p4; \n\n::  atomic {i==2;read_2?v;}  goto p4; \n\n::  atomic {i==3;read_3?v;}  goto p4; \n\nfi;\np8: if\n::  atomic {i==0;read_0?v;}  goto p9; \n\n::  atomic {i==1;read_1?v;}  goto p9; \n\n::  atomic {i==2;read_2?v;}  goto p9; \n\n::  atomic {i==3;read_3?v;}  goto p9; \n\n:: i==4; goto CS; \n\nfi;\np4: if\n::  d_step {v==0;i = i+1;}  goto p3; \n\n:: v==1; goto p5; \n\nfi;\np5: if\n:: v==1; goto p6; \n\n:: v==0; goto NCS; \n\nfi;\np6: if\n:: write_3!0; goto w2; \n\nfi;\np61: if\n::  atomic {i==0;read_0?v;}  goto p5; \n\n::  atomic {i==1;read_1?v;}  goto p5; \n\n::  atomic {i==2;read_2?v;}  goto p5; \n\n::  atomic {i==3;read_3?v;}  goto p5; \n\nfi;\nw2: if\n:: done_3?0; goto p61; \n\nfi;\np9: if\n::  atomic {v==1 && i==0;read_0?v;}  goto p9; \n\n::  atomic {v==1 && i==1;read_1?v;}  goto p9; \n\n::  atomic {v==1 && i==2;read_2?v;}  goto p9; \n\n::  atomic {v==1 && i==3;read_3?v;}  goto p9; \n\n::  d_step {v==0;i = i+1;}  goto p8; \n\nfi;\nCS: if\n:: write_3!0; goto w3; \n\nfi;\nw3: if\n:: done_3?0; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "A mutual exclusion algorithm. In this case, read and\n    write operations need not be atomic.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "chan read_0 =[0] of {int};\nchan write_0 =[0] of {int};\nchan done_0 =[0] of {int};\nchan read_1 =[0] of {int};\nchan write_1 =[0] of {int};\nchan done_1 =[0] of {int};\nchan read_2 =[0] of {int};\nchan write_2 =[0] of {int};\nchan done_2 =[0] of {int};\nchan read_3 =[0] of {int};\nchan write_3 =[0] of {int};\nchan done_3 =[0] of {int};\nchan read_4 =[0] of {int};\nchan write_4 =[0] of {int};\nchan done_4 =[0] of {int};\n\nactive proctype NonatomicVar_0() { \nbyte x=0;\nbyte v=0;\n\nq: if\n:: read_0!x; goto q; \n\n:: write_0?v; goto r; \n\nfi;\nr: if\n::  atomic {done_0!0;x = v;}  goto q; \n\n:: read_0!0; goto r; \n\n:: read_0!1; goto r; \n\nfi;\n}\n\nactive proctype NonatomicVar_1() { \nbyte x=0;\nbyte v=0;\n\nq: if\n:: read_1!x; goto q; \n\n:: write_1?v; goto r; \n\nfi;\nr: if\n::  atomic {done_1!0;x = v;}  goto q; \n\n:: read_1!0; goto r; \n\n:: read_1!1; goto r; \n\nfi;\n}\n\nactive proctype NonatomicVar_2() { \nbyte x=0;\nbyte v=0;\n\nq: if\n:: read_2!x; goto q; \n\n:: write_2?v; goto r; \n\nfi;\nr: if\n::  atomic {done_2!0;x = v;}  goto q; \n\n:: read_2!0; goto r; \n\n:: read_2!1; goto r; \n\nfi;\n}\n\nactive proctype NonatomicVar_3() { \nbyte x=0;\nbyte v=0;\n\nq: if\n:: read_3!x; goto q; \n\n:: write_3?v; goto r; \n\nfi;\nr: if\n::  atomic {done_3!0;x = v;}  goto q; \n\n:: read_3!0; goto r; \n\n:: read_3!1; goto r; \n\nfi;\n}\n\nactive proctype NonatomicVar_4() { \nbyte x=0;\nbyte v=0;\n\nq: if\n:: read_4!x; goto q; \n\n:: write_4?v; goto r; \n\nfi;\nr: if\n::  atomic {done_4!0;x = v;}  goto q; \n\n:: read_4!0; goto r; \n\n:: read_4!1; goto r; \n\nfi;\n}\n\nactive proctype P_0() { \nbyte i=0;\nbyte v=0;\n\nNCS: if\n:: write_0!1; goto w1; \n\nfi;\nw1: if\n::  atomic {done_0?0;i = 0;}  goto p3; \n\nfi;\np3: if\n::  d_step {i==0;i = 0+1;}  goto p8; \n\n::  atomic {i==0;read_0?v;}  goto p4; \n\n::  atomic {i==1;read_1?v;}  goto p4; \n\n::  atomic {i==2;read_2?v;}  goto p4; \n\n::  atomic {i==3;read_3?v;}  goto p4; \n\n::  atomic {i==4;read_4?v;}  goto p4; \n\nfi;\np8: if\n::  atomic {i==0;read_0?v;}  goto p9; \n\n::  atomic {i==1;read_1?v;}  goto p9; \n\n::  atomic {i==2;read_2?v;}  goto p9; \n\n::  atomic {i==3;read_3?v;}  goto p9; \n\n::  atomic {i==4;read_4?v;}  goto p9; \n\n:: i==5; goto CS; \n\nfi;\np4: if\n::  d_step {v==0;i = i+1;}  goto p3; \n\n:: v==1; goto p5; \n\nfi;\np5: if\n:: v==1; goto p6; \n\n:: v==0; goto NCS; \n\nfi;\np6: if\n:: write_0!0; goto w2; \n\nfi;\np61: if\n::  atomic {i==0;read_0?v;}  goto p5; \n\n::  atomic {i==1;read_1?v;}  goto p5; \n\n::  atomic {i==2;read_2?v;}  goto p5; \n\n::  atomic {i==3;read_3?v;}  goto p5; \n\n::  atomic {i==4;read_4?v;}  goto p5; \n\nfi;\nw2: if\n:: done_0?0; goto p61; \n\nfi;\np9: if\n::  atomic {v==1 && i==0;read_0?v;}  goto p9; \n\n::  atomic {v==1 && i==1;read_1?v;}  goto p9; \n\n::  atomic {v==1 && i==2;read_2?v;}  goto p9; \n\n::  atomic {v==1 && i==3;read_3?v;}  goto p9; \n\n::  atomic {v==1 && i==4;read_4?v;}  goto p9; \n\n::  d_step {v==0;i = i+1;}  goto p8; \n\nfi;\nCS: if\n:: write_0!0; goto w3; \n\nfi;\nw3: if\n:: done_0?0; goto NCS; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte i=0;\nbyte v=0;\n\nNCS: if\n:: write_1!1; goto w1; \n\nfi;\nw1: if\n::  atomic {done_1?0;i = 0;}  goto p3; \n\nfi;\np3: if\n::  d_step {i==1;i = 1+1;}  goto p8; \n\n::  atomic {i==0;read_0?v;}  goto p4; \n\n::  atomic {i==1;read_1?v;}  goto p4; \n\n::  atomic {i==2;read_2?v;}  goto p4; \n\n::  atomic {i==3;read_3?v;}  goto p4; \n\n::  atomic {i==4;read_4?v;}  goto p4; \n\nfi;\np8: if\n::  atomic {i==0;read_0?v;}  goto p9; \n\n::  atomic {i==1;read_1?v;}  goto p9; \n\n::  atomic {i==2;read_2?v;}  goto p9; \n\n::  atomic {i==3;read_3?v;}  goto p9; \n\n::  atomic {i==4;read_4?v;}  goto p9; \n\n:: i==5; goto CS; \n\nfi;\np4: if\n::  d_step {v==0;i = i+1;}  goto p3; \n\n:: v==1; goto p5; \n\nfi;\np5: if\n:: v==1; goto p6; \n\n:: v==0; goto NCS; \n\nfi;\np6: if\n:: write_1!0; goto w2; \n\nfi;\np61: if\n::  atomic {i==0;read_0?v;}  goto p5; \n\n::  atomic {i==1;read_1?v;}  goto p5; \n\n::  atomic {i==2;read_2?v;}  goto p5; \n\n::  atomic {i==3;read_3?v;}  goto p5; \n\n::  atomic {i==4;read_4?v;}  goto p5; \n\nfi;\nw2: if\n:: done_1?0; goto p61; \n\nfi;\np9: if\n::  atomic {v==1 && i==0;read_0?v;}  goto p9; \n\n::  atomic {v==1 && i==1;read_1?v;}  goto p9; \n\n::  atomic {v==1 && i==2;read_2?v;}  goto p9; \n\n::  atomic {v==1 && i==3;read_3?v;}  goto p9; \n\n::  atomic {v==1 && i==4;read_4?v;}  goto p9; \n\n::  d_step {v==0;i = i+1;}  goto p8; \n\nfi;\nCS: if\n:: write_1!0; goto w3; \n\nfi;\nw3: if\n:: done_1?0; goto NCS; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte i=0;\nbyte v=0;\n\nNCS: if\n:: write_2!1; goto w1; \n\nfi;\nw1: if\n::  atomic {done_2?0;i = 0;}  goto p3; \n\nfi;\np3: if\n::  d_step {i==2;i = 2+1;}  goto p8; \n\n::  atomic {i==0;read_0?v;}  goto p4; \n\n::  atomic {i==1;read_1?v;}  goto p4; \n\n::  atomic {i==2;read_2?v;}  goto p4; \n\n::  atomic {i==3;read_3?v;}  goto p4; \n\n::  atomic {i==4;read_4?v;}  goto p4; \n\nfi;\np8: if\n::  atomic {i==0;read_0?v;}  goto p9; \n\n::  atomic {i==1;read_1?v;}  goto p9; \n\n::  atomic {i==2;read_2?v;}  goto p9; \n\n::  atomic {i==3;read_3?v;}  goto p9; \n\n::  atomic {i==4;read_4?v;}  goto p9; \n\n:: i==5; goto CS; \n\nfi;\np4: if\n::  d_step {v==0;i = i+1;}  goto p3; \n\n:: v==1; goto p5; \n\nfi;\np5: if\n:: v==1; goto p6; \n\n:: v==0; goto NCS; \n\nfi;\np6: if\n:: write_2!0; goto w2; \n\nfi;\np61: if\n::  atomic {i==0;read_0?v;}  goto p5; \n\n::  atomic {i==1;read_1?v;}  goto p5; \n\n::  atomic {i==2;read_2?v;}  goto p5; \n\n::  atomic {i==3;read_3?v;}  goto p5; \n\n::  atomic {i==4;read_4?v;}  goto p5; \n\nfi;\nw2: if\n:: done_2?0; goto p61; \n\nfi;\np9: if\n::  atomic {v==1 && i==0;read_0?v;}  goto p9; \n\n::  atomic {v==1 && i==1;read_1?v;}  goto p9; \n\n::  atomic {v==1 && i==2;read_2?v;}  goto p9; \n\n::  atomic {v==1 && i==3;read_3?v;}  goto p9; \n\n::  atomic {v==1 && i==4;read_4?v;}  goto p9; \n\n::  d_step {v==0;i = i+1;}  goto p8; \n\nfi;\nCS: if\n:: write_2!0; goto w3; \n\nfi;\nw3: if\n:: done_2?0; goto NCS; \n\nfi;\n}\n\nactive proctype P_3() { \nbyte i=0;\nbyte v=0;\n\nNCS: if\n:: write_3!1; goto w1; \n\nfi;\nw1: if\n::  atomic {done_3?0;i = 0;}  goto p3; \n\nfi;\np3: if\n::  d_step {i==3;i = 3+1;}  goto p8; \n\n::  atomic {i==0;read_0?v;}  goto p4; \n\n::  atomic {i==1;read_1?v;}  goto p4; \n\n::  atomic {i==2;read_2?v;}  goto p4; \n\n::  atomic {i==3;read_3?v;}  goto p4; \n\n::  atomic {i==4;read_4?v;}  goto p4; \n\nfi;\np8: if\n::  atomic {i==0;read_0?v;}  goto p9; \n\n::  atomic {i==1;read_1?v;}  goto p9; \n\n::  atomic {i==2;read_2?v;}  goto p9; \n\n::  atomic {i==3;read_3?v;}  goto p9; \n\n::  atomic {i==4;read_4?v;}  goto p9; \n\n:: i==5; goto CS; \n\nfi;\np4: if\n::  d_step {v==0;i = i+1;}  goto p3; \n\n:: v==1; goto p5; \n\nfi;\np5: if\n:: v==1; goto p6; \n\n:: v==0; goto NCS; \n\nfi;\np6: if\n:: write_3!0; goto w2; \n\nfi;\np61: if\n::  atomic {i==0;read_0?v;}  goto p5; \n\n::  atomic {i==1;read_1?v;}  goto p5; \n\n::  atomic {i==2;read_2?v;}  goto p5; \n\n::  atomic {i==3;read_3?v;}  goto p5; \n\n::  atomic {i==4;read_4?v;}  goto p5; \n\nfi;\nw2: if\n:: done_3?0; goto p61; \n\nfi;\np9: if\n::  atomic {v==1 && i==0;read_0?v;}  goto p9; \n\n::  atomic {v==1 && i==1;read_1?v;}  goto p9; \n\n::  atomic {v==1 && i==2;read_2?v;}  goto p9; \n\n::  atomic {v==1 && i==3;read_3?v;}  goto p9; \n\n::  atomic {v==1 && i==4;read_4?v;}  goto p9; \n\n::  d_step {v==0;i = i+1;}  goto p8; \n\nfi;\nCS: if\n:: write_3!0; goto w3; \n\nfi;\nw3: if\n:: done_3?0; goto NCS; \n\nfi;\n}\n\nactive proctype P_4() { \nbyte i=0;\nbyte v=0;\n\nNCS: if\n:: write_4!1; goto w1; \n\nfi;\nw1: if\n::  atomic {done_4?0;i = 0;}  goto p3; \n\nfi;\np3: if\n::  d_step {i==4;i = 4+1;}  goto p8; \n\n::  atomic {i==0;read_0?v;}  goto p4; \n\n::  atomic {i==1;read_1?v;}  goto p4; \n\n::  atomic {i==2;read_2?v;}  goto p4; \n\n::  atomic {i==3;read_3?v;}  goto p4; \n\n::  atomic {i==4;read_4?v;}  goto p4; \n\nfi;\np8: if\n::  atomic {i==0;read_0?v;}  goto p9; \n\n::  atomic {i==1;read_1?v;}  goto p9; \n\n::  atomic {i==2;read_2?v;}  goto p9; \n\n::  atomic {i==3;read_3?v;}  goto p9; \n\n::  atomic {i==4;read_4?v;}  goto p9; \n\n:: i==5; goto CS; \n\nfi;\np4: if\n::  d_step {v==0;i = i+1;}  goto p3; \n\n:: v==1; goto p5; \n\nfi;\np5: if\n:: v==1; goto p6; \n\n:: v==0; goto NCS; \n\nfi;\np6: if\n:: write_4!0; goto w2; \n\nfi;\np61: if\n::  atomic {i==0;read_0?v;}  goto p5; \n\n::  atomic {i==1;read_1?v;}  goto p5; \n\n::  atomic {i==2;read_2?v;}  goto p5; \n\n::  atomic {i==3;read_3?v;}  goto p5; \n\n::  atomic {i==4;read_4?v;}  goto p5; \n\nfi;\nw2: if\n:: done_4?0; goto p61; \n\nfi;\np9: if\n::  atomic {v==1 && i==0;read_0?v;}  goto p9; \n\n::  atomic {v==1 && i==1;read_1?v;}  goto p9; \n\n::  atomic {v==1 && i==2;read_2?v;}  goto p9; \n\n::  atomic {v==1 && i==3;read_3?v;}  goto p9; \n\n::  atomic {v==1 && i==4;read_4?v;}  goto p9; \n\n::  d_step {v==0;i = i+1;}  goto p8; \n\nfi;\nCS: if\n:: write_4!0; goto w3; \n\nfi;\nw3: if\n:: done_4?0; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "N nodes are connected by a token ring. The token is used\n    to guarantee mutual exclusion access to shared resource. The communications\n    link are unreliable, i.e., token can get lost. The leader election\n    algorithm is used for sending of a new token after the timeout.\n\nParameters:\n\n\n\n\n\nAtomic propositions:\n, , \n\nProperties to verify:"}, {"role": "assistant", "content": "chan link_0_in =[0] of {int};\nchan link_0_out =[0] of {int};\nchan link_1_in =[0] of {int};\nchan link_1_out =[0] of {int};\nchan link_2_in =[0] of {int};\nchan link_2_out =[0] of {int};\n\nactive proctype P_0() { \nbyte status=0;\nbyte v=0;\n\nCS: if\n::  atomic {link_1_in!255;status = 0;}  goto wait; \n\nfi;\nwait: if\n:: link_0_out?v; goto got_msg; \n\n::  atomic {status==0;link_1_in!24;status = 1;}  goto wait; \n\nfi;\ngot_msg: if\n:: v==255; goto CS; \n\n::  atomic {v!=255 && v>24;link_1_in!v;}  goto wait; \n\n::  atomic {v!=255 && status==1 && v<24;link_1_in!v;status = 2;}  goto wait; \n\n::  atomic {v!=255 && status==0 && v<24;link_1_in!v;}  goto wait; \n\n::  d_step {v!=255 && v==24 && status!=1;status = 0;}  goto wait; \n\n:: v!=255 && v==24 && status==1; goto CS; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte status=0;\nbyte v=0;\n\nwait: if\n:: link_1_out?v; goto got_msg; \n\n::  atomic {status==0;link_2_in!14;status = 1;}  goto wait; \n\nfi;\nCS: if\n::  atomic {link_2_in!255;status = 0;}  goto wait; \n\nfi;\ngot_msg: if\n:: v==255; goto CS; \n\n::  atomic {v!=255 && v>14;link_2_in!v;}  goto wait; \n\n::  atomic {v!=255 && status==1 && v<14;link_2_in!v;status = 2;}  goto wait; \n\n::  atomic {v!=255 && status==0 && v<14;link_2_in!v;}  goto wait; \n\n::  d_step {v!=255 && v==14 && status!=1;status = 0;}  goto wait; \n\n:: v!=255 && v==14 && status==1; goto CS; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte status=0;\nbyte v=0;\n\nwait: if\n:: link_2_out?v; goto got_msg; \n\n::  atomic {status==0;link_0_in!6;status = 1;}  goto wait; \n\nfi;\nCS: if\n::  atomic {link_0_in!255;status = 0;}  goto wait; \n\nfi;\ngot_msg: if\n:: v==255; goto CS; \n\n::  atomic {v!=255 && v>6;link_0_in!v;}  goto wait; \n\n::  atomic {v!=255 && status==1 && v<6;link_0_in!v;status = 2;}  goto wait; \n\n::  atomic {v!=255 && status==0 && v<6;link_0_in!v;}  goto wait; \n\n::  d_step {v!=255 && v==6 && status!=1;status = 0;}  goto wait; \n\n:: v!=255 && v==6 && status==1; goto CS; \n\nfi;\n}\n\nactive proctype chnlnel_link_0() { \nbyte v=0;\n\nready: if\n:: link_0_in?v; goto tr; \n\nfi;\ntr: if\n:: link_0_out!v; goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_link_1() { \nbyte v=0;\n\nready: if\n:: link_1_in?v; goto tr; \n\nfi;\ntr: if\n:: link_1_out!v; goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_link_2() { \nbyte v=0;\n\nready: if\n:: link_2_in?v; goto tr; \n\nfi;\ntr: if\n:: link_2_out!v; goto ready; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "N nodes are connected by a token ring. The token is used\n    to guarantee mutual exclusion access to shared resource. The communications\n    link are unreliable, i.e., token can get lost. The leader election\n    algorithm is used for sending of a new token after the timeout.\n\nParameters:\n\n\n\n\n\nAtomic propositions:\n, , \n\nProperties to verify:"}, {"role": "assistant", "content": "chan link_0_in =[0] of {int};\nchan link_0_out =[0] of {int};\nchan link_1_in =[0] of {int};\nchan link_1_out =[0] of {int};\nchan link_2_in =[0] of {int};\nchan link_2_out =[0] of {int};\nchan link_3_in =[0] of {int};\nchan link_3_out =[0] of {int};\n\nactive proctype P_0() { \nbyte status=0;\nbyte v=0;\nbyte sended=0;\n\nCS: if\n::  atomic {link_1_in!255;status = 0;}  goto wait; \n\nfi;\nwait: if\n:: link_0_out?v; goto got_msg; \n\n::  atomic {status==0 && sended==0;link_1_in!24;status = 1;sended = 1;}  goto wait; \n\nfi;\ngot_msg: if\n:: v==255; goto CS; \n\n:: v!=255 && v>24; goto wait; \n\n::  atomic {v!=255 && status==1 && v<24;link_1_in!v;status = 2;}  goto wait; \n\n::  atomic {v!=255 && status==0 && v<24;link_1_in!v;}  goto wait; \n\n::  d_step {v!=255 && v==24 && status!=1;status = 0;sended = 0;}  goto wait; \n\n::  d_step {v!=255 && v==24 && status==1;sended = 0;}  goto CS; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte status=0;\nbyte v=0;\nbyte sended=0;\n\nwait: if\n:: link_1_out?v; goto got_msg; \n\n::  atomic {status==0 && sended==0;link_2_in!14;status = 1;sended = 1;}  goto wait; \n\nfi;\nCS: if\n::  atomic {link_2_in!255;status = 0;}  goto wait; \n\nfi;\ngot_msg: if\n:: v==255; goto CS; \n\n:: v!=255 && v>14; goto wait; \n\n::  atomic {v!=255 && status==1 && v<14;link_2_in!v;status = 2;}  goto wait; \n\n::  atomic {v!=255 && status==0 && v<14;link_2_in!v;}  goto wait; \n\n::  d_step {v!=255 && v==14 && status!=1;status = 0;sended = 0;}  goto wait; \n\n::  d_step {v!=255 && v==14 && status==1;sended = 0;}  goto CS; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte status=0;\nbyte v=0;\nbyte sended=0;\n\nwait: if\n:: link_2_out?v; goto got_msg; \n\n::  atomic {status==0 && sended==0;link_3_in!6;status = 1;sended = 1;}  goto wait; \n\nfi;\nCS: if\n::  atomic {link_3_in!255;status = 0;}  goto wait; \n\nfi;\ngot_msg: if\n:: v==255; goto CS; \n\n:: v!=255 && v>6; goto wait; \n\n::  atomic {v!=255 && status==1 && v<6;link_3_in!v;status = 2;}  goto wait; \n\n::  atomic {v!=255 && status==0 && v<6;link_3_in!v;}  goto wait; \n\n::  d_step {v!=255 && v==6 && status!=1;status = 0;sended = 0;}  goto wait; \n\n::  d_step {v!=255 && v==6 && status==1;sended = 0;}  goto CS; \n\nfi;\n}\n\nactive proctype P_3() { \nbyte status=0;\nbyte v=0;\nbyte sended=0;\n\nwait: if\n:: link_3_out?v; goto got_msg; \n\n::  atomic {status==0 && sended==0;link_0_in!0;status = 1;sended = 1;}  goto wait; \n\nfi;\nCS: if\n::  atomic {link_0_in!255;status = 0;}  goto wait; \n\nfi;\ngot_msg: if\n:: v==255; goto CS; \n\n:: v!=255 && v>0; goto wait; \n\n::  atomic {v!=255 && status==1 && v<0;link_0_in!v;status = 2;}  goto wait; \n\n::  atomic {v!=255 && status==0 && v<0;link_0_in!v;}  goto wait; \n\n::  d_step {v!=255 && v==0 && status!=1;status = 0;sended = 0;}  goto wait; \n\n::  d_step {v!=255 && v==0 && status==1;sended = 0;}  goto CS; \n\nfi;\n}\n\nactive proctype chnlnel_link_0() { \nbyte v=0;\n\nready: if\n:: link_0_in?v; goto tr; \n\nfi;\ntr: if\n:: link_0_out!v; goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_link_1() { \nbyte v=0;\n\nready: if\n:: link_1_in?v; goto tr; \n\nfi;\ntr: if\n:: link_1_out!v; goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_link_2() { \nbyte v=0;\n\nready: if\n:: link_2_in?v; goto tr; \n\nfi;\ntr: if\n:: link_2_out!v; goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_link_3() { \nbyte v=0;\n\nready: if\n:: link_3_in?v; goto tr; \n\nfi;\ntr: if\n:: link_3_out!v; goto ready; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "N nodes are connected by a token ring. The token is used\n    to guarantee mutual exclusion access to shared resource. The communications\n    link are unreliable, i.e., token can get lost. The leader election\n    algorithm is used for sending of a new token after the timeout.\n\nParameters:\n\n\n\n\n\nAtomic propositions:\n, , \n\nProperties to verify:"}, {"role": "assistant", "content": "chan link_0_in =[0] of {int};\nchan link_0_out =[0] of {int};\nchan link_1_in =[0] of {int};\nchan link_1_out =[0] of {int};\nchan link_2_in =[0] of {int};\nchan link_2_out =[0] of {int};\nchan link_3_in =[0] of {int};\nchan link_3_out =[0] of {int};\n\nactive proctype P_0() { \nbyte status=0;\nbyte v=0;\n\nCS: if\n::  atomic {link_1_in!255;status = 0;}  goto wait; \n\nfi;\nwait: if\n:: link_0_out?v; goto got_msg; \n\n::  atomic {status==0;link_1_in!24;status = 1;}  goto wait; \n\nfi;\ngot_msg: if\n:: v==255; goto CS; \n\n:: v!=255 && v>24; goto wait; \n\n::  atomic {v!=255 && status==1 && v<24;link_1_in!v;status = 2;}  goto wait; \n\n::  atomic {v!=255 && status==0 && v<24;link_1_in!v;}  goto wait; \n\n::  d_step {v!=255 && v==24 && status!=1;status = 0;}  goto wait; \n\n:: v!=255 && v==24 && status==1; goto CS; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte status=0;\nbyte v=0;\n\nwait: if\n:: link_1_out?v; goto got_msg; \n\n::  atomic {status==0;link_2_in!14;status = 1;}  goto wait; \n\nfi;\nCS: if\n::  atomic {link_2_in!255;status = 0;}  goto wait; \n\nfi;\ngot_msg: if\n:: v==255; goto CS; \n\n:: v!=255 && v>14; goto wait; \n\n::  atomic {v!=255 && status==1 && v<14;link_2_in!v;status = 2;}  goto wait; \n\n::  atomic {v!=255 && status==0 && v<14;link_2_in!v;}  goto wait; \n\n::  d_step {v!=255 && v==14 && status!=1;status = 0;}  goto wait; \n\n:: v!=255 && v==14 && status==1; goto CS; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte status=0;\nbyte v=0;\n\nwait: if\n:: link_2_out?v; goto got_msg; \n\n::  atomic {status==0;link_3_in!6;status = 1;}  goto wait; \n\nfi;\nCS: if\n::  atomic {link_3_in!255;status = 0;}  goto wait; \n\nfi;\ngot_msg: if\n:: v==255; goto CS; \n\n:: v!=255 && v>6; goto wait; \n\n::  atomic {v!=255 && status==1 && v<6;link_3_in!v;status = 2;}  goto wait; \n\n::  atomic {v!=255 && status==0 && v<6;link_3_in!v;}  goto wait; \n\n::  d_step {v!=255 && v==6 && status!=1;status = 0;}  goto wait; \n\n:: v!=255 && v==6 && status==1; goto CS; \n\nfi;\n}\n\nactive proctype P_3() { \nbyte status=0;\nbyte v=0;\n\nwait: if\n:: link_3_out?v; goto got_msg; \n\n::  atomic {status==0;link_0_in!0;status = 1;}  goto wait; \n\nfi;\nCS: if\n::  atomic {link_0_in!255;status = 0;}  goto wait; \n\nfi;\ngot_msg: if\n:: v==255; goto CS; \n\n:: v!=255 && v>0; goto wait; \n\n::  atomic {v!=255 && status==1 && v<0;link_0_in!v;status = 2;}  goto wait; \n\n::  atomic {v!=255 && status==0 && v<0;link_0_in!v;}  goto wait; \n\n::  d_step {v!=255 && v==0 && status!=1;status = 0;}  goto wait; \n\n:: v!=255 && v==0 && status==1; goto CS; \n\nfi;\n}\n\nactive proctype chnlnel_link_0() { \nbyte v=0;\n\nready: if\n:: link_0_in?v; goto tr; \n\nfi;\ntr: if\n::  goto ready; \n\n:: link_0_out!v; goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_link_1() { \nbyte v=0;\n\nready: if\n:: link_1_in?v; goto tr; \n\nfi;\ntr: if\n::  goto ready; \n\n:: link_1_out!v; goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_link_2() { \nbyte v=0;\n\nready: if\n:: link_2_in?v; goto tr; \n\nfi;\ntr: if\n::  goto ready; \n\n:: link_2_out!v; goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_link_3() { \nbyte v=0;\n\nready: if\n:: link_3_in?v; goto tr; \n\nfi;\ntr: if\n::  goto ready; \n\n:: link_3_out!v; goto ready; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "N nodes are connected by a token ring. The token is used\n    to guarantee mutual exclusion access to shared resource. The communications\n    link are unreliable, i.e., token can get lost. The leader election\n    algorithm is used for sending of a new token after the timeout.\n\nParameters:\n\n\n\n\n\nAtomic propositions:\n, , \n\nProperties to verify:"}, {"role": "assistant", "content": "chan link_0_in =[0] of {int};\nchan link_0_out =[0] of {int};\nchan link_1_in =[0] of {int};\nchan link_1_out =[0] of {int};\nchan link_2_in =[0] of {int};\nchan link_2_out =[0] of {int};\nchan link_3_in =[0] of {int};\nchan link_3_out =[0] of {int};\nchan link_4_in =[0] of {int};\nchan link_4_out =[0] of {int};\n\nactive proctype P_0() { \nbyte status=0;\nbyte v=0;\nbyte sended=0;\n\nCS: if\n::  atomic {link_1_in!255;status = 0;}  goto wait; \n\nfi;\nwait: if\n:: link_0_out?v; goto got_msg; \n\n::  atomic {status==0 && sended==0;link_1_in!24;status = 1;sended = 1;}  goto wait; \n\nfi;\ngot_msg: if\n:: v==255; goto CS; \n\n::  atomic {v!=255 && v>24;link_1_in!v;}  goto wait; \n\n::  atomic {v!=255 && status==1 && v<24;link_1_in!v;status = 2;}  goto wait; \n\n::  atomic {v!=255 && status==0 && v<24;link_1_in!v;}  goto wait; \n\n::  d_step {v!=255 && v==24 && status!=1;status = 0;sended = 0;}  goto wait; \n\n::  d_step {v!=255 && v==24 && status==1;sended = 0;}  goto CS; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte status=0;\nbyte v=0;\nbyte sended=0;\n\nwait: if\n:: link_1_out?v; goto got_msg; \n\n::  atomic {status==0 && sended==0;link_2_in!14;status = 1;sended = 1;}  goto wait; \n\nfi;\nCS: if\n::  atomic {link_2_in!255;status = 0;}  goto wait; \n\nfi;\ngot_msg: if\n:: v==255; goto CS; \n\n::  atomic {v!=255 && v>14;link_2_in!v;}  goto wait; \n\n::  atomic {v!=255 && status==1 && v<14;link_2_in!v;status = 2;}  goto wait; \n\n::  atomic {v!=255 && status==0 && v<14;link_2_in!v;}  goto wait; \n\n::  d_step {v!=255 && v==14 && status!=1;status = 0;sended = 0;}  goto wait; \n\n::  d_step {v!=255 && v==14 && status==1;sended = 0;}  goto CS; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte status=0;\nbyte v=0;\nbyte sended=0;\n\nwait: if\n:: link_2_out?v; goto got_msg; \n\n::  atomic {status==0 && sended==0;link_3_in!6;status = 1;sended = 1;}  goto wait; \n\nfi;\nCS: if\n::  atomic {link_3_in!255;status = 0;}  goto wait; \n\nfi;\ngot_msg: if\n:: v==255; goto CS; \n\n::  atomic {v!=255 && v>6;link_3_in!v;}  goto wait; \n\n::  atomic {v!=255 && status==1 && v<6;link_3_in!v;status = 2;}  goto wait; \n\n::  atomic {v!=255 && status==0 && v<6;link_3_in!v;}  goto wait; \n\n::  d_step {v!=255 && v==6 && status!=1;status = 0;sended = 0;}  goto wait; \n\n::  d_step {v!=255 && v==6 && status==1;sended = 0;}  goto CS; \n\nfi;\n}\n\nactive proctype P_3() { \nbyte status=0;\nbyte v=0;\nbyte sended=0;\n\nwait: if\n:: link_3_out?v; goto got_msg; \n\n::  atomic {status==0 && sended==0;link_4_in!0;status = 1;sended = 1;}  goto wait; \n\nfi;\nCS: if\n::  atomic {link_4_in!255;status = 0;}  goto wait; \n\nfi;\ngot_msg: if\n:: v==255; goto CS; \n\n::  atomic {v!=255 && v>0;link_4_in!v;}  goto wait; \n\n::  atomic {v!=255 && status==1 && v<0;link_4_in!v;status = 2;}  goto wait; \n\n::  atomic {v!=255 && status==0 && v<0;link_4_in!v;}  goto wait; \n\n::  d_step {v!=255 && v==0 && status!=1;status = 0;sended = 0;}  goto wait; \n\n::  d_step {v!=255 && v==0 && status==1;sended = 0;}  goto CS; \n\nfi;\n}\n\nactive proctype P_4() { \nbyte status=0;\nbyte v=0;\nbyte sended=0;\n\nwait: if\n:: link_4_out?v; goto got_msg; \n\n::  atomic {status==0 && sended==0;link_0_in!23;status = 1;sended = 1;}  goto wait; \n\nfi;\nCS: if\n::  atomic {link_0_in!255;status = 0;}  goto wait; \n\nfi;\ngot_msg: if\n:: v==255; goto CS; \n\n::  atomic {v!=255 && v>23;link_0_in!v;}  goto wait; \n\n::  atomic {v!=255 && status==1 && v<23;link_0_in!v;status = 2;}  goto wait; \n\n::  atomic {v!=255 && status==0 && v<23;link_0_in!v;}  goto wait; \n\n::  d_step {v!=255 && v==23 && status!=1;status = 0;sended = 0;}  goto wait; \n\n::  d_step {v!=255 && v==23 && status==1;sended = 0;}  goto CS; \n\nfi;\n}\n\nactive proctype chnlnel_link_0() { \nbyte v=0;\n\nready: if\n:: link_0_in?v; goto tr; \n\nfi;\ntr: if\n:: link_0_out!v; goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_link_1() { \nbyte v=0;\n\nready: if\n:: link_1_in?v; goto tr; \n\nfi;\ntr: if\n:: link_1_out!v; goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_link_2() { \nbyte v=0;\n\nready: if\n:: link_2_in?v; goto tr; \n\nfi;\ntr: if\n:: link_2_out!v; goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_link_3() { \nbyte v=0;\n\nready: if\n:: link_3_in?v; goto tr; \n\nfi;\ntr: if\n:: link_3_out!v; goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_link_4() { \nbyte v=0;\n\nready: if\n:: link_4_in?v; goto tr; \n\nfi;\ntr: if\n:: link_4_out!v; goto ready; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "N nodes are connected by a token ring. The token is used\n    to guarantee mutual exclusion access to shared resource. The communications\n    link are unreliable, i.e., token can get lost. The leader election\n    algorithm is used for sending of a new token after the timeout.\n\nParameters:\n\n\n\n\n\nAtomic propositions:\n, , \n\nProperties to verify:"}, {"role": "assistant", "content": "chan link_0_in =[0] of {int};\nchan link_0_out =[0] of {int};\nchan link_1_in =[0] of {int};\nchan link_1_out =[0] of {int};\nchan link_2_in =[0] of {int};\nchan link_2_out =[0] of {int};\nchan link_3_in =[0] of {int};\nchan link_3_out =[0] of {int};\nchan link_4_in =[0] of {int};\nchan link_4_out =[0] of {int};\nchan link_5_in =[0] of {int};\nchan link_5_out =[0] of {int};\n\nactive proctype P_0() { \nbyte status=0;\nbyte v=0;\nbyte sended=0;\n\nCS: if\n::  atomic {link_1_in!255;status = 0;}  goto wait; \n\nfi;\nwait: if\n:: link_0_out?v; goto got_msg; \n\n::  atomic {status==0 && sended==0;link_1_in!24;status = 1;sended = 1;}  goto wait; \n\nfi;\ngot_msg: if\n:: v==255; goto CS; \n\n:: v!=255 && v>24; goto wait; \n\n::  atomic {v!=255 && status==1 && v<24;link_1_in!v;status = 2;}  goto wait; \n\n::  atomic {v!=255 && status==0 && v<24;link_1_in!v;}  goto wait; \n\n::  d_step {v!=255 && v==24 && status!=1;status = 0;sended = 0;}  goto wait; \n\n::  d_step {v!=255 && v==24 && status==1;sended = 0;}  goto CS; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte status=0;\nbyte v=0;\nbyte sended=0;\n\nwait: if\n:: link_1_out?v; goto got_msg; \n\n::  atomic {status==0 && sended==0;link_2_in!14;status = 1;sended = 1;}  goto wait; \n\nfi;\nCS: if\n::  atomic {link_2_in!255;status = 0;}  goto wait; \n\nfi;\ngot_msg: if\n:: v==255; goto CS; \n\n:: v!=255 && v>14; goto wait; \n\n::  atomic {v!=255 && status==1 && v<14;link_2_in!v;status = 2;}  goto wait; \n\n::  atomic {v!=255 && status==0 && v<14;link_2_in!v;}  goto wait; \n\n::  d_step {v!=255 && v==14 && status!=1;status = 0;sended = 0;}  goto wait; \n\n::  d_step {v!=255 && v==14 && status==1;sended = 0;}  goto CS; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte status=0;\nbyte v=0;\nbyte sended=0;\n\nwait: if\n:: link_2_out?v; goto got_msg; \n\n::  atomic {status==0 && sended==0;link_3_in!6;status = 1;sended = 1;}  goto wait; \n\nfi;\nCS: if\n::  atomic {link_3_in!255;status = 0;}  goto wait; \n\nfi;\ngot_msg: if\n:: v==255; goto CS; \n\n:: v!=255 && v>6; goto wait; \n\n::  atomic {v!=255 && status==1 && v<6;link_3_in!v;status = 2;}  goto wait; \n\n::  atomic {v!=255 && status==0 && v<6;link_3_in!v;}  goto wait; \n\n::  d_step {v!=255 && v==6 && status!=1;status = 0;sended = 0;}  goto wait; \n\n::  d_step {v!=255 && v==6 && status==1;sended = 0;}  goto CS; \n\nfi;\n}\n\nactive proctype P_3() { \nbyte status=0;\nbyte v=0;\nbyte sended=0;\n\nwait: if\n:: link_3_out?v; goto got_msg; \n\n::  atomic {status==0 && sended==0;link_4_in!0;status = 1;sended = 1;}  goto wait; \n\nfi;\nCS: if\n::  atomic {link_4_in!255;status = 0;}  goto wait; \n\nfi;\ngot_msg: if\n:: v==255; goto CS; \n\n:: v!=255 && v>0; goto wait; \n\n::  atomic {v!=255 && status==1 && v<0;link_4_in!v;status = 2;}  goto wait; \n\n::  atomic {v!=255 && status==0 && v<0;link_4_in!v;}  goto wait; \n\n::  d_step {v!=255 && v==0 && status!=1;status = 0;sended = 0;}  goto wait; \n\n::  d_step {v!=255 && v==0 && status==1;sended = 0;}  goto CS; \n\nfi;\n}\n\nactive proctype P_4() { \nbyte status=0;\nbyte v=0;\nbyte sended=0;\n\nwait: if\n:: link_4_out?v; goto got_msg; \n\n::  atomic {status==0 && sended==0;link_5_in!23;status = 1;sended = 1;}  goto wait; \n\nfi;\nCS: if\n::  atomic {link_5_in!255;status = 0;}  goto wait; \n\nfi;\ngot_msg: if\n:: v==255; goto CS; \n\n:: v!=255 && v>23; goto wait; \n\n::  atomic {v!=255 && status==1 && v<23;link_5_in!v;status = 2;}  goto wait; \n\n::  atomic {v!=255 && status==0 && v<23;link_5_in!v;}  goto wait; \n\n::  d_step {v!=255 && v==23 && status!=1;status = 0;sended = 0;}  goto wait; \n\n::  d_step {v!=255 && v==23 && status==1;sended = 0;}  goto CS; \n\nfi;\n}\n\nactive proctype P_5() { \nbyte status=0;\nbyte v=0;\nbyte sended=0;\n\nwait: if\n:: link_5_out?v; goto got_msg; \n\n::  atomic {status==0 && sended==0;link_0_in!21;status = 1;sended = 1;}  goto wait; \n\nfi;\nCS: if\n::  atomic {link_0_in!255;status = 0;}  goto wait; \n\nfi;\ngot_msg: if\n:: v==255; goto CS; \n\n:: v!=255 && v>21; goto wait; \n\n::  atomic {v!=255 && status==1 && v<21;link_0_in!v;status = 2;}  goto wait; \n\n::  atomic {v!=255 && status==0 && v<21;link_0_in!v;}  goto wait; \n\n::  d_step {v!=255 && v==21 && status!=1;status = 0;sended = 0;}  goto wait; \n\n::  d_step {v!=255 && v==21 && status==1;sended = 0;}  goto CS; \n\nfi;\n}\n\nactive proctype chnlnel_link_0() { \nbyte v=0;\n\nready: if\n:: link_0_in?v; goto tr; \n\nfi;\ntr: if\n:: link_0_out!v; goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_link_1() { \nbyte v=0;\n\nready: if\n:: link_1_in?v; goto tr; \n\nfi;\ntr: if\n:: link_1_out!v; goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_link_2() { \nbyte v=0;\n\nready: if\n:: link_2_in?v; goto tr; \n\nfi;\ntr: if\n:: link_2_out!v; goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_link_3() { \nbyte v=0;\n\nready: if\n:: link_3_in?v; goto tr; \n\nfi;\ntr: if\n:: link_3_out!v; goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_link_4() { \nbyte v=0;\n\nready: if\n:: link_4_in?v; goto tr; \n\nfi;\ntr: if\n:: link_4_out!v; goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_link_5() { \nbyte v=0;\n\nready: if\n:: link_5_in?v; goto tr; \n\nfi;\ntr: if\n:: link_5_out!v; goto ready; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "N nodes are connected by a token ring. The token is used\n    to guarantee mutual exclusion access to shared resource. The communications\n    link are unreliable, i.e., token can get lost. The leader election\n    algorithm is used for sending of a new token after the timeout.\n\nParameters:\n\n\n\n\n\nAtomic propositions:\n, , \n\nProperties to verify:"}, {"role": "assistant", "content": "chan link_0_in =[0] of {int};\nchan link_0_out =[0] of {int};\nchan link_1_in =[0] of {int};\nchan link_1_out =[0] of {int};\nchan link_2_in =[0] of {int};\nchan link_2_out =[0] of {int};\nchan link_3_in =[0] of {int};\nchan link_3_out =[0] of {int};\n\nactive proctype P_0() { \nbyte status=0;\nbyte v=0;\n\nCS: if\n::  atomic {link_1_in!255;status = 0;}  goto wait; \n\nfi;\nwait: if\n:: link_0_out?v; goto got_msg; \n\n::  atomic {status==0;link_1_in!24;status = 1;}  goto wait; \n\nfi;\ngot_msg: if\n:: v==255; goto CS; \n\n::  atomic {v!=255 && v>24;link_1_in!v;}  goto wait; \n\n::  atomic {v!=255 && status==1 && v<24;link_1_in!v;status = 2;}  goto wait; \n\n::  atomic {v!=255 && status==0 && v<24;link_1_in!v;}  goto wait; \n\n::  d_step {v!=255 && v==24 && status!=1;status = 0;}  goto wait; \n\n:: v!=255 && v==24 && status==1; goto CS; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte status=0;\nbyte v=0;\n\nwait: if\n:: link_1_out?v; goto got_msg; \n\n::  atomic {status==0;link_2_in!14;status = 1;}  goto wait; \n\nfi;\nCS: if\n::  atomic {link_2_in!255;status = 0;}  goto wait; \n\nfi;\ngot_msg: if\n:: v==255; goto CS; \n\n::  atomic {v!=255 && v>14;link_2_in!v;}  goto wait; \n\n::  atomic {v!=255 && status==1 && v<14;link_2_in!v;status = 2;}  goto wait; \n\n::  atomic {v!=255 && status==0 && v<14;link_2_in!v;}  goto wait; \n\n::  d_step {v!=255 && v==14 && status!=1;status = 0;}  goto wait; \n\n:: v!=255 && v==14 && status==1; goto CS; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte status=0;\nbyte v=0;\n\nwait: if\n:: link_2_out?v; goto got_msg; \n\n::  atomic {status==0;link_3_in!6;status = 1;}  goto wait; \n\nfi;\nCS: if\n::  atomic {link_3_in!255;status = 0;}  goto wait; \n\nfi;\ngot_msg: if\n:: v==255; goto CS; \n\n::  atomic {v!=255 && v>6;link_3_in!v;}  goto wait; \n\n::  atomic {v!=255 && status==1 && v<6;link_3_in!v;status = 2;}  goto wait; \n\n::  atomic {v!=255 && status==0 && v<6;link_3_in!v;}  goto wait; \n\n::  d_step {v!=255 && v==6 && status!=1;status = 0;}  goto wait; \n\n:: v!=255 && v==6 && status==1; goto CS; \n\nfi;\n}\n\nactive proctype P_3() { \nbyte status=0;\nbyte v=0;\n\nwait: if\n:: link_3_out?v; goto got_msg; \n\n::  atomic {status==0;link_0_in!0;status = 1;}  goto wait; \n\nfi;\nCS: if\n::  atomic {link_0_in!255;status = 0;}  goto wait; \n\nfi;\ngot_msg: if\n:: v==255; goto CS; \n\n::  atomic {v!=255 && v>0;link_0_in!v;}  goto wait; \n\n::  atomic {v!=255 && status==1 && v<0;link_0_in!v;status = 2;}  goto wait; \n\n::  atomic {v!=255 && status==0 && v<0;link_0_in!v;}  goto wait; \n\n::  d_step {v!=255 && v==0 && status!=1;status = 0;}  goto wait; \n\n:: v!=255 && v==0 && status==1; goto CS; \n\nfi;\n}\n\nactive proctype chnlnel_link_0() { \nbyte v=0;\n\nready: if\n:: link_0_in?v; goto tr; \n\nfi;\ntr: if\n::  goto ready; \n\n:: link_0_out!v; goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_link_1() { \nbyte v=0;\n\nready: if\n:: link_1_in?v; goto tr; \n\nfi;\ntr: if\n::  goto ready; \n\n:: link_1_out!v; goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_link_2() { \nbyte v=0;\n\nready: if\n:: link_2_in?v; goto tr; \n\nfi;\ntr: if\n::  goto ready; \n\n:: link_2_out!v; goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_link_3() { \nbyte v=0;\n\nready: if\n:: link_3_in?v; goto tr; \n\nfi;\ntr: if\n::  goto ready; \n\n:: link_3_out!v; goto ready; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "N nodes are connected by a token ring. The token is used\n    to guarantee mutual exclusion access to shared resource. The communications\n    link are unreliable, i.e., token can get lost. The leader election\n    algorithm is used for sending of a new token after the timeout.\n\nParameters:\n\n\n\n\n\nAtomic propositions:\n, , \n\nProperties to verify:"}, {"role": "assistant", "content": "chan link_0_in =[0] of {int};\nchan link_0_out =[0] of {int};\nchan link_1_in =[0] of {int};\nchan link_1_out =[0] of {int};\nchan link_2_in =[0] of {int};\nchan link_2_out =[0] of {int};\nchan link_3_in =[0] of {int};\nchan link_3_out =[0] of {int};\nchan link_4_in =[0] of {int};\nchan link_4_out =[0] of {int};\n\nactive proctype P_0() { \nbyte status=0;\nbyte v=0;\n\nCS: if\n::  atomic {link_1_in!255;status = 0;}  goto wait; \n\nfi;\nwait: if\n:: link_0_out?v; goto got_msg; \n\n::  atomic {status==0;link_1_in!24;status = 1;}  goto wait; \n\nfi;\ngot_msg: if\n:: v==255; goto CS; \n\n:: v!=255 && v>24; goto wait; \n\n::  atomic {v!=255 && status==1 && v<24;link_1_in!v;status = 2;}  goto wait; \n\n::  atomic {v!=255 && status==0 && v<24;link_1_in!v;}  goto wait; \n\n::  d_step {v!=255 && v==24 && status!=1;status = 0;}  goto wait; \n\n:: v!=255 && v==24 && status==1; goto CS; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte status=0;\nbyte v=0;\n\nwait: if\n:: link_1_out?v; goto got_msg; \n\n::  atomic {status==0;link_2_in!14;status = 1;}  goto wait; \n\nfi;\nCS: if\n::  atomic {link_2_in!255;status = 0;}  goto wait; \n\nfi;\ngot_msg: if\n:: v==255; goto CS; \n\n:: v!=255 && v>14; goto wait; \n\n::  atomic {v!=255 && status==1 && v<14;link_2_in!v;status = 2;}  goto wait; \n\n::  atomic {v!=255 && status==0 && v<14;link_2_in!v;}  goto wait; \n\n::  d_step {v!=255 && v==14 && status!=1;status = 0;}  goto wait; \n\n:: v!=255 && v==14 && status==1; goto CS; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte status=0;\nbyte v=0;\n\nwait: if\n:: link_2_out?v; goto got_msg; \n\n::  atomic {status==0;link_3_in!6;status = 1;}  goto wait; \n\nfi;\nCS: if\n::  atomic {link_3_in!255;status = 0;}  goto wait; \n\nfi;\ngot_msg: if\n:: v==255; goto CS; \n\n:: v!=255 && v>6; goto wait; \n\n::  atomic {v!=255 && status==1 && v<6;link_3_in!v;status = 2;}  goto wait; \n\n::  atomic {v!=255 && status==0 && v<6;link_3_in!v;}  goto wait; \n\n::  d_step {v!=255 && v==6 && status!=1;status = 0;}  goto wait; \n\n:: v!=255 && v==6 && status==1; goto CS; \n\nfi;\n}\n\nactive proctype P_3() { \nbyte status=0;\nbyte v=0;\n\nwait: if\n:: link_3_out?v; goto got_msg; \n\n::  atomic {status==0;link_4_in!0;status = 1;}  goto wait; \n\nfi;\nCS: if\n::  atomic {link_4_in!255;status = 0;}  goto wait; \n\nfi;\ngot_msg: if\n:: v==255; goto CS; \n\n:: v!=255 && v>0; goto wait; \n\n::  atomic {v!=255 && status==1 && v<0;link_4_in!v;status = 2;}  goto wait; \n\n::  atomic {v!=255 && status==0 && v<0;link_4_in!v;}  goto wait; \n\n::  d_step {v!=255 && v==0 && status!=1;status = 0;}  goto wait; \n\n:: v!=255 && v==0 && status==1; goto CS; \n\nfi;\n}\n\nactive proctype P_4() { \nbyte status=0;\nbyte v=0;\n\nwait: if\n:: link_4_out?v; goto got_msg; \n\n::  atomic {status==0;link_0_in!23;status = 1;}  goto wait; \n\nfi;\nCS: if\n::  atomic {link_0_in!255;status = 0;}  goto wait; \n\nfi;\ngot_msg: if\n:: v==255; goto CS; \n\n:: v!=255 && v>23; goto wait; \n\n::  atomic {v!=255 && status==1 && v<23;link_0_in!v;status = 2;}  goto wait; \n\n::  atomic {v!=255 && status==0 && v<23;link_0_in!v;}  goto wait; \n\n::  d_step {v!=255 && v==23 && status!=1;status = 0;}  goto wait; \n\n:: v!=255 && v==23 && status==1; goto CS; \n\nfi;\n}\n\nactive proctype chnlnel_link_0() { \nbyte v=0;\n\nready: if\n:: link_0_in?v; goto tr; \n\nfi;\ntr: if\n::  goto ready; \n\n:: link_0_out!v; goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_link_1() { \nbyte v=0;\n\nready: if\n:: link_1_in?v; goto tr; \n\nfi;\ntr: if\n::  goto ready; \n\n:: link_1_out!v; goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_link_2() { \nbyte v=0;\n\nready: if\n:: link_2_in?v; goto tr; \n\nfi;\ntr: if\n::  goto ready; \n\n:: link_2_out!v; goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_link_3() { \nbyte v=0;\n\nready: if\n:: link_3_in?v; goto tr; \n\nfi;\ntr: if\n::  goto ready; \n\n:: link_3_out!v; goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_link_4() { \nbyte v=0;\n\nready: if\n:: link_4_in?v; goto tr; \n\nfi;\ntr: if\n::  goto ready; \n\n:: link_4_out!v; goto ready; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "N nodes are connected by a token ring. The token is used\n    to guarantee mutual exclusion access to shared resource. The communications\n    link are unreliable, i.e., token can get lost. The leader election\n    algorithm is used for sending of a new token after the timeout.\n\nParameters:\n\n\n\n\n\nAtomic propositions:\n, , \n\nProperties to verify:"}, {"role": "assistant", "content": "chan link_0_in =[0] of {int};\nchan link_0_out =[0] of {int};\nchan link_1_in =[0] of {int};\nchan link_1_out =[0] of {int};\nchan link_2_in =[0] of {int};\nchan link_2_out =[0] of {int};\nchan link_3_in =[0] of {int};\nchan link_3_out =[0] of {int};\nchan link_4_in =[0] of {int};\nchan link_4_out =[0] of {int};\n\nactive proctype P_0() { \nbyte status=0;\nbyte v=0;\n\nCS: if\n::  atomic {link_1_in!255;status = 0;}  goto wait; \n\nfi;\nwait: if\n:: link_0_out?v; goto got_msg; \n\n::  atomic {status==0;link_1_in!24;status = 1;}  goto wait; \n\nfi;\ngot_msg: if\n:: v==255; goto CS; \n\n::  atomic {v!=255 && v>24;link_1_in!v;}  goto wait; \n\n::  atomic {v!=255 && status==1 && v<24;link_1_in!v;status = 2;}  goto wait; \n\n::  atomic {v!=255 && status==0 && v<24;link_1_in!v;}  goto wait; \n\n::  d_step {v!=255 && v==24 && status!=1;status = 0;}  goto wait; \n\n:: v!=255 && v==24 && status==1; goto CS; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte status=0;\nbyte v=0;\n\nwait: if\n:: link_1_out?v; goto got_msg; \n\n::  atomic {status==0;link_2_in!14;status = 1;}  goto wait; \n\nfi;\nCS: if\n::  atomic {link_2_in!255;status = 0;}  goto wait; \n\nfi;\ngot_msg: if\n:: v==255; goto CS; \n\n::  atomic {v!=255 && v>14;link_2_in!v;}  goto wait; \n\n::  atomic {v!=255 && status==1 && v<14;link_2_in!v;status = 2;}  goto wait; \n\n::  atomic {v!=255 && status==0 && v<14;link_2_in!v;}  goto wait; \n\n::  d_step {v!=255 && v==14 && status!=1;status = 0;}  goto wait; \n\n:: v!=255 && v==14 && status==1; goto CS; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte status=0;\nbyte v=0;\n\nwait: if\n:: link_2_out?v; goto got_msg; \n\n::  atomic {status==0;link_3_in!6;status = 1;}  goto wait; \n\nfi;\nCS: if\n::  atomic {link_3_in!255;status = 0;}  goto wait; \n\nfi;\ngot_msg: if\n:: v==255; goto CS; \n\n::  atomic {v!=255 && v>6;link_3_in!v;}  goto wait; \n\n::  atomic {v!=255 && status==1 && v<6;link_3_in!v;status = 2;}  goto wait; \n\n::  atomic {v!=255 && status==0 && v<6;link_3_in!v;}  goto wait; \n\n::  d_step {v!=255 && v==6 && status!=1;status = 0;}  goto wait; \n\n:: v!=255 && v==6 && status==1; goto CS; \n\nfi;\n}\n\nactive proctype P_3() { \nbyte status=0;\nbyte v=0;\n\nwait: if\n:: link_3_out?v; goto got_msg; \n\n::  atomic {status==0;link_4_in!0;status = 1;}  goto wait; \n\nfi;\nCS: if\n::  atomic {link_4_in!255;status = 0;}  goto wait; \n\nfi;\ngot_msg: if\n:: v==255; goto CS; \n\n::  atomic {v!=255 && v>0;link_4_in!v;}  goto wait; \n\n::  atomic {v!=255 && status==1 && v<0;link_4_in!v;status = 2;}  goto wait; \n\n::  atomic {v!=255 && status==0 && v<0;link_4_in!v;}  goto wait; \n\n::  d_step {v!=255 && v==0 && status!=1;status = 0;}  goto wait; \n\n:: v!=255 && v==0 && status==1; goto CS; \n\nfi;\n}\n\nactive proctype P_4() { \nbyte status=0;\nbyte v=0;\n\nwait: if\n:: link_4_out?v; goto got_msg; \n\n::  atomic {status==0;link_0_in!23;status = 1;}  goto wait; \n\nfi;\nCS: if\n::  atomic {link_0_in!255;status = 0;}  goto wait; \n\nfi;\ngot_msg: if\n:: v==255; goto CS; \n\n::  atomic {v!=255 && v>23;link_0_in!v;}  goto wait; \n\n::  atomic {v!=255 && status==1 && v<23;link_0_in!v;status = 2;}  goto wait; \n\n::  atomic {v!=255 && status==0 && v<23;link_0_in!v;}  goto wait; \n\n::  d_step {v!=255 && v==23 && status!=1;status = 0;}  goto wait; \n\n:: v!=255 && v==23 && status==1; goto CS; \n\nfi;\n}\n\nactive proctype chnlnel_link_0() { \nbyte v=0;\n\nready: if\n:: link_0_in?v; goto tr; \n\nfi;\ntr: if\n::  goto ready; \n\n:: link_0_out!v; goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_link_1() { \nbyte v=0;\n\nready: if\n:: link_1_in?v; goto tr; \n\nfi;\ntr: if\n::  goto ready; \n\n:: link_1_out!v; goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_link_2() { \nbyte v=0;\n\nready: if\n:: link_2_in?v; goto tr; \n\nfi;\ntr: if\n::  goto ready; \n\n:: link_2_out!v; goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_link_3() { \nbyte v=0;\n\nready: if\n:: link_3_in?v; goto tr; \n\nfi;\ntr: if\n::  goto ready; \n\n:: link_3_out!v; goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_link_4() { \nbyte v=0;\n\nready: if\n:: link_4_in?v; goto tr; \n\nfi;\ntr: if\n::  goto ready; \n\n:: link_4_out!v; goto ready; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "A filter is a piece of code that satisfy the following\n    conditions: a) if m processes enter the filter, then at most m/2 processes\n    exit; b) if some process enter the filter, then at least one of them exits.\n    This model is leader election algorithm based on\n    filters.\n\nParameters:\n\n\n\nAtomic propositions:\n, \n\nProperties to verify:"}, {"role": "assistant", "content": "byte turn[5];\nbyte b[5];\nbyte c[5];\n\n\nactive proctype P_0() { \nbyte curr=0;\n\np1: if\n:: turn[curr] = 0; goto p2; \n\nfi;\np2: if\n:: b[curr]==0; goto p3; \n\nfi;\np3: if\n:: b[curr] = 1; goto p4; \n\nfi;\np4: if\n:: turn[curr]!=0; goto p5; \n\n:: turn[curr]==0; goto p8; \n\nfi;\np5: if\n:: c[curr] = 1; goto p6; \n\nfi;\np6: if\n:: b[curr] = 0; goto p7; \n\nfi;\np8: if\n:: curr>0 && c[curr-1]==0; goto p9; \n\n::  d_step {curr==0 || c[curr-1]==1;curr = curr+1;}  goto p1; \n\nfi;\np9: if\n::  goto elected; \n\nfi;\np7: \nelected: \n false; }\n\nactive proctype P_1() { \nbyte curr=0;\n\np1: if\n:: turn[curr] = 1; goto p2; \n\nfi;\np2: if\n:: b[curr]==0; goto p3; \n\nfi;\np3: if\n:: b[curr] = 1; goto p4; \n\nfi;\np4: if\n:: turn[curr]!=1; goto p5; \n\n:: turn[curr]==1; goto p8; \n\nfi;\np5: if\n:: c[curr] = 1; goto p6; \n\nfi;\np6: if\n:: b[curr] = 0; goto p7; \n\nfi;\np8: if\n:: curr>0 && c[curr-1]==0; goto p9; \n\n::  d_step {curr==0 || c[curr-1]==1;curr = curr+1;}  goto p1; \n\nfi;\np9: if\n::  goto elected; \n\nfi;\np7: \nelected: \n false; }\n\nactive proctype P_2() { \nbyte curr=0;\n\np1: if\n:: turn[curr] = 2; goto p2; \n\nfi;\np2: if\n:: b[curr]==0; goto p3; \n\nfi;\np3: if\n:: b[curr] = 1; goto p4; \n\nfi;\np4: if\n:: turn[curr]!=2; goto p5; \n\n:: turn[curr]==2; goto p8; \n\nfi;\np5: if\n:: c[curr] = 1; goto p6; \n\nfi;\np6: if\n:: b[curr] = 0; goto p7; \n\nfi;\np8: if\n:: curr>0 && c[curr-1]==0; goto p9; \n\n::  d_step {curr==0 || c[curr-1]==1;curr = curr+1;}  goto p1; \n\nfi;\np9: if\n::  goto elected; \n\nfi;\np7: \nelected: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "A filter is a piece of code that satisfy the following\n    conditions: a) if m processes enter the filter, then at most m/2 processes\n    exit; b) if some process enter the filter, then at least one of them exits.\n    This model is leader election algorithm based on\n    filters.\n\nParameters:\n\n\n\nAtomic propositions:\n, \n\nProperties to verify:"}, {"role": "assistant", "content": "byte turn[5];\nbyte b[5];\nbyte c[5];\n\n\nactive proctype P_0() { \nbyte curr=0;\n\np1: if\n:: turn[curr] = 0; goto p2; \n\nfi;\np2: if\n::  goto p3; \n\nfi;\np3: if\n:: b[curr] = 1; goto p4; \n\nfi;\np4: if\n:: turn[curr]!=0; goto p5; \n\n:: turn[curr]==0; goto p8; \n\nfi;\np5: if\n:: c[curr] = 1; goto p6; \n\nfi;\np6: if\n:: b[curr] = 0; goto p7; \n\nfi;\np8: if\n:: curr>0 && c[curr-1]==0; goto p9; \n\n::  d_step {curr==0 || c[curr-1]==1;curr = curr+1;}  goto p1; \n\nfi;\np9: if\n::  goto elected; \n\nfi;\np7: \nelected: \n false; }\n\nactive proctype P_1() { \nbyte curr=0;\n\np1: if\n:: turn[curr] = 1; goto p2; \n\nfi;\np2: if\n::  goto p3; \n\nfi;\np3: if\n:: b[curr] = 1; goto p4; \n\nfi;\np4: if\n:: turn[curr]!=1; goto p5; \n\n:: turn[curr]==1; goto p8; \n\nfi;\np5: if\n:: c[curr] = 1; goto p6; \n\nfi;\np6: if\n:: b[curr] = 0; goto p7; \n\nfi;\np8: if\n:: curr>0 && c[curr-1]==0; goto p9; \n\n::  d_step {curr==0 || c[curr-1]==1;curr = curr+1;}  goto p1; \n\nfi;\np9: if\n::  goto elected; \n\nfi;\np7: \nelected: \n false; }\n\nactive proctype P_2() { \nbyte curr=0;\n\np1: if\n:: turn[curr] = 2; goto p2; \n\nfi;\np2: if\n::  goto p3; \n\nfi;\np3: if\n:: b[curr] = 1; goto p4; \n\nfi;\np4: if\n:: turn[curr]!=2; goto p5; \n\n:: turn[curr]==2; goto p8; \n\nfi;\np5: if\n:: c[curr] = 1; goto p6; \n\nfi;\np6: if\n:: b[curr] = 0; goto p7; \n\nfi;\np8: if\n:: curr>0 && c[curr-1]==0; goto p9; \n\n::  d_step {curr==0 || c[curr-1]==1;curr = curr+1;}  goto p1; \n\nfi;\np9: if\n::  goto elected; \n\nfi;\np7: \nelected: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "A filter is a piece of code that satisfy the following\n    conditions: a) if m processes enter the filter, then at most m/2 processes\n    exit; b) if some process enter the filter, then at least one of them exits.\n    This model is leader election algorithm based on\n    filters.\n\nParameters:\n\n\n\nAtomic propositions:\n, \n\nProperties to verify:"}, {"role": "assistant", "content": "byte turn[5];\nbyte b[5];\nbyte c[5];\n\n\nactive proctype P_0() { \nbyte curr=0;\n\np1: if\n:: turn[curr] = 0; goto p2; \n\nfi;\np2: if\n:: b[curr]==0; goto p3; \n\nfi;\np3: if\n:: b[curr] = 1; goto p4; \n\nfi;\np4: if\n:: turn[curr]!=0; goto p5; \n\n:: turn[curr]==0; goto p8; \n\nfi;\np5: if\n:: c[curr] = 1; goto p6; \n\nfi;\np6: if\n:: b[curr] = 0; goto p7; \n\nfi;\np8: if\n:: curr>0 && c[curr-1]==0; goto p9; \n\n::  d_step {curr==0 || c[curr-1]==1;curr = curr+1;}  goto p1; \n\nfi;\np9: if\n::  goto elected; \n\nfi;\np7: \nelected: \n false; }\n\nactive proctype P_1() { \nbyte curr=0;\n\np1: if\n:: turn[curr] = 1; goto p2; \n\nfi;\np2: if\n:: b[curr]==0; goto p3; \n\nfi;\np3: if\n:: b[curr] = 1; goto p4; \n\nfi;\np4: if\n:: turn[curr]!=1; goto p5; \n\n:: turn[curr]==1; goto p8; \n\nfi;\np5: if\n:: c[curr] = 1; goto p6; \n\nfi;\np6: if\n:: b[curr] = 0; goto p7; \n\nfi;\np8: if\n:: curr>0 && c[curr-1]==0; goto p9; \n\n::  d_step {curr==0 || c[curr-1]==1;curr = curr+1;}  goto p1; \n\nfi;\np9: if\n::  goto elected; \n\nfi;\np7: \nelected: \n false; }\n\nactive proctype P_2() { \nbyte curr=0;\n\np1: if\n:: turn[curr] = 2; goto p2; \n\nfi;\np2: if\n:: b[curr]==0; goto p3; \n\nfi;\np3: if\n:: b[curr] = 1; goto p4; \n\nfi;\np4: if\n:: turn[curr]!=2; goto p5; \n\n:: turn[curr]==2; goto p8; \n\nfi;\np5: if\n:: c[curr] = 1; goto p6; \n\nfi;\np6: if\n:: b[curr] = 0; goto p7; \n\nfi;\np8: if\n:: curr>0 && c[curr-1]==0; goto p9; \n\n::  d_step {curr==0 || c[curr-1]==1;curr = curr+1;}  goto p1; \n\nfi;\np9: if\n::  goto elected; \n\nfi;\np7: \nelected: \n false; }\n\nactive proctype P_3() { \nbyte curr=0;\n\np1: if\n:: turn[curr] = 3; goto p2; \n\nfi;\np2: if\n:: b[curr]==0; goto p3; \n\nfi;\np3: if\n:: b[curr] = 1; goto p4; \n\nfi;\np4: if\n:: turn[curr]!=3; goto p5; \n\n:: turn[curr]==3; goto p8; \n\nfi;\np5: if\n:: c[curr] = 1; goto p6; \n\nfi;\np6: if\n:: b[curr] = 0; goto p7; \n\nfi;\np8: if\n:: curr>0 && c[curr-1]==0; goto p9; \n\n::  d_step {curr==0 || c[curr-1]==1;curr = curr+1;}  goto p1; \n\nfi;\np9: if\n::  goto elected; \n\nfi;\np7: \nelected: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "A filter is a piece of code that satisfy the following\n    conditions: a) if m processes enter the filter, then at most m/2 processes\n    exit; b) if some process enter the filter, then at least one of them exits.\n    This model is leader election algorithm based on\n    filters.\n\nParameters:\n\n\n\nAtomic propositions:\n, \n\nProperties to verify:"}, {"role": "assistant", "content": "byte turn[5];\nbyte b[5];\nbyte c[5];\n\n\nactive proctype P_0() { \nbyte curr=0;\n\np1: if\n:: turn[curr] = 0; goto p2; \n\nfi;\np2: if\n:: b[curr]==0; goto p3; \n\nfi;\np3: if\n:: b[curr] = 1; goto p4; \n\nfi;\np4: if\n:: turn[curr]!=0; goto p5; \n\n:: turn[curr]==0; goto p8; \n\nfi;\np5: if\n::  goto p6; \n\nfi;\np6: if\n:: b[curr] = 0; goto p7; \n\nfi;\np8: if\n:: curr>0 && c[curr-1]==0; goto p9; \n\n::  d_step {curr==0 || c[curr-1]==1;curr = curr+1;}  goto p1; \n\nfi;\np9: if\n::  goto elected; \n\nfi;\np7: \nelected: \n false; }\n\nactive proctype P_1() { \nbyte curr=0;\n\np1: if\n:: turn[curr] = 1; goto p2; \n\nfi;\np2: if\n:: b[curr]==0; goto p3; \n\nfi;\np3: if\n:: b[curr] = 1; goto p4; \n\nfi;\np4: if\n:: turn[curr]!=1; goto p5; \n\n:: turn[curr]==1; goto p8; \n\nfi;\np5: if\n::  goto p6; \n\nfi;\np6: if\n:: b[curr] = 0; goto p7; \n\nfi;\np8: if\n:: curr>0 && c[curr-1]==0; goto p9; \n\n::  d_step {curr==0 || c[curr-1]==1;curr = curr+1;}  goto p1; \n\nfi;\np9: if\n::  goto elected; \n\nfi;\np7: \nelected: \n false; }\n\nactive proctype P_2() { \nbyte curr=0;\n\np1: if\n:: turn[curr] = 2; goto p2; \n\nfi;\np2: if\n:: b[curr]==0; goto p3; \n\nfi;\np3: if\n:: b[curr] = 1; goto p4; \n\nfi;\np4: if\n:: turn[curr]!=2; goto p5; \n\n:: turn[curr]==2; goto p8; \n\nfi;\np5: if\n::  goto p6; \n\nfi;\np6: if\n:: b[curr] = 0; goto p7; \n\nfi;\np8: if\n:: curr>0 && c[curr-1]==0; goto p9; \n\n::  d_step {curr==0 || c[curr-1]==1;curr = curr+1;}  goto p1; \n\nfi;\np9: if\n::  goto elected; \n\nfi;\np7: \nelected: \n false; }\n\nactive proctype P_3() { \nbyte curr=0;\n\np1: if\n:: turn[curr] = 3; goto p2; \n\nfi;\np2: if\n:: b[curr]==0; goto p3; \n\nfi;\np3: if\n:: b[curr] = 1; goto p4; \n\nfi;\np4: if\n:: turn[curr]!=3; goto p5; \n\n:: turn[curr]==3; goto p8; \n\nfi;\np5: if\n::  goto p6; \n\nfi;\np6: if\n:: b[curr] = 0; goto p7; \n\nfi;\np8: if\n:: curr>0 && c[curr-1]==0; goto p9; \n\n::  d_step {curr==0 || c[curr-1]==1;curr = curr+1;}  goto p1; \n\nfi;\np9: if\n::  goto elected; \n\nfi;\np7: \nelected: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "A filter is a piece of code that satisfy the following\n    conditions: a) if m processes enter the filter, then at most m/2 processes\n    exit; b) if some process enter the filter, then at least one of them exits.\n    This model is leader election algorithm based on\n    filters.\n\nParameters:\n\n\n\nAtomic propositions:\n, \n\nProperties to verify:"}, {"role": "assistant", "content": "byte turn[6];\nbyte b[6];\nbyte c[6];\n\n\nactive proctype P_0() { \nbyte curr=0;\n\np1: if\n:: turn[curr] = 0; goto p2; \n\nfi;\np2: if\n:: b[curr]==0; goto p3; \n\nfi;\np3: if\n:: b[curr] = 1; goto p4; \n\nfi;\np4: if\n:: turn[curr]!=0; goto p5; \n\n:: turn[curr]==0; goto p8; \n\nfi;\np5: if\n:: c[curr] = 1; goto p6; \n\nfi;\np6: if\n:: b[curr] = 0; goto p7; \n\nfi;\np8: if\n:: curr>0 && c[curr-1]==0; goto p9; \n\n::  d_step {curr==0 || c[curr-1]==1;curr = curr+1;}  goto p1; \n\nfi;\np9: if\n::  goto elected; \n\nfi;\np7: \nelected: \n false; }\n\nactive proctype P_1() { \nbyte curr=0;\n\np1: if\n:: turn[curr] = 1; goto p2; \n\nfi;\np2: if\n:: b[curr]==0; goto p3; \n\nfi;\np3: if\n:: b[curr] = 1; goto p4; \n\nfi;\np4: if\n:: turn[curr]!=1; goto p5; \n\n:: turn[curr]==1; goto p8; \n\nfi;\np5: if\n:: c[curr] = 1; goto p6; \n\nfi;\np6: if\n:: b[curr] = 0; goto p7; \n\nfi;\np8: if\n:: curr>0 && c[curr-1]==0; goto p9; \n\n::  d_step {curr==0 || c[curr-1]==1;curr = curr+1;}  goto p1; \n\nfi;\np9: if\n::  goto elected; \n\nfi;\np7: \nelected: \n false; }\n\nactive proctype P_2() { \nbyte curr=0;\n\np1: if\n:: turn[curr] = 2; goto p2; \n\nfi;\np2: if\n:: b[curr]==0; goto p3; \n\nfi;\np3: if\n:: b[curr] = 1; goto p4; \n\nfi;\np4: if\n:: turn[curr]!=2; goto p5; \n\n:: turn[curr]==2; goto p8; \n\nfi;\np5: if\n:: c[curr] = 1; goto p6; \n\nfi;\np6: if\n:: b[curr] = 0; goto p7; \n\nfi;\np8: if\n:: curr>0 && c[curr-1]==0; goto p9; \n\n::  d_step {curr==0 || c[curr-1]==1;curr = curr+1;}  goto p1; \n\nfi;\np9: if\n::  goto elected; \n\nfi;\np7: \nelected: \n false; }\n\nactive proctype P_3() { \nbyte curr=0;\n\np1: if\n:: turn[curr] = 3; goto p2; \n\nfi;\np2: if\n:: b[curr]==0; goto p3; \n\nfi;\np3: if\n:: b[curr] = 1; goto p4; \n\nfi;\np4: if\n:: turn[curr]!=3; goto p5; \n\n:: turn[curr]==3; goto p8; \n\nfi;\np5: if\n:: c[curr] = 1; goto p6; \n\nfi;\np6: if\n:: b[curr] = 0; goto p7; \n\nfi;\np8: if\n:: curr>0 && c[curr-1]==0; goto p9; \n\n::  d_step {curr==0 || c[curr-1]==1;curr = curr+1;}  goto p1; \n\nfi;\np9: if\n::  goto elected; \n\nfi;\np7: \nelected: \n false; }\n\nactive proctype P_4() { \nbyte curr=0;\n\np1: if\n:: turn[curr] = 4; goto p2; \n\nfi;\np2: if\n:: b[curr]==0; goto p3; \n\nfi;\np3: if\n:: b[curr] = 1; goto p4; \n\nfi;\np4: if\n:: turn[curr]!=4; goto p5; \n\n:: turn[curr]==4; goto p8; \n\nfi;\np5: if\n:: c[curr] = 1; goto p6; \n\nfi;\np6: if\n:: b[curr] = 0; goto p7; \n\nfi;\np8: if\n:: curr>0 && c[curr-1]==0; goto p9; \n\n::  d_step {curr==0 || c[curr-1]==1;curr = curr+1;}  goto p1; \n\nfi;\np9: if\n::  goto elected; \n\nfi;\np7: \nelected: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "A filter is a piece of code that satisfy the following\n    conditions: a) if m processes enter the filter, then at most m/2 processes\n    exit; b) if some process enter the filter, then at least one of them exits.\n    This model is leader election algorithm based on\n    filters.\n\nParameters:\n\n\n\nAtomic propositions:\n, \n\nProperties to verify:"}, {"role": "assistant", "content": "byte turn[6];\nbyte b[6];\nbyte c[6];\n\n\nactive proctype P_0() { \nbyte curr=0;\n\np1: if\n:: turn[curr] = 0; goto p2; \n\nfi;\np2: if\n::  goto p3; \n\nfi;\np3: if\n:: b[curr] = 1; goto p4; \n\nfi;\np4: if\n:: turn[curr]!=0; goto p5; \n\n:: turn[curr]==0; goto p8; \n\nfi;\np5: if\n:: c[curr] = 1; goto p6; \n\nfi;\np6: if\n:: b[curr] = 0; goto p7; \n\nfi;\np8: if\n:: curr>0 && c[curr-1]==0; goto p9; \n\n::  d_step {curr==0 || c[curr-1]==1;curr = curr+1;}  goto p1; \n\nfi;\np9: if\n::  goto elected; \n\nfi;\np7: \nelected: \n false; }\n\nactive proctype P_1() { \nbyte curr=0;\n\np1: if\n:: turn[curr] = 1; goto p2; \n\nfi;\np2: if\n::  goto p3; \n\nfi;\np3: if\n:: b[curr] = 1; goto p4; \n\nfi;\np4: if\n:: turn[curr]!=1; goto p5; \n\n:: turn[curr]==1; goto p8; \n\nfi;\np5: if\n:: c[curr] = 1; goto p6; \n\nfi;\np6: if\n:: b[curr] = 0; goto p7; \n\nfi;\np8: if\n:: curr>0 && c[curr-1]==0; goto p9; \n\n::  d_step {curr==0 || c[curr-1]==1;curr = curr+1;}  goto p1; \n\nfi;\np9: if\n::  goto elected; \n\nfi;\np7: \nelected: \n false; }\n\nactive proctype P_2() { \nbyte curr=0;\n\np1: if\n:: turn[curr] = 2; goto p2; \n\nfi;\np2: if\n::  goto p3; \n\nfi;\np3: if\n:: b[curr] = 1; goto p4; \n\nfi;\np4: if\n:: turn[curr]!=2; goto p5; \n\n:: turn[curr]==2; goto p8; \n\nfi;\np5: if\n:: c[curr] = 1; goto p6; \n\nfi;\np6: if\n:: b[curr] = 0; goto p7; \n\nfi;\np8: if\n:: curr>0 && c[curr-1]==0; goto p9; \n\n::  d_step {curr==0 || c[curr-1]==1;curr = curr+1;}  goto p1; \n\nfi;\np9: if\n::  goto elected; \n\nfi;\np7: \nelected: \n false; }\n\nactive proctype P_3() { \nbyte curr=0;\n\np1: if\n:: turn[curr] = 3; goto p2; \n\nfi;\np2: if\n::  goto p3; \n\nfi;\np3: if\n:: b[curr] = 1; goto p4; \n\nfi;\np4: if\n:: turn[curr]!=3; goto p5; \n\n:: turn[curr]==3; goto p8; \n\nfi;\np5: if\n:: c[curr] = 1; goto p6; \n\nfi;\np6: if\n:: b[curr] = 0; goto p7; \n\nfi;\np8: if\n:: curr>0 && c[curr-1]==0; goto p9; \n\n::  d_step {curr==0 || c[curr-1]==1;curr = curr+1;}  goto p1; \n\nfi;\np9: if\n::  goto elected; \n\nfi;\np7: \nelected: \n false; }\n\nactive proctype P_4() { \nbyte curr=0;\n\np1: if\n:: turn[curr] = 4; goto p2; \n\nfi;\np2: if\n::  goto p3; \n\nfi;\np3: if\n:: b[curr] = 1; goto p4; \n\nfi;\np4: if\n:: turn[curr]!=4; goto p5; \n\n:: turn[curr]==4; goto p8; \n\nfi;\np5: if\n:: c[curr] = 1; goto p6; \n\nfi;\np6: if\n:: b[curr] = 0; goto p7; \n\nfi;\np8: if\n:: curr>0 && c[curr-1]==0; goto p9; \n\n::  d_step {curr==0 || c[curr-1]==1;curr = curr+1;}  goto p1; \n\nfi;\np9: if\n::  goto elected; \n\nfi;\np7: \nelected: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "A filter is a piece of code that satisfy the following\n    conditions: a) if m processes enter the filter, then at most m/2 processes\n    exit; b) if some process enter the filter, then at least one of them exits.\n    This model is leader election algorithm based on\n    filters.\n\nParameters:\n\n\n\nAtomic propositions:\n, \n\nProperties to verify:"}, {"role": "assistant", "content": "byte turn[6];\nbyte b[6];\nbyte c[6];\n\n\nactive proctype P_0() { \nbyte curr=0;\n\np1: if\n:: turn[curr] = 0; goto p2; \n\nfi;\np2: if\n:: b[curr]==0; goto p3; \n\nfi;\np3: if\n:: b[curr] = 1; goto p4; \n\nfi;\np4: if\n:: turn[curr]!=0; goto p5; \n\n:: turn[curr]==0; goto p8; \n\nfi;\np5: if\n:: c[curr] = 1; goto p6; \n\nfi;\np6: if\n:: b[curr] = 0; goto p7; \n\nfi;\np8: if\n:: curr>0 && c[curr-1]==0; goto p9; \n\n::  d_step {curr==0 || c[curr-1]==1;curr = curr+1;}  goto p1; \n\nfi;\np9: if\n::  goto elected; \n\nfi;\np7: \nelected: \n false; }\n\nactive proctype P_1() { \nbyte curr=0;\n\np1: if\n:: turn[curr] = 1; goto p2; \n\nfi;\np2: if\n:: b[curr]==0; goto p3; \n\nfi;\np3: if\n:: b[curr] = 1; goto p4; \n\nfi;\np4: if\n:: turn[curr]!=1; goto p5; \n\n:: turn[curr]==1; goto p8; \n\nfi;\np5: if\n:: c[curr] = 1; goto p6; \n\nfi;\np6: if\n:: b[curr] = 0; goto p7; \n\nfi;\np8: if\n:: curr>0 && c[curr-1]==0; goto p9; \n\n::  d_step {curr==0 || c[curr-1]==1;curr = curr+1;}  goto p1; \n\nfi;\np9: if\n::  goto elected; \n\nfi;\np7: \nelected: \n false; }\n\nactive proctype P_2() { \nbyte curr=0;\n\np1: if\n:: turn[curr] = 2; goto p2; \n\nfi;\np2: if\n:: b[curr]==0; goto p3; \n\nfi;\np3: if\n:: b[curr] = 1; goto p4; \n\nfi;\np4: if\n:: turn[curr]!=2; goto p5; \n\n:: turn[curr]==2; goto p8; \n\nfi;\np5: if\n:: c[curr] = 1; goto p6; \n\nfi;\np6: if\n:: b[curr] = 0; goto p7; \n\nfi;\np8: if\n:: curr>0 && c[curr-1]==0; goto p9; \n\n::  d_step {curr==0 || c[curr-1]==1;curr = curr+1;}  goto p1; \n\nfi;\np9: if\n::  goto elected; \n\nfi;\np7: \nelected: \n false; }\n\nactive proctype P_3() { \nbyte curr=0;\n\np1: if\n:: turn[curr] = 3; goto p2; \n\nfi;\np2: if\n:: b[curr]==0; goto p3; \n\nfi;\np3: if\n:: b[curr] = 1; goto p4; \n\nfi;\np4: if\n:: turn[curr]!=3; goto p5; \n\n:: turn[curr]==3; goto p8; \n\nfi;\np5: if\n:: c[curr] = 1; goto p6; \n\nfi;\np6: if\n:: b[curr] = 0; goto p7; \n\nfi;\np8: if\n:: curr>0 && c[curr-1]==0; goto p9; \n\n::  d_step {curr==0 || c[curr-1]==1;curr = curr+1;}  goto p1; \n\nfi;\np9: if\n::  goto elected; \n\nfi;\np7: \nelected: \n false; }\n\nactive proctype P_4() { \nbyte curr=0;\n\np1: if\n:: turn[curr] = 4; goto p2; \n\nfi;\np2: if\n:: b[curr]==0; goto p3; \n\nfi;\np3: if\n:: b[curr] = 1; goto p4; \n\nfi;\np4: if\n:: turn[curr]!=4; goto p5; \n\n:: turn[curr]==4; goto p8; \n\nfi;\np5: if\n:: c[curr] = 1; goto p6; \n\nfi;\np6: if\n:: b[curr] = 0; goto p7; \n\nfi;\np8: if\n:: curr>0 && c[curr-1]==0; goto p9; \n\n::  d_step {curr==0 || c[curr-1]==1;curr = curr+1;}  goto p1; \n\nfi;\np9: if\n::  goto elected; \n\nfi;\np7: \nelected: \n false; }\n\nactive proctype P_5() { \nbyte curr=0;\n\np1: if\n:: turn[curr] = 5; goto p2; \n\nfi;\np2: if\n:: b[curr]==0; goto p3; \n\nfi;\np3: if\n:: b[curr] = 1; goto p4; \n\nfi;\np4: if\n:: turn[curr]!=5; goto p5; \n\n:: turn[curr]==5; goto p8; \n\nfi;\np5: if\n:: c[curr] = 1; goto p6; \n\nfi;\np6: if\n:: b[curr] = 0; goto p7; \n\nfi;\np8: if\n:: curr>0 && c[curr-1]==0; goto p9; \n\n::  d_step {curr==0 || c[curr-1]==1;curr = curr+1;}  goto p1; \n\nfi;\np9: if\n::  goto elected; \n\nfi;\np7: \nelected: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The \"15 puzzle\" is a sliding square puzzle introduced by Sam Lloyd in 1878.\nIt consists of 15 squares numbered from 1 to 15 which are placed in a box\nleaving one position out of the 16 empty. The goal is to reposition the\nsquares from a given arbitrary starting arrangement by sliding them one\nat a time into a configuration, where the squares are ordered by their\nnumbers. For more details see:\nhttp://mathworld.wolfram.com/15Puzzle.html.\n\nBecause the 'fifteen' version has too big state space, we consider smaller\n    instances as well. The goal, expressed by the reachability property below,\n    is to reverse the order of pieces.\n\nParameters:\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte a[6];\nbyte x=0;\nbyte y=0;\n\n\ninit { \n d_step { \na[0] =0; a[1] =1; a[2] =2; a[3] =3; a[4] =4; a[5] =5; }\natomic { \nrun P();\nrun Check();\n} }\n\nproctype P() { \n\nq: if\n::  d_step {x>0;a[(y)*2+x] = a[(y)*2+x-1];a[(y)*2+x-1] = 0;x = x-1;}  goto q; \n\n::  d_step {x<2-1;a[(y)*2+x] = a[(y)*2+x+1];a[(y)*2+x+1] = 0;x = x+1;}  goto q; \n\n::  d_step {y>0;a[(y)*2+x] = a[(y-1)*2+x];a[(y-1)*2+x] = 0;y = y-1;}  goto q; \n\n::  d_step {y<3-1;a[(y)*2+x] = a[(y+1)*2+x];a[(y+1)*2+x] = 0;y = y+1;}  goto q; \n\nfi;\n}\n\nproctype Check() { \n\nnot_done: if\n:: a[0]==5 && a[1]==4 && a[2]==3 && a[3]==2 && a[4]==1 && a[5]==0; goto done; \n\nfi;\ndone: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The \"15 puzzle\" is a sliding square puzzle introduced by Sam Lloyd in 1878.\nIt consists of 15 squares numbered from 1 to 15 which are placed in a box\nleaving one position out of the 16 empty. The goal is to reposition the\nsquares from a given arbitrary starting arrangement by sliding them one\nat a time into a configuration, where the squares are ordered by their\nnumbers. For more details see:\nhttp://mathworld.wolfram.com/15Puzzle.html.\n\nBecause the 'fifteen' version has too big state space, we consider smaller\n    instances as well. The goal, expressed by the reachability property below,\n    is to reverse the order of pieces.\n\nParameters:\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte a[9];\nbyte x=0;\nbyte y=0;\n\n\ninit { \n d_step { \na[0] =0; a[1] =1; a[2] =2; a[3] =3; a[4] =4; a[5] =5; a[6] =6; a[7] =7; a[8] =8; }\natomic { \nrun P();\nrun Check();\n} }\n\nproctype P() { \n\nq: if\n::  d_step {x>0;a[(y)*3+x] = a[(y)*3+x-1];a[(y)*3+x-1] = 0;x = x-1;}  goto q; \n\n::  d_step {x<3-1;a[(y)*3+x] = a[(y)*3+x+1];a[(y)*3+x+1] = 0;x = x+1;}  goto q; \n\n::  d_step {y>0;a[(y)*3+x] = a[(y-1)*3+x];a[(y-1)*3+x] = 0;y = y-1;}  goto q; \n\n::  d_step {y<3-1;a[(y)*3+x] = a[(y+1)*3+x];a[(y+1)*3+x] = 0;y = y+1;}  goto q; \n\nfi;\n}\n\nproctype Check() { \n\nnot_done: if\n:: a[0]==8 && a[1]==7 && a[2]==6 && a[3]==5 && a[4]==4 && a[5]==3 && a[6]==2 && a[7]==1 && a[8]==0; goto done; \n\nfi;\ndone: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The \"15 puzzle\" is a sliding square puzzle introduced by Sam Lloyd in 1878.\nIt consists of 15 squares numbered from 1 to 15 which are placed in a box\nleaving one position out of the 16 empty. The goal is to reposition the\nsquares from a given arbitrary starting arrangement by sliding them one\nat a time into a configuration, where the squares are ordered by their\nnumbers. For more details see:\nhttp://mathworld.wolfram.com/15Puzzle.html.\n\nBecause the 'fifteen' version has too big state space, we consider smaller\n    instances as well. The goal, expressed by the reachability property below,\n    is to reverse the order of pieces.\n\nParameters:\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte a[12];\nbyte x=0;\nbyte y=0;\n\n\ninit { \n d_step { \na[0] =0; a[1] =1; a[2] =2; a[3] =3; a[4] =4; a[5] =5; a[6] =6; a[7] =7; a[8] =8; a[9] =9; a[10] =10; a[11] =11; }\natomic { \nrun P();\nrun Check();\n} }\n\nproctype P() { \n\nq: if\n::  d_step {x>0;a[(y)*4+x] = a[(y)*4+x-1];a[(y)*4+x-1] = 0;x = x-1;}  goto q; \n\n::  d_step {x<4-1;a[(y)*4+x] = a[(y)*4+x+1];a[(y)*4+x+1] = 0;x = x+1;}  goto q; \n\n::  d_step {y>0;a[(y)*4+x] = a[(y-1)*4+x];a[(y-1)*4+x] = 0;y = y-1;}  goto q; \n\n::  d_step {y<3-1;a[(y)*4+x] = a[(y+1)*4+x];a[(y+1)*4+x] = 0;y = y+1;}  goto q; \n\nfi;\n}\n\nproctype Check() { \n\nnot_done: if\n:: a[0]==11 && a[1]==10 && a[2]==9 && a[3]==8 && a[4]==7 && a[5]==6 && a[6]==5 && a[7]==4 && a[8]==3 && a[9]==2 && a[10]==1 && a[11]==0; goto done; \n\nfi;\ndone: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually.\n\nThis is Mellor-Crummey and Scott list-based queue lock using\n    fetch-and-store and compare-and-swap algorithm.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte next[3];\nbyte locked[3];\nbyte tail=255;\n\n\ninit { \n d_step { \nnext[0] =255; next[1] =255; next[2] =255; }\natomic { \nrun P_0();\nrun P_1();\nrun P_2();\n} }\n\nproctype P_0() { \nbyte pred=0;\n\nNCS: if\n:: next[0] = 255; goto p2; \n\nfi;\np2: if\n::  d_step {pred = tail;tail = 0;}  goto p3; \n\nfi;\np3: if\n:: pred==255; goto CS; \n\n:: pred!=255; goto p4; \n\nfi;\np4: if\n:: locked[0] = 1; goto p5; \n\nfi;\np5: if\n:: next[pred] = 0; goto p6; \n\nfi;\np6: if\n:: locked[0]==0; goto CS; \n\nfi;\nCS: if\n:: next[0]==255; goto p9; \n\n:: next[0]!=255; goto p13; \n\nfi;\np9: if\n::  d_step {tail==0;tail = 255;}  goto NCS; \n\n:: tail!=0; goto p10; \n\nfi;\np13: if\n:: locked[next[0]] = 0; goto NCS; \n\nfi;\np10: if\n:: next[0]!=255; goto p13; \n\nfi;\n}\n\nproctype P_1() { \nbyte pred=0;\n\nNCS: if\n:: next[1] = 255; goto p2; \n\nfi;\np2: if\n::  d_step {pred = tail;tail = 1;}  goto p3; \n\nfi;\np3: if\n:: pred==255; goto CS; \n\n:: pred!=255; goto p4; \n\nfi;\np4: if\n:: locked[1] = 1; goto p5; \n\nfi;\np5: if\n:: next[pred] = 1; goto p6; \n\nfi;\np6: if\n:: locked[1]==0; goto CS; \n\nfi;\nCS: if\n:: next[1]==255; goto p9; \n\n:: next[1]!=255; goto p13; \n\nfi;\np9: if\n::  d_step {tail==1;tail = 255;}  goto NCS; \n\n:: tail!=1; goto p10; \n\nfi;\np13: if\n:: locked[next[1]] = 0; goto NCS; \n\nfi;\np10: if\n:: next[1]!=255; goto p13; \n\nfi;\n}\n\nproctype P_2() { \nbyte pred=0;\n\nNCS: if\n:: next[2] = 255; goto p2; \n\nfi;\np2: if\n::  d_step {pred = tail;tail = 2;}  goto p3; \n\nfi;\np3: if\n:: pred==255; goto CS; \n\n:: pred!=255; goto p4; \n\nfi;\np4: if\n:: locked[2] = 1; goto p5; \n\nfi;\np5: if\n:: next[pred] = 2; goto p6; \n\nfi;\np6: if\n:: locked[2]==0; goto CS; \n\nfi;\nCS: if\n:: next[2]==255; goto p9; \n\n:: next[2]!=255; goto p13; \n\nfi;\np9: if\n::  d_step {tail==2;tail = 255;}  goto NCS; \n\n:: tail!=2; goto p10; \n\nfi;\np13: if\n:: locked[next[2]] = 0; goto NCS; \n\nfi;\np10: if\n:: next[2]!=255; goto p13; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually.\n\nThis is Mellor-Crummey and Scott list-based queue lock using\n    fetch-and-store and compare-and-swap algorithm.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte next[3];\nbyte locked[3];\nbyte tail=255;\n\n\ninit { \n d_step { \nnext[0] =255; next[1] =255; next[2] =255; }\natomic { \nrun P_0();\nrun P_1();\nrun P_2();\n} }\n\nproctype P_0() { \nbyte pred=0;\n\nNCS: if\n:: next[0] = 255; goto p2; \n\nfi;\np2: if\n::  d_step {pred = tail;tail = 0;}  goto p3; \n\nfi;\np3: if\n:: pred==255; goto CS; \n\n:: pred!=255; goto p4; \n\nfi;\np4: if\n:: locked[0] = 1; goto p5; \n\nfi;\np5: if\n:: next[pred] = 0; goto p6; \n\nfi;\np6: if\n:: locked[0]==0; goto CS; \n\nfi;\nCS: if\n:: next[0]==255; goto p9; \n\n:: next[0]!=255; goto p13; \n\nfi;\np9: if\n::  d_step {tail==0;tail = 255;}  goto NCS; \n\n:: tail!=0; goto p10; \n\nfi;\np13: if\n:: locked[0] = 0; goto NCS; \n\nfi;\np10: if\n:: next[0]!=255; goto p13; \n\nfi;\n}\n\nproctype P_1() { \nbyte pred=0;\n\nNCS: if\n:: next[1] = 255; goto p2; \n\nfi;\np2: if\n::  d_step {pred = tail;tail = 1;}  goto p3; \n\nfi;\np3: if\n:: pred==255; goto CS; \n\n:: pred!=255; goto p4; \n\nfi;\np4: if\n:: locked[1] = 1; goto p5; \n\nfi;\np5: if\n:: next[pred] = 1; goto p6; \n\nfi;\np6: if\n:: locked[1]==0; goto CS; \n\nfi;\nCS: if\n:: next[1]==255; goto p9; \n\n:: next[1]!=255; goto p13; \n\nfi;\np9: if\n::  d_step {tail==1;tail = 255;}  goto NCS; \n\n:: tail!=1; goto p10; \n\nfi;\np13: if\n:: locked[1] = 0; goto NCS; \n\nfi;\np10: if\n:: next[1]!=255; goto p13; \n\nfi;\n}\n\nproctype P_2() { \nbyte pred=0;\n\nNCS: if\n:: next[2] = 255; goto p2; \n\nfi;\np2: if\n::  d_step {pred = tail;tail = 2;}  goto p3; \n\nfi;\np3: if\n:: pred==255; goto CS; \n\n:: pred!=255; goto p4; \n\nfi;\np4: if\n:: locked[2] = 1; goto p5; \n\nfi;\np5: if\n:: next[pred] = 2; goto p6; \n\nfi;\np6: if\n:: locked[2]==0; goto CS; \n\nfi;\nCS: if\n:: next[2]==255; goto p9; \n\n:: next[2]!=255; goto p13; \n\nfi;\np9: if\n::  d_step {tail==2;tail = 255;}  goto NCS; \n\n:: tail!=2; goto p10; \n\nfi;\np13: if\n:: locked[2] = 0; goto NCS; \n\nfi;\np10: if\n:: next[2]!=255; goto p13; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually.\n\nThis is Mellor-Crummey and Scott list-based queue lock using\n    fetch-and-store and compare-and-swap algorithm.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte next[4];\nbyte locked[4];\nbyte tail=255;\n\n\ninit { \n d_step { \nnext[0] =255; next[1] =255; next[2] =255; next[3] =255; }\natomic { \nrun P_0();\nrun P_1();\nrun P_2();\nrun P_3();\n} }\n\nproctype P_0() { \nbyte pred=0;\n\nNCS: if\n:: next[0] = 255; goto p2; \n\nfi;\np2: if\n::  d_step {pred = tail;tail = 0;}  goto p3; \n\nfi;\np3: if\n:: pred==255; goto CS; \n\n:: pred!=255; goto p4; \n\nfi;\np4: if\n:: locked[0] = 1; goto p5; \n\nfi;\np5: if\n:: next[pred] = 0; goto p6; \n\nfi;\np6: if\n:: locked[0]==0; goto CS; \n\nfi;\nCS: if\n:: next[0]==255; goto p9; \n\n:: next[0]!=255; goto p13; \n\nfi;\np9: if\n::  d_step {tail==0;tail = 255;}  goto NCS; \n\n:: tail!=0; goto p10; \n\nfi;\np13: if\n:: locked[next[0]] = 0; goto NCS; \n\nfi;\np10: if\n:: next[0]!=255; goto p13; \n\nfi;\n}\n\nproctype P_1() { \nbyte pred=0;\n\nNCS: if\n:: next[1] = 255; goto p2; \n\nfi;\np2: if\n::  d_step {pred = tail;tail = 1;}  goto p3; \n\nfi;\np3: if\n:: pred==255; goto CS; \n\n:: pred!=255; goto p4; \n\nfi;\np4: if\n:: locked[1] = 1; goto p5; \n\nfi;\np5: if\n:: next[pred] = 1; goto p6; \n\nfi;\np6: if\n:: locked[1]==0; goto CS; \n\nfi;\nCS: if\n:: next[1]==255; goto p9; \n\n:: next[1]!=255; goto p13; \n\nfi;\np9: if\n::  d_step {tail==1;tail = 255;}  goto NCS; \n\n:: tail!=1; goto p10; \n\nfi;\np13: if\n:: locked[next[1]] = 0; goto NCS; \n\nfi;\np10: if\n:: next[1]!=255; goto p13; \n\nfi;\n}\n\nproctype P_2() { \nbyte pred=0;\n\nNCS: if\n:: next[2] = 255; goto p2; \n\nfi;\np2: if\n::  d_step {pred = tail;tail = 2;}  goto p3; \n\nfi;\np3: if\n:: pred==255; goto CS; \n\n:: pred!=255; goto p4; \n\nfi;\np4: if\n:: locked[2] = 1; goto p5; \n\nfi;\np5: if\n:: next[pred] = 2; goto p6; \n\nfi;\np6: if\n:: locked[2]==0; goto CS; \n\nfi;\nCS: if\n:: next[2]==255; goto p9; \n\n:: next[2]!=255; goto p13; \n\nfi;\np9: if\n::  d_step {tail==2;tail = 255;}  goto NCS; \n\n:: tail!=2; goto p10; \n\nfi;\np13: if\n:: locked[next[2]] = 0; goto NCS; \n\nfi;\np10: if\n:: next[2]!=255; goto p13; \n\nfi;\n}\n\nproctype P_3() { \nbyte pred=0;\n\nNCS: if\n:: next[3] = 255; goto p2; \n\nfi;\np2: if\n::  d_step {pred = tail;tail = 3;}  goto p3; \n\nfi;\np3: if\n:: pred==255; goto CS; \n\n:: pred!=255; goto p4; \n\nfi;\np4: if\n:: locked[3] = 1; goto p5; \n\nfi;\np5: if\n:: next[pred] = 3; goto p6; \n\nfi;\np6: if\n:: locked[3]==0; goto CS; \n\nfi;\nCS: if\n:: next[3]==255; goto p9; \n\n:: next[3]!=255; goto p13; \n\nfi;\np9: if\n::  d_step {tail==3;tail = 255;}  goto NCS; \n\n:: tail!=3; goto p10; \n\nfi;\np13: if\n:: locked[next[3]] = 0; goto NCS; \n\nfi;\np10: if\n:: next[3]!=255; goto p13; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually.\n\nThis is Mellor-Crummey and Scott list-based queue lock using\n    fetch-and-store and compare-and-swap algorithm.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte next[4];\nbyte locked[4];\nbyte tail=255;\n\n\ninit { \n d_step { \nnext[0] =255; next[1] =255; next[2] =255; next[3] =255; }\natomic { \nrun P_0();\nrun P_1();\nrun P_2();\nrun P_3();\n} }\n\nproctype P_0() { \nbyte pred=0;\n\nNCS: if\n:: next[0] = 255; goto p2; \n\nfi;\np2: if\n::  d_step {pred = tail;tail = 0;}  goto p3; \n\nfi;\np3: if\n:: pred==255; goto CS; \n\n:: pred!=255; goto p4; \n\nfi;\np4: if\n:: locked[0] = 1; goto p5; \n\nfi;\np5: if\n:: next[0] = 0; goto p6; \n\nfi;\np6: if\n:: locked[0]==0; goto CS; \n\nfi;\nCS: if\n:: next[0]==255; goto p9; \n\n:: next[0]!=255; goto p13; \n\nfi;\np9: if\n::  d_step {tail==0;tail = 255;}  goto NCS; \n\n:: tail!=0; goto p10; \n\nfi;\np13: if\n:: locked[next[0]] = 0; goto NCS; \n\nfi;\np10: if\n:: next[0]!=255; goto p13; \n\nfi;\n}\n\nproctype P_1() { \nbyte pred=0;\n\nNCS: if\n:: next[1] = 255; goto p2; \n\nfi;\np2: if\n::  d_step {pred = tail;tail = 1;}  goto p3; \n\nfi;\np3: if\n:: pred==255; goto CS; \n\n:: pred!=255; goto p4; \n\nfi;\np4: if\n:: locked[1] = 1; goto p5; \n\nfi;\np5: if\n:: next[1] = 1; goto p6; \n\nfi;\np6: if\n:: locked[1]==0; goto CS; \n\nfi;\nCS: if\n:: next[1]==255; goto p9; \n\n:: next[1]!=255; goto p13; \n\nfi;\np9: if\n::  d_step {tail==1;tail = 255;}  goto NCS; \n\n:: tail!=1; goto p10; \n\nfi;\np13: if\n:: locked[next[1]] = 0; goto NCS; \n\nfi;\np10: if\n:: next[1]!=255; goto p13; \n\nfi;\n}\n\nproctype P_2() { \nbyte pred=0;\n\nNCS: if\n:: next[2] = 255; goto p2; \n\nfi;\np2: if\n::  d_step {pred = tail;tail = 2;}  goto p3; \n\nfi;\np3: if\n:: pred==255; goto CS; \n\n:: pred!=255; goto p4; \n\nfi;\np4: if\n:: locked[2] = 1; goto p5; \n\nfi;\np5: if\n:: next[2] = 2; goto p6; \n\nfi;\np6: if\n:: locked[2]==0; goto CS; \n\nfi;\nCS: if\n:: next[2]==255; goto p9; \n\n:: next[2]!=255; goto p13; \n\nfi;\np9: if\n::  d_step {tail==2;tail = 255;}  goto NCS; \n\n:: tail!=2; goto p10; \n\nfi;\np13: if\n:: locked[next[2]] = 0; goto NCS; \n\nfi;\np10: if\n:: next[2]!=255; goto p13; \n\nfi;\n}\n\nproctype P_3() { \nbyte pred=0;\n\nNCS: if\n:: next[3] = 255; goto p2; \n\nfi;\np2: if\n::  d_step {pred = tail;tail = 3;}  goto p3; \n\nfi;\np3: if\n:: pred==255; goto CS; \n\n:: pred!=255; goto p4; \n\nfi;\np4: if\n:: locked[3] = 1; goto p5; \n\nfi;\np5: if\n:: next[3] = 3; goto p6; \n\nfi;\np6: if\n:: locked[3]==0; goto CS; \n\nfi;\nCS: if\n:: next[3]==255; goto p9; \n\n:: next[3]!=255; goto p13; \n\nfi;\np9: if\n::  d_step {tail==3;tail = 255;}  goto NCS; \n\n:: tail!=3; goto p10; \n\nfi;\np13: if\n:: locked[next[3]] = 0; goto NCS; \n\nfi;\np10: if\n:: next[3]!=255; goto p13; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually.\n\nThis is Mellor-Crummey and Scott list-based queue lock using\n    fetch-and-store and compare-and-swap algorithm.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte next[5];\nbyte locked[5];\nbyte tail=255;\n\n\ninit { \n d_step { \nnext[0] =255; next[1] =255; next[2] =255; next[3] =255; next[4] =255; }\natomic { \nrun P_0();\nrun P_1();\nrun P_2();\nrun P_3();\nrun P_4();\n} }\n\nproctype P_0() { \nbyte pred=0;\n\nNCS: if\n:: next[0] = 255; goto p2; \n\nfi;\np2: if\n::  d_step {pred = tail;tail = 0;}  goto p3; \n\nfi;\np3: if\n:: pred==255; goto CS; \n\n:: pred!=255; goto p4; \n\nfi;\np4: if\n:: locked[0] = 1; goto p5; \n\nfi;\np5: if\n:: next[pred] = 0; goto p6; \n\nfi;\np6: if\n:: locked[0]==0; goto CS; \n\nfi;\nCS: if\n:: next[0]==255; goto p9; \n\n:: next[0]!=255; goto p13; \n\nfi;\np9: if\n::  d_step {tail==0;tail = 255;}  goto NCS; \n\n:: tail!=0; goto p10; \n\nfi;\np13: if\n:: locked[next[0]] = 0; goto NCS; \n\nfi;\np10: if\n:: next[0]!=255; goto p13; \n\nfi;\n}\n\nproctype P_1() { \nbyte pred=0;\n\nNCS: if\n:: next[1] = 255; goto p2; \n\nfi;\np2: if\n::  d_step {pred = tail;tail = 1;}  goto p3; \n\nfi;\np3: if\n:: pred==255; goto CS; \n\n:: pred!=255; goto p4; \n\nfi;\np4: if\n:: locked[1] = 1; goto p5; \n\nfi;\np5: if\n:: next[pred] = 1; goto p6; \n\nfi;\np6: if\n:: locked[1]==0; goto CS; \n\nfi;\nCS: if\n:: next[1]==255; goto p9; \n\n:: next[1]!=255; goto p13; \n\nfi;\np9: if\n::  d_step {tail==1;tail = 255;}  goto NCS; \n\n:: tail!=1; goto p10; \n\nfi;\np13: if\n:: locked[next[1]] = 0; goto NCS; \n\nfi;\np10: if\n:: next[1]!=255; goto p13; \n\nfi;\n}\n\nproctype P_2() { \nbyte pred=0;\n\nNCS: if\n:: next[2] = 255; goto p2; \n\nfi;\np2: if\n::  d_step {pred = tail;tail = 2;}  goto p3; \n\nfi;\np3: if\n:: pred==255; goto CS; \n\n:: pred!=255; goto p4; \n\nfi;\np4: if\n:: locked[2] = 1; goto p5; \n\nfi;\np5: if\n:: next[pred] = 2; goto p6; \n\nfi;\np6: if\n:: locked[2]==0; goto CS; \n\nfi;\nCS: if\n:: next[2]==255; goto p9; \n\n:: next[2]!=255; goto p13; \n\nfi;\np9: if\n::  d_step {tail==2;tail = 255;}  goto NCS; \n\n:: tail!=2; goto p10; \n\nfi;\np13: if\n:: locked[next[2]] = 0; goto NCS; \n\nfi;\np10: if\n:: next[2]!=255; goto p13; \n\nfi;\n}\n\nproctype P_3() { \nbyte pred=0;\n\nNCS: if\n:: next[3] = 255; goto p2; \n\nfi;\np2: if\n::  d_step {pred = tail;tail = 3;}  goto p3; \n\nfi;\np3: if\n:: pred==255; goto CS; \n\n:: pred!=255; goto p4; \n\nfi;\np4: if\n:: locked[3] = 1; goto p5; \n\nfi;\np5: if\n:: next[pred] = 3; goto p6; \n\nfi;\np6: if\n:: locked[3]==0; goto CS; \n\nfi;\nCS: if\n:: next[3]==255; goto p9; \n\n:: next[3]!=255; goto p13; \n\nfi;\np9: if\n::  d_step {tail==3;tail = 255;}  goto NCS; \n\n:: tail!=3; goto p10; \n\nfi;\np13: if\n:: locked[next[3]] = 0; goto NCS; \n\nfi;\np10: if\n:: next[3]!=255; goto p13; \n\nfi;\n}\n\nproctype P_4() { \nbyte pred=0;\n\nNCS: if\n:: next[4] = 255; goto p2; \n\nfi;\np2: if\n::  d_step {pred = tail;tail = 4;}  goto p3; \n\nfi;\np3: if\n:: pred==255; goto CS; \n\n:: pred!=255; goto p4; \n\nfi;\np4: if\n:: locked[4] = 1; goto p5; \n\nfi;\np5: if\n:: next[pred] = 4; goto p6; \n\nfi;\np6: if\n:: locked[4]==0; goto CS; \n\nfi;\nCS: if\n:: next[4]==255; goto p9; \n\n:: next[4]!=255; goto p13; \n\nfi;\np9: if\n::  d_step {tail==4;tail = 255;}  goto NCS; \n\n:: tail!=4; goto p10; \n\nfi;\np13: if\n:: locked[next[4]] = 0; goto NCS; \n\nfi;\np10: if\n:: next[4]!=255; goto p13; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually.\n\nThis is Mellor-Crummey and Scott list-based queue lock using\n    fetch-and-store and compare-and-swap algorithm.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte next[5];\nbyte locked[5];\nbyte tail=255;\n\n\ninit { \n d_step { \nnext[0] =255; next[1] =255; next[2] =255; next[3] =255; next[4] =255; }\natomic { \nrun P_0();\nrun P_1();\nrun P_2();\nrun P_3();\nrun P_4();\n} }\n\nproctype P_0() { \nbyte pred=0;\n\nNCS: if\n:: next[0] = 255; goto p2; \n\nfi;\np2: if\n::  d_step {pred = tail;tail = 0;}  goto p3; \n\nfi;\np3: if\n:: pred==255; goto CS; \n\n:: pred!=255; goto p4; \n\nfi;\np4: if\n:: locked[0] = 1; goto p5; \n\nfi;\np5: if\n:: next[0] = 0; goto p6; \n\nfi;\np6: if\n:: locked[0]==0; goto CS; \n\nfi;\nCS: if\n:: next[0]==255; goto p9; \n\n:: next[0]!=255; goto p13; \n\nfi;\np9: if\n::  d_step {tail==0;tail = 255;}  goto NCS; \n\n:: tail!=0; goto p10; \n\nfi;\np13: if\n:: locked[next[0]] = 0; goto NCS; \n\nfi;\np10: if\n:: next[0]!=255; goto p13; \n\nfi;\n}\n\nproctype P_1() { \nbyte pred=0;\n\nNCS: if\n:: next[1] = 255; goto p2; \n\nfi;\np2: if\n::  d_step {pred = tail;tail = 1;}  goto p3; \n\nfi;\np3: if\n:: pred==255; goto CS; \n\n:: pred!=255; goto p4; \n\nfi;\np4: if\n:: locked[1] = 1; goto p5; \n\nfi;\np5: if\n:: next[1] = 1; goto p6; \n\nfi;\np6: if\n:: locked[1]==0; goto CS; \n\nfi;\nCS: if\n:: next[1]==255; goto p9; \n\n:: next[1]!=255; goto p13; \n\nfi;\np9: if\n::  d_step {tail==1;tail = 255;}  goto NCS; \n\n:: tail!=1; goto p10; \n\nfi;\np13: if\n:: locked[next[1]] = 0; goto NCS; \n\nfi;\np10: if\n:: next[1]!=255; goto p13; \n\nfi;\n}\n\nproctype P_2() { \nbyte pred=0;\n\nNCS: if\n:: next[2] = 255; goto p2; \n\nfi;\np2: if\n::  d_step {pred = tail;tail = 2;}  goto p3; \n\nfi;\np3: if\n:: pred==255; goto CS; \n\n:: pred!=255; goto p4; \n\nfi;\np4: if\n:: locked[2] = 1; goto p5; \n\nfi;\np5: if\n:: next[2] = 2; goto p6; \n\nfi;\np6: if\n:: locked[2]==0; goto CS; \n\nfi;\nCS: if\n:: next[2]==255; goto p9; \n\n:: next[2]!=255; goto p13; \n\nfi;\np9: if\n::  d_step {tail==2;tail = 255;}  goto NCS; \n\n:: tail!=2; goto p10; \n\nfi;\np13: if\n:: locked[next[2]] = 0; goto NCS; \n\nfi;\np10: if\n:: next[2]!=255; goto p13; \n\nfi;\n}\n\nproctype P_3() { \nbyte pred=0;\n\nNCS: if\n:: next[3] = 255; goto p2; \n\nfi;\np2: if\n::  d_step {pred = tail;tail = 3;}  goto p3; \n\nfi;\np3: if\n:: pred==255; goto CS; \n\n:: pred!=255; goto p4; \n\nfi;\np4: if\n:: locked[3] = 1; goto p5; \n\nfi;\np5: if\n:: next[3] = 3; goto p6; \n\nfi;\np6: if\n:: locked[3]==0; goto CS; \n\nfi;\nCS: if\n:: next[3]==255; goto p9; \n\n:: next[3]!=255; goto p13; \n\nfi;\np9: if\n::  d_step {tail==3;tail = 255;}  goto NCS; \n\n:: tail!=3; goto p10; \n\nfi;\np13: if\n:: locked[next[3]] = 0; goto NCS; \n\nfi;\np10: if\n:: next[3]!=255; goto p13; \n\nfi;\n}\n\nproctype P_4() { \nbyte pred=0;\n\nNCS: if\n:: next[4] = 255; goto p2; \n\nfi;\np2: if\n::  d_step {pred = tail;tail = 4;}  goto p3; \n\nfi;\np3: if\n:: pred==255; goto CS; \n\n:: pred!=255; goto p4; \n\nfi;\np4: if\n:: locked[4] = 1; goto p5; \n\nfi;\np5: if\n:: next[4] = 4; goto p6; \n\nfi;\np6: if\n:: locked[4]==0; goto CS; \n\nfi;\nCS: if\n:: next[4]==255; goto p9; \n\n:: next[4]!=255; goto p13; \n\nfi;\np9: if\n::  d_step {tail==4;tail = 255;}  goto NCS; \n\n:: tail!=4; goto p10; \n\nfi;\np13: if\n:: locked[next[4]] = 0; goto NCS; \n\nfi;\np10: if\n:: next[4]!=255; goto p13; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Multiprocessor Shared-Memory Information Exchange (MSMIE)\n    is a protocol for communication between processors in a real-time control\n    system. The processors are classified as either masters, which perform\n    application-related tasks, or slaves, which provide dedicated functions.\n    This protocol is an extension of readers (masters)/writers (slaves) problem.\n\nParameters:\n\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte b[3];\nbyte readers=0;\nbyte sem=1;\nbyte chnlge_to=0;\n\n\ninit { \n d_step { \nb[0] =0; b[1] =0; b[2] =2; }\natomic { \nrun slave_1();\nrun slave_2();\nrun master_1();\nrun master_2();\nrun master_3();\n} }\n\nproctype slave_1() { \n\nidle: if\n::  d_step {sem==1;sem = 0;}  goto q0; \n\nfi;\nq0: if\n::  d_step {b[0]==1;b[0] = 0;}  goto q1; \n\n::  d_step {b[1]==1;b[1] = 0;}  goto q1; \n\n::  d_step {b[2]==1;b[2] = 0;}  goto q1; \n\n:: b[0]!=1 && b[1]!=1 && b[2]!=1; goto q1; \n\nfi;\nq1: if\n::  d_step {b[0]==2;b[0] = 1;}  goto q2; \n\n::  d_step {b[1]==2;b[1] = 1;}  goto q2; \n\n::  d_step {b[2]==2;b[2] = 1;}  goto q2; \n\n:: b[0]!=2 && b[1]!=2 && b[2]!=2; goto error_state; \n\nfi;\nq2: if\n::  d_step {b[0]==0;b[0] = 2;}  goto q3; \n\n::  d_step {b[1]==0;b[1] = 2;}  goto q3; \n\n::  d_step {b[2]==0;b[2] = 2;}  goto q3; \n\n:: b[0]!=0 && b[1]!=0 && b[2]!=0; goto error_state; \n\nfi;\nq3: if\n:: sem = 1; goto idle; \n\nfi;\nerror_state: \n false; }\n\nproctype slave_2() { \n\nidle: if\n::  d_step {sem==1;sem = 0;}  goto q0; \n\nfi;\nq0: if\n::  d_step {b[0]==1;b[0] = 0;}  goto q1; \n\n::  d_step {b[1]==1;b[1] = 0;}  goto q1; \n\n::  d_step {b[2]==1;b[2] = 0;}  goto q1; \n\n:: b[0]!=1 && b[1]!=1 && b[2]!=1; goto q1; \n\nfi;\nq1: if\n::  d_step {b[0]==2;b[0] = 1;}  goto q2; \n\n::  d_step {b[1]==2;b[1] = 1;}  goto q2; \n\n::  d_step {b[2]==2;b[2] = 1;}  goto q2; \n\n:: b[0]!=2 && b[1]!=2 && b[2]!=2; goto error_state; \n\nfi;\nq2: if\n::  d_step {b[0]==0;b[0] = 2;}  goto q3; \n\n::  d_step {b[1]==0;b[1] = 2;}  goto q3; \n\n::  d_step {b[2]==0;b[2] = 2;}  goto q3; \n\n:: b[0]!=0 && b[1]!=0 && b[2]!=0; goto error_state; \n\nfi;\nq3: if\n:: sem = 1; goto idle; \n\nfi;\nerror_state: \n false; }\n\nproctype master_1() { \n\nidle: if\n::  d_step {sem==1;sem = 0;}  goto q0; \n\nfi;\nq0: if\n:: b[0]==3; goto master; \n\n:: b[1]==3; goto master; \n\n:: b[2]==3; goto master; \n\n:: b[0]!=3 && b[1]!=3 && b[2]!=3; goto no_master; \n\nfi;\nno_master: if\n::  d_step {b[0]==1;b[0] = 3;}  goto master; \n\n::  d_step {b[1]==1;b[1] = 3;}  goto master; \n\n::  d_step {b[2]==1;b[2] = 3;}  goto master; \n\n::  d_step {b[0]!=1 && b[1]!=1 && b[2]!=1;sem = 1;}  goto idle; \n\nfi;\nmaster: if\n::  d_step {readers = readers+1;sem = 1;}  goto reading; \n\nfi;\nreading: if\n::  d_step {sem==1;sem = 0;readers = readers-1;}  goto r0; \n\nfi;\nr0: if\n:: readers==0; goto no_readers; \n\n:: readers>0; goto r1; \n\nfi;\nno_readers: if\n::  d_step {b[0]==1 || b[0]==1 || b[0]==1;chnlge_to = 0;}  goto chnlge; \n\n::  d_step {b[0]!=1 && b[0]!=1 && b[0]!=1;chnlge_to = 1;}  goto chnlge; \n\nfi;\nchnlge: if\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\nfi;\nr1: if\n:: sem = 1; goto idle; \n\nfi;\n}\n\nproctype master_2() { \n\nidle: if\n::  d_step {sem==1;sem = 0;}  goto q0; \n\nfi;\nq0: if\n:: b[0]==3; goto master; \n\n:: b[1]==3; goto master; \n\n:: b[2]==3; goto master; \n\n:: b[0]!=3 && b[1]!=3 && b[2]!=3; goto no_master; \n\nfi;\nno_master: if\n::  d_step {b[0]==1;b[0] = 3;}  goto master; \n\n::  d_step {b[1]==1;b[1] = 3;}  goto master; \n\n::  d_step {b[2]==1;b[2] = 3;}  goto master; \n\n::  d_step {b[0]!=1 && b[1]!=1 && b[2]!=1;sem = 1;}  goto idle; \n\nfi;\nmaster: if\n::  d_step {readers = readers+1;sem = 1;}  goto reading; \n\nfi;\nreading: if\n::  d_step {sem==1;sem = 0;readers = readers-1;}  goto r0; \n\nfi;\nr0: if\n:: readers==0; goto no_readers; \n\n:: readers>0; goto r1; \n\nfi;\nno_readers: if\n::  d_step {b[0]==1 || b[0]==1 || b[0]==1;chnlge_to = 0;}  goto chnlge; \n\n::  d_step {b[0]!=1 && b[0]!=1 && b[0]!=1;chnlge_to = 1;}  goto chnlge; \n\nfi;\nchnlge: if\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\nfi;\nr1: if\n:: sem = 1; goto idle; \n\nfi;\n}\n\nproctype master_3() { \n\nidle: if\n::  d_step {sem==1;sem = 0;}  goto q0; \n\nfi;\nq0: if\n:: b[0]==3; goto master; \n\n:: b[1]==3; goto master; \n\n:: b[2]==3; goto master; \n\n:: b[0]!=3 && b[1]!=3 && b[2]!=3; goto no_master; \n\nfi;\nno_master: if\n::  d_step {b[0]==1;b[0] = 3;}  goto master; \n\n::  d_step {b[1]==1;b[1] = 3;}  goto master; \n\n::  d_step {b[2]==1;b[2] = 3;}  goto master; \n\n::  d_step {b[0]!=1 && b[1]!=1 && b[2]!=1;sem = 1;}  goto idle; \n\nfi;\nmaster: if\n::  d_step {readers = readers+1;sem = 1;}  goto reading; \n\nfi;\nreading: if\n::  d_step {sem==1;sem = 0;readers = readers-1;}  goto r0; \n\nfi;\nr0: if\n:: readers==0; goto no_readers; \n\n:: readers>0; goto r1; \n\nfi;\nno_readers: if\n::  d_step {b[0]==1 || b[0]==1 || b[0]==1;chnlge_to = 0;}  goto chnlge; \n\n::  d_step {b[0]!=1 && b[0]!=1 && b[0]!=1;chnlge_to = 1;}  goto chnlge; \n\nfi;\nchnlge: if\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\nfi;\nr1: if\n:: sem = 1; goto idle; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Multiprocessor Shared-Memory Information Exchange (MSMIE)\n    is a protocol for communication between processors in a real-time control\n    system. The processors are classified as either masters, which perform\n    application-related tasks, or slaves, which provide dedicated functions.\n    This protocol is an extension of readers (masters)/writers (slaves) problem.\n\nParameters:\n\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte b[2];\nbyte readers=0;\nbyte sem=1;\nbyte chnlge_to=0;\n\n\ninit { \n d_step { \nb[0] =0; b[1] =2; }\natomic { \nrun slave_1();\nrun slave_2();\nrun slave_3();\nrun slave_4();\nrun slave_5();\nrun slave_6();\nrun slave_7();\nrun master_1();\nrun master_2();\nrun master_3();\nrun master_4();\nrun master_5();\nrun master_6();\n} }\n\nproctype slave_1() { \n\nidle: if\n::  d_step {sem==1;sem = 0;}  goto q0; \n\nfi;\nq0: if\n::  d_step {b[0]==1;b[0] = 0;}  goto q1; \n\n::  d_step {b[1]==1;b[1] = 0;}  goto q1; \n\n:: b[0]!=1 && b[1]!=1; goto q1; \n\nfi;\nq1: if\n::  d_step {b[0]==2;b[0] = 1;}  goto q2; \n\n::  d_step {b[1]==2;b[1] = 1;}  goto q2; \n\n:: b[0]!=2 && b[1]!=2; goto error_state; \n\nfi;\nq2: if\n::  d_step {b[0]==0;b[0] = 2;}  goto q3; \n\n::  d_step {b[1]==0;b[1] = 2;}  goto q3; \n\n:: b[0]!=0 && b[1]!=0; goto error_state; \n\nfi;\nq3: if\n:: sem = 1; goto idle; \n\nfi;\nerror_state: \n false; }\n\nproctype slave_2() { \n\nidle: if\n::  d_step {sem==1;sem = 0;}  goto q0; \n\nfi;\nq0: if\n::  d_step {b[0]==1;b[0] = 0;}  goto q1; \n\n::  d_step {b[1]==1;b[1] = 0;}  goto q1; \n\n:: b[0]!=1 && b[1]!=1; goto q1; \n\nfi;\nq1: if\n::  d_step {b[0]==2;b[0] = 1;}  goto q2; \n\n::  d_step {b[1]==2;b[1] = 1;}  goto q2; \n\n:: b[0]!=2 && b[1]!=2; goto error_state; \n\nfi;\nq2: if\n::  d_step {b[0]==0;b[0] = 2;}  goto q3; \n\n::  d_step {b[1]==0;b[1] = 2;}  goto q3; \n\n:: b[0]!=0 && b[1]!=0; goto error_state; \n\nfi;\nq3: if\n:: sem = 1; goto idle; \n\nfi;\nerror_state: \n false; }\n\nproctype slave_3() { \n\nidle: if\n::  d_step {sem==1;sem = 0;}  goto q0; \n\nfi;\nq0: if\n::  d_step {b[0]==1;b[0] = 0;}  goto q1; \n\n::  d_step {b[1]==1;b[1] = 0;}  goto q1; \n\n:: b[0]!=1 && b[1]!=1; goto q1; \n\nfi;\nq1: if\n::  d_step {b[0]==2;b[0] = 1;}  goto q2; \n\n::  d_step {b[1]==2;b[1] = 1;}  goto q2; \n\n:: b[0]!=2 && b[1]!=2; goto error_state; \n\nfi;\nq2: if\n::  d_step {b[0]==0;b[0] = 2;}  goto q3; \n\n::  d_step {b[1]==0;b[1] = 2;}  goto q3; \n\n:: b[0]!=0 && b[1]!=0; goto error_state; \n\nfi;\nq3: if\n:: sem = 1; goto idle; \n\nfi;\nerror_state: \n false; }\n\nproctype slave_4() { \n\nidle: if\n::  d_step {sem==1;sem = 0;}  goto q0; \n\nfi;\nq0: if\n::  d_step {b[0]==1;b[0] = 0;}  goto q1; \n\n::  d_step {b[1]==1;b[1] = 0;}  goto q1; \n\n:: b[0]!=1 && b[1]!=1; goto q1; \n\nfi;\nq1: if\n::  d_step {b[0]==2;b[0] = 1;}  goto q2; \n\n::  d_step {b[1]==2;b[1] = 1;}  goto q2; \n\n:: b[0]!=2 && b[1]!=2; goto error_state; \n\nfi;\nq2: if\n::  d_step {b[0]==0;b[0] = 2;}  goto q3; \n\n::  d_step {b[1]==0;b[1] = 2;}  goto q3; \n\n:: b[0]!=0 && b[1]!=0; goto error_state; \n\nfi;\nq3: if\n:: sem = 1; goto idle; \n\nfi;\nerror_state: \n false; }\n\nproctype slave_5() { \n\nidle: if\n::  d_step {sem==1;sem = 0;}  goto q0; \n\nfi;\nq0: if\n::  d_step {b[0]==1;b[0] = 0;}  goto q1; \n\n::  d_step {b[1]==1;b[1] = 0;}  goto q1; \n\n:: b[0]!=1 && b[1]!=1; goto q1; \n\nfi;\nq1: if\n::  d_step {b[0]==2;b[0] = 1;}  goto q2; \n\n::  d_step {b[1]==2;b[1] = 1;}  goto q2; \n\n:: b[0]!=2 && b[1]!=2; goto error_state; \n\nfi;\nq2: if\n::  d_step {b[0]==0;b[0] = 2;}  goto q3; \n\n::  d_step {b[1]==0;b[1] = 2;}  goto q3; \n\n:: b[0]!=0 && b[1]!=0; goto error_state; \n\nfi;\nq3: if\n:: sem = 1; goto idle; \n\nfi;\nerror_state: \n false; }\n\nproctype slave_6() { \n\nidle: if\n::  d_step {sem==1;sem = 0;}  goto q0; \n\nfi;\nq0: if\n::  d_step {b[0]==1;b[0] = 0;}  goto q1; \n\n::  d_step {b[1]==1;b[1] = 0;}  goto q1; \n\n:: b[0]!=1 && b[1]!=1; goto q1; \n\nfi;\nq1: if\n::  d_step {b[0]==2;b[0] = 1;}  goto q2; \n\n::  d_step {b[1]==2;b[1] = 1;}  goto q2; \n\n:: b[0]!=2 && b[1]!=2; goto error_state; \n\nfi;\nq2: if\n::  d_step {b[0]==0;b[0] = 2;}  goto q3; \n\n::  d_step {b[1]==0;b[1] = 2;}  goto q3; \n\n:: b[0]!=0 && b[1]!=0; goto error_state; \n\nfi;\nq3: if\n:: sem = 1; goto idle; \n\nfi;\nerror_state: \n false; }\n\nproctype slave_7() { \n\nidle: if\n::  d_step {sem==1;sem = 0;}  goto q0; \n\nfi;\nq0: if\n::  d_step {b[0]==1;b[0] = 0;}  goto q1; \n\n::  d_step {b[1]==1;b[1] = 0;}  goto q1; \n\n:: b[0]!=1 && b[1]!=1; goto q1; \n\nfi;\nq1: if\n::  d_step {b[0]==2;b[0] = 1;}  goto q2; \n\n::  d_step {b[1]==2;b[1] = 1;}  goto q2; \n\n:: b[0]!=2 && b[1]!=2; goto error_state; \n\nfi;\nq2: if\n::  d_step {b[0]==0;b[0] = 2;}  goto q3; \n\n::  d_step {b[1]==0;b[1] = 2;}  goto q3; \n\n:: b[0]!=0 && b[1]!=0; goto error_state; \n\nfi;\nq3: if\n:: sem = 1; goto idle; \n\nfi;\nerror_state: \n false; }\n\nproctype master_1() { \n\nidle: if\n::  d_step {sem==1;sem = 0;}  goto q0; \n\nfi;\nq0: if\n:: b[0]==3; goto master; \n\n:: b[1]==3; goto master; \n\n:: b[0]!=3 && b[1]!=3; goto no_master; \n\nfi;\nno_master: if\n::  d_step {b[0]==1;b[0] = 3;}  goto master; \n\n::  d_step {b[1]==1;b[1] = 3;}  goto master; \n\n::  d_step {b[0]!=1 && b[1]!=1;sem = 1;}  goto idle; \n\nfi;\nmaster: if\n::  d_step {readers = readers+1;sem = 1;}  goto reading; \n\nfi;\nreading: if\n::  d_step {sem==1;sem = 0;readers = readers-1;}  goto r0; \n\nfi;\nr0: if\n:: readers==0; goto no_readers; \n\n:: readers>0; goto r1; \n\nfi;\nno_readers: if\n::  d_step {b[0]==1 || b[0]==1;chnlge_to = 0;}  goto chnlge; \n\n::  d_step {b[0]!=1 && b[0]!=1;chnlge_to = 1;}  goto chnlge; \n\nfi;\nchnlge: if\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\nfi;\nr1: if\n:: sem = 1; goto idle; \n\nfi;\n}\n\nproctype master_2() { \n\nidle: if\n::  d_step {sem==1;sem = 0;}  goto q0; \n\nfi;\nq0: if\n:: b[0]==3; goto master; \n\n:: b[1]==3; goto master; \n\n:: b[0]!=3 && b[1]!=3; goto no_master; \n\nfi;\nno_master: if\n::  d_step {b[0]==1;b[0] = 3;}  goto master; \n\n::  d_step {b[1]==1;b[1] = 3;}  goto master; \n\n::  d_step {b[0]!=1 && b[1]!=1;sem = 1;}  goto idle; \n\nfi;\nmaster: if\n::  d_step {readers = readers+1;sem = 1;}  goto reading; \n\nfi;\nreading: if\n::  d_step {sem==1;sem = 0;readers = readers-1;}  goto r0; \n\nfi;\nr0: if\n:: readers==0; goto no_readers; \n\n:: readers>0; goto r1; \n\nfi;\nno_readers: if\n::  d_step {b[0]==1 || b[0]==1;chnlge_to = 0;}  goto chnlge; \n\n::  d_step {b[0]!=1 && b[0]!=1;chnlge_to = 1;}  goto chnlge; \n\nfi;\nchnlge: if\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\nfi;\nr1: if\n:: sem = 1; goto idle; \n\nfi;\n}\n\nproctype master_3() { \n\nidle: if\n::  d_step {sem==1;sem = 0;}  goto q0; \n\nfi;\nq0: if\n:: b[0]==3; goto master; \n\n:: b[1]==3; goto master; \n\n:: b[0]!=3 && b[1]!=3; goto no_master; \n\nfi;\nno_master: if\n::  d_step {b[0]==1;b[0] = 3;}  goto master; \n\n::  d_step {b[1]==1;b[1] = 3;}  goto master; \n\n::  d_step {b[0]!=1 && b[1]!=1;sem = 1;}  goto idle; \n\nfi;\nmaster: if\n::  d_step {readers = readers+1;sem = 1;}  goto reading; \n\nfi;\nreading: if\n::  d_step {sem==1;sem = 0;readers = readers-1;}  goto r0; \n\nfi;\nr0: if\n:: readers==0; goto no_readers; \n\n:: readers>0; goto r1; \n\nfi;\nno_readers: if\n::  d_step {b[0]==1 || b[0]==1;chnlge_to = 0;}  goto chnlge; \n\n::  d_step {b[0]!=1 && b[0]!=1;chnlge_to = 1;}  goto chnlge; \n\nfi;\nchnlge: if\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\nfi;\nr1: if\n:: sem = 1; goto idle; \n\nfi;\n}\n\nproctype master_4() { \n\nidle: if\n::  d_step {sem==1;sem = 0;}  goto q0; \n\nfi;\nq0: if\n:: b[0]==3; goto master; \n\n:: b[1]==3; goto master; \n\n:: b[0]!=3 && b[1]!=3; goto no_master; \n\nfi;\nno_master: if\n::  d_step {b[0]==1;b[0] = 3;}  goto master; \n\n::  d_step {b[1]==1;b[1] = 3;}  goto master; \n\n::  d_step {b[0]!=1 && b[1]!=1;sem = 1;}  goto idle; \n\nfi;\nmaster: if\n::  d_step {readers = readers+1;sem = 1;}  goto reading; \n\nfi;\nreading: if\n::  d_step {sem==1;sem = 0;readers = readers-1;}  goto r0; \n\nfi;\nr0: if\n:: readers==0; goto no_readers; \n\n:: readers>0; goto r1; \n\nfi;\nno_readers: if\n::  d_step {b[0]==1 || b[0]==1;chnlge_to = 0;}  goto chnlge; \n\n::  d_step {b[0]!=1 && b[0]!=1;chnlge_to = 1;}  goto chnlge; \n\nfi;\nchnlge: if\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\nfi;\nr1: if\n:: sem = 1; goto idle; \n\nfi;\n}\n\nproctype master_5() { \n\nidle: if\n::  d_step {sem==1;sem = 0;}  goto q0; \n\nfi;\nq0: if\n:: b[0]==3; goto master; \n\n:: b[1]==3; goto master; \n\n:: b[0]!=3 && b[1]!=3; goto no_master; \n\nfi;\nno_master: if\n::  d_step {b[0]==1;b[0] = 3;}  goto master; \n\n::  d_step {b[1]==1;b[1] = 3;}  goto master; \n\n::  d_step {b[0]!=1 && b[1]!=1;sem = 1;}  goto idle; \n\nfi;\nmaster: if\n::  d_step {readers = readers+1;sem = 1;}  goto reading; \n\nfi;\nreading: if\n::  d_step {sem==1;sem = 0;readers = readers-1;}  goto r0; \n\nfi;\nr0: if\n:: readers==0; goto no_readers; \n\n:: readers>0; goto r1; \n\nfi;\nno_readers: if\n::  d_step {b[0]==1 || b[0]==1;chnlge_to = 0;}  goto chnlge; \n\n::  d_step {b[0]!=1 && b[0]!=1;chnlge_to = 1;}  goto chnlge; \n\nfi;\nchnlge: if\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\nfi;\nr1: if\n:: sem = 1; goto idle; \n\nfi;\n}\n\nproctype master_6() { \n\nidle: if\n::  d_step {sem==1;sem = 0;}  goto q0; \n\nfi;\nq0: if\n:: b[0]==3; goto master; \n\n:: b[1]==3; goto master; \n\n:: b[0]!=3 && b[1]!=3; goto no_master; \n\nfi;\nno_master: if\n::  d_step {b[0]==1;b[0] = 3;}  goto master; \n\n::  d_step {b[1]==1;b[1] = 3;}  goto master; \n\n::  d_step {b[0]!=1 && b[1]!=1;sem = 1;}  goto idle; \n\nfi;\nmaster: if\n::  d_step {readers = readers+1;sem = 1;}  goto reading; \n\nfi;\nreading: if\n::  d_step {sem==1;sem = 0;readers = readers-1;}  goto r0; \n\nfi;\nr0: if\n:: readers==0; goto no_readers; \n\n:: readers>0; goto r1; \n\nfi;\nno_readers: if\n::  d_step {b[0]==1 || b[0]==1;chnlge_to = 0;}  goto chnlge; \n\n::  d_step {b[0]!=1 && b[0]!=1;chnlge_to = 1;}  goto chnlge; \n\nfi;\nchnlge: if\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\nfi;\nr1: if\n:: sem = 1; goto idle; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Multiprocessor Shared-Memory Information Exchange (MSMIE)\n    is a protocol for communication between processors in a real-time control\n    system. The processors are classified as either masters, which perform\n    application-related tasks, or slaves, which provide dedicated functions.\n    This protocol is an extension of readers (masters)/writers (slaves) problem.\n\nParameters:\n\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte b[4];\nbyte readers=0;\nbyte sem=1;\nbyte chnlge_to=0;\n\n\ninit { \n d_step { \nb[0] =0; b[1] =0; b[2] =0; b[3] =2; }\natomic { \nrun slave_1();\nrun slave_2();\nrun slave_3();\nrun slave_4();\nrun slave_5();\nrun slave_6();\nrun slave_7();\nrun master_1();\nrun master_2();\nrun master_3();\nrun master_4();\nrun master_5();\nrun master_6();\n} }\n\nproctype slave_1() { \n\nidle: if\n::  d_step {sem==1;sem = 0;}  goto q0; \n\nfi;\nq0: if\n::  d_step {b[0]==1;b[0] = 0;}  goto q1; \n\n::  d_step {b[1]==1;b[1] = 0;}  goto q1; \n\n::  d_step {b[2]==1;b[2] = 0;}  goto q1; \n\n::  d_step {b[3]==1;b[3] = 0;}  goto q1; \n\n:: b[0]!=1 && b[1]!=1 && b[2]!=1 && b[3]!=1; goto q1; \n\nfi;\nq1: if\n::  d_step {b[0]==2;b[0] = 1;}  goto q2; \n\n::  d_step {b[1]==2;b[1] = 1;}  goto q2; \n\n::  d_step {b[2]==2;b[2] = 1;}  goto q2; \n\n::  d_step {b[3]==2;b[3] = 1;}  goto q2; \n\n:: b[0]!=2 && b[1]!=2 && b[2]!=2 && b[3]!=2; goto error_state; \n\nfi;\nq2: if\n::  d_step {b[0]==0;b[0] = 2;}  goto q3; \n\n::  d_step {b[1]==0;b[1] = 2;}  goto q3; \n\n::  d_step {b[2]==0;b[2] = 2;}  goto q3; \n\n::  d_step {b[3]==0;b[3] = 2;}  goto q3; \n\n:: b[0]!=0 && b[1]!=0 && b[2]!=0 && b[3]!=0; goto error_state; \n\nfi;\nq3: if\n:: sem = 1; goto idle; \n\nfi;\nerror_state: \n false; }\n\nproctype slave_2() { \n\nidle: if\n::  d_step {sem==1;sem = 0;}  goto q0; \n\nfi;\nq0: if\n::  d_step {b[0]==1;b[0] = 0;}  goto q1; \n\n::  d_step {b[1]==1;b[1] = 0;}  goto q1; \n\n::  d_step {b[2]==1;b[2] = 0;}  goto q1; \n\n::  d_step {b[3]==1;b[3] = 0;}  goto q1; \n\n:: b[0]!=1 && b[1]!=1 && b[2]!=1 && b[3]!=1; goto q1; \n\nfi;\nq1: if\n::  d_step {b[0]==2;b[0] = 1;}  goto q2; \n\n::  d_step {b[1]==2;b[1] = 1;}  goto q2; \n\n::  d_step {b[2]==2;b[2] = 1;}  goto q2; \n\n::  d_step {b[3]==2;b[3] = 1;}  goto q2; \n\n:: b[0]!=2 && b[1]!=2 && b[2]!=2 && b[3]!=2; goto error_state; \n\nfi;\nq2: if\n::  d_step {b[0]==0;b[0] = 2;}  goto q3; \n\n::  d_step {b[1]==0;b[1] = 2;}  goto q3; \n\n::  d_step {b[2]==0;b[2] = 2;}  goto q3; \n\n::  d_step {b[3]==0;b[3] = 2;}  goto q3; \n\n:: b[0]!=0 && b[1]!=0 && b[2]!=0 && b[3]!=0; goto error_state; \n\nfi;\nq3: if\n:: sem = 1; goto idle; \n\nfi;\nerror_state: \n false; }\n\nproctype slave_3() { \n\nidle: if\n::  d_step {sem==1;sem = 0;}  goto q0; \n\nfi;\nq0: if\n::  d_step {b[0]==1;b[0] = 0;}  goto q1; \n\n::  d_step {b[1]==1;b[1] = 0;}  goto q1; \n\n::  d_step {b[2]==1;b[2] = 0;}  goto q1; \n\n::  d_step {b[3]==1;b[3] = 0;}  goto q1; \n\n:: b[0]!=1 && b[1]!=1 && b[2]!=1 && b[3]!=1; goto q1; \n\nfi;\nq1: if\n::  d_step {b[0]==2;b[0] = 1;}  goto q2; \n\n::  d_step {b[1]==2;b[1] = 1;}  goto q2; \n\n::  d_step {b[2]==2;b[2] = 1;}  goto q2; \n\n::  d_step {b[3]==2;b[3] = 1;}  goto q2; \n\n:: b[0]!=2 && b[1]!=2 && b[2]!=2 && b[3]!=2; goto error_state; \n\nfi;\nq2: if\n::  d_step {b[0]==0;b[0] = 2;}  goto q3; \n\n::  d_step {b[1]==0;b[1] = 2;}  goto q3; \n\n::  d_step {b[2]==0;b[2] = 2;}  goto q3; \n\n::  d_step {b[3]==0;b[3] = 2;}  goto q3; \n\n:: b[0]!=0 && b[1]!=0 && b[2]!=0 && b[3]!=0; goto error_state; \n\nfi;\nq3: if\n:: sem = 1; goto idle; \n\nfi;\nerror_state: \n false; }\n\nproctype slave_4() { \n\nidle: if\n::  d_step {sem==1;sem = 0;}  goto q0; \n\nfi;\nq0: if\n::  d_step {b[0]==1;b[0] = 0;}  goto q1; \n\n::  d_step {b[1]==1;b[1] = 0;}  goto q1; \n\n::  d_step {b[2]==1;b[2] = 0;}  goto q1; \n\n::  d_step {b[3]==1;b[3] = 0;}  goto q1; \n\n:: b[0]!=1 && b[1]!=1 && b[2]!=1 && b[3]!=1; goto q1; \n\nfi;\nq1: if\n::  d_step {b[0]==2;b[0] = 1;}  goto q2; \n\n::  d_step {b[1]==2;b[1] = 1;}  goto q2; \n\n::  d_step {b[2]==2;b[2] = 1;}  goto q2; \n\n::  d_step {b[3]==2;b[3] = 1;}  goto q2; \n\n:: b[0]!=2 && b[1]!=2 && b[2]!=2 && b[3]!=2; goto error_state; \n\nfi;\nq2: if\n::  d_step {b[0]==0;b[0] = 2;}  goto q3; \n\n::  d_step {b[1]==0;b[1] = 2;}  goto q3; \n\n::  d_step {b[2]==0;b[2] = 2;}  goto q3; \n\n::  d_step {b[3]==0;b[3] = 2;}  goto q3; \n\n:: b[0]!=0 && b[1]!=0 && b[2]!=0 && b[3]!=0; goto error_state; \n\nfi;\nq3: if\n:: sem = 1; goto idle; \n\nfi;\nerror_state: \n false; }\n\nproctype slave_5() { \n\nidle: if\n::  d_step {sem==1;sem = 0;}  goto q0; \n\nfi;\nq0: if\n::  d_step {b[0]==1;b[0] = 0;}  goto q1; \n\n::  d_step {b[1]==1;b[1] = 0;}  goto q1; \n\n::  d_step {b[2]==1;b[2] = 0;}  goto q1; \n\n::  d_step {b[3]==1;b[3] = 0;}  goto q1; \n\n:: b[0]!=1 && b[1]!=1 && b[2]!=1 && b[3]!=1; goto q1; \n\nfi;\nq1: if\n::  d_step {b[0]==2;b[0] = 1;}  goto q2; \n\n::  d_step {b[1]==2;b[1] = 1;}  goto q2; \n\n::  d_step {b[2]==2;b[2] = 1;}  goto q2; \n\n::  d_step {b[3]==2;b[3] = 1;}  goto q2; \n\n:: b[0]!=2 && b[1]!=2 && b[2]!=2 && b[3]!=2; goto error_state; \n\nfi;\nq2: if\n::  d_step {b[0]==0;b[0] = 2;}  goto q3; \n\n::  d_step {b[1]==0;b[1] = 2;}  goto q3; \n\n::  d_step {b[2]==0;b[2] = 2;}  goto q3; \n\n::  d_step {b[3]==0;b[3] = 2;}  goto q3; \n\n:: b[0]!=0 && b[1]!=0 && b[2]!=0 && b[3]!=0; goto error_state; \n\nfi;\nq3: if\n:: sem = 1; goto idle; \n\nfi;\nerror_state: \n false; }\n\nproctype slave_6() { \n\nidle: if\n::  d_step {sem==1;sem = 0;}  goto q0; \n\nfi;\nq0: if\n::  d_step {b[0]==1;b[0] = 0;}  goto q1; \n\n::  d_step {b[1]==1;b[1] = 0;}  goto q1; \n\n::  d_step {b[2]==1;b[2] = 0;}  goto q1; \n\n::  d_step {b[3]==1;b[3] = 0;}  goto q1; \n\n:: b[0]!=1 && b[1]!=1 && b[2]!=1 && b[3]!=1; goto q1; \n\nfi;\nq1: if\n::  d_step {b[0]==2;b[0] = 1;}  goto q2; \n\n::  d_step {b[1]==2;b[1] = 1;}  goto q2; \n\n::  d_step {b[2]==2;b[2] = 1;}  goto q2; \n\n::  d_step {b[3]==2;b[3] = 1;}  goto q2; \n\n:: b[0]!=2 && b[1]!=2 && b[2]!=2 && b[3]!=2; goto error_state; \n\nfi;\nq2: if\n::  d_step {b[0]==0;b[0] = 2;}  goto q3; \n\n::  d_step {b[1]==0;b[1] = 2;}  goto q3; \n\n::  d_step {b[2]==0;b[2] = 2;}  goto q3; \n\n::  d_step {b[3]==0;b[3] = 2;}  goto q3; \n\n:: b[0]!=0 && b[1]!=0 && b[2]!=0 && b[3]!=0; goto error_state; \n\nfi;\nq3: if\n:: sem = 1; goto idle; \n\nfi;\nerror_state: \n false; }\n\nproctype slave_7() { \n\nidle: if\n::  d_step {sem==1;sem = 0;}  goto q0; \n\nfi;\nq0: if\n::  d_step {b[0]==1;b[0] = 0;}  goto q1; \n\n::  d_step {b[1]==1;b[1] = 0;}  goto q1; \n\n::  d_step {b[2]==1;b[2] = 0;}  goto q1; \n\n::  d_step {b[3]==1;b[3] = 0;}  goto q1; \n\n:: b[0]!=1 && b[1]!=1 && b[2]!=1 && b[3]!=1; goto q1; \n\nfi;\nq1: if\n::  d_step {b[0]==2;b[0] = 1;}  goto q2; \n\n::  d_step {b[1]==2;b[1] = 1;}  goto q2; \n\n::  d_step {b[2]==2;b[2] = 1;}  goto q2; \n\n::  d_step {b[3]==2;b[3] = 1;}  goto q2; \n\n:: b[0]!=2 && b[1]!=2 && b[2]!=2 && b[3]!=2; goto error_state; \n\nfi;\nq2: if\n::  d_step {b[0]==0;b[0] = 2;}  goto q3; \n\n::  d_step {b[1]==0;b[1] = 2;}  goto q3; \n\n::  d_step {b[2]==0;b[2] = 2;}  goto q3; \n\n::  d_step {b[3]==0;b[3] = 2;}  goto q3; \n\n:: b[0]!=0 && b[1]!=0 && b[2]!=0 && b[3]!=0; goto error_state; \n\nfi;\nq3: if\n:: sem = 1; goto idle; \n\nfi;\nerror_state: \n false; }\n\nproctype master_1() { \n\nidle: if\n::  d_step {sem==1;sem = 0;}  goto q0; \n\nfi;\nq0: if\n:: b[0]==3; goto master; \n\n:: b[1]==3; goto master; \n\n:: b[2]==3; goto master; \n\n:: b[3]==3; goto master; \n\n:: b[0]!=3 && b[1]!=3 && b[2]!=3 && b[3]!=3; goto no_master; \n\nfi;\nno_master: if\n::  d_step {b[0]==1;b[0] = 3;}  goto master; \n\n::  d_step {b[1]==1;b[1] = 3;}  goto master; \n\n::  d_step {b[2]==1;b[2] = 3;}  goto master; \n\n::  d_step {b[3]==1;b[3] = 3;}  goto master; \n\n::  d_step {b[0]!=1 && b[1]!=1 && b[2]!=1 && b[3]!=1;sem = 1;}  goto idle; \n\nfi;\nmaster: if\n::  d_step {readers = readers+1;sem = 1;}  goto reading; \n\nfi;\nreading: if\n::  d_step {sem==1;sem = 0;readers = readers-1;}  goto r0; \n\nfi;\nr0: if\n:: readers==0; goto no_readers; \n\n:: readers>0; goto r1; \n\nfi;\nno_readers: if\n::  d_step {b[0]==1 || b[0]==1 || b[0]==1 || b[0]==1;chnlge_to = 0;}  goto chnlge; \n\n::  d_step {b[0]!=1 && b[0]!=1 && b[0]!=1 && b[0]!=1;chnlge_to = 1;}  goto chnlge; \n\nfi;\nchnlge: if\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\nfi;\nr1: if\n:: sem = 1; goto idle; \n\nfi;\n}\n\nproctype master_2() { \n\nidle: if\n::  d_step {sem==1;sem = 0;}  goto q0; \n\nfi;\nq0: if\n:: b[0]==3; goto master; \n\n:: b[1]==3; goto master; \n\n:: b[2]==3; goto master; \n\n:: b[3]==3; goto master; \n\n:: b[0]!=3 && b[1]!=3 && b[2]!=3 && b[3]!=3; goto no_master; \n\nfi;\nno_master: if\n::  d_step {b[0]==1;b[0] = 3;}  goto master; \n\n::  d_step {b[1]==1;b[1] = 3;}  goto master; \n\n::  d_step {b[2]==1;b[2] = 3;}  goto master; \n\n::  d_step {b[3]==1;b[3] = 3;}  goto master; \n\n::  d_step {b[0]!=1 && b[1]!=1 && b[2]!=1 && b[3]!=1;sem = 1;}  goto idle; \n\nfi;\nmaster: if\n::  d_step {readers = readers+1;sem = 1;}  goto reading; \n\nfi;\nreading: if\n::  d_step {sem==1;sem = 0;readers = readers-1;}  goto r0; \n\nfi;\nr0: if\n:: readers==0; goto no_readers; \n\n:: readers>0; goto r1; \n\nfi;\nno_readers: if\n::  d_step {b[0]==1 || b[0]==1 || b[0]==1 || b[0]==1;chnlge_to = 0;}  goto chnlge; \n\n::  d_step {b[0]!=1 && b[0]!=1 && b[0]!=1 && b[0]!=1;chnlge_to = 1;}  goto chnlge; \n\nfi;\nchnlge: if\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\nfi;\nr1: if\n:: sem = 1; goto idle; \n\nfi;\n}\n\nproctype master_3() { \n\nidle: if\n::  d_step {sem==1;sem = 0;}  goto q0; \n\nfi;\nq0: if\n:: b[0]==3; goto master; \n\n:: b[1]==3; goto master; \n\n:: b[2]==3; goto master; \n\n:: b[3]==3; goto master; \n\n:: b[0]!=3 && b[1]!=3 && b[2]!=3 && b[3]!=3; goto no_master; \n\nfi;\nno_master: if\n::  d_step {b[0]==1;b[0] = 3;}  goto master; \n\n::  d_step {b[1]==1;b[1] = 3;}  goto master; \n\n::  d_step {b[2]==1;b[2] = 3;}  goto master; \n\n::  d_step {b[3]==1;b[3] = 3;}  goto master; \n\n::  d_step {b[0]!=1 && b[1]!=1 && b[2]!=1 && b[3]!=1;sem = 1;}  goto idle; \n\nfi;\nmaster: if\n::  d_step {readers = readers+1;sem = 1;}  goto reading; \n\nfi;\nreading: if\n::  d_step {sem==1;sem = 0;readers = readers-1;}  goto r0; \n\nfi;\nr0: if\n:: readers==0; goto no_readers; \n\n:: readers>0; goto r1; \n\nfi;\nno_readers: if\n::  d_step {b[0]==1 || b[0]==1 || b[0]==1 || b[0]==1;chnlge_to = 0;}  goto chnlge; \n\n::  d_step {b[0]!=1 && b[0]!=1 && b[0]!=1 && b[0]!=1;chnlge_to = 1;}  goto chnlge; \n\nfi;\nchnlge: if\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\nfi;\nr1: if\n:: sem = 1; goto idle; \n\nfi;\n}\n\nproctype master_4() { \n\nidle: if\n::  d_step {sem==1;sem = 0;}  goto q0; \n\nfi;\nq0: if\n:: b[0]==3; goto master; \n\n:: b[1]==3; goto master; \n\n:: b[2]==3; goto master; \n\n:: b[3]==3; goto master; \n\n:: b[0]!=3 && b[1]!=3 && b[2]!=3 && b[3]!=3; goto no_master; \n\nfi;\nno_master: if\n::  d_step {b[0]==1;b[0] = 3;}  goto master; \n\n::  d_step {b[1]==1;b[1] = 3;}  goto master; \n\n::  d_step {b[2]==1;b[2] = 3;}  goto master; \n\n::  d_step {b[3]==1;b[3] = 3;}  goto master; \n\n::  d_step {b[0]!=1 && b[1]!=1 && b[2]!=1 && b[3]!=1;sem = 1;}  goto idle; \n\nfi;\nmaster: if\n::  d_step {readers = readers+1;sem = 1;}  goto reading; \n\nfi;\nreading: if\n::  d_step {sem==1;sem = 0;readers = readers-1;}  goto r0; \n\nfi;\nr0: if\n:: readers==0; goto no_readers; \n\n:: readers>0; goto r1; \n\nfi;\nno_readers: if\n::  d_step {b[0]==1 || b[0]==1 || b[0]==1 || b[0]==1;chnlge_to = 0;}  goto chnlge; \n\n::  d_step {b[0]!=1 && b[0]!=1 && b[0]!=1 && b[0]!=1;chnlge_to = 1;}  goto chnlge; \n\nfi;\nchnlge: if\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\nfi;\nr1: if\n:: sem = 1; goto idle; \n\nfi;\n}\n\nproctype master_5() { \n\nidle: if\n::  d_step {sem==1;sem = 0;}  goto q0; \n\nfi;\nq0: if\n:: b[0]==3; goto master; \n\n:: b[1]==3; goto master; \n\n:: b[2]==3; goto master; \n\n:: b[3]==3; goto master; \n\n:: b[0]!=3 && b[1]!=3 && b[2]!=3 && b[3]!=3; goto no_master; \n\nfi;\nno_master: if\n::  d_step {b[0]==1;b[0] = 3;}  goto master; \n\n::  d_step {b[1]==1;b[1] = 3;}  goto master; \n\n::  d_step {b[2]==1;b[2] = 3;}  goto master; \n\n::  d_step {b[3]==1;b[3] = 3;}  goto master; \n\n::  d_step {b[0]!=1 && b[1]!=1 && b[2]!=1 && b[3]!=1;sem = 1;}  goto idle; \n\nfi;\nmaster: if\n::  d_step {readers = readers+1;sem = 1;}  goto reading; \n\nfi;\nreading: if\n::  d_step {sem==1;sem = 0;readers = readers-1;}  goto r0; \n\nfi;\nr0: if\n:: readers==0; goto no_readers; \n\n:: readers>0; goto r1; \n\nfi;\nno_readers: if\n::  d_step {b[0]==1 || b[0]==1 || b[0]==1 || b[0]==1;chnlge_to = 0;}  goto chnlge; \n\n::  d_step {b[0]!=1 && b[0]!=1 && b[0]!=1 && b[0]!=1;chnlge_to = 1;}  goto chnlge; \n\nfi;\nchnlge: if\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\nfi;\nr1: if\n:: sem = 1; goto idle; \n\nfi;\n}\n\nproctype master_6() { \n\nidle: if\n::  d_step {sem==1;sem = 0;}  goto q0; \n\nfi;\nq0: if\n:: b[0]==3; goto master; \n\n:: b[1]==3; goto master; \n\n:: b[2]==3; goto master; \n\n:: b[3]==3; goto master; \n\n:: b[0]!=3 && b[1]!=3 && b[2]!=3 && b[3]!=3; goto no_master; \n\nfi;\nno_master: if\n::  d_step {b[0]==1;b[0] = 3;}  goto master; \n\n::  d_step {b[1]==1;b[1] = 3;}  goto master; \n\n::  d_step {b[2]==1;b[2] = 3;}  goto master; \n\n::  d_step {b[3]==1;b[3] = 3;}  goto master; \n\n::  d_step {b[0]!=1 && b[1]!=1 && b[2]!=1 && b[3]!=1;sem = 1;}  goto idle; \n\nfi;\nmaster: if\n::  d_step {readers = readers+1;sem = 1;}  goto reading; \n\nfi;\nreading: if\n::  d_step {sem==1;sem = 0;readers = readers-1;}  goto r0; \n\nfi;\nr0: if\n:: readers==0; goto no_readers; \n\n:: readers>0; goto r1; \n\nfi;\nno_readers: if\n::  d_step {b[0]==1 || b[0]==1 || b[0]==1 || b[0]==1;chnlge_to = 0;}  goto chnlge; \n\n::  d_step {b[0]!=1 && b[0]!=1 && b[0]!=1 && b[0]!=1;chnlge_to = 1;}  goto chnlge; \n\nfi;\nchnlge: if\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\n::  d_step {b[0]==3;b[0] = chnlge_to;}  goto r1; \n\nfi;\nr1: if\n:: sem = 1; goto idle; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The aim of the protocol is to establish mutual\n    authentication between an initiator and responder, after which some session\n    involving the exchange of messages between them can take place.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "chan net_N_P_P =[0] of {int};\nchan net_N_N_P =[0] of {int};\nchan net_N_P =[0] of {int};\n\nactive proctype initiator_0() { \nint m=0;\nint party_nonce=0;\n\nstart: if\n:: net_N_P_P!((1)+(7)*15+(10*15*15)); goto wait_resp; \n\nfi;\nwait_resp: if\n:: net_N_N_P?m; goto got_resp; \n\nfi;\ngot_resp: if\n::  d_step {((m)%15)==1 && ((m)/(15*15))==7;party_nonce = (((m)%(15*15))/15);}  goto commited; \n\n::  ! (((m)%15)==1 && ((m)/(15*15))==7); goto corrupted; \n\nfi;\ncommited: if\n:: net_N_P!((party_nonce)+(10)*15+(0*15*15)); goto finished; \n\nfi;\nfinished: \ncorrupted: \n false; }\n\nactive proctype responder_0() { \nint m=0;\nint party=0;\nint party_nonce=0;\n\nstart: if\n:: net_N_P_P?m; goto got_msg; \n\nfi;\ngot_msg: if\n::  d_step {((m)/(15*15))==10;party = (((m)%(15*15))/15);party_nonce = ((m)%15);}  goto send_reply; \n\n::  ! (((m)/(15*15))==10); goto corrupted; \n\nfi;\nsend_reply: if\n:: net_N_N_P!((party_nonce)+(4)*15+(party*15*15)); goto wait_resp; \n\nfi;\nwait_resp: if\n:: net_N_P?m; goto got_resp; \n\nfi;\ngot_resp: if\n::  ! (((m)%15)==4 && (((m)%(15*15))/15)==10); goto corrupted; \n\n:: ((m)%15)==4 && (((m)%(15*15))/15)==10; goto finished; \n\nfi;\nfinished: \ncorrupted: \n false; }\n\nactive proctype intruder() { \nbyte kNa=0;\nbyte kNb=0;\nbyte k_Na_Nb__A=0;\nbyte k_Na_A__B=0;\nbyte k_Nb__B=0;\nint m=0;\n\nq: if\n:: net_N_N_P?m; goto got3; \n\n:: net_N_P_P?m; goto got3; \n\n:: net_N_P?m; goto got2; \n\n:: net_N_P_P!((13)+(7)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((13)+(10)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((13)+(1)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((7)+(7)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((7)+(10)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((7)+(1)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((10)+(7)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((10)+(10)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((10)+(1)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((1)+(7)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((1)+(10)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((1)+(1)*15+(10*15*15)); goto q; \n\n::  atomic {kNa==1;net_N_N_P!((1)+(1)*15+(7*15*15));}  goto q; \n\n::  atomic {kNa==1 && kNb==1 || k_Na_Nb__A==1;net_N_N_P!((1)+(4)*15+(7*15*15));}  goto q; \n\n::  atomic {kNa==1;net_N_N_P!((1)+(13)*15+(7*15*15));}  goto q; \n\n::  atomic {kNa==1;net_N_P_P!((1)+(7)*15+(7*15*15));}  goto q; \n\n::  atomic {kNa==1;net_N_P_P!((1)+(10)*15+(7*15*15));}  goto q; \n\n::  atomic {kNa==1;net_N_P_P!((1)+(1)*15+(7*15*15));}  goto q; \n\n::  atomic {kNa==1 || k_Na_A__B;net_N_P_P!((1)+(7)*15+(10*15*15));}  goto q; \n\n::  atomic {kNa==1;net_N_P_P!((1)+(10)*15+(10*15*15));}  goto q; \n\n::  atomic {kNa==1;net_N_P_P!((1)+(1)*15+(10*15*15));}  goto q; \n\n::  atomic {kNb==1;net_N_P_P!((4)+(7)*15+(10*15*15));}  goto q; \n\n::  atomic {kNb==1;net_N_P_P!((4)+(10)*15+(10*15*15));}  goto q; \n\n::  atomic {kNb==1;net_N_P_P!((4)+(1)*15+(10*15*15));}  goto q; \n\n::  atomic {kNb==1 || k_Nb__B==1;net_N_P!((4)+(10)*15+(0*15*15));}  goto q; \n\nfi;\ngot3: if\n::  goto q; \n\n:: ((m)/(15*15))==1; goto c1; \n\n:: ((m)/(15*15))!=1; goto d1; \n\nfi;\nc1: if\n::  d_step {((m)%15)==1;kNa = 1;}  goto c2; \n\n::  d_step {((m)%15)==4;kNb = 1;}  goto c2; \n\n:: ((m)%15)!=1 && ((m)%15)!=4; goto c2; \n\nfi;\nc2: if\n::  d_step {((m)%15)==4 && (((m)%(15*15))/15)==10;k_Nb__B = 1;}  goto q; \n\n::  ! (((m)%15)==4 && (((m)%(15*15))/15)==10); goto q; \n\nfi;\nd1: if\n::  d_step {((m)%15)==1 && (((m)%(15*15))/15)==7 && ((m)/(15*15))==10;k_Na_A__B = 1;}  goto q; \n\n::  d_step {((m)%15)==1 && (((m)%(15*15))/15)==4 && ((m)/(15*15))==7;k_Na_Nb__A = 1;}  goto q; \n\n::  goto q; \n\nfi;\ngot2: if\n:: (((m)%(15*15))/15)==1; goto e1; \n\n:: (((m)%(15*15))/15)!=1; goto f1; \n\nfi;\ne1: if\n::  d_step {((m)%15)==1;kNa = 1;}  goto q; \n\n::  d_step {((m)%15)==4;kNb = 1;}  goto q; \n\n:: ((m)%15)!=1 && ((m)%15)!=4; goto q; \n\nfi;\nf1: if\n::  d_step {((m)%15)==4 && (((m)%(15*15))/15)==10;k_Nb__B = 1;}  goto q; \n\n::  ! (((m)%15)==4 && (((m)%(15*15))/15)==10); goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The aim of the protocol is to establish mutual\n    authentication between an initiator and responder, after which some session\n    involving the exchange of messages between them can take place.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "chan net_N_P_P =[0] of {int};\nchan net_N_N_P =[0] of {int};\nchan net_N_P =[0] of {int};\n\nactive proctype initiator_0() { \nint m=0;\nint party_nonce=0;\n\nstart: if\n:: net_N_P_P!((1)+(7)*15+(10*15*15)); goto wait_resp; \n\nfi;\nwait_resp: if\n:: net_N_N_P?m; goto got_resp; \n\nfi;\ngot_resp: if\n::  d_step {((m)%15)==1 && ((m)/(15*15))==7;party_nonce = (((m)%(15*15))/15);}  goto commited; \n\n::  ! (((m)%15)==1 && ((m)/(15*15))==7); goto corrupted; \n\nfi;\ncommited: if\n:: net_N_P!((party_nonce)+(10)*15+(0*15*15)); goto finished; \n\nfi;\nfinished: \ncorrupted: \n false; }\n\nactive proctype initiator_1() { \nint m=0;\nint party_nonce=0;\n\nstart: if\n:: net_N_P_P!((2)+(8)*15+(11*15*15)); goto wait_resp; \n\nfi;\nwait_resp: if\n:: net_N_N_P?m; goto got_resp; \n\nfi;\ngot_resp: if\n::  d_step {((m)%15)==2 && ((m)/(15*15))==8;party_nonce = (((m)%(15*15))/15);}  goto commited; \n\n::  ! (((m)%15)==2 && ((m)/(15*15))==8); goto corrupted; \n\nfi;\ncommited: if\n:: net_N_P!((party_nonce)+(11)*15+(0*15*15)); goto finished; \n\nfi;\nfinished: \ncorrupted: \n false; }\n\nactive proctype responder_0() { \nint m=0;\nint party=0;\nint party_nonce=0;\n\nstart: if\n:: net_N_P_P?m; goto got_msg; \n\nfi;\ngot_msg: if\n::  d_step {((m)/(15*15))==10;party = (((m)%(15*15))/15);party_nonce = ((m)%15);}  goto send_reply; \n\n::  ! (((m)/(15*15))==10); goto corrupted; \n\nfi;\nsend_reply: if\n:: net_N_N_P!((party_nonce)+(4)*15+(party*15*15)); goto wait_resp; \n\nfi;\nwait_resp: if\n:: net_N_P?m; goto got_resp; \n\nfi;\ngot_resp: if\n::  ! (((m)%15)==4 && (((m)%(15*15))/15)==10); goto corrupted; \n\n:: ((m)%15)==4 && (((m)%(15*15))/15)==10; goto finished; \n\nfi;\nfinished: \ncorrupted: \n false; }\n\nactive proctype responder_1() { \nint m=0;\nint party=0;\nint party_nonce=0;\n\nstart: if\n:: net_N_P_P?m; goto got_msg; \n\nfi;\ngot_msg: if\n::  d_step {((m)/(15*15))==11;party = (((m)%(15*15))/15);party_nonce = ((m)%15);}  goto send_reply; \n\n::  ! (((m)/(15*15))==11); goto corrupted; \n\nfi;\nsend_reply: if\n:: net_N_N_P!((party_nonce)+(5)*15+(party*15*15)); goto wait_resp; \n\nfi;\nwait_resp: if\n:: net_N_P?m; goto got_resp; \n\nfi;\ngot_resp: if\n::  ! (((m)%15)==5 && (((m)%(15*15))/15)==11); goto corrupted; \n\n:: ((m)%15)==5 && (((m)%(15*15))/15)==11; goto finished; \n\nfi;\nfinished: \ncorrupted: \n false; }\n\nactive proctype intruder() { \nbyte kNa=0;\nbyte kNb=0;\nbyte k_Na_Nb__A=0;\nbyte k_Na_A__B=0;\nbyte k_Nb__B=0;\nint m=0;\n\nq: if\n:: net_N_N_P?m; goto got3; \n\n:: net_N_P_P?m; goto got3; \n\n:: net_N_P?m; goto got2; \n\n:: net_N_P_P!((13)+(7)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((13)+(10)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((13)+(2)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((7)+(7)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((7)+(10)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((7)+(2)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((10)+(7)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((10)+(10)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((10)+(2)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((2)+(7)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((2)+(10)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((2)+(2)*15+(10*15*15)); goto q; \n\n::  atomic {kNa==1;net_N_N_P!((1)+(1)*15+(7*15*15));}  goto q; \n\n::  atomic {kNa==1 && kNb==1 || k_Na_Nb__A==1;net_N_N_P!((1)+(4)*15+(7*15*15));}  goto q; \n\n::  atomic {kNa==1;net_N_N_P!((1)+(13)*15+(7*15*15));}  goto q; \n\n::  atomic {kNa==1;net_N_P_P!((1)+(7)*15+(7*15*15));}  goto q; \n\n::  atomic {kNa==1;net_N_P_P!((1)+(10)*15+(7*15*15));}  goto q; \n\n::  atomic {kNa==1;net_N_P_P!((1)+(2)*15+(7*15*15));}  goto q; \n\n::  atomic {kNa==1 || k_Na_A__B;net_N_P_P!((1)+(7)*15+(10*15*15));}  goto q; \n\n::  atomic {kNa==1;net_N_P_P!((1)+(10)*15+(10*15*15));}  goto q; \n\n::  atomic {kNa==1;net_N_P_P!((1)+(2)*15+(10*15*15));}  goto q; \n\n::  atomic {kNb==1;net_N_P_P!((4)+(7)*15+(10*15*15));}  goto q; \n\n::  atomic {kNb==1;net_N_P_P!((4)+(10)*15+(10*15*15));}  goto q; \n\n::  atomic {kNb==1;net_N_P_P!((4)+(2)*15+(10*15*15));}  goto q; \n\n::  atomic {kNb==1 || k_Nb__B==1;net_N_P!((4)+(10)*15+(0*15*15));}  goto q; \n\nfi;\ngot3: if\n::  goto q; \n\n:: ((m)/(15*15))==2; goto c1; \n\n:: ((m)/(15*15))!=2; goto d1; \n\nfi;\nc1: if\n::  d_step {((m)%15)==1;kNa = 1;}  goto c2; \n\n::  d_step {((m)%15)==4;kNb = 1;}  goto c2; \n\n:: ((m)%15)!=1 && ((m)%15)!=4; goto c2; \n\nfi;\nc2: if\n::  d_step {((m)%15)==4 && (((m)%(15*15))/15)==10;k_Nb__B = 1;}  goto q; \n\n::  ! (((m)%15)==4 && (((m)%(15*15))/15)==10); goto q; \n\nfi;\nd1: if\n::  d_step {((m)%15)==1 && (((m)%(15*15))/15)==7 && ((m)/(15*15))==10;k_Na_A__B = 1;}  goto q; \n\n::  d_step {((m)%15)==1 && (((m)%(15*15))/15)==4 && ((m)/(15*15))==7;k_Na_Nb__A = 1;}  goto q; \n\n::  goto q; \n\nfi;\ngot2: if\n:: (((m)%(15*15))/15)==2; goto e1; \n\n:: (((m)%(15*15))/15)!=2; goto f1; \n\nfi;\ne1: if\n::  d_step {((m)%15)==1;kNa = 1;}  goto q; \n\n::  d_step {((m)%15)==4;kNb = 1;}  goto q; \n\n:: ((m)%15)!=1 && ((m)%15)!=4; goto q; \n\nfi;\nf1: if\n::  d_step {((m)%15)==4 && (((m)%(15*15))/15)==10;k_Nb__B = 1;}  goto q; \n\n::  ! (((m)%15)==4 && (((m)%(15*15))/15)==10); goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The aim of the protocol is to establish mutual\n    authentication between an initiator and responder, after which some session\n    involving the exchange of messages between them can take place.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "chan net_N_P_P =[0] of {int};\nchan net_N_N_P =[0] of {int};\nchan net_N_P =[0] of {int};\n\nactive proctype initiator_0() { \nint m=0;\nint party_nonce=0;\n\nstart: if\n:: net_N_P_P!((1)+(7)*15+(10*15*15)); goto wait_resp; \n\nfi;\nwait_resp: if\n:: net_N_N_P?m; goto got_resp; \n\nfi;\ngot_resp: if\n::  d_step {((m)%15)==1 && ((m)/(15*15))==7;party_nonce = (((m)%(15*15))/15);}  goto commited; \n\n::  ! (((m)%15)==1 && ((m)/(15*15))==7); goto corrupted; \n\nfi;\ncommited: if\n:: net_N_P!((party_nonce)+(10)*15+(0*15*15)); goto finished; \n\nfi;\nfinished: \ncorrupted: \n false; }\n\nactive proctype initiator_1() { \nint m=0;\nint party_nonce=0;\n\nstart: if\n:: net_N_P_P!((2)+(8)*15+(11*15*15)); goto wait_resp; \n\nfi;\nwait_resp: if\n:: net_N_N_P?m; goto got_resp; \n\nfi;\ngot_resp: if\n::  d_step {((m)%15)==2 && ((m)/(15*15))==8;party_nonce = (((m)%(15*15))/15);}  goto commited; \n\n::  ! (((m)%15)==2 && ((m)/(15*15))==8); goto corrupted; \n\nfi;\ncommited: if\n:: net_N_P!((party_nonce)+(11)*15+(0*15*15)); goto finished; \n\nfi;\nfinished: \ncorrupted: \n false; }\n\nactive proctype initiator_2() { \nint m=0;\nint party_nonce=0;\n\nstart: if\n:: net_N_P_P!((3)+(9)*15+(12*15*15)); goto wait_resp; \n\nfi;\nwait_resp: if\n:: net_N_N_P?m; goto got_resp; \n\nfi;\ngot_resp: if\n::  d_step {((m)%15)==3 && ((m)/(15*15))==9;party_nonce = (((m)%(15*15))/15);}  goto commited; \n\n::  ! (((m)%15)==3 && ((m)/(15*15))==9); goto corrupted; \n\nfi;\ncommited: if\n:: net_N_P!((party_nonce)+(12)*15+(0*15*15)); goto finished; \n\nfi;\nfinished: \ncorrupted: \n false; }\n\nactive proctype responder_0() { \nint m=0;\nint party=0;\nint party_nonce=0;\n\nstart: if\n:: net_N_P_P?m; goto got_msg; \n\nfi;\ngot_msg: if\n::  d_step {((m)/(15*15))==10;party = (((m)%(15*15))/15);party_nonce = ((m)%15);}  goto send_reply; \n\n::  ! (((m)/(15*15))==10); goto corrupted; \n\nfi;\nsend_reply: if\n:: net_N_N_P!((party_nonce)+(4)*15+(party*15*15)); goto wait_resp; \n\nfi;\nwait_resp: if\n:: net_N_P?m; goto got_resp; \n\nfi;\ngot_resp: if\n::  ! (((m)%15)==4 && (((m)%(15*15))/15)==10); goto corrupted; \n\n:: ((m)%15)==4 && (((m)%(15*15))/15)==10; goto finished; \n\nfi;\nfinished: \ncorrupted: \n false; }\n\nactive proctype responder_1() { \nint m=0;\nint party=0;\nint party_nonce=0;\n\nstart: if\n:: net_N_P_P?m; goto got_msg; \n\nfi;\ngot_msg: if\n::  d_step {((m)/(15*15))==11;party = (((m)%(15*15))/15);party_nonce = ((m)%15);}  goto send_reply; \n\n::  ! (((m)/(15*15))==11); goto corrupted; \n\nfi;\nsend_reply: if\n:: net_N_N_P!((party_nonce)+(5)*15+(party*15*15)); goto wait_resp; \n\nfi;\nwait_resp: if\n:: net_N_P?m; goto got_resp; \n\nfi;\ngot_resp: if\n::  ! (((m)%15)==5 && (((m)%(15*15))/15)==11); goto corrupted; \n\n:: ((m)%15)==5 && (((m)%(15*15))/15)==11; goto finished; \n\nfi;\nfinished: \ncorrupted: \n false; }\n\nactive proctype intruder() { \nbyte kNa=0;\nbyte kNb=0;\nbyte k_Na_Nb__A=0;\nbyte k_Na_A__B=0;\nbyte k_Nb__B=0;\nint m=0;\n\nq: if\n:: net_N_N_P?m; goto got3; \n\n:: net_N_P_P?m; goto got3; \n\n:: net_N_P?m; goto got2; \n\n:: net_N_P_P!((13)+(7)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((13)+(10)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((13)+(3)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((7)+(7)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((7)+(10)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((7)+(3)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((10)+(7)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((10)+(10)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((10)+(3)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((3)+(7)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((3)+(10)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((3)+(3)*15+(10*15*15)); goto q; \n\n::  atomic {kNa==1;net_N_N_P!((1)+(1)*15+(7*15*15));}  goto q; \n\n::  atomic {kNa==1 && kNb==1 || k_Na_Nb__A==1;net_N_N_P!((1)+(4)*15+(7*15*15));}  goto q; \n\n::  atomic {kNa==1;net_N_N_P!((1)+(13)*15+(7*15*15));}  goto q; \n\n::  atomic {kNa==1;net_N_P_P!((1)+(7)*15+(7*15*15));}  goto q; \n\n::  atomic {kNa==1;net_N_P_P!((1)+(10)*15+(7*15*15));}  goto q; \n\n::  atomic {kNa==1;net_N_P_P!((1)+(3)*15+(7*15*15));}  goto q; \n\n::  atomic {kNa==1 || k_Na_A__B;net_N_P_P!((1)+(7)*15+(10*15*15));}  goto q; \n\n::  atomic {kNa==1;net_N_P_P!((1)+(10)*15+(10*15*15));}  goto q; \n\n::  atomic {kNa==1;net_N_P_P!((1)+(3)*15+(10*15*15));}  goto q; \n\n::  atomic {kNb==1;net_N_P_P!((4)+(7)*15+(10*15*15));}  goto q; \n\n::  atomic {kNb==1;net_N_P_P!((4)+(10)*15+(10*15*15));}  goto q; \n\n::  atomic {kNb==1;net_N_P_P!((4)+(3)*15+(10*15*15));}  goto q; \n\n::  atomic {kNb==1 || k_Nb__B==1;net_N_P!((4)+(10)*15+(0*15*15));}  goto q; \n\nfi;\ngot3: if\n::  goto q; \n\n:: ((m)/(15*15))==3; goto c1; \n\n:: ((m)/(15*15))!=3; goto d1; \n\nfi;\nc1: if\n::  d_step {((m)%15)==1;kNa = 1;}  goto c2; \n\n::  d_step {((m)%15)==4;kNb = 1;}  goto c2; \n\n:: ((m)%15)!=1 && ((m)%15)!=4; goto c2; \n\nfi;\nc2: if\n::  d_step {((m)%15)==4 && (((m)%(15*15))/15)==10;k_Nb__B = 1;}  goto q; \n\n::  ! (((m)%15)==4 && (((m)%(15*15))/15)==10); goto q; \n\nfi;\nd1: if\n::  d_step {((m)%15)==1 && (((m)%(15*15))/15)==7 && ((m)/(15*15))==10;k_Na_A__B = 1;}  goto q; \n\n::  d_step {((m)%15)==1 && (((m)%(15*15))/15)==4 && ((m)/(15*15))==7;k_Na_Nb__A = 1;}  goto q; \n\n::  goto q; \n\nfi;\ngot2: if\n:: (((m)%(15*15))/15)==3; goto e1; \n\n:: (((m)%(15*15))/15)!=3; goto f1; \n\nfi;\ne1: if\n::  d_step {((m)%15)==1;kNa = 1;}  goto q; \n\n::  d_step {((m)%15)==4;kNb = 1;}  goto q; \n\n:: ((m)%15)!=1 && ((m)%15)!=4; goto q; \n\nfi;\nf1: if\n::  d_step {((m)%15)==4 && (((m)%(15*15))/15)==10;k_Nb__B = 1;}  goto q; \n\n::  ! (((m)%15)==4 && (((m)%(15*15))/15)==10); goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The aim of the protocol is to establish mutual\n    authentication between an initiator and responder, after which some session\n    involving the exchange of messages between them can take place.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "chan net_N_P_P =[0] of {int};\nchan net_N_N_P =[0] of {int};\nchan net_N_P =[0] of {int};\n\nactive proctype initiator_0() { \nint m=0;\nint party_nonce=0;\n\nstart: if\n:: net_N_P_P!((1)+(7)*15+(10*15*15)); goto wait_resp; \n\nfi;\nwait_resp: if\n:: net_N_N_P?m; goto got_resp; \n\nfi;\ngot_resp: if\n::  d_step {((m)%15)==1 && ((m)/(15*15))==7;party_nonce = (((m)%(15*15))/15);}  goto commited; \n\n::  ! (((m)%15)==1 && ((m)/(15*15))==7); goto corrupted; \n\nfi;\ncommited: if\n:: net_N_P!((party_nonce)+(10)*15+(0*15*15)); goto finished; \n\nfi;\nfinished: \ncorrupted: \n false; }\n\nactive proctype initiator_1() { \nint m=0;\nint party_nonce=0;\n\nstart: if\n:: net_N_P_P!((2)+(8)*15+(11*15*15)); goto wait_resp; \n\nfi;\nwait_resp: if\n:: net_N_N_P?m; goto got_resp; \n\nfi;\ngot_resp: if\n::  d_step {((m)%15)==2 && ((m)/(15*15))==8;party_nonce = (((m)%(15*15))/15);}  goto commited; \n\n::  ! (((m)%15)==2 && ((m)/(15*15))==8); goto corrupted; \n\nfi;\ncommited: if\n:: net_N_P!((party_nonce)+(11)*15+(0*15*15)); goto finished; \n\nfi;\nfinished: \ncorrupted: \n false; }\n\nactive proctype initiator_2() { \nint m=0;\nint party_nonce=0;\n\nstart: if\n:: net_N_P_P!((3)+(9)*15+(12*15*15)); goto wait_resp; \n\nfi;\nwait_resp: if\n:: net_N_N_P?m; goto got_resp; \n\nfi;\ngot_resp: if\n::  d_step {((m)%15)==3 && ((m)/(15*15))==9;party_nonce = (((m)%(15*15))/15);}  goto commited; \n\n::  ! (((m)%15)==3 && ((m)/(15*15))==9); goto corrupted; \n\nfi;\ncommited: if\n:: net_N_P!((party_nonce)+(12)*15+(0*15*15)); goto finished; \n\nfi;\nfinished: \ncorrupted: \n false; }\n\nactive proctype responder_0() { \nint m=0;\nint party=0;\nint party_nonce=0;\n\nstart: if\n:: net_N_P_P?m; goto got_msg; \n\nfi;\ngot_msg: if\n::  d_step {((m)/(15*15))==10;party = (((m)%(15*15))/15);party_nonce = ((m)%15);}  goto send_reply; \n\n::  ! (((m)/(15*15))==10); goto corrupted; \n\nfi;\nsend_reply: if\n:: net_N_N_P!((party_nonce)+(4)*15+(party*15*15)); goto wait_resp; \n\nfi;\nwait_resp: if\n:: net_N_P?m; goto got_resp; \n\nfi;\ngot_resp: if\n::  ! (((m)%15)==4 && (((m)%(15*15))/15)==10); goto corrupted; \n\n:: ((m)%15)==4 && (((m)%(15*15))/15)==10; goto finished; \n\nfi;\nfinished: \ncorrupted: \n false; }\n\nactive proctype responder_1() { \nint m=0;\nint party=0;\nint party_nonce=0;\n\nstart: if\n:: net_N_P_P?m; goto got_msg; \n\nfi;\ngot_msg: if\n::  d_step {((m)/(15*15))==11;party = (((m)%(15*15))/15);party_nonce = ((m)%15);}  goto send_reply; \n\n::  ! (((m)/(15*15))==11); goto corrupted; \n\nfi;\nsend_reply: if\n:: net_N_N_P!((party_nonce)+(5)*15+(party*15*15)); goto wait_resp; \n\nfi;\nwait_resp: if\n:: net_N_P?m; goto got_resp; \n\nfi;\ngot_resp: if\n::  ! (((m)%15)==5 && (((m)%(15*15))/15)==11); goto corrupted; \n\n:: ((m)%15)==5 && (((m)%(15*15))/15)==11; goto finished; \n\nfi;\nfinished: \ncorrupted: \n false; }\n\nactive proctype responder_2() { \nint m=0;\nint party=0;\nint party_nonce=0;\n\nstart: if\n:: net_N_P_P?m; goto got_msg; \n\nfi;\ngot_msg: if\n::  d_step {((m)/(15*15))==12;party = (((m)%(15*15))/15);party_nonce = ((m)%15);}  goto send_reply; \n\n::  ! (((m)/(15*15))==12); goto corrupted; \n\nfi;\nsend_reply: if\n:: net_N_N_P!((party_nonce)+(6)*15+(party*15*15)); goto wait_resp; \n\nfi;\nwait_resp: if\n:: net_N_P?m; goto got_resp; \n\nfi;\ngot_resp: if\n::  ! (((m)%15)==6 && (((m)%(15*15))/15)==12); goto corrupted; \n\n:: ((m)%15)==6 && (((m)%(15*15))/15)==12; goto finished; \n\nfi;\nfinished: \ncorrupted: \n false; }\n\nactive proctype intruder() { \nbyte kNa=0;\nbyte kNb=0;\nbyte k_Na_Nb__A=0;\nbyte k_Na_A__B=0;\nbyte k_Nb__B=0;\nint m=0;\n\nq: if\n:: net_N_N_P?m; goto got3; \n\n:: net_N_P_P?m; goto got3; \n\n:: net_N_P?m; goto got2; \n\n:: net_N_P_P!((13)+(7)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((13)+(10)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((13)+(3)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((7)+(7)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((7)+(10)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((7)+(3)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((10)+(7)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((10)+(10)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((10)+(3)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((3)+(7)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((3)+(10)*15+(10*15*15)); goto q; \n\n:: net_N_P_P!((3)+(3)*15+(10*15*15)); goto q; \n\n::  atomic {kNa==1;net_N_N_P!((1)+(1)*15+(7*15*15));}  goto q; \n\n::  atomic {kNa==1 && kNb==1 || k_Na_Nb__A==1;net_N_N_P!((1)+(4)*15+(7*15*15));}  goto q; \n\n::  atomic {kNa==1;net_N_N_P!((1)+(13)*15+(7*15*15));}  goto q; \n\n::  atomic {kNa==1;net_N_P_P!((1)+(7)*15+(7*15*15));}  goto q; \n\n::  atomic {kNa==1;net_N_P_P!((1)+(10)*15+(7*15*15));}  goto q; \n\n::  atomic {kNa==1;net_N_P_P!((1)+(3)*15+(7*15*15));}  goto q; \n\n::  atomic {kNa==1 || k_Na_A__B;net_N_P_P!((1)+(7)*15+(10*15*15));}  goto q; \n\n::  atomic {kNa==1;net_N_P_P!((1)+(10)*15+(10*15*15));}  goto q; \n\n::  atomic {kNa==1;net_N_P_P!((1)+(3)*15+(10*15*15));}  goto q; \n\n::  atomic {kNb==1;net_N_P_P!((4)+(7)*15+(10*15*15));}  goto q; \n\n::  atomic {kNb==1;net_N_P_P!((4)+(10)*15+(10*15*15));}  goto q; \n\n::  atomic {kNb==1;net_N_P_P!((4)+(3)*15+(10*15*15));}  goto q; \n\n::  atomic {kNb==1 || k_Nb__B==1;net_N_P!((4)+(10)*15+(0*15*15));}  goto q; \n\nfi;\ngot3: if\n::  goto q; \n\n:: ((m)/(15*15))==3; goto c1; \n\n:: ((m)/(15*15))!=3; goto d1; \n\nfi;\nc1: if\n::  d_step {((m)%15)==1;kNa = 1;}  goto c2; \n\n::  d_step {((m)%15)==4;kNb = 1;}  goto c2; \n\n:: ((m)%15)!=1 && ((m)%15)!=4; goto c2; \n\nfi;\nc2: if\n::  d_step {((m)%15)==4 && (((m)%(15*15))/15)==10;k_Nb__B = 1;}  goto q; \n\n::  ! (((m)%15)==4 && (((m)%(15*15))/15)==10); goto q; \n\nfi;\nd1: if\n::  d_step {((m)%15)==1 && (((m)%(15*15))/15)==7 && ((m)/(15*15))==10;k_Na_A__B = 1;}  goto q; \n\n::  d_step {((m)%15)==1 && (((m)%(15*15))/15)==4 && ((m)/(15*15))==7;k_Na_Nb__A = 1;}  goto q; \n\n::  goto q; \n\nfi;\ngot2: if\n:: (((m)%(15*15))/15)==3; goto e1; \n\n:: (((m)%(15*15))/15)!=3; goto f1; \n\nfi;\ne1: if\n::  d_step {((m)%15)==1;kNa = 1;}  goto q; \n\n::  d_step {((m)%15)==4;kNb = 1;}  goto q; \n\n:: ((m)%15)!=1 && ((m)%15)!=4; goto q; \n\nfi;\nf1: if\n::  d_step {((m)%15)==4 && (((m)%(15*15))/15)==10;k_Nb__B = 1;}  goto q; \n\n::  ! (((m)%15)==4 && (((m)%(15*15))/15)==10); goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Peg solitaire is an old board game for one player. The\n    basic rules are the following: A game board with 33 holes in cross form is given. 32 pegs are in. The centre\n    hole is empty. You have to remove the pegs one after the other by jumping\n    horizontally or vertically over one. In the end one peg should be left. We\n    can of course consider different variants (different boards, allow crossway\n    jumps).\n\nParameters:\n\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte a[16];\nbyte peg_count=15;\n\n\ninit { \n d_step { \na[0] =1; a[1] =1; a[2] =1; a[3] =1; a[4] =1; a[5] =1; a[6] =1; a[7] =1; a[8] =1; a[9] =1; a[10] =1; a[11] =1; a[12] =1; a[13] =1; a[14] =1; a[15] =0; }\natomic { \nrun P();\n} }\n\nproctype P() { \n\nq: if\n::  d_step {a[((0)*4+0)]==1 && a[((0+1)*4+0+1)]==1 && a[((0+2)*4+0+2)]==0;a[((0)*4+0)] = 0;a[((0+1)*4+0+1)] = 0;a[((0+2)*4+0+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((0)*4+1)]==1 && a[((0+1)*4+1+1)]==1 && a[((0+2)*4+1+2)]==0;a[((0)*4+1)] = 0;a[((0+1)*4+1+1)] = 0;a[((0+2)*4+1+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*4+0)]==1 && a[((1+1)*4+0+1)]==1 && a[((1+2)*4+0+2)]==0;a[((1)*4+0)] = 0;a[((1+1)*4+0+1)] = 0;a[((1+2)*4+0+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*4+1)]==1 && a[((1+1)*4+1+1)]==1 && a[((1+2)*4+1+2)]==0;a[((1)*4+1)] = 0;a[((1+1)*4+1+1)] = 0;a[((1+2)*4+1+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*4+0)]==1 && a[((2-1)*4+0+1)]==1 && a[((2-2)*4+0+2)]==0;a[((2)*4+0)] = 0;a[((2-1)*4+0+1)] = 0;a[((2-2)*4+0+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*4+1)]==1 && a[((2-1)*4+1+1)]==1 && a[((2-2)*4+1+2)]==0;a[((2)*4+1)] = 0;a[((2-1)*4+1+1)] = 0;a[((2-2)*4+1+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*4+0)]==1 && a[((3-1)*4+0+1)]==1 && a[((3-2)*4+0+2)]==0;a[((3)*4+0)] = 0;a[((3-1)*4+0+1)] = 0;a[((3-2)*4+0+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*4+1)]==1 && a[((3-1)*4+1+1)]==1 && a[((3-2)*4+1+2)]==0;a[((3)*4+1)] = 0;a[((3-1)*4+1+1)] = 0;a[((3-2)*4+1+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((0)*4+2)]==1 && a[((0+1)*4+2-1)]==1 && a[((0+2)*4+2-2)]==0;a[((0)*4+2)] = 0;a[((0+1)*4+2-1)] = 0;a[((0+2)*4+2-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((0)*4+3)]==1 && a[((0+1)*4+3-1)]==1 && a[((0+2)*4+3-2)]==0;a[((0)*4+3)] = 0;a[((0+1)*4+3-1)] = 0;a[((0+2)*4+3-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*4+2)]==1 && a[((1+1)*4+2-1)]==1 && a[((1+2)*4+2-2)]==0;a[((1)*4+2)] = 0;a[((1+1)*4+2-1)] = 0;a[((1+2)*4+2-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*4+3)]==1 && a[((1+1)*4+3-1)]==1 && a[((1+2)*4+3-2)]==0;a[((1)*4+3)] = 0;a[((1+1)*4+3-1)] = 0;a[((1+2)*4+3-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*4+2)]==1 && a[((2-1)*4+2-1)]==1 && a[((2-2)*4+2-2)]==0;a[((2)*4+2)] = 0;a[((2-1)*4+2-1)] = 0;a[((2-2)*4+2-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*4+3)]==1 && a[((2-1)*4+3-1)]==1 && a[((2-2)*4+3-2)]==0;a[((2)*4+3)] = 0;a[((2-1)*4+3-1)] = 0;a[((2-2)*4+3-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*4+2)]==1 && a[((3-1)*4+2-1)]==1 && a[((3-2)*4+2-2)]==0;a[((3)*4+2)] = 0;a[((3-1)*4+2-1)] = 0;a[((3-2)*4+2-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*4+3)]==1 && a[((3-1)*4+3-1)]==1 && a[((3-2)*4+3-2)]==0;a[((3)*4+3)] = 0;a[((3-1)*4+3-1)] = 0;a[((3-2)*4+3-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((0)*4+0)]==1 && a[((0)*4+0+1)]==1 && a[((0)*4+0+2)]==0;a[((0)*4+0)] = 0;a[((0)*4+0+1)] = 0;a[((0)*4+0+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((0)*4+1)]==1 && a[((0)*4+1+1)]==1 && a[((0)*4+1+2)]==0;a[((0)*4+1)] = 0;a[((0)*4+1+1)] = 0;a[((0)*4+1+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*4+0)]==1 && a[((1)*4+0+1)]==1 && a[((1)*4+0+2)]==0;a[((1)*4+0)] = 0;a[((1)*4+0+1)] = 0;a[((1)*4+0+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*4+1)]==1 && a[((1)*4+1+1)]==1 && a[((1)*4+1+2)]==0;a[((1)*4+1)] = 0;a[((1)*4+1+1)] = 0;a[((1)*4+1+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*4+0)]==1 && a[((2)*4+0+1)]==1 && a[((2)*4+0+2)]==0;a[((2)*4+0)] = 0;a[((2)*4+0+1)] = 0;a[((2)*4+0+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*4+1)]==1 && a[((2)*4+1+1)]==1 && a[((2)*4+1+2)]==0;a[((2)*4+1)] = 0;a[((2)*4+1+1)] = 0;a[((2)*4+1+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*4+0)]==1 && a[((3)*4+0+1)]==1 && a[((3)*4+0+2)]==0;a[((3)*4+0)] = 0;a[((3)*4+0+1)] = 0;a[((3)*4+0+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*4+1)]==1 && a[((3)*4+1+1)]==1 && a[((3)*4+1+2)]==0;a[((3)*4+1)] = 0;a[((3)*4+1+1)] = 0;a[((3)*4+1+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((0)*4+2)]==1 && a[((0)*4+2-1)]==1 && a[((0)*4+2-2)]==0;a[((0)*4+2)] = 0;a[((0)*4+2-1)] = 0;a[((0)*4+2-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((0)*4+3)]==1 && a[((0)*4+3-1)]==1 && a[((0)*4+3-2)]==0;a[((0)*4+3)] = 0;a[((0)*4+3-1)] = 0;a[((0)*4+3-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*4+2)]==1 && a[((1)*4+2-1)]==1 && a[((1)*4+2-2)]==0;a[((1)*4+2)] = 0;a[((1)*4+2-1)] = 0;a[((1)*4+2-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*4+3)]==1 && a[((1)*4+3-1)]==1 && a[((1)*4+3-2)]==0;a[((1)*4+3)] = 0;a[((1)*4+3-1)] = 0;a[((1)*4+3-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*4+2)]==1 && a[((2)*4+2-1)]==1 && a[((2)*4+2-2)]==0;a[((2)*4+2)] = 0;a[((2)*4+2-1)] = 0;a[((2)*4+2-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*4+3)]==1 && a[((2)*4+3-1)]==1 && a[((2)*4+3-2)]==0;a[((2)*4+3)] = 0;a[((2)*4+3-1)] = 0;a[((2)*4+3-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*4+2)]==1 && a[((3)*4+2-1)]==1 && a[((3)*4+2-2)]==0;a[((3)*4+2)] = 0;a[((3)*4+2-1)] = 0;a[((3)*4+2-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*4+3)]==1 && a[((3)*4+3-1)]==1 && a[((3)*4+3-2)]==0;a[((3)*4+3)] = 0;a[((3)*4+3-1)] = 0;a[((3)*4+3-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((0)*4+0)]==1 && a[((0+1)*4+0)]==1 && a[((0+2)*4+0)]==0;a[((0)*4+0)] = 0;a[((0+1)*4+0)] = 0;a[((0+2)*4+0)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((0)*4+1)]==1 && a[((0+1)*4+1)]==1 && a[((0+2)*4+1)]==0;a[((0)*4+1)] = 0;a[((0+1)*4+1)] = 0;a[((0+2)*4+1)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((0)*4+2)]==1 && a[((0+1)*4+2)]==1 && a[((0+2)*4+2)]==0;a[((0)*4+2)] = 0;a[((0+1)*4+2)] = 0;a[((0+2)*4+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((0)*4+3)]==1 && a[((0+1)*4+3)]==1 && a[((0+2)*4+3)]==0;a[((0)*4+3)] = 0;a[((0+1)*4+3)] = 0;a[((0+2)*4+3)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*4+0)]==1 && a[((1+1)*4+0)]==1 && a[((1+2)*4+0)]==0;a[((1)*4+0)] = 0;a[((1+1)*4+0)] = 0;a[((1+2)*4+0)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*4+1)]==1 && a[((1+1)*4+1)]==1 && a[((1+2)*4+1)]==0;a[((1)*4+1)] = 0;a[((1+1)*4+1)] = 0;a[((1+2)*4+1)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*4+2)]==1 && a[((1+1)*4+2)]==1 && a[((1+2)*4+2)]==0;a[((1)*4+2)] = 0;a[((1+1)*4+2)] = 0;a[((1+2)*4+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*4+3)]==1 && a[((1+1)*4+3)]==1 && a[((1+2)*4+3)]==0;a[((1)*4+3)] = 0;a[((1+1)*4+3)] = 0;a[((1+2)*4+3)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*4+0)]==1 && a[((2-1)*4+0)]==1 && a[((2-2)*4+0)]==0;a[((2)*4+0)] = 0;a[((2-1)*4+0)] = 0;a[((2-2)*4+0)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*4+1)]==1 && a[((2-1)*4+1)]==1 && a[((2-2)*4+1)]==0;a[((2)*4+1)] = 0;a[((2-1)*4+1)] = 0;a[((2-2)*4+1)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*4+2)]==1 && a[((2-1)*4+2)]==1 && a[((2-2)*4+2)]==0;a[((2)*4+2)] = 0;a[((2-1)*4+2)] = 0;a[((2-2)*4+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*4+3)]==1 && a[((2-1)*4+3)]==1 && a[((2-2)*4+3)]==0;a[((2)*4+3)] = 0;a[((2-1)*4+3)] = 0;a[((2-2)*4+3)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*4+0)]==1 && a[((3-1)*4+0)]==1 && a[((3-2)*4+0)]==0;a[((3)*4+0)] = 0;a[((3-1)*4+0)] = 0;a[((3-2)*4+0)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*4+1)]==1 && a[((3-1)*4+1)]==1 && a[((3-2)*4+1)]==0;a[((3)*4+1)] = 0;a[((3-1)*4+1)] = 0;a[((3-2)*4+1)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*4+2)]==1 && a[((3-1)*4+2)]==1 && a[((3-2)*4+2)]==0;a[((3)*4+2)] = 0;a[((3-1)*4+2)] = 0;a[((3-2)*4+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*4+3)]==1 && a[((3-1)*4+3)]==1 && a[((3-2)*4+3)]==0;a[((3)*4+3)] = 0;a[((3-1)*4+3)] = 0;a[((3-2)*4+3)] = 1;peg_count = peg_count-1;}  goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Peg solitaire is an old board game for one player. The\n    basic rules are the following: A game board with 33 holes in cross form is given. 32 pegs are in. The centre\n    hole is empty. You have to remove the pegs one after the other by jumping\n    horizontally or vertically over one. In the end one peg should be left. We\n    can of course consider different variants (different boards, allow crossway\n    jumps).\n\nParameters:\n\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte a[25];\nbyte peg_count=24;\n\n\ninit { \n d_step { \na[0] =1; a[1] =1; a[2] =1; a[3] =1; a[4] =1; a[5] =1; a[6] =1; a[7] =1; a[8] =1; a[9] =1; a[10] =1; a[11] =1; a[12] =1; a[13] =1; a[14] =1; a[15] =1; a[16] =1; a[17] =1; a[18] =1; a[19] =1; a[20] =1; a[21] =1; a[22] =1; a[23] =1; a[24] =0; }\natomic { \nrun P();\n} }\n\nproctype P() { \n\nq: if\n::  d_step {a[((0)*5+0)]==1 && a[((0)*5+0+1)]==1 && a[((0)*5+0+2)]==0;a[((0)*5+0)] = 0;a[((0)*5+0+1)] = 0;a[((0)*5+0+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((0)*5+1)]==1 && a[((0)*5+1+1)]==1 && a[((0)*5+1+2)]==0;a[((0)*5+1)] = 0;a[((0)*5+1+1)] = 0;a[((0)*5+1+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((0)*5+2)]==1 && a[((0)*5+2+1)]==1 && a[((0)*5+2+2)]==0;a[((0)*5+2)] = 0;a[((0)*5+2+1)] = 0;a[((0)*5+2+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*5+0)]==1 && a[((1)*5+0+1)]==1 && a[((1)*5+0+2)]==0;a[((1)*5+0)] = 0;a[((1)*5+0+1)] = 0;a[((1)*5+0+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*5+1)]==1 && a[((1)*5+1+1)]==1 && a[((1)*5+1+2)]==0;a[((1)*5+1)] = 0;a[((1)*5+1+1)] = 0;a[((1)*5+1+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*5+2)]==1 && a[((1)*5+2+1)]==1 && a[((1)*5+2+2)]==0;a[((1)*5+2)] = 0;a[((1)*5+2+1)] = 0;a[((1)*5+2+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*5+0)]==1 && a[((2)*5+0+1)]==1 && a[((2)*5+0+2)]==0;a[((2)*5+0)] = 0;a[((2)*5+0+1)] = 0;a[((2)*5+0+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*5+1)]==1 && a[((2)*5+1+1)]==1 && a[((2)*5+1+2)]==0;a[((2)*5+1)] = 0;a[((2)*5+1+1)] = 0;a[((2)*5+1+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*5+2)]==1 && a[((2)*5+2+1)]==1 && a[((2)*5+2+2)]==0;a[((2)*5+2)] = 0;a[((2)*5+2+1)] = 0;a[((2)*5+2+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*5+0)]==1 && a[((3)*5+0+1)]==1 && a[((3)*5+0+2)]==0;a[((3)*5+0)] = 0;a[((3)*5+0+1)] = 0;a[((3)*5+0+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*5+1)]==1 && a[((3)*5+1+1)]==1 && a[((3)*5+1+2)]==0;a[((3)*5+1)] = 0;a[((3)*5+1+1)] = 0;a[((3)*5+1+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*5+2)]==1 && a[((3)*5+2+1)]==1 && a[((3)*5+2+2)]==0;a[((3)*5+2)] = 0;a[((3)*5+2+1)] = 0;a[((3)*5+2+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((4)*5+0)]==1 && a[((4)*5+0+1)]==1 && a[((4)*5+0+2)]==0;a[((4)*5+0)] = 0;a[((4)*5+0+1)] = 0;a[((4)*5+0+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((4)*5+1)]==1 && a[((4)*5+1+1)]==1 && a[((4)*5+1+2)]==0;a[((4)*5+1)] = 0;a[((4)*5+1+1)] = 0;a[((4)*5+1+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((4)*5+2)]==1 && a[((4)*5+2+1)]==1 && a[((4)*5+2+2)]==0;a[((4)*5+2)] = 0;a[((4)*5+2+1)] = 0;a[((4)*5+2+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((0)*5+2)]==1 && a[((0)*5+2-1)]==1 && a[((0)*5+2-2)]==0;a[((0)*5+2)] = 0;a[((0)*5+2-1)] = 0;a[((0)*5+2-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((0)*5+3)]==1 && a[((0)*5+3-1)]==1 && a[((0)*5+3-2)]==0;a[((0)*5+3)] = 0;a[((0)*5+3-1)] = 0;a[((0)*5+3-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((0)*5+4)]==1 && a[((0)*5+4-1)]==1 && a[((0)*5+4-2)]==0;a[((0)*5+4)] = 0;a[((0)*5+4-1)] = 0;a[((0)*5+4-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*5+2)]==1 && a[((1)*5+2-1)]==1 && a[((1)*5+2-2)]==0;a[((1)*5+2)] = 0;a[((1)*5+2-1)] = 0;a[((1)*5+2-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*5+3)]==1 && a[((1)*5+3-1)]==1 && a[((1)*5+3-2)]==0;a[((1)*5+3)] = 0;a[((1)*5+3-1)] = 0;a[((1)*5+3-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*5+4)]==1 && a[((1)*5+4-1)]==1 && a[((1)*5+4-2)]==0;a[((1)*5+4)] = 0;a[((1)*5+4-1)] = 0;a[((1)*5+4-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*5+2)]==1 && a[((2)*5+2-1)]==1 && a[((2)*5+2-2)]==0;a[((2)*5+2)] = 0;a[((2)*5+2-1)] = 0;a[((2)*5+2-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*5+3)]==1 && a[((2)*5+3-1)]==1 && a[((2)*5+3-2)]==0;a[((2)*5+3)] = 0;a[((2)*5+3-1)] = 0;a[((2)*5+3-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*5+4)]==1 && a[((2)*5+4-1)]==1 && a[((2)*5+4-2)]==0;a[((2)*5+4)] = 0;a[((2)*5+4-1)] = 0;a[((2)*5+4-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*5+2)]==1 && a[((3)*5+2-1)]==1 && a[((3)*5+2-2)]==0;a[((3)*5+2)] = 0;a[((3)*5+2-1)] = 0;a[((3)*5+2-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*5+3)]==1 && a[((3)*5+3-1)]==1 && a[((3)*5+3-2)]==0;a[((3)*5+3)] = 0;a[((3)*5+3-1)] = 0;a[((3)*5+3-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*5+4)]==1 && a[((3)*5+4-1)]==1 && a[((3)*5+4-2)]==0;a[((3)*5+4)] = 0;a[((3)*5+4-1)] = 0;a[((3)*5+4-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((4)*5+2)]==1 && a[((4)*5+2-1)]==1 && a[((4)*5+2-2)]==0;a[((4)*5+2)] = 0;a[((4)*5+2-1)] = 0;a[((4)*5+2-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((4)*5+3)]==1 && a[((4)*5+3-1)]==1 && a[((4)*5+3-2)]==0;a[((4)*5+3)] = 0;a[((4)*5+3-1)] = 0;a[((4)*5+3-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((4)*5+4)]==1 && a[((4)*5+4-1)]==1 && a[((4)*5+4-2)]==0;a[((4)*5+4)] = 0;a[((4)*5+4-1)] = 0;a[((4)*5+4-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((0)*5+0)]==1 && a[((0+1)*5+0)]==1 && a[((0+2)*5+0)]==0;a[((0)*5+0)] = 0;a[((0+1)*5+0)] = 0;a[((0+2)*5+0)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((0)*5+1)]==1 && a[((0+1)*5+1)]==1 && a[((0+2)*5+1)]==0;a[((0)*5+1)] = 0;a[((0+1)*5+1)] = 0;a[((0+2)*5+1)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((0)*5+2)]==1 && a[((0+1)*5+2)]==1 && a[((0+2)*5+2)]==0;a[((0)*5+2)] = 0;a[((0+1)*5+2)] = 0;a[((0+2)*5+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((0)*5+3)]==1 && a[((0+1)*5+3)]==1 && a[((0+2)*5+3)]==0;a[((0)*5+3)] = 0;a[((0+1)*5+3)] = 0;a[((0+2)*5+3)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((0)*5+4)]==1 && a[((0+1)*5+4)]==1 && a[((0+2)*5+4)]==0;a[((0)*5+4)] = 0;a[((0+1)*5+4)] = 0;a[((0+2)*5+4)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*5+0)]==1 && a[((1+1)*5+0)]==1 && a[((1+2)*5+0)]==0;a[((1)*5+0)] = 0;a[((1+1)*5+0)] = 0;a[((1+2)*5+0)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*5+1)]==1 && a[((1+1)*5+1)]==1 && a[((1+2)*5+1)]==0;a[((1)*5+1)] = 0;a[((1+1)*5+1)] = 0;a[((1+2)*5+1)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*5+2)]==1 && a[((1+1)*5+2)]==1 && a[((1+2)*5+2)]==0;a[((1)*5+2)] = 0;a[((1+1)*5+2)] = 0;a[((1+2)*5+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*5+3)]==1 && a[((1+1)*5+3)]==1 && a[((1+2)*5+3)]==0;a[((1)*5+3)] = 0;a[((1+1)*5+3)] = 0;a[((1+2)*5+3)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*5+4)]==1 && a[((1+1)*5+4)]==1 && a[((1+2)*5+4)]==0;a[((1)*5+4)] = 0;a[((1+1)*5+4)] = 0;a[((1+2)*5+4)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*5+0)]==1 && a[((2+1)*5+0)]==1 && a[((2+2)*5+0)]==0;a[((2)*5+0)] = 0;a[((2+1)*5+0)] = 0;a[((2+2)*5+0)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*5+1)]==1 && a[((2+1)*5+1)]==1 && a[((2+2)*5+1)]==0;a[((2)*5+1)] = 0;a[((2+1)*5+1)] = 0;a[((2+2)*5+1)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*5+2)]==1 && a[((2+1)*5+2)]==1 && a[((2+2)*5+2)]==0;a[((2)*5+2)] = 0;a[((2+1)*5+2)] = 0;a[((2+2)*5+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*5+3)]==1 && a[((2+1)*5+3)]==1 && a[((2+2)*5+3)]==0;a[((2)*5+3)] = 0;a[((2+1)*5+3)] = 0;a[((2+2)*5+3)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*5+4)]==1 && a[((2+1)*5+4)]==1 && a[((2+2)*5+4)]==0;a[((2)*5+4)] = 0;a[((2+1)*5+4)] = 0;a[((2+2)*5+4)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*5+0)]==1 && a[((2-1)*5+0)]==1 && a[((2-2)*5+0)]==0;a[((2)*5+0)] = 0;a[((2-1)*5+0)] = 0;a[((2-2)*5+0)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*5+1)]==1 && a[((2-1)*5+1)]==1 && a[((2-2)*5+1)]==0;a[((2)*5+1)] = 0;a[((2-1)*5+1)] = 0;a[((2-2)*5+1)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*5+2)]==1 && a[((2-1)*5+2)]==1 && a[((2-2)*5+2)]==0;a[((2)*5+2)] = 0;a[((2-1)*5+2)] = 0;a[((2-2)*5+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*5+3)]==1 && a[((2-1)*5+3)]==1 && a[((2-2)*5+3)]==0;a[((2)*5+3)] = 0;a[((2-1)*5+3)] = 0;a[((2-2)*5+3)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*5+4)]==1 && a[((2-1)*5+4)]==1 && a[((2-2)*5+4)]==0;a[((2)*5+4)] = 0;a[((2-1)*5+4)] = 0;a[((2-2)*5+4)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*5+0)]==1 && a[((3-1)*5+0)]==1 && a[((3-2)*5+0)]==0;a[((3)*5+0)] = 0;a[((3-1)*5+0)] = 0;a[((3-2)*5+0)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*5+1)]==1 && a[((3-1)*5+1)]==1 && a[((3-2)*5+1)]==0;a[((3)*5+1)] = 0;a[((3-1)*5+1)] = 0;a[((3-2)*5+1)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*5+2)]==1 && a[((3-1)*5+2)]==1 && a[((3-2)*5+2)]==0;a[((3)*5+2)] = 0;a[((3-1)*5+2)] = 0;a[((3-2)*5+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*5+3)]==1 && a[((3-1)*5+3)]==1 && a[((3-2)*5+3)]==0;a[((3)*5+3)] = 0;a[((3-1)*5+3)] = 0;a[((3-2)*5+3)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*5+4)]==1 && a[((3-1)*5+4)]==1 && a[((3-2)*5+4)]==0;a[((3)*5+4)] = 0;a[((3-1)*5+4)] = 0;a[((3-2)*5+4)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((4)*5+0)]==1 && a[((4-1)*5+0)]==1 && a[((4-2)*5+0)]==0;a[((4)*5+0)] = 0;a[((4-1)*5+0)] = 0;a[((4-2)*5+0)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((4)*5+1)]==1 && a[((4-1)*5+1)]==1 && a[((4-2)*5+1)]==0;a[((4)*5+1)] = 0;a[((4-1)*5+1)] = 0;a[((4-2)*5+1)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((4)*5+2)]==1 && a[((4-1)*5+2)]==1 && a[((4-2)*5+2)]==0;a[((4)*5+2)] = 0;a[((4-1)*5+2)] = 0;a[((4-2)*5+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((4)*5+3)]==1 && a[((4-1)*5+3)]==1 && a[((4-2)*5+3)]==0;a[((4)*5+3)] = 0;a[((4-1)*5+3)] = 0;a[((4-2)*5+3)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((4)*5+4)]==1 && a[((4-1)*5+4)]==1 && a[((4-2)*5+4)]==0;a[((4)*5+4)] = 0;a[((4-1)*5+4)] = 0;a[((4-2)*5+4)] = 1;peg_count = peg_count-1;}  goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Peg solitaire is an old board game for one player. The\n    basic rules are the following: A game board with 33 holes in cross form is given. 32 pegs are in. The centre\n    hole is empty. You have to remove the pegs one after the other by jumping\n    horizontally or vertically over one. In the end one peg should be left. We\n    can of course consider different variants (different boards, allow crossway\n    jumps).\n\nParameters:\n\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte a[36];\nbyte peg_count=35;\n\n\ninit { \n d_step { \na[0] =1; a[1] =1; a[2] =1; a[3] =1; a[4] =1; a[5] =1; a[6] =1; a[7] =1; a[8] =1; a[9] =1; a[10] =1; a[11] =1; a[12] =1; a[13] =1; a[14] =1; a[15] =1; a[16] =1; a[17] =1; a[18] =1; a[19] =1; a[20] =1; a[21] =1; a[22] =1; a[23] =1; a[24] =1; a[25] =1; a[26] =1; a[27] =1; a[28] =1; a[29] =1; a[30] =1; a[31] =1; a[32] =1; a[33] =1; a[34] =1; a[35] =0; }\natomic { \nrun P();\n} }\n\nproctype P() { \n\nq: if\n::  d_step {a[((0)*6+0)]==1 && a[((0)*6+0+1)]==1 && a[((0)*6+0+2)]==0;a[((0)*6+0)] = 0;a[((0)*6+0+1)] = 0;a[((0)*6+0+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((0)*6+1)]==1 && a[((0)*6+1+1)]==1 && a[((0)*6+1+2)]==0;a[((0)*6+1)] = 0;a[((0)*6+1+1)] = 0;a[((0)*6+1+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((0)*6+2)]==1 && a[((0)*6+2+1)]==1 && a[((0)*6+2+2)]==0;a[((0)*6+2)] = 0;a[((0)*6+2+1)] = 0;a[((0)*6+2+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((0)*6+3)]==1 && a[((0)*6+3+1)]==1 && a[((0)*6+3+2)]==0;a[((0)*6+3)] = 0;a[((0)*6+3+1)] = 0;a[((0)*6+3+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*6+0)]==1 && a[((1)*6+0+1)]==1 && a[((1)*6+0+2)]==0;a[((1)*6+0)] = 0;a[((1)*6+0+1)] = 0;a[((1)*6+0+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*6+1)]==1 && a[((1)*6+1+1)]==1 && a[((1)*6+1+2)]==0;a[((1)*6+1)] = 0;a[((1)*6+1+1)] = 0;a[((1)*6+1+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*6+2)]==1 && a[((1)*6+2+1)]==1 && a[((1)*6+2+2)]==0;a[((1)*6+2)] = 0;a[((1)*6+2+1)] = 0;a[((1)*6+2+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*6+3)]==1 && a[((1)*6+3+1)]==1 && a[((1)*6+3+2)]==0;a[((1)*6+3)] = 0;a[((1)*6+3+1)] = 0;a[((1)*6+3+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*6+0)]==1 && a[((2)*6+0+1)]==1 && a[((2)*6+0+2)]==0;a[((2)*6+0)] = 0;a[((2)*6+0+1)] = 0;a[((2)*6+0+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*6+1)]==1 && a[((2)*6+1+1)]==1 && a[((2)*6+1+2)]==0;a[((2)*6+1)] = 0;a[((2)*6+1+1)] = 0;a[((2)*6+1+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*6+2)]==1 && a[((2)*6+2+1)]==1 && a[((2)*6+2+2)]==0;a[((2)*6+2)] = 0;a[((2)*6+2+1)] = 0;a[((2)*6+2+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*6+3)]==1 && a[((2)*6+3+1)]==1 && a[((2)*6+3+2)]==0;a[((2)*6+3)] = 0;a[((2)*6+3+1)] = 0;a[((2)*6+3+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*6+0)]==1 && a[((3)*6+0+1)]==1 && a[((3)*6+0+2)]==0;a[((3)*6+0)] = 0;a[((3)*6+0+1)] = 0;a[((3)*6+0+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*6+1)]==1 && a[((3)*6+1+1)]==1 && a[((3)*6+1+2)]==0;a[((3)*6+1)] = 0;a[((3)*6+1+1)] = 0;a[((3)*6+1+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*6+2)]==1 && a[((3)*6+2+1)]==1 && a[((3)*6+2+2)]==0;a[((3)*6+2)] = 0;a[((3)*6+2+1)] = 0;a[((3)*6+2+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*6+3)]==1 && a[((3)*6+3+1)]==1 && a[((3)*6+3+2)]==0;a[((3)*6+3)] = 0;a[((3)*6+3+1)] = 0;a[((3)*6+3+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((4)*6+0)]==1 && a[((4)*6+0+1)]==1 && a[((4)*6+0+2)]==0;a[((4)*6+0)] = 0;a[((4)*6+0+1)] = 0;a[((4)*6+0+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((4)*6+1)]==1 && a[((4)*6+1+1)]==1 && a[((4)*6+1+2)]==0;a[((4)*6+1)] = 0;a[((4)*6+1+1)] = 0;a[((4)*6+1+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((4)*6+2)]==1 && a[((4)*6+2+1)]==1 && a[((4)*6+2+2)]==0;a[((4)*6+2)] = 0;a[((4)*6+2+1)] = 0;a[((4)*6+2+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((4)*6+3)]==1 && a[((4)*6+3+1)]==1 && a[((4)*6+3+2)]==0;a[((4)*6+3)] = 0;a[((4)*6+3+1)] = 0;a[((4)*6+3+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((5)*6+0)]==1 && a[((5)*6+0+1)]==1 && a[((5)*6+0+2)]==0;a[((5)*6+0)] = 0;a[((5)*6+0+1)] = 0;a[((5)*6+0+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((5)*6+1)]==1 && a[((5)*6+1+1)]==1 && a[((5)*6+1+2)]==0;a[((5)*6+1)] = 0;a[((5)*6+1+1)] = 0;a[((5)*6+1+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((5)*6+2)]==1 && a[((5)*6+2+1)]==1 && a[((5)*6+2+2)]==0;a[((5)*6+2)] = 0;a[((5)*6+2+1)] = 0;a[((5)*6+2+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((5)*6+3)]==1 && a[((5)*6+3+1)]==1 && a[((5)*6+3+2)]==0;a[((5)*6+3)] = 0;a[((5)*6+3+1)] = 0;a[((5)*6+3+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((0)*6+2)]==1 && a[((0)*6+2-1)]==1 && a[((0)*6+2-2)]==0;a[((0)*6+2)] = 0;a[((0)*6+2-1)] = 0;a[((0)*6+2-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((0)*6+3)]==1 && a[((0)*6+3-1)]==1 && a[((0)*6+3-2)]==0;a[((0)*6+3)] = 0;a[((0)*6+3-1)] = 0;a[((0)*6+3-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((0)*6+4)]==1 && a[((0)*6+4-1)]==1 && a[((0)*6+4-2)]==0;a[((0)*6+4)] = 0;a[((0)*6+4-1)] = 0;a[((0)*6+4-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((0)*6+5)]==1 && a[((0)*6+5-1)]==1 && a[((0)*6+5-2)]==0;a[((0)*6+5)] = 0;a[((0)*6+5-1)] = 0;a[((0)*6+5-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*6+2)]==1 && a[((1)*6+2-1)]==1 && a[((1)*6+2-2)]==0;a[((1)*6+2)] = 0;a[((1)*6+2-1)] = 0;a[((1)*6+2-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*6+3)]==1 && a[((1)*6+3-1)]==1 && a[((1)*6+3-2)]==0;a[((1)*6+3)] = 0;a[((1)*6+3-1)] = 0;a[((1)*6+3-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*6+4)]==1 && a[((1)*6+4-1)]==1 && a[((1)*6+4-2)]==0;a[((1)*6+4)] = 0;a[((1)*6+4-1)] = 0;a[((1)*6+4-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*6+5)]==1 && a[((1)*6+5-1)]==1 && a[((1)*6+5-2)]==0;a[((1)*6+5)] = 0;a[((1)*6+5-1)] = 0;a[((1)*6+5-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*6+2)]==1 && a[((2)*6+2-1)]==1 && a[((2)*6+2-2)]==0;a[((2)*6+2)] = 0;a[((2)*6+2-1)] = 0;a[((2)*6+2-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*6+3)]==1 && a[((2)*6+3-1)]==1 && a[((2)*6+3-2)]==0;a[((2)*6+3)] = 0;a[((2)*6+3-1)] = 0;a[((2)*6+3-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*6+4)]==1 && a[((2)*6+4-1)]==1 && a[((2)*6+4-2)]==0;a[((2)*6+4)] = 0;a[((2)*6+4-1)] = 0;a[((2)*6+4-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*6+5)]==1 && a[((2)*6+5-1)]==1 && a[((2)*6+5-2)]==0;a[((2)*6+5)] = 0;a[((2)*6+5-1)] = 0;a[((2)*6+5-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*6+2)]==1 && a[((3)*6+2-1)]==1 && a[((3)*6+2-2)]==0;a[((3)*6+2)] = 0;a[((3)*6+2-1)] = 0;a[((3)*6+2-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*6+3)]==1 && a[((3)*6+3-1)]==1 && a[((3)*6+3-2)]==0;a[((3)*6+3)] = 0;a[((3)*6+3-1)] = 0;a[((3)*6+3-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*6+4)]==1 && a[((3)*6+4-1)]==1 && a[((3)*6+4-2)]==0;a[((3)*6+4)] = 0;a[((3)*6+4-1)] = 0;a[((3)*6+4-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*6+5)]==1 && a[((3)*6+5-1)]==1 && a[((3)*6+5-2)]==0;a[((3)*6+5)] = 0;a[((3)*6+5-1)] = 0;a[((3)*6+5-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((4)*6+2)]==1 && a[((4)*6+2-1)]==1 && a[((4)*6+2-2)]==0;a[((4)*6+2)] = 0;a[((4)*6+2-1)] = 0;a[((4)*6+2-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((4)*6+3)]==1 && a[((4)*6+3-1)]==1 && a[((4)*6+3-2)]==0;a[((4)*6+3)] = 0;a[((4)*6+3-1)] = 0;a[((4)*6+3-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((4)*6+4)]==1 && a[((4)*6+4-1)]==1 && a[((4)*6+4-2)]==0;a[((4)*6+4)] = 0;a[((4)*6+4-1)] = 0;a[((4)*6+4-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((4)*6+5)]==1 && a[((4)*6+5-1)]==1 && a[((4)*6+5-2)]==0;a[((4)*6+5)] = 0;a[((4)*6+5-1)] = 0;a[((4)*6+5-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((5)*6+2)]==1 && a[((5)*6+2-1)]==1 && a[((5)*6+2-2)]==0;a[((5)*6+2)] = 0;a[((5)*6+2-1)] = 0;a[((5)*6+2-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((5)*6+3)]==1 && a[((5)*6+3-1)]==1 && a[((5)*6+3-2)]==0;a[((5)*6+3)] = 0;a[((5)*6+3-1)] = 0;a[((5)*6+3-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((5)*6+4)]==1 && a[((5)*6+4-1)]==1 && a[((5)*6+4-2)]==0;a[((5)*6+4)] = 0;a[((5)*6+4-1)] = 0;a[((5)*6+4-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((5)*6+5)]==1 && a[((5)*6+5-1)]==1 && a[((5)*6+5-2)]==0;a[((5)*6+5)] = 0;a[((5)*6+5-1)] = 0;a[((5)*6+5-2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((0)*6+0)]==1 && a[((0+1)*6+0)]==1 && a[((0+2)*6+0)]==0;a[((0)*6+0)] = 0;a[((0+1)*6+0)] = 0;a[((0+2)*6+0)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((0)*6+1)]==1 && a[((0+1)*6+1)]==1 && a[((0+2)*6+1)]==0;a[((0)*6+1)] = 0;a[((0+1)*6+1)] = 0;a[((0+2)*6+1)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((0)*6+2)]==1 && a[((0+1)*6+2)]==1 && a[((0+2)*6+2)]==0;a[((0)*6+2)] = 0;a[((0+1)*6+2)] = 0;a[((0+2)*6+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((0)*6+3)]==1 && a[((0+1)*6+3)]==1 && a[((0+2)*6+3)]==0;a[((0)*6+3)] = 0;a[((0+1)*6+3)] = 0;a[((0+2)*6+3)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((0)*6+4)]==1 && a[((0+1)*6+4)]==1 && a[((0+2)*6+4)]==0;a[((0)*6+4)] = 0;a[((0+1)*6+4)] = 0;a[((0+2)*6+4)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((0)*6+5)]==1 && a[((0+1)*6+5)]==1 && a[((0+2)*6+5)]==0;a[((0)*6+5)] = 0;a[((0+1)*6+5)] = 0;a[((0+2)*6+5)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*6+0)]==1 && a[((1+1)*6+0)]==1 && a[((1+2)*6+0)]==0;a[((1)*6+0)] = 0;a[((1+1)*6+0)] = 0;a[((1+2)*6+0)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*6+1)]==1 && a[((1+1)*6+1)]==1 && a[((1+2)*6+1)]==0;a[((1)*6+1)] = 0;a[((1+1)*6+1)] = 0;a[((1+2)*6+1)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*6+2)]==1 && a[((1+1)*6+2)]==1 && a[((1+2)*6+2)]==0;a[((1)*6+2)] = 0;a[((1+1)*6+2)] = 0;a[((1+2)*6+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*6+3)]==1 && a[((1+1)*6+3)]==1 && a[((1+2)*6+3)]==0;a[((1)*6+3)] = 0;a[((1+1)*6+3)] = 0;a[((1+2)*6+3)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*6+4)]==1 && a[((1+1)*6+4)]==1 && a[((1+2)*6+4)]==0;a[((1)*6+4)] = 0;a[((1+1)*6+4)] = 0;a[((1+2)*6+4)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((1)*6+5)]==1 && a[((1+1)*6+5)]==1 && a[((1+2)*6+5)]==0;a[((1)*6+5)] = 0;a[((1+1)*6+5)] = 0;a[((1+2)*6+5)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*6+0)]==1 && a[((2+1)*6+0)]==1 && a[((2+2)*6+0)]==0;a[((2)*6+0)] = 0;a[((2+1)*6+0)] = 0;a[((2+2)*6+0)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*6+1)]==1 && a[((2+1)*6+1)]==1 && a[((2+2)*6+1)]==0;a[((2)*6+1)] = 0;a[((2+1)*6+1)] = 0;a[((2+2)*6+1)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*6+2)]==1 && a[((2+1)*6+2)]==1 && a[((2+2)*6+2)]==0;a[((2)*6+2)] = 0;a[((2+1)*6+2)] = 0;a[((2+2)*6+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*6+3)]==1 && a[((2+1)*6+3)]==1 && a[((2+2)*6+3)]==0;a[((2)*6+3)] = 0;a[((2+1)*6+3)] = 0;a[((2+2)*6+3)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*6+4)]==1 && a[((2+1)*6+4)]==1 && a[((2+2)*6+4)]==0;a[((2)*6+4)] = 0;a[((2+1)*6+4)] = 0;a[((2+2)*6+4)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*6+5)]==1 && a[((2+1)*6+5)]==1 && a[((2+2)*6+5)]==0;a[((2)*6+5)] = 0;a[((2+1)*6+5)] = 0;a[((2+2)*6+5)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*6+0)]==1 && a[((3+1)*6+0)]==1 && a[((3+2)*6+0)]==0;a[((3)*6+0)] = 0;a[((3+1)*6+0)] = 0;a[((3+2)*6+0)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*6+1)]==1 && a[((3+1)*6+1)]==1 && a[((3+2)*6+1)]==0;a[((3)*6+1)] = 0;a[((3+1)*6+1)] = 0;a[((3+2)*6+1)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*6+2)]==1 && a[((3+1)*6+2)]==1 && a[((3+2)*6+2)]==0;a[((3)*6+2)] = 0;a[((3+1)*6+2)] = 0;a[((3+2)*6+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*6+3)]==1 && a[((3+1)*6+3)]==1 && a[((3+2)*6+3)]==0;a[((3)*6+3)] = 0;a[((3+1)*6+3)] = 0;a[((3+2)*6+3)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*6+4)]==1 && a[((3+1)*6+4)]==1 && a[((3+2)*6+4)]==0;a[((3)*6+4)] = 0;a[((3+1)*6+4)] = 0;a[((3+2)*6+4)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*6+5)]==1 && a[((3+1)*6+5)]==1 && a[((3+2)*6+5)]==0;a[((3)*6+5)] = 0;a[((3+1)*6+5)] = 0;a[((3+2)*6+5)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*6+0)]==1 && a[((2-1)*6+0)]==1 && a[((2-2)*6+0)]==0;a[((2)*6+0)] = 0;a[((2-1)*6+0)] = 0;a[((2-2)*6+0)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*6+1)]==1 && a[((2-1)*6+1)]==1 && a[((2-2)*6+1)]==0;a[((2)*6+1)] = 0;a[((2-1)*6+1)] = 0;a[((2-2)*6+1)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*6+2)]==1 && a[((2-1)*6+2)]==1 && a[((2-2)*6+2)]==0;a[((2)*6+2)] = 0;a[((2-1)*6+2)] = 0;a[((2-2)*6+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*6+3)]==1 && a[((2-1)*6+3)]==1 && a[((2-2)*6+3)]==0;a[((2)*6+3)] = 0;a[((2-1)*6+3)] = 0;a[((2-2)*6+3)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*6+4)]==1 && a[((2-1)*6+4)]==1 && a[((2-2)*6+4)]==0;a[((2)*6+4)] = 0;a[((2-1)*6+4)] = 0;a[((2-2)*6+4)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((2)*6+5)]==1 && a[((2-1)*6+5)]==1 && a[((2-2)*6+5)]==0;a[((2)*6+5)] = 0;a[((2-1)*6+5)] = 0;a[((2-2)*6+5)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*6+0)]==1 && a[((3-1)*6+0)]==1 && a[((3-2)*6+0)]==0;a[((3)*6+0)] = 0;a[((3-1)*6+0)] = 0;a[((3-2)*6+0)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*6+1)]==1 && a[((3-1)*6+1)]==1 && a[((3-2)*6+1)]==0;a[((3)*6+1)] = 0;a[((3-1)*6+1)] = 0;a[((3-2)*6+1)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*6+2)]==1 && a[((3-1)*6+2)]==1 && a[((3-2)*6+2)]==0;a[((3)*6+2)] = 0;a[((3-1)*6+2)] = 0;a[((3-2)*6+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*6+3)]==1 && a[((3-1)*6+3)]==1 && a[((3-2)*6+3)]==0;a[((3)*6+3)] = 0;a[((3-1)*6+3)] = 0;a[((3-2)*6+3)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*6+4)]==1 && a[((3-1)*6+4)]==1 && a[((3-2)*6+4)]==0;a[((3)*6+4)] = 0;a[((3-1)*6+4)] = 0;a[((3-2)*6+4)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((3)*6+5)]==1 && a[((3-1)*6+5)]==1 && a[((3-2)*6+5)]==0;a[((3)*6+5)] = 0;a[((3-1)*6+5)] = 0;a[((3-2)*6+5)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((4)*6+0)]==1 && a[((4-1)*6+0)]==1 && a[((4-2)*6+0)]==0;a[((4)*6+0)] = 0;a[((4-1)*6+0)] = 0;a[((4-2)*6+0)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((4)*6+1)]==1 && a[((4-1)*6+1)]==1 && a[((4-2)*6+1)]==0;a[((4)*6+1)] = 0;a[((4-1)*6+1)] = 0;a[((4-2)*6+1)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((4)*6+2)]==1 && a[((4-1)*6+2)]==1 && a[((4-2)*6+2)]==0;a[((4)*6+2)] = 0;a[((4-1)*6+2)] = 0;a[((4-2)*6+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((4)*6+3)]==1 && a[((4-1)*6+3)]==1 && a[((4-2)*6+3)]==0;a[((4)*6+3)] = 0;a[((4-1)*6+3)] = 0;a[((4-2)*6+3)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((4)*6+4)]==1 && a[((4-1)*6+4)]==1 && a[((4-2)*6+4)]==0;a[((4)*6+4)] = 0;a[((4-1)*6+4)] = 0;a[((4-2)*6+4)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((4)*6+5)]==1 && a[((4-1)*6+5)]==1 && a[((4-2)*6+5)]==0;a[((4)*6+5)] = 0;a[((4-1)*6+5)] = 0;a[((4-2)*6+5)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((5)*6+0)]==1 && a[((5-1)*6+0)]==1 && a[((5-2)*6+0)]==0;a[((5)*6+0)] = 0;a[((5-1)*6+0)] = 0;a[((5-2)*6+0)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((5)*6+1)]==1 && a[((5-1)*6+1)]==1 && a[((5-2)*6+1)]==0;a[((5)*6+1)] = 0;a[((5-1)*6+1)] = 0;a[((5-2)*6+1)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((5)*6+2)]==1 && a[((5-1)*6+2)]==1 && a[((5-2)*6+2)]==0;a[((5)*6+2)] = 0;a[((5-1)*6+2)] = 0;a[((5-2)*6+2)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((5)*6+3)]==1 && a[((5-1)*6+3)]==1 && a[((5-2)*6+3)]==0;a[((5)*6+3)] = 0;a[((5-1)*6+3)] = 0;a[((5-2)*6+3)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((5)*6+4)]==1 && a[((5-1)*6+4)]==1 && a[((5-2)*6+4)]==0;a[((5)*6+4)] = 0;a[((5-1)*6+4)] = 0;a[((5-2)*6+4)] = 1;peg_count = peg_count-1;}  goto q; \n\n::  d_step {a[((5)*6+5)]==1 && a[((5-1)*6+5)]==1 && a[((5-2)*6+5)]==0;a[((5)*6+5)] = 0;a[((5-1)*6+5)] = 0;a[((5-2)*6+5)] = 1;peg_count = peg_count-1;}  goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually.\n\nSee also other mutex examples.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte pos[3];\nbyte step[3];\n\n\nactive proctype P_0() { \nbyte j=0;\nbyte k=0;\n\nNCS: if\n:: j = 1; goto wait; \n\nfi;\nCS: if\n:: pos[0] = 0; goto NCS; \n\nfi;\nwait: if\n::  d_step {j<3;pos[0] = j;}  goto q2; \n\n:: j==3; goto CS; \n\nfi;\nq2: if\n::  d_step {step[j-1] = 0;k = 0;}  goto q3; \n\nfi;\nq3: if\n::  d_step {k<3 && (k==0 || pos[k]<j);k = k+1;}  goto q3; \n\n::  d_step {step[j-1]!=0 || k==3;j = j+1;}  goto wait; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte j=0;\nbyte k=0;\n\nNCS: if\n:: j = 1; goto wait; \n\nfi;\nCS: if\n:: pos[1] = 0; goto NCS; \n\nfi;\nwait: if\n::  d_step {j<3;pos[1] = j;}  goto q2; \n\n:: j==3; goto CS; \n\nfi;\nq2: if\n::  d_step {step[j-1] = 1;k = 0;}  goto q3; \n\nfi;\nq3: if\n::  d_step {k<3 && (k==1 || pos[k]<j);k = k+1;}  goto q3; \n\n::  d_step {step[j-1]!=1 || k==3;j = j+1;}  goto wait; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte j=0;\nbyte k=0;\n\nNCS: if\n:: j = 1; goto wait; \n\nfi;\nCS: if\n:: pos[2] = 0; goto NCS; \n\nfi;\nwait: if\n::  d_step {j<3;pos[2] = j;}  goto q2; \n\n:: j==3; goto CS; \n\nfi;\nq2: if\n::  d_step {step[j-1] = 2;k = 0;}  goto q3; \n\nfi;\nq3: if\n::  d_step {k<3 && (k==2 || pos[k]<j);k = k+1;}  goto q3; \n\n::  d_step {step[j-1]!=2 || k==3;j = j+1;}  goto wait; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually.\n\nSee also other mutex examples.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte pos[3];\nbyte step[3];\n\n\nactive proctype P_0() { \nbyte j=0;\nbyte k=0;\n\nNCS: if\n:: j = 1; goto wait; \n\nfi;\nCS: if\n:: pos[0] = 0; goto NCS; \n\nfi;\nwait: if\n::  d_step {j<3;pos[0] = j;}  goto q2; \n\n:: j==3; goto CS; \n\nfi;\nq2: if\n::  d_step {step[j-1] = 0;k = 0;}  goto q3; \n\nfi;\nq3: if\n::  d_step {k<3 && (k==0 || pos[k]<=j);k = k+1;}  goto q3; \n\n::  d_step {step[j-1]!=0 || k==3;j = j+1;}  goto wait; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte j=0;\nbyte k=0;\n\nNCS: if\n:: j = 1; goto wait; \n\nfi;\nCS: if\n:: pos[1] = 0; goto NCS; \n\nfi;\nwait: if\n::  d_step {j<3;pos[1] = j;}  goto q2; \n\n:: j==3; goto CS; \n\nfi;\nq2: if\n::  d_step {step[j-1] = 1;k = 0;}  goto q3; \n\nfi;\nq3: if\n::  d_step {k<3 && (k==1 || pos[k]<=j);k = k+1;}  goto q3; \n\n::  d_step {step[j-1]!=1 || k==3;j = j+1;}  goto wait; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte j=0;\nbyte k=0;\n\nNCS: if\n:: j = 1; goto wait; \n\nfi;\nCS: if\n:: pos[2] = 0; goto NCS; \n\nfi;\nwait: if\n::  d_step {j<3;pos[2] = j;}  goto q2; \n\n:: j==3; goto CS; \n\nfi;\nq2: if\n::  d_step {step[j-1] = 2;k = 0;}  goto q3; \n\nfi;\nq3: if\n::  d_step {k<3 && (k==2 || pos[k]<=j);k = k+1;}  goto q3; \n\n::  d_step {step[j-1]!=2 || k==3;j = j+1;}  goto wait; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually.\n\nSee also other mutex examples.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte pos[3];\nbyte step[3];\n\n\nactive proctype P_0() { \nbyte j=0;\nbyte k=0;\n\nNCS: if\n:: j = 1; goto wait; \n\nfi;\nCS: if\n:: pos[0] = 0; goto NCS; \n\nfi;\nwait: if\n::  d_step {j<3;pos[0] = j;}  goto q2; \n\n:: j==3; goto CS; \n\nfi;\nq2: if\n::  d_step {step[j-1] = 0;k = 0;}  goto q3; \n\nfi;\nq3: if\n::  d_step {k<3 && (k==0 || pos[k]<j);k = k+1;}  goto q3; \n\n::  d_step {pos[j-1]!=0 || k==3;j = j+1;}  goto wait; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte j=0;\nbyte k=0;\n\nNCS: if\n:: j = 1; goto wait; \n\nfi;\nCS: if\n:: pos[1] = 0; goto NCS; \n\nfi;\nwait: if\n::  d_step {j<3;pos[1] = j;}  goto q2; \n\n:: j==3; goto CS; \n\nfi;\nq2: if\n::  d_step {step[j-1] = 1;k = 0;}  goto q3; \n\nfi;\nq3: if\n::  d_step {k<3 && (k==1 || pos[k]<j);k = k+1;}  goto q3; \n\n::  d_step {pos[j-1]!=1 || k==3;j = j+1;}  goto wait; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte j=0;\nbyte k=0;\n\nNCS: if\n:: j = 1; goto wait; \n\nfi;\nCS: if\n:: pos[2] = 0; goto NCS; \n\nfi;\nwait: if\n::  d_step {j<3;pos[2] = j;}  goto q2; \n\n:: j==3; goto CS; \n\nfi;\nq2: if\n::  d_step {step[j-1] = 2;k = 0;}  goto q3; \n\nfi;\nq3: if\n::  d_step {k<3 && (k==2 || pos[k]<j);k = k+1;}  goto q3; \n\n::  d_step {pos[j-1]!=2 || k==3;j = j+1;}  goto wait; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually.\n\nSee also other mutex examples.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte pos[4];\nbyte step[4];\n\n\nactive proctype P_0() { \nbyte j=0;\nbyte k=0;\n\nNCS: if\n:: j = 1; goto wait; \n\nfi;\nCS: if\n:: pos[0] = 0; goto NCS; \n\nfi;\nwait: if\n::  d_step {j<4;pos[0] = j;}  goto q2; \n\n:: j==4; goto CS; \n\nfi;\nq2: if\n::  d_step {step[j-1] = 0;k = 0;}  goto q3; \n\nfi;\nq3: if\n::  d_step {k<4 && (k==0 || pos[k]<j);k = k+1;}  goto q3; \n\n::  d_step {step[j-1]!=0 || k==4;j = j+1;}  goto wait; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte j=0;\nbyte k=0;\n\nNCS: if\n:: j = 1; goto wait; \n\nfi;\nCS: if\n:: pos[1] = 0; goto NCS; \n\nfi;\nwait: if\n::  d_step {j<4;pos[1] = j;}  goto q2; \n\n:: j==4; goto CS; \n\nfi;\nq2: if\n::  d_step {step[j-1] = 1;k = 0;}  goto q3; \n\nfi;\nq3: if\n::  d_step {k<4 && (k==1 || pos[k]<j);k = k+1;}  goto q3; \n\n::  d_step {step[j-1]!=1 || k==4;j = j+1;}  goto wait; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte j=0;\nbyte k=0;\n\nNCS: if\n:: j = 1; goto wait; \n\nfi;\nCS: if\n:: pos[2] = 0; goto NCS; \n\nfi;\nwait: if\n::  d_step {j<4;pos[2] = j;}  goto q2; \n\n:: j==4; goto CS; \n\nfi;\nq2: if\n::  d_step {step[j-1] = 2;k = 0;}  goto q3; \n\nfi;\nq3: if\n::  d_step {k<4 && (k==2 || pos[k]<j);k = k+1;}  goto q3; \n\n::  d_step {step[j-1]!=2 || k==4;j = j+1;}  goto wait; \n\nfi;\n}\n\nactive proctype P_3() { \nbyte j=0;\nbyte k=0;\n\nNCS: if\n:: j = 1; goto wait; \n\nfi;\nCS: if\n:: pos[3] = 0; goto NCS; \n\nfi;\nwait: if\n::  d_step {j<4;pos[3] = j;}  goto q2; \n\n:: j==4; goto CS; \n\nfi;\nq2: if\n::  d_step {step[j-1] = 3;k = 0;}  goto q3; \n\nfi;\nq3: if\n::  d_step {k<4 && (k==3 || pos[k]<j);k = k+1;}  goto q3; \n\n::  d_step {step[j-1]!=3 || k==4;j = j+1;}  goto wait; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually.\n\nSee also other mutex examples.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte pos[4];\nbyte step[4];\n\n\nactive proctype P_0() { \nbyte j=0;\nbyte k=0;\n\nNCS: if\n:: j = 1; goto wait; \n\nfi;\nCS: if\n:: pos[0] = 0; goto NCS; \n\nfi;\nwait: if\n::  d_step {j<4;pos[0] = j;}  goto q2; \n\n:: j==4; goto CS; \n\nfi;\nq2: if\n::  d_step {step[j-1] = 0;k = 0;}  goto q3; \n\nfi;\nq3: if\n::  d_step {k<4 && (k==0 || pos[k]<=j);k = k+1;}  goto q3; \n\n::  d_step {step[j-1]!=0 || k==4;j = j+1;}  goto wait; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte j=0;\nbyte k=0;\n\nNCS: if\n:: j = 1; goto wait; \n\nfi;\nCS: if\n:: pos[1] = 0; goto NCS; \n\nfi;\nwait: if\n::  d_step {j<4;pos[1] = j;}  goto q2; \n\n:: j==4; goto CS; \n\nfi;\nq2: if\n::  d_step {step[j-1] = 1;k = 0;}  goto q3; \n\nfi;\nq3: if\n::  d_step {k<4 && (k==1 || pos[k]<=j);k = k+1;}  goto q3; \n\n::  d_step {step[j-1]!=1 || k==4;j = j+1;}  goto wait; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte j=0;\nbyte k=0;\n\nNCS: if\n:: j = 1; goto wait; \n\nfi;\nCS: if\n:: pos[2] = 0; goto NCS; \n\nfi;\nwait: if\n::  d_step {j<4;pos[2] = j;}  goto q2; \n\n:: j==4; goto CS; \n\nfi;\nq2: if\n::  d_step {step[j-1] = 2;k = 0;}  goto q3; \n\nfi;\nq3: if\n::  d_step {k<4 && (k==2 || pos[k]<=j);k = k+1;}  goto q3; \n\n::  d_step {step[j-1]!=2 || k==4;j = j+1;}  goto wait; \n\nfi;\n}\n\nactive proctype P_3() { \nbyte j=0;\nbyte k=0;\n\nNCS: if\n:: j = 1; goto wait; \n\nfi;\nCS: if\n:: pos[3] = 0; goto NCS; \n\nfi;\nwait: if\n::  d_step {j<4;pos[3] = j;}  goto q2; \n\n:: j==4; goto CS; \n\nfi;\nq2: if\n::  d_step {step[j-1] = 3;k = 0;}  goto q3; \n\nfi;\nq3: if\n::  d_step {k<4 && (k==3 || pos[k]<=j);k = k+1;}  goto q3; \n\n::  d_step {step[j-1]!=3 || k==4;j = j+1;}  goto wait; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually.\n\nSee also other mutex examples.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte pos[4];\nbyte step[4];\n\n\nactive proctype P_0() { \nbyte j=0;\nbyte k=0;\n\nNCS: if\n:: j = 1; goto wait; \n\nfi;\nCS: if\n:: pos[0] = 0; goto NCS; \n\nfi;\nwait: if\n::  d_step {j<4;pos[0] = j;}  goto q2; \n\n:: j==4; goto CS; \n\nfi;\nq2: if\n::  d_step {step[j-1] = 0;k = 0;}  goto q3; \n\nfi;\nq3: if\n::  d_step {k<4 && (k==0 || pos[k]<j);k = k+1;}  goto q3; \n\n::  d_step {pos[j-1]!=0 || k==4;j = j+1;}  goto wait; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte j=0;\nbyte k=0;\n\nNCS: if\n:: j = 1; goto wait; \n\nfi;\nCS: if\n:: pos[1] = 0; goto NCS; \n\nfi;\nwait: if\n::  d_step {j<4;pos[1] = j;}  goto q2; \n\n:: j==4; goto CS; \n\nfi;\nq2: if\n::  d_step {step[j-1] = 1;k = 0;}  goto q3; \n\nfi;\nq3: if\n::  d_step {k<4 && (k==1 || pos[k]<j);k = k+1;}  goto q3; \n\n::  d_step {pos[j-1]!=1 || k==4;j = j+1;}  goto wait; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte j=0;\nbyte k=0;\n\nNCS: if\n:: j = 1; goto wait; \n\nfi;\nCS: if\n:: pos[2] = 0; goto NCS; \n\nfi;\nwait: if\n::  d_step {j<4;pos[2] = j;}  goto q2; \n\n:: j==4; goto CS; \n\nfi;\nq2: if\n::  d_step {step[j-1] = 2;k = 0;}  goto q3; \n\nfi;\nq3: if\n::  d_step {k<4 && (k==2 || pos[k]<j);k = k+1;}  goto q3; \n\n::  d_step {pos[j-1]!=2 || k==4;j = j+1;}  goto wait; \n\nfi;\n}\n\nactive proctype P_3() { \nbyte j=0;\nbyte k=0;\n\nNCS: if\n:: j = 1; goto wait; \n\nfi;\nCS: if\n:: pos[3] = 0; goto NCS; \n\nfi;\nwait: if\n::  d_step {j<4;pos[3] = j;}  goto q2; \n\n:: j==4; goto CS; \n\nfi;\nq2: if\n::  d_step {step[j-1] = 3;k = 0;}  goto q3; \n\nfi;\nq3: if\n::  d_step {k<4 && (k==3 || pos[k]<j);k = k+1;}  goto q3; \n\n::  d_step {pos[j-1]!=3 || k==4;j = j+1;}  goto wait; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually.\n\nSee also other mutex examples.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte pos[5];\nbyte step[5];\n\n\nactive proctype P_0() { \nbyte j=0;\nbyte k=0;\n\nNCS: if\n:: j = 1; goto wait; \n\nfi;\nCS: if\n:: pos[0] = 0; goto NCS; \n\nfi;\nwait: if\n::  d_step {j<5;pos[0] = j;}  goto q2; \n\n:: j==5; goto CS; \n\nfi;\nq2: if\n::  d_step {step[j-1] = 0;k = 0;}  goto q3; \n\nfi;\nq3: if\n::  d_step {k<5 && (k==0 || pos[k]<j);k = k+1;}  goto q3; \n\n::  d_step {step[j-1]!=0 || k==5;j = j+1;}  goto wait; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte j=0;\nbyte k=0;\n\nNCS: if\n:: j = 1; goto wait; \n\nfi;\nCS: if\n:: pos[1] = 0; goto NCS; \n\nfi;\nwait: if\n::  d_step {j<5;pos[1] = j;}  goto q2; \n\n:: j==5; goto CS; \n\nfi;\nq2: if\n::  d_step {step[j-1] = 1;k = 0;}  goto q3; \n\nfi;\nq3: if\n::  d_step {k<5 && (k==1 || pos[k]<j);k = k+1;}  goto q3; \n\n::  d_step {step[j-1]!=1 || k==5;j = j+1;}  goto wait; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte j=0;\nbyte k=0;\n\nNCS: if\n:: j = 1; goto wait; \n\nfi;\nCS: if\n:: pos[2] = 0; goto NCS; \n\nfi;\nwait: if\n::  d_step {j<5;pos[2] = j;}  goto q2; \n\n:: j==5; goto CS; \n\nfi;\nq2: if\n::  d_step {step[j-1] = 2;k = 0;}  goto q3; \n\nfi;\nq3: if\n::  d_step {k<5 && (k==2 || pos[k]<j);k = k+1;}  goto q3; \n\n::  d_step {step[j-1]!=2 || k==5;j = j+1;}  goto wait; \n\nfi;\n}\n\nactive proctype P_3() { \nbyte j=0;\nbyte k=0;\n\nNCS: if\n:: j = 1; goto wait; \n\nfi;\nCS: if\n:: pos[3] = 0; goto NCS; \n\nfi;\nwait: if\n::  d_step {j<5;pos[3] = j;}  goto q2; \n\n:: j==5; goto CS; \n\nfi;\nq2: if\n::  d_step {step[j-1] = 3;k = 0;}  goto q3; \n\nfi;\nq3: if\n::  d_step {k<5 && (k==3 || pos[k]<j);k = k+1;}  goto q3; \n\n::  d_step {step[j-1]!=3 || k==5;j = j+1;}  goto wait; \n\nfi;\n}\n\nactive proctype P_4() { \nbyte j=0;\nbyte k=0;\n\nNCS: if\n:: j = 1; goto wait; \n\nfi;\nCS: if\n:: pos[4] = 0; goto NCS; \n\nfi;\nwait: if\n::  d_step {j<5;pos[4] = j;}  goto q2; \n\n:: j==5; goto CS; \n\nfi;\nq2: if\n::  d_step {step[j-1] = 4;k = 0;}  goto q3; \n\nfi;\nq3: if\n::  d_step {k<5 && (k==4 || pos[k]<j);k = k+1;}  goto q3; \n\n::  d_step {step[j-1]!=4 || k==5;j = j+1;}  goto wait; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Imagine that five philosophers who spend their lives just\n    thinking and easting. In the middle of the dining room is a circular table\n    with five chairs. The table has a big plate of spaghetti. However, there\n    are only five chopsticks available, as shown in the following figure. Each\n    philosopher thinks. When he gets hungry, he sits down and picks up the two\n    chopsticks that are closest to him. If a philosopher can pick up both\n    chopsticks, he eats for a while. After a philosopher finishes eating, he\n    puts down the chopsticks and starts to think.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte fork[4];\n\n\nactive proctype phil_0() { \n\nthink: if\n::  d_step {fork[0]==0;fork[0] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[1]==0;fork[1] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[0] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[1] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_1() { \n\nthink: if\n::  d_step {fork[1]==0;fork[1] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[2]==0;fork[2] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[1] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[2] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_2() { \n\nthink: if\n::  d_step {fork[2]==0;fork[2] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[3]==0;fork[3] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[2] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[3] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_3() { \n\nthink: if\n::  d_step {fork[3]==0;fork[3] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[0]==0;fork[0] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[3] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[0] = 0; goto think; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Imagine that five philosophers who spend their lives just\n    thinking and easting. In the middle of the dining room is a circular table\n    with five chairs. The table has a big plate of spaghetti. However, there\n    are only five chopsticks available, as shown in the following figure. Each\n    philosopher thinks. When he gets hungry, he sits down and picks up the two\n    chopsticks that are closest to him. If a philosopher can pick up both\n    chopsticks, he eats for a while. After a philosopher finishes eating, he\n    puts down the chopsticks and starts to think.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte fork[5];\nbyte count=0;\n\n\nactive proctype phil_0() { \n\nthink: if\n::  d_step {count<3;count = count+1;}  goto inside; \n\nfi;\ninside: if\n:: count = count-1; goto think; \n\n::  d_step {fork[0]==0;fork[0] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[1]==0;fork[1] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[0] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[1] = 0; goto inside; \n\nfi;\n}\n\nactive proctype phil_1() { \n\nthink: if\n::  d_step {count<3;count = count+1;}  goto inside; \n\nfi;\ninside: if\n:: count = count-1; goto think; \n\n::  d_step {fork[1]==0;fork[1] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[2]==0;fork[2] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[1] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[2] = 0; goto inside; \n\nfi;\n}\n\nactive proctype phil_2() { \n\nthink: if\n::  d_step {count<3;count = count+1;}  goto inside; \n\nfi;\ninside: if\n:: count = count-1; goto think; \n\n::  d_step {fork[2]==0;fork[2] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[3]==0;fork[3] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[2] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[3] = 0; goto inside; \n\nfi;\n}\n\nactive proctype phil_3() { \n\nthink: if\n::  d_step {count<3;count = count+1;}  goto inside; \n\nfi;\ninside: if\n:: count = count-1; goto think; \n\n::  d_step {fork[3]==0;fork[3] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[4]==0;fork[4] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[3] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[4] = 0; goto inside; \n\nfi;\n}\n\nactive proctype phil_4() { \n\nthink: if\n::  d_step {count<3;count = count+1;}  goto inside; \n\nfi;\ninside: if\n:: count = count-1; goto think; \n\n::  d_step {fork[4]==0;fork[4] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[0]==0;fork[0] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[4] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[0] = 0; goto inside; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Imagine that five philosophers who spend their lives just\n    thinking and easting. In the middle of the dining room is a circular table\n    with five chairs. The table has a big plate of spaghetti. However, there\n    are only five chopsticks available, as shown in the following figure. Each\n    philosopher thinks. When he gets hungry, he sits down and picks up the two\n    chopsticks that are closest to him. If a philosopher can pick up both\n    chopsticks, he eats for a while. After a philosopher finishes eating, he\n    puts down the chopsticks and starts to think.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte fork[6];\n\n\nactive proctype phil_0() { \n\nthink: if\n::  d_step {fork[1]==0;fork[1] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[0]==0;fork[0] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[1] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[0] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_1() { \n\nthink: if\n::  d_step {fork[1]==0;fork[1] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[2]==0;fork[2] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[1] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[2] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_2() { \n\nthink: if\n::  d_step {fork[2]==0;fork[2] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[3]==0;fork[3] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[2] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[3] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_3() { \n\nthink: if\n::  d_step {fork[3]==0;fork[3] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[4]==0;fork[4] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[3] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[4] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_4() { \n\nthink: if\n::  d_step {fork[4]==0;fork[4] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[5]==0;fork[5] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[4] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[5] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_5() { \n\nthink: if\n::  d_step {fork[5]==0;fork[5] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[0]==0;fork[0] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[5] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[0] = 0; goto think; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Imagine that five philosophers who spend their lives just\n    thinking and easting. In the middle of the dining room is a circular table\n    with five chairs. The table has a big plate of spaghetti. However, there\n    are only five chopsticks available, as shown in the following figure. Each\n    philosopher thinks. When he gets hungry, he sits down and picks up the two\n    chopsticks that are closest to him. If a philosopher can pick up both\n    chopsticks, he eats for a while. After a philosopher finishes eating, he\n    puts down the chopsticks and starts to think.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte fork[9];\nbyte count=0;\n\n\nactive proctype phil_0() { \n\nthink: if\n::  d_step {count<7;count = count+1;}  goto inside; \n\nfi;\ninside: if\n:: count = count-1; goto think; \n\n::  d_step {fork[0]==0;fork[0] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[1]==0;fork[1] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[0] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[1] = 0; goto inside; \n\nfi;\n}\n\nactive proctype phil_1() { \n\nthink: if\n::  d_step {count<7;count = count+1;}  goto inside; \n\nfi;\ninside: if\n:: count = count-1; goto think; \n\n::  d_step {fork[1]==0;fork[1] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[2]==0;fork[2] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[1] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[2] = 0; goto inside; \n\nfi;\n}\n\nactive proctype phil_2() { \n\nthink: if\n::  d_step {count<7;count = count+1;}  goto inside; \n\nfi;\ninside: if\n:: count = count-1; goto think; \n\n::  d_step {fork[2]==0;fork[2] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[3]==0;fork[3] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[2] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[3] = 0; goto inside; \n\nfi;\n}\n\nactive proctype phil_3() { \n\nthink: if\n::  d_step {count<7;count = count+1;}  goto inside; \n\nfi;\ninside: if\n:: count = count-1; goto think; \n\n::  d_step {fork[3]==0;fork[3] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[4]==0;fork[4] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[3] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[4] = 0; goto inside; \n\nfi;\n}\n\nactive proctype phil_4() { \n\nthink: if\n::  d_step {count<7;count = count+1;}  goto inside; \n\nfi;\ninside: if\n:: count = count-1; goto think; \n\n::  d_step {fork[4]==0;fork[4] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[5]==0;fork[5] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[4] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[5] = 0; goto inside; \n\nfi;\n}\n\nactive proctype phil_5() { \n\nthink: if\n::  d_step {count<7;count = count+1;}  goto inside; \n\nfi;\ninside: if\n:: count = count-1; goto think; \n\n::  d_step {fork[5]==0;fork[5] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[6]==0;fork[6] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[5] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[6] = 0; goto inside; \n\nfi;\n}\n\nactive proctype phil_6() { \n\nthink: if\n::  d_step {count<7;count = count+1;}  goto inside; \n\nfi;\ninside: if\n:: count = count-1; goto think; \n\n::  d_step {fork[6]==0;fork[6] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[7]==0;fork[7] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[6] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[7] = 0; goto inside; \n\nfi;\n}\n\nactive proctype phil_7() { \n\nthink: if\n::  d_step {count<7;count = count+1;}  goto inside; \n\nfi;\ninside: if\n:: count = count-1; goto think; \n\n::  d_step {fork[7]==0;fork[7] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[8]==0;fork[8] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[7] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[8] = 0; goto inside; \n\nfi;\n}\n\nactive proctype phil_8() { \n\nthink: if\n::  d_step {count<7;count = count+1;}  goto inside; \n\nfi;\ninside: if\n:: count = count-1; goto think; \n\n::  d_step {fork[8]==0;fork[8] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[0]==0;fork[0] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[8] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[0] = 0; goto inside; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Imagine that five philosophers who spend their lives just\n    thinking and easting. In the middle of the dining room is a circular table\n    with five chairs. The table has a big plate of spaghetti. However, there\n    are only five chopsticks available, as shown in the following figure. Each\n    philosopher thinks. When he gets hungry, he sits down and picks up the two\n    chopsticks that are closest to him. If a philosopher can pick up both\n    chopsticks, he eats for a while. After a philosopher finishes eating, he\n    puts down the chopsticks and starts to think.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte fork[12];\n\n\nactive proctype phil_0() { \n\nthink: if\n::  d_step {fork[0]==0;fork[0] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[1]==0;fork[1] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[0] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[1] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_1() { \n\nthink: if\n::  d_step {fork[1]==0;fork[1] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[2]==0;fork[2] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[1] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[2] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_2() { \n\nthink: if\n::  d_step {fork[2]==0;fork[2] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[3]==0;fork[3] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[2] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[3] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_3() { \n\nthink: if\n::  d_step {fork[3]==0;fork[3] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[4]==0;fork[4] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[3] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[4] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_4() { \n\nthink: if\n::  d_step {fork[4]==0;fork[4] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[5]==0;fork[5] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[4] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[5] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_5() { \n\nthink: if\n::  d_step {fork[5]==0;fork[5] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[6]==0;fork[6] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[5] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[6] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_6() { \n\nthink: if\n::  d_step {fork[6]==0;fork[6] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[7]==0;fork[7] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[6] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[7] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_7() { \n\nthink: if\n::  d_step {fork[7]==0;fork[7] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[8]==0;fork[8] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[7] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[8] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_8() { \n\nthink: if\n::  d_step {fork[8]==0;fork[8] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[9]==0;fork[9] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[8] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[9] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_9() { \n\nthink: if\n::  d_step {fork[9]==0;fork[9] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[10]==0;fork[10] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[9] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[10] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_10() { \n\nthink: if\n::  d_step {fork[10]==0;fork[10] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[11]==0;fork[11] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[10] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[11] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_11() { \n\nthink: if\n::  d_step {fork[11]==0;fork[11] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[0]==0;fork[0] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[11] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[0] = 0; goto think; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Imagine that five philosophers who spend their lives just\n    thinking and easting. In the middle of the dining room is a circular table\n    with five chairs. The table has a big plate of spaghetti. However, there\n    are only five chopsticks available, as shown in the following figure. Each\n    philosopher thinks. When he gets hungry, he sits down and picks up the two\n    chopsticks that are closest to him. If a philosopher can pick up both\n    chopsticks, he eats for a while. After a philosopher finishes eating, he\n    puts down the chopsticks and starts to think.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte fork[15];\n\n\nactive proctype phil_0() { \n\nthink: if\n::  d_step {fork[0]==0;fork[0] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[1]==0;fork[1] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[0] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[1] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_1() { \n\nthink: if\n::  d_step {fork[1]==0;fork[1] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[2]==0;fork[2] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[1] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[2] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_2() { \n\nthink: if\n::  d_step {fork[2]==0;fork[2] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[3]==0;fork[3] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[2] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[3] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_3() { \n\nthink: if\n::  d_step {fork[3]==0;fork[3] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[4]==0;fork[4] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[3] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[4] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_4() { \n\nthink: if\n::  d_step {fork[4]==0;fork[4] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[5]==0;fork[5] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[4] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[5] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_5() { \n\nthink: if\n::  d_step {fork[5]==0;fork[5] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[6]==0;fork[6] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[5] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[6] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_6() { \n\nthink: if\n::  d_step {fork[6]==0;fork[6] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[7]==0;fork[7] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[6] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[7] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_7() { \n\nthink: if\n::  d_step {fork[7]==0;fork[7] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[8]==0;fork[8] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[7] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[8] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_8() { \n\nthink: if\n::  d_step {fork[8]==0;fork[8] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[9]==0;fork[9] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[8] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[9] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_9() { \n\nthink: if\n::  d_step {fork[9]==0;fork[9] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[10]==0;fork[10] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[9] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[10] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_10() { \n\nthink: if\n::  d_step {fork[10]==0;fork[10] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[11]==0;fork[11] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[10] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[11] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_11() { \n\nthink: if\n::  d_step {fork[11]==0;fork[11] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[12]==0;fork[12] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[11] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[12] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_12() { \n\nthink: if\n::  d_step {fork[12]==0;fork[12] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[13]==0;fork[13] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[12] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[13] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_13() { \n\nthink: if\n::  d_step {fork[13]==0;fork[13] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[14]==0;fork[14] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[13] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[14] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_14() { \n\nthink: if\n::  d_step {fork[14]==0;fork[14] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[0]==0;fork[0] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[14] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[0] = 0; goto think; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Imagine that five philosophers who spend their lives just\n    thinking and easting. In the middle of the dining room is a circular table\n    with five chairs. The table has a big plate of spaghetti. However, there\n    are only five chopsticks available, as shown in the following figure. Each\n    philosopher thinks. When he gets hungry, he sits down and picks up the two\n    chopsticks that are closest to him. If a philosopher can pick up both\n    chopsticks, he eats for a while. After a philosopher finishes eating, he\n    puts down the chopsticks and starts to think.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte fork[13];\nbyte count=0;\n\n\nactive proctype phil_0() { \n\nthink: if\n::  d_step {count<9;count = count+1;}  goto inside; \n\nfi;\ninside: if\n:: count = count-1; goto think; \n\n::  d_step {fork[0]==0;fork[0] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[1]==0;fork[1] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[0] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[1] = 0; goto inside; \n\nfi;\n}\n\nactive proctype phil_1() { \n\nthink: if\n::  d_step {count<9;count = count+1;}  goto inside; \n\nfi;\ninside: if\n:: count = count-1; goto think; \n\n::  d_step {fork[1]==0;fork[1] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[2]==0;fork[2] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[1] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[2] = 0; goto inside; \n\nfi;\n}\n\nactive proctype phil_2() { \n\nthink: if\n::  d_step {count<9;count = count+1;}  goto inside; \n\nfi;\ninside: if\n:: count = count-1; goto think; \n\n::  d_step {fork[2]==0;fork[2] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[3]==0;fork[3] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[2] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[3] = 0; goto inside; \n\nfi;\n}\n\nactive proctype phil_3() { \n\nthink: if\n::  d_step {count<9;count = count+1;}  goto inside; \n\nfi;\ninside: if\n:: count = count-1; goto think; \n\n::  d_step {fork[3]==0;fork[3] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[4]==0;fork[4] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[3] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[4] = 0; goto inside; \n\nfi;\n}\n\nactive proctype phil_4() { \n\nthink: if\n::  d_step {count<9;count = count+1;}  goto inside; \n\nfi;\ninside: if\n:: count = count-1; goto think; \n\n::  d_step {fork[4]==0;fork[4] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[5]==0;fork[5] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[4] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[5] = 0; goto inside; \n\nfi;\n}\n\nactive proctype phil_5() { \n\nthink: if\n::  d_step {count<9;count = count+1;}  goto inside; \n\nfi;\ninside: if\n:: count = count-1; goto think; \n\n::  d_step {fork[5]==0;fork[5] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[6]==0;fork[6] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[5] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[6] = 0; goto inside; \n\nfi;\n}\n\nactive proctype phil_6() { \n\nthink: if\n::  d_step {count<9;count = count+1;}  goto inside; \n\nfi;\ninside: if\n:: count = count-1; goto think; \n\n::  d_step {fork[6]==0;fork[6] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[7]==0;fork[7] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[6] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[7] = 0; goto inside; \n\nfi;\n}\n\nactive proctype phil_7() { \n\nthink: if\n::  d_step {count<9;count = count+1;}  goto inside; \n\nfi;\ninside: if\n:: count = count-1; goto think; \n\n::  d_step {fork[7]==0;fork[7] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[8]==0;fork[8] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[7] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[8] = 0; goto inside; \n\nfi;\n}\n\nactive proctype phil_8() { \n\nthink: if\n::  d_step {count<9;count = count+1;}  goto inside; \n\nfi;\ninside: if\n:: count = count-1; goto think; \n\n::  d_step {fork[8]==0;fork[8] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[9]==0;fork[9] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[8] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[9] = 0; goto inside; \n\nfi;\n}\n\nactive proctype phil_9() { \n\nthink: if\n::  d_step {count<9;count = count+1;}  goto inside; \n\nfi;\ninside: if\n:: count = count-1; goto think; \n\n::  d_step {fork[9]==0;fork[9] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[10]==0;fork[10] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[9] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[10] = 0; goto inside; \n\nfi;\n}\n\nactive proctype phil_10() { \n\nthink: if\n::  d_step {count<9;count = count+1;}  goto inside; \n\nfi;\ninside: if\n:: count = count-1; goto think; \n\n::  d_step {fork[10]==0;fork[10] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[11]==0;fork[11] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[10] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[11] = 0; goto inside; \n\nfi;\n}\n\nactive proctype phil_11() { \n\nthink: if\n::  d_step {count<9;count = count+1;}  goto inside; \n\nfi;\ninside: if\n:: count = count-1; goto think; \n\n::  d_step {fork[11]==0;fork[11] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[12]==0;fork[12] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[11] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[12] = 0; goto inside; \n\nfi;\n}\n\nactive proctype phil_12() { \n\nthink: if\n::  d_step {count<9;count = count+1;}  goto inside; \n\nfi;\ninside: if\n:: count = count-1; goto think; \n\n::  d_step {fork[12]==0;fork[12] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[0]==0;fork[0] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[12] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[0] = 0; goto inside; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Imagine that five philosophers who spend their lives just\n    thinking and easting. In the middle of the dining room is a circular table\n    with five chairs. The table has a big plate of spaghetti. However, there\n    are only five chopsticks available, as shown in the following figure. Each\n    philosopher thinks. When he gets hungry, he sits down and picks up the two\n    chopsticks that are closest to him. If a philosopher can pick up both\n    chopsticks, he eats for a while. After a philosopher finishes eating, he\n    puts down the chopsticks and starts to think.\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte fork[16];\n\n\nactive proctype phil_0() { \n\nthink: if\n::  d_step {fork[0]==0;fork[0] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[1]==0;fork[1] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[0] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[1] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_1() { \n\nthink: if\n::  d_step {fork[1]==0;fork[1] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[2]==0;fork[2] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[1] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[2] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_2() { \n\nthink: if\n::  d_step {fork[2]==0;fork[2] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[3]==0;fork[3] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[2] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[3] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_3() { \n\nthink: if\n::  d_step {fork[3]==0;fork[3] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[4]==0;fork[4] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[3] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[4] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_4() { \n\nthink: if\n::  d_step {fork[4]==0;fork[4] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[5]==0;fork[5] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[4] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[5] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_5() { \n\nthink: if\n::  d_step {fork[5]==0;fork[5] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[6]==0;fork[6] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[5] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[6] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_6() { \n\nthink: if\n::  d_step {fork[6]==0;fork[6] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[7]==0;fork[7] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[6] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[7] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_7() { \n\nthink: if\n::  d_step {fork[7]==0;fork[7] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[8]==0;fork[8] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[7] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[8] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_8() { \n\nthink: if\n::  d_step {fork[8]==0;fork[8] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[9]==0;fork[9] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[8] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[9] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_9() { \n\nthink: if\n::  d_step {fork[9]==0;fork[9] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[10]==0;fork[10] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[9] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[10] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_10() { \n\nthink: if\n::  d_step {fork[10]==0;fork[10] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[11]==0;fork[11] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[10] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[11] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_11() { \n\nthink: if\n::  d_step {fork[11]==0;fork[11] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[12]==0;fork[12] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[11] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[12] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_12() { \n\nthink: if\n::  d_step {fork[12]==0;fork[12] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[13]==0;fork[13] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[12] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[13] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_13() { \n\nthink: if\n::  d_step {fork[13]==0;fork[13] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[14]==0;fork[14] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[13] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[14] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_14() { \n\nthink: if\n::  d_step {fork[14]==0;fork[14] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[15]==0;fork[15] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[14] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[15] = 0; goto think; \n\nfi;\n}\n\nactive proctype phil_15() { \n\nthink: if\n::  d_step {fork[15]==0;fork[15] = 1;}  goto one; \n\nfi;\none: if\n::  d_step {fork[0]==0;fork[0] = 1;}  goto eat; \n\nfi;\neat: if\n:: fork[15] = 0; goto finish; \n\nfi;\nfinish: if\n:: fork[0] = 0; goto think; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The task of the production cell case study was to develop\n    control software for a realistic industrial production cell, comprising\n    several machines (e.g., a robot, a press, two conveyor belts). This\n    software had to fulfill certain safety and liveness requirements (e.g.,\n    never close the press while a robot arm is inside it). The example was\n    taken from real world (a metal processing plant in Germany), but was at the\n    same time of managable complexity. This model captures just the basic\n    structure of the problem.\n\nParameters:\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte done=0;\n\nchan plt_belt_0 =[0] of {int};\nchan plt_table_0 =[0] of {int};\nchan plt_press_0 =[0] of {int};\nchan plt_deposit_0 =[0] of {int};\nchan plt_belt_1 =[0] of {int};\nchan plt_table_1 =[0] of {int};\nchan plt_press_1 =[0] of {int};\nchan plt_deposit_1 =[0] of {int};\nchan plt_belt_2 =[0] of {int};\nchan plt_table_2 =[0] of {int};\nchan plt_press_2 =[0] of {int};\nchan plt_deposit_2 =[0] of {int};\nchan new_plate =[0] of {int};\nchan sen =[0] of {int};\nchan read =[0] of {int};\nchan put_table =[0] of {int};\nchan get_table =[0] of {int};\nchan put_press =[0] of {int};\nchan get_press =[0] of {int};\nchan put_deposit =[0] of {int};\n\nactive proctype Plate_0() { \n\nnew: if\n:: new_plate!0; goto wait_belt; \n\nfi;\nwait_belt: if\n:: plt_belt_0!0; goto wait_table; \n\nfi;\nwait_table: if\n:: plt_table_0!0; goto wait_press; \n\nfi;\nwait_press: if\n:: plt_press_0!0; goto wait_deposit; \n\nfi;\nwait_deposit: if\n:: plt_deposit_0!0; goto new; \n\nfi;\n}\n\nactive proctype Plate_1() { \n\nnew: if\n:: new_plate!1; goto wait_belt; \n\nfi;\nwait_belt: if\n:: plt_belt_1!0; goto wait_table; \n\nfi;\nwait_table: if\n:: plt_table_1!0; goto wait_press; \n\nfi;\nwait_press: if\n:: plt_press_1!0; goto wait_deposit; \n\nfi;\nwait_deposit: if\n:: plt_deposit_1!0; goto new; \n\nfi;\n}\n\nactive proctype Plate_2() { \n\nnew: if\n:: new_plate!2; goto wait_belt; \n\nfi;\nwait_belt: if\n:: plt_belt_2!0; goto wait_table; \n\nfi;\nwait_table: if\n:: plt_table_2!0; goto wait_press; \n\nfi;\nwait_press: if\n:: plt_press_2!0; goto wait_deposit; \n\nfi;\nwait_deposit: if\n:: plt_deposit_2!0; goto new; \n\nfi;\n}\n\nactive proctype Belt() { \nbyte k=0;\n\nwait: if\n:: new_plate?k; goto got_new; \n\nfi;\ngot_new: if\n:: sen!0; goto q1; \n\nfi;\nq1: if\n::  atomic {k==0;plt_belt_0?0;}  goto q2; \n\n::  atomic {k==1;plt_belt_1?0;}  goto q2; \n\n::  atomic {k==2;plt_belt_2?0;}  goto q2; \n\nfi;\nq2: if\n:: put_table!k; goto wait; \n\nfi;\n}\n\nactive proctype Sensor() { \nbyte count=0;\n\nq: if\n::  atomic {sen?0;count = count+1;}  goto q; \n\n::  atomic {count>0;read!0;count = count-1;}  goto q; \n\nfi;\n}\n\nactive proctype Table() { \nbyte k=0;\n\ndown_empty: if\n:: put_table?k; goto down_full; \n\nfi;\ndown_full: if\n::  atomic {k==0;plt_table_0?0;}  goto up_full; \n\n::  atomic {k==1;plt_table_1?0;}  goto up_full; \n\n::  atomic {k==2;plt_table_2?0;}  goto up_full; \n\nfi;\nup_empty: if\n::  goto down_empty; \n\nfi;\nup_full: if\n:: get_table!k; goto up_empty; \n\nfi;\n}\n\nactive proctype Press() { \nbyte k=0;\n\nwait: if\n:: put_press?k; goto pressing; \n\nfi;\npressing: if\n::  atomic {k==0;plt_press_0?0;}  goto done; \n\n::  atomic {k==1;plt_press_1?0;}  goto done; \n\n::  atomic {k==2;plt_press_2?0;}  goto done; \n\nfi;\ndone: if\n:: get_press!k; goto wait; \n\nfi;\n}\n\nactive proctype Deposit() { \nbyte k=0;\n\nwait: if\n:: put_deposit?k; goto loaded; \n\nfi;\nloaded: if\n::  atomic {k==0;plt_deposit_0?0;}  goto wait; \n\n::  atomic {k==1;plt_deposit_1?0;}  goto wait; \n\n::  atomic {k==2;plt_deposit_2?0;}  goto wait; \n\nfi;\n}\n\nactive proctype Robot() { \nbyte at_press=0;\nbyte at_table=0;\nbyte A=255;\nbyte B=255;\n\nwait: if\n:: (B==255 && at_press==1) || (A==255 && at_table==1); goto Bpress; \n\n::  atomic {at_table==0;read?0;at_table = 1;}  goto wait; \n\n:: (A!=255 && at_press==0) || B!=255; goto Apress; \n\nfi;\nAtable: if\n::  atomic {at_table==1 && A==255;get_table?A;at_table = 0;}  goto Atable; \n\n:: A!=255; goto Bpress; \n\nfi;\nBpress: if\n::  atomic {B==255 && at_press==1;get_press?B;at_press = 0;}  goto Bpress; \n\n:: A==255 && at_table==1; goto Atable; \n\n:: (A!=255 && at_press==0) || (B!=255 && (A!=255 || at_table==0)); goto wait; \n\nfi;\nApress: if\n::  atomic {A!=255 && at_press==0;put_press!A;A = 255;at_press = 1;}  goto Apress; \n\n:: B!=255; goto Bdeposit; \n\n:: (A==255 || at_press==1) && B==255; goto wait; \n\nfi;\nBdeposit: if\n::  atomic {B!=255;put_deposit!B;B = 255;}  goto Bdeposit; \n\n:: B==255; goto Apress; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The task of the production cell case study was to develop\n    control software for a realistic industrial production cell, comprising\n    several machines (e.g., a robot, a press, two conveyor belts). This\n    software had to fulfill certain safety and liveness requirements (e.g.,\n    never close the press while a robot arm is inside it). The example was\n    taken from real world (a metal processing plant in Germany), but was at the\n    same time of managable complexity. This model captures just the basic\n    structure of the problem.\n\nParameters:\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte done=0;\n\nchan plt_belt_0 =[0] of {int};\nchan plt_table_0 =[0] of {int};\nchan plt_press_0 =[0] of {int};\nchan plt_deposit_0 =[0] of {int};\nchan plt_belt_1 =[0] of {int};\nchan plt_table_1 =[0] of {int};\nchan plt_press_1 =[0] of {int};\nchan plt_deposit_1 =[0] of {int};\nchan new_plate =[0] of {int};\nchan sen =[0] of {int};\nchan read =[0] of {int};\nchan put_table =[0] of {int};\nchan get_table =[0] of {int};\nchan put_press =[0] of {int};\nchan get_press =[0] of {int};\nchan put_deposit =[0] of {int};\n\nactive proctype Plate_0() { \n\nnew: if\n:: new_plate!0; goto wait_belt; \n\nfi;\nwait_belt: if\n:: plt_belt_0!0; goto wait_table; \n\nfi;\nwait_table: if\n:: plt_table_0!0; goto wait_press; \n\nfi;\nwait_press: if\n:: plt_press_0!0; goto wait_deposit; \n\nfi;\nwait_deposit: if\n::  atomic {done<5;plt_deposit_0!0;done = done+1;}  goto new; \n\nfi;\n}\n\nactive proctype Plate_1() { \n\nnew: if\n:: new_plate!1; goto wait_belt; \n\nfi;\nwait_belt: if\n:: plt_belt_1!0; goto wait_table; \n\nfi;\nwait_table: if\n:: plt_table_1!0; goto wait_press; \n\nfi;\nwait_press: if\n:: plt_press_1!0; goto wait_deposit; \n\nfi;\nwait_deposit: if\n::  atomic {done<5;plt_deposit_1!0;done = done+1;}  goto new; \n\nfi;\n}\n\nactive proctype Belt() { \nbyte k=0;\n\nwait: if\n:: new_plate?k; goto got_new; \n\nfi;\ngot_new: if\n:: sen!0; goto q1; \n\nfi;\nq1: if\n::  atomic {k==0;plt_belt_0?0;}  goto q2; \n\n::  atomic {k==1;plt_belt_1?0;}  goto q2; \n\nfi;\nq2: if\n:: put_table!k; goto wait; \n\nfi;\n}\n\nactive proctype Sensor() { \nbyte count=0;\n\nq: if\n::  atomic {sen?0;count = count+1;}  goto q; \n\n::  atomic {count>0;read!0;count = count-1;}  goto q; \n\nfi;\n}\n\nactive proctype Table() { \nbyte k=0;\n\ndown_empty: if\n:: put_table?k; goto down_full; \n\nfi;\ndown_full: if\n::  atomic {k==0;plt_table_0?0;}  goto up_full; \n\n::  atomic {k==1;plt_table_1?0;}  goto up_full; \n\nfi;\nup_empty: if\n::  goto down_empty; \n\nfi;\nup_full: if\n:: get_table!k; goto up_empty; \n\nfi;\n}\n\nactive proctype Press() { \nbyte k=0;\n\nwait: if\n:: put_press?k; goto pressing; \n\nfi;\npressing: if\n::  atomic {k==0;plt_press_0?0;}  goto done; \n\n::  atomic {k==1;plt_press_1?0;}  goto done; \n\nfi;\ndone: if\n:: get_press!k; goto wait; \n\nfi;\n}\n\nactive proctype Deposit() { \nbyte k=0;\n\nwait: if\n:: put_deposit?k; goto loaded; \n\nfi;\nloaded: if\n::  atomic {k==0;plt_deposit_0?0;}  goto wait; \n\n::  atomic {k==1;plt_deposit_1?0;}  goto wait; \n\nfi;\n}\n\nactive proctype Robot() { \nbyte at_press=0;\nbyte at_table=0;\nbyte A=255;\nbyte B=255;\n\nwait: if\n:: (B==255 && at_press==1) || (A==255 && at_table==1); goto Bpress; \n\n::  atomic {at_table==0;read?0;at_table = 1;}  goto wait; \n\n:: (A!=255 && at_press==0) || B!=255; goto Apress; \n\nfi;\nAtable: if\n::  atomic {at_table==1 && A==255;get_table?A;at_table = 0;}  goto Atable; \n\n:: A!=255; goto Bpress; \n\nfi;\nBpress: if\n::  atomic {B==255 && at_press==1;get_press?B;at_press = 0;}  goto Bpress; \n\n:: A==255 && at_table==1; goto Atable; \n\n:: (A!=255 && at_press==0) || (B!=255 && (A!=255 || at_table==0)); goto wait; \n\nfi;\nApress: if\n::  atomic {A!=255 && at_press==0;put_press!A;A = 255;at_press = 1;}  goto Apress; \n\n:: B!=255; goto Bdeposit; \n\n:: (A==255 || at_press==1) && B==255; goto wait; \n\nfi;\nBdeposit: if\n::  atomic {B!=255;put_deposit!B;B = 255;}  goto Bdeposit; \n\n:: B==255; goto Apress; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The task of the production cell case study was to develop\n    control software for a realistic industrial production cell, comprising\n    several machines (e.g., a robot, a press, two conveyor belts). This\n    software had to fulfill certain safety and liveness requirements (e.g.,\n    never close the press while a robot arm is inside it). The example was\n    taken from real world (a metal processing plant in Germany), but was at the\n    same time of managable complexity. This model captures just the basic\n    structure of the problem.\n\nParameters:\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte done=0;\n\nchan plt_belt_0 =[0] of {int};\nchan plt_table_0 =[0] of {int};\nchan plt_press_0 =[0] of {int};\nchan plt_deposit_0 =[0] of {int};\nchan plt_belt_1 =[0] of {int};\nchan plt_table_1 =[0] of {int};\nchan plt_press_1 =[0] of {int};\nchan plt_deposit_1 =[0] of {int};\nchan plt_belt_2 =[0] of {int};\nchan plt_table_2 =[0] of {int};\nchan plt_press_2 =[0] of {int};\nchan plt_deposit_2 =[0] of {int};\nchan plt_belt_3 =[0] of {int};\nchan plt_table_3 =[0] of {int};\nchan plt_press_3 =[0] of {int};\nchan plt_deposit_3 =[0] of {int};\nchan plt_belt_4 =[0] of {int};\nchan plt_table_4 =[0] of {int};\nchan plt_press_4 =[0] of {int};\nchan plt_deposit_4 =[0] of {int};\nchan plt_belt_5 =[0] of {int};\nchan plt_table_5 =[0] of {int};\nchan plt_press_5 =[0] of {int};\nchan plt_deposit_5 =[0] of {int};\nchan new_plate =[0] of {int};\nchan sen =[0] of {int};\nchan read =[0] of {int};\nchan put_table =[0] of {int};\nchan get_table =[0] of {int};\nchan put_press =[0] of {int};\nchan get_press =[0] of {int};\nchan put_deposit =[0] of {int};\n\nactive proctype Plate_0() { \n\nnew: if\n:: new_plate!0; goto wait_belt; \n\nfi;\nwait_belt: if\n:: plt_belt_0!0; goto wait_table; \n\nfi;\nwait_table: if\n:: plt_table_0!0; goto wait_press; \n\nfi;\nwait_press: if\n:: plt_press_0!0; goto wait_deposit; \n\nfi;\nwait_deposit: if\n:: plt_deposit_0!0; goto new; \n\nfi;\n}\n\nactive proctype Plate_1() { \n\nnew: if\n:: new_plate!1; goto wait_belt; \n\nfi;\nwait_belt: if\n:: plt_belt_1!0; goto wait_table; \n\nfi;\nwait_table: if\n:: plt_table_1!0; goto wait_press; \n\nfi;\nwait_press: if\n:: plt_press_1!0; goto wait_deposit; \n\nfi;\nwait_deposit: if\n:: plt_deposit_1!0; goto new; \n\nfi;\n}\n\nactive proctype Plate_2() { \n\nnew: if\n:: new_plate!2; goto wait_belt; \n\nfi;\nwait_belt: if\n:: plt_belt_2!0; goto wait_table; \n\nfi;\nwait_table: if\n:: plt_table_2!0; goto wait_press; \n\nfi;\nwait_press: if\n:: plt_press_2!0; goto wait_deposit; \n\nfi;\nwait_deposit: if\n:: plt_deposit_2!0; goto new; \n\nfi;\n}\n\nactive proctype Plate_3() { \n\nnew: if\n:: new_plate!3; goto wait_belt; \n\nfi;\nwait_belt: if\n:: plt_belt_3!0; goto wait_table; \n\nfi;\nwait_table: if\n:: plt_table_3!0; goto wait_press; \n\nfi;\nwait_press: if\n:: plt_press_3!0; goto wait_deposit; \n\nfi;\nwait_deposit: if\n:: plt_deposit_3!0; goto new; \n\nfi;\n}\n\nactive proctype Plate_4() { \n\nnew: if\n:: new_plate!4; goto wait_belt; \n\nfi;\nwait_belt: if\n:: plt_belt_4!0; goto wait_table; \n\nfi;\nwait_table: if\n:: plt_table_4!0; goto wait_press; \n\nfi;\nwait_press: if\n:: plt_press_4!0; goto wait_deposit; \n\nfi;\nwait_deposit: if\n:: plt_deposit_4!0; goto new; \n\nfi;\n}\n\nactive proctype Plate_5() { \n\nnew: if\n:: new_plate!5; goto wait_belt; \n\nfi;\nwait_belt: if\n:: plt_belt_5!0; goto wait_table; \n\nfi;\nwait_table: if\n:: plt_table_5!0; goto wait_press; \n\nfi;\nwait_press: if\n:: plt_press_5!0; goto wait_deposit; \n\nfi;\nwait_deposit: if\n:: plt_deposit_5!0; goto new; \n\nfi;\n}\n\nactive proctype Belt() { \nbyte k=0;\n\nwait: if\n:: new_plate?k; goto got_new; \n\nfi;\ngot_new: if\n:: sen!0; goto q1; \n\nfi;\nq1: if\n::  atomic {k==0;plt_belt_0?0;}  goto q2; \n\n::  atomic {k==1;plt_belt_1?0;}  goto q2; \n\n::  atomic {k==2;plt_belt_2?0;}  goto q2; \n\n::  atomic {k==3;plt_belt_3?0;}  goto q2; \n\n::  atomic {k==4;plt_belt_4?0;}  goto q2; \n\n::  atomic {k==5;plt_belt_5?0;}  goto q2; \n\nfi;\nq2: if\n:: put_table!k; goto wait; \n\nfi;\n}\n\nactive proctype Sensor() { \nbyte count=0;\n\nq: if\n::  atomic {sen?0;count = count+1;}  goto q; \n\n::  atomic {count>0;read!0;count = count-1;}  goto q; \n\nfi;\n}\n\nactive proctype Table() { \nbyte k=0;\n\ndown_empty: if\n:: put_table?k; goto down_full; \n\nfi;\ndown_full: if\n::  atomic {k==0;plt_table_0?0;}  goto up_full; \n\n::  atomic {k==1;plt_table_1?0;}  goto up_full; \n\n::  atomic {k==2;plt_table_2?0;}  goto up_full; \n\n::  atomic {k==3;plt_table_3?0;}  goto up_full; \n\n::  atomic {k==4;plt_table_4?0;}  goto up_full; \n\n::  atomic {k==5;plt_table_5?0;}  goto up_full; \n\nfi;\nup_empty: if\n::  goto down_empty; \n\nfi;\nup_full: if\n:: get_table!k; goto up_empty; \n\nfi;\n}\n\nactive proctype Press() { \nbyte k=0;\n\nwait: if\n:: put_press?k; goto pressing; \n\nfi;\npressing: if\n::  atomic {k==0;plt_press_0?0;}  goto done; \n\n::  atomic {k==1;plt_press_1?0;}  goto done; \n\n::  atomic {k==2;plt_press_2?0;}  goto done; \n\n::  atomic {k==3;plt_press_3?0;}  goto done; \n\n::  atomic {k==4;plt_press_4?0;}  goto done; \n\n::  atomic {k==5;plt_press_5?0;}  goto done; \n\nfi;\ndone: if\n:: get_press!k; goto wait; \n\nfi;\n}\n\nactive proctype Deposit() { \nbyte k=0;\n\nwait: if\n:: put_deposit?k; goto loaded; \n\nfi;\nloaded: if\n::  atomic {k==0;plt_deposit_0?0;}  goto wait; \n\n::  atomic {k==1;plt_deposit_1?0;}  goto wait; \n\n::  atomic {k==2;plt_deposit_2?0;}  goto wait; \n\n::  atomic {k==3;plt_deposit_3?0;}  goto wait; \n\n::  atomic {k==4;plt_deposit_4?0;}  goto wait; \n\n::  atomic {k==5;plt_deposit_5?0;}  goto wait; \n\nfi;\n}\n\nactive proctype Robot() { \nbyte at_press=0;\nbyte at_table=0;\nbyte A=255;\nbyte B=255;\n\nwait: if\n:: (B==255 && at_press==1) || (A==255 && at_table==1); goto Bpress; \n\n::  atomic {at_table==0;read?0;at_table = 1;}  goto wait; \n\n:: (A!=255 && at_press==0) || B!=255; goto Apress; \n\nfi;\nAtable: if\n::  atomic {at_table==1 && A==255;get_table?A;at_table = 0;}  goto Atable; \n\n:: A!=255; goto Bpress; \n\nfi;\nBpress: if\n::  atomic {B==255 && at_press==1;get_press?B;at_press = 0;}  goto Bpress; \n\n:: A==255 && at_table==1; goto Atable; \n\n:: (A!=255 && at_press==0) || (B!=255 && (A!=255 || at_table==0)); goto wait; \n\nfi;\nApress: if\n::  atomic {A!=255 && at_press==0;put_press!A;A = 255;at_press = 1;}  goto Apress; \n\n:: B!=255; goto Bdeposit; \n\n:: (A==255 || at_press==1) && B==255; goto wait; \n\nfi;\nBdeposit: if\n::  atomic {B!=255;put_deposit!B;B = 255;}  goto Bdeposit; \n\n:: B==255; goto Apress; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The task of the production cell case study was to develop\n    control software for a realistic industrial production cell, comprising\n    several machines (e.g., a robot, a press, two conveyor belts). This\n    software had to fulfill certain safety and liveness requirements (e.g.,\n    never close the press while a robot arm is inside it). The example was\n    taken from real world (a metal processing plant in Germany), but was at the\n    same time of managable complexity. This model captures just the basic\n    structure of the problem.\n\nParameters:\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte done=0;\n\nchan plt_belt_0 =[0] of {int};\nchan plt_table_0 =[0] of {int};\nchan plt_press_0 =[0] of {int};\nchan plt_deposit_0 =[0] of {int};\nchan plt_belt_1 =[0] of {int};\nchan plt_table_1 =[0] of {int};\nchan plt_press_1 =[0] of {int};\nchan plt_deposit_1 =[0] of {int};\nchan plt_belt_2 =[0] of {int};\nchan plt_table_2 =[0] of {int};\nchan plt_press_2 =[0] of {int};\nchan plt_deposit_2 =[0] of {int};\nchan plt_belt_3 =[0] of {int};\nchan plt_table_3 =[0] of {int};\nchan plt_press_3 =[0] of {int};\nchan plt_deposit_3 =[0] of {int};\nchan new_plate =[0] of {int};\nchan sen =[0] of {int};\nchan read =[0] of {int};\nchan put_table =[0] of {int};\nchan get_table =[0] of {int};\nchan put_press =[0] of {int};\nchan get_press =[0] of {int};\nchan put_deposit =[0] of {int};\n\nactive proctype Plate_0() { \n\nnew: if\n:: new_plate!0; goto wait_belt; \n\nfi;\nwait_belt: if\n:: plt_belt_0!0; goto wait_table; \n\nfi;\nwait_table: if\n:: plt_table_0!0; goto wait_press; \n\nfi;\nwait_press: if\n:: plt_press_0!0; goto wait_deposit; \n\nfi;\nwait_deposit: if\n::  atomic {done<4;plt_deposit_0!0;done = done+1;}  goto new; \n\nfi;\n}\n\nactive proctype Plate_1() { \n\nnew: if\n:: new_plate!1; goto wait_belt; \n\nfi;\nwait_belt: if\n:: plt_belt_1!0; goto wait_table; \n\nfi;\nwait_table: if\n:: plt_table_1!0; goto wait_press; \n\nfi;\nwait_press: if\n:: plt_press_1!0; goto wait_deposit; \n\nfi;\nwait_deposit: if\n::  atomic {done<4;plt_deposit_1!0;done = done+1;}  goto new; \n\nfi;\n}\n\nactive proctype Plate_2() { \n\nnew: if\n:: new_plate!2; goto wait_belt; \n\nfi;\nwait_belt: if\n:: plt_belt_2!0; goto wait_table; \n\nfi;\nwait_table: if\n:: plt_table_2!0; goto wait_press; \n\nfi;\nwait_press: if\n:: plt_press_2!0; goto wait_deposit; \n\nfi;\nwait_deposit: if\n::  atomic {done<4;plt_deposit_2!0;done = done+1;}  goto new; \n\nfi;\n}\n\nactive proctype Plate_3() { \n\nnew: if\n:: new_plate!3; goto wait_belt; \n\nfi;\nwait_belt: if\n:: plt_belt_3!0; goto wait_table; \n\nfi;\nwait_table: if\n:: plt_table_3!0; goto wait_press; \n\nfi;\nwait_press: if\n:: plt_press_3!0; goto wait_deposit; \n\nfi;\nwait_deposit: if\n::  atomic {done<4;plt_deposit_3!0;done = done+1;}  goto new; \n\nfi;\n}\n\nactive proctype Belt() { \nbyte k=0;\n\nwait: if\n:: new_plate?k; goto got_new; \n\nfi;\ngot_new: if\n:: sen!0; goto q1; \n\nfi;\nq1: if\n::  atomic {k==0;plt_belt_0?0;}  goto q2; \n\n::  atomic {k==1;plt_belt_1?0;}  goto q2; \n\n::  atomic {k==2;plt_belt_2?0;}  goto q2; \n\n::  atomic {k==3;plt_belt_3?0;}  goto q2; \n\nfi;\nq2: if\n:: put_table!k; goto wait; \n\nfi;\n}\n\nactive proctype Sensor() { \nbyte count=0;\n\nq: if\n::  atomic {sen?0;count = count+1;}  goto q; \n\n::  atomic {count>0;read!0;count = count-1;}  goto q; \n\nfi;\n}\n\nactive proctype Table() { \nbyte k=0;\n\ndown_empty: if\n:: put_table?k; goto down_full; \n\nfi;\ndown_full: if\n::  atomic {k==0;plt_table_0?0;}  goto up_full; \n\n::  atomic {k==1;plt_table_1?0;}  goto up_full; \n\n::  atomic {k==2;plt_table_2?0;}  goto up_full; \n\n::  atomic {k==3;plt_table_3?0;}  goto up_full; \n\nfi;\nup_empty: if\n::  goto down_empty; \n\nfi;\nup_full: if\n:: get_table!k; goto up_empty; \n\nfi;\n}\n\nactive proctype Press() { \nbyte k=0;\n\nwait: if\n:: put_press?k; goto pressing; \n\nfi;\npressing: if\n::  atomic {k==0;plt_press_0?0;}  goto done; \n\n::  atomic {k==1;plt_press_1?0;}  goto done; \n\n::  atomic {k==2;plt_press_2?0;}  goto done; \n\n::  atomic {k==3;plt_press_3?0;}  goto done; \n\nfi;\ndone: if\n:: get_press!k; goto wait; \n\nfi;\n}\n\nactive proctype Deposit() { \nbyte k=0;\n\nwait: if\n:: put_deposit?k; goto loaded; \n\nfi;\nloaded: if\n::  atomic {k==0;plt_deposit_0?0;}  goto wait; \n\n::  atomic {k==1;plt_deposit_1?0;}  goto wait; \n\n::  atomic {k==2;plt_deposit_2?0;}  goto wait; \n\n::  atomic {k==3;plt_deposit_3?0;}  goto wait; \n\nfi;\n}\n\nactive proctype Robot() { \nbyte at_press=0;\nbyte at_table=0;\nbyte A=255;\nbyte B=255;\n\nwait: if\n:: (B==255 && at_press==1) || (A==255 && at_table==1); goto Bpress; \n\n::  atomic {at_table==0;read?0;at_table = 1;}  goto wait; \n\n:: (A!=255 && at_press==0) || B!=255; goto Apress; \n\nfi;\nAtable: if\n::  atomic {at_table==1 && A==255;get_table?A;at_table = 0;}  goto Atable; \n\n:: A!=255; goto Bpress; \n\nfi;\nBpress: if\n::  atomic {B==255 && at_press==1;get_press?B;at_press = 0;}  goto Bpress; \n\n:: A==255 && at_table==1; goto Atable; \n\n:: (A!=255 && at_press==0) || (B!=255 && (A!=255 || at_table==0)); goto wait; \n\nfi;\nApress: if\n::  atomic {A!=255 && at_press==0;put_press!A;A = 255;at_press = 1;}  goto Apress; \n\n:: B!=255; goto Bdeposit; \n\n:: (A==255 || at_press==1) && B==255; goto wait; \n\nfi;\nBdeposit: if\n::  atomic {B!=255;put_deposit!B;B = 255;}  goto Bdeposit; \n\n:: B==255; goto Apress; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The task of the production cell case study was to develop\n    control software for a realistic industrial production cell, comprising\n    several machines (e.g., a robot, a press, two conveyor belts). This\n    software had to fulfill certain safety and liveness requirements (e.g.,\n    never close the press while a robot arm is inside it). The example was\n    taken from real world (a metal processing plant in Germany), but was at the\n    same time of managable complexity. This model captures just the basic\n    structure of the problem.\n\nParameters:\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte done=0;\n\nchan plt_belt_0 =[0] of {int};\nchan plt_table_0 =[0] of {int};\nchan plt_press_0 =[0] of {int};\nchan plt_deposit_0 =[0] of {int};\nchan plt_belt_1 =[0] of {int};\nchan plt_table_1 =[0] of {int};\nchan plt_press_1 =[0] of {int};\nchan plt_deposit_1 =[0] of {int};\nchan plt_belt_2 =[0] of {int};\nchan plt_table_2 =[0] of {int};\nchan plt_press_2 =[0] of {int};\nchan plt_deposit_2 =[0] of {int};\nchan plt_belt_3 =[0] of {int};\nchan plt_table_3 =[0] of {int};\nchan plt_press_3 =[0] of {int};\nchan plt_deposit_3 =[0] of {int};\nchan plt_belt_4 =[0] of {int};\nchan plt_table_4 =[0] of {int};\nchan plt_press_4 =[0] of {int};\nchan plt_deposit_4 =[0] of {int};\nchan plt_belt_5 =[0] of {int};\nchan plt_table_5 =[0] of {int};\nchan plt_press_5 =[0] of {int};\nchan plt_deposit_5 =[0] of {int};\nchan plt_belt_6 =[0] of {int};\nchan plt_table_6 =[0] of {int};\nchan plt_press_6 =[0] of {int};\nchan plt_deposit_6 =[0] of {int};\nchan plt_belt_7 =[0] of {int};\nchan plt_table_7 =[0] of {int};\nchan plt_press_7 =[0] of {int};\nchan plt_deposit_7 =[0] of {int};\nchan new_plate =[0] of {int};\nchan sen =[0] of {int};\nchan read =[0] of {int};\nchan put_table =[0] of {int};\nchan get_table =[0] of {int};\nchan put_press =[0] of {int};\nchan get_press =[0] of {int};\nchan put_deposit =[0] of {int};\n\nactive proctype Plate_0() { \n\nnew: if\n:: new_plate!0; goto wait_belt; \n\nfi;\nwait_belt: if\n:: plt_belt_0!0; goto wait_table; \n\nfi;\nwait_table: if\n:: plt_table_0!0; goto wait_press; \n\nfi;\nwait_press: if\n:: plt_press_0!0; goto wait_deposit; \n\nfi;\nwait_deposit: if\n:: plt_deposit_0!0; goto new; \n\nfi;\n}\n\nactive proctype Plate_1() { \n\nnew: if\n:: new_plate!1; goto wait_belt; \n\nfi;\nwait_belt: if\n:: plt_belt_1!0; goto wait_table; \n\nfi;\nwait_table: if\n:: plt_table_1!0; goto wait_press; \n\nfi;\nwait_press: if\n:: plt_press_1!0; goto wait_deposit; \n\nfi;\nwait_deposit: if\n:: plt_deposit_1!0; goto new; \n\nfi;\n}\n\nactive proctype Plate_2() { \n\nnew: if\n:: new_plate!2; goto wait_belt; \n\nfi;\nwait_belt: if\n:: plt_belt_2!0; goto wait_table; \n\nfi;\nwait_table: if\n:: plt_table_2!0; goto wait_press; \n\nfi;\nwait_press: if\n:: plt_press_2!0; goto wait_deposit; \n\nfi;\nwait_deposit: if\n:: plt_deposit_2!0; goto new; \n\nfi;\n}\n\nactive proctype Plate_3() { \n\nnew: if\n:: new_plate!3; goto wait_belt; \n\nfi;\nwait_belt: if\n:: plt_belt_3!0; goto wait_table; \n\nfi;\nwait_table: if\n:: plt_table_3!0; goto wait_press; \n\nfi;\nwait_press: if\n:: plt_press_3!0; goto wait_deposit; \n\nfi;\nwait_deposit: if\n:: plt_deposit_3!0; goto new; \n\nfi;\n}\n\nactive proctype Plate_4() { \n\nnew: if\n:: new_plate!4; goto wait_belt; \n\nfi;\nwait_belt: if\n:: plt_belt_4!0; goto wait_table; \n\nfi;\nwait_table: if\n:: plt_table_4!0; goto wait_press; \n\nfi;\nwait_press: if\n:: plt_press_4!0; goto wait_deposit; \n\nfi;\nwait_deposit: if\n:: plt_deposit_4!0; goto new; \n\nfi;\n}\n\nactive proctype Plate_5() { \n\nnew: if\n:: new_plate!5; goto wait_belt; \n\nfi;\nwait_belt: if\n:: plt_belt_5!0; goto wait_table; \n\nfi;\nwait_table: if\n:: plt_table_5!0; goto wait_press; \n\nfi;\nwait_press: if\n:: plt_press_5!0; goto wait_deposit; \n\nfi;\nwait_deposit: if\n:: plt_deposit_5!0; goto new; \n\nfi;\n}\n\nactive proctype Plate_6() { \n\nnew: if\n:: new_plate!6; goto wait_belt; \n\nfi;\nwait_belt: if\n:: plt_belt_6!0; goto wait_table; \n\nfi;\nwait_table: if\n:: plt_table_6!0; goto wait_press; \n\nfi;\nwait_press: if\n:: plt_press_6!0; goto wait_deposit; \n\nfi;\nwait_deposit: if\n:: plt_deposit_6!0; goto new; \n\nfi;\n}\n\nactive proctype Plate_7() { \n\nnew: if\n:: new_plate!7; goto wait_belt; \n\nfi;\nwait_belt: if\n:: plt_belt_7!0; goto wait_table; \n\nfi;\nwait_table: if\n:: plt_table_7!0; goto wait_press; \n\nfi;\nwait_press: if\n:: plt_press_7!0; goto wait_deposit; \n\nfi;\nwait_deposit: if\n:: plt_deposit_7!0; goto new; \n\nfi;\n}\n\nactive proctype Belt() { \nbyte k=0;\n\nwait: if\n:: new_plate?k; goto got_new; \n\nfi;\ngot_new: if\n:: sen!0; goto q1; \n\nfi;\nq1: if\n::  atomic {k==0;plt_belt_0?0;}  goto q2; \n\n::  atomic {k==1;plt_belt_1?0;}  goto q2; \n\n::  atomic {k==2;plt_belt_2?0;}  goto q2; \n\n::  atomic {k==3;plt_belt_3?0;}  goto q2; \n\n::  atomic {k==4;plt_belt_4?0;}  goto q2; \n\n::  atomic {k==5;plt_belt_5?0;}  goto q2; \n\n::  atomic {k==6;plt_belt_6?0;}  goto q2; \n\n::  atomic {k==7;plt_belt_7?0;}  goto q2; \n\nfi;\nq2: if\n:: put_table!k; goto wait; \n\nfi;\n}\n\nactive proctype Sensor() { \nbyte count=0;\n\nq: if\n::  atomic {sen?0;count = count+1;}  goto q; \n\n::  atomic {count>0;read!0;count = count-1;}  goto q; \n\nfi;\n}\n\nactive proctype Table() { \nbyte k=0;\n\ndown_empty: if\n:: put_table?k; goto down_full; \n\nfi;\ndown_full: if\n::  atomic {k==0;plt_table_0?0;}  goto up_full; \n\n::  atomic {k==1;plt_table_1?0;}  goto up_full; \n\n::  atomic {k==2;plt_table_2?0;}  goto up_full; \n\n::  atomic {k==3;plt_table_3?0;}  goto up_full; \n\n::  atomic {k==4;plt_table_4?0;}  goto up_full; \n\n::  atomic {k==5;plt_table_5?0;}  goto up_full; \n\n::  atomic {k==6;plt_table_6?0;}  goto up_full; \n\n::  atomic {k==7;plt_table_7?0;}  goto up_full; \n\nfi;\nup_empty: if\n::  goto down_empty; \n\nfi;\nup_full: if\n:: get_table!k; goto up_empty; \n\nfi;\n}\n\nactive proctype Press() { \nbyte k=0;\n\nwait: if\n:: put_press?k; goto pressing; \n\nfi;\npressing: if\n::  atomic {k==0;plt_press_0?0;}  goto done; \n\n::  atomic {k==1;plt_press_1?0;}  goto done; \n\n::  atomic {k==2;plt_press_2?0;}  goto done; \n\n::  atomic {k==3;plt_press_3?0;}  goto done; \n\n::  atomic {k==4;plt_press_4?0;}  goto done; \n\n::  atomic {k==5;plt_press_5?0;}  goto done; \n\n::  atomic {k==6;plt_press_6?0;}  goto done; \n\n::  atomic {k==7;plt_press_7?0;}  goto done; \n\nfi;\ndone: if\n:: get_press!k; goto wait; \n\nfi;\n}\n\nactive proctype Deposit() { \nbyte k=0;\n\nwait: if\n:: put_deposit?k; goto loaded; \n\nfi;\nloaded: if\n::  atomic {k==0;plt_deposit_0?0;}  goto wait; \n\n::  atomic {k==1;plt_deposit_1?0;}  goto wait; \n\n::  atomic {k==2;plt_deposit_2?0;}  goto wait; \n\n::  atomic {k==3;plt_deposit_3?0;}  goto wait; \n\n::  atomic {k==4;plt_deposit_4?0;}  goto wait; \n\n::  atomic {k==5;plt_deposit_5?0;}  goto wait; \n\n::  atomic {k==6;plt_deposit_6?0;}  goto wait; \n\n::  atomic {k==7;plt_deposit_7?0;}  goto wait; \n\nfi;\n}\n\nactive proctype Robot() { \nbyte at_press=0;\nbyte at_table=0;\nbyte A=255;\nbyte B=255;\n\nwait: if\n:: (B==255 && at_press==1) || (A==255 && at_table==1); goto Bpress; \n\n::  atomic {at_table==0;read?0;at_table = 1;}  goto wait; \n\n:: (A!=255 && at_press==0) || B!=255; goto Apress; \n\nfi;\nAtable: if\n::  atomic {at_table==1 && A==255;get_table?A;at_table = 0;}  goto Atable; \n\n:: A!=255; goto Bpress; \n\nfi;\nBpress: if\n::  atomic {B==255 && at_press==1;get_press?B;at_press = 0;}  goto Bpress; \n\n:: A==255 && at_table==1; goto Atable; \n\n:: (A!=255 && at_press==0) || (B!=255 && (A!=255 || at_table==0)); goto wait; \n\nfi;\nApress: if\n::  atomic {A!=255 && at_press==0;put_press!A;A = 255;at_press = 1;}  goto Apress; \n\n:: B!=255; goto Bdeposit; \n\n:: (A==255 || at_press==1) && B==255; goto wait; \n\nfi;\nBdeposit: if\n::  atomic {B!=255;put_deposit!B;B = 255;}  goto Bdeposit; \n\n:: B==255; goto Apress; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The task of the production cell case study was to develop\n    control software for a realistic industrial production cell, comprising\n    several machines (e.g., a robot, a press, two conveyor belts). This\n    software had to fulfill certain safety and liveness requirements (e.g.,\n    never close the press while a robot arm is inside it). The example was\n    taken from real world (a metal processing plant in Germany), but was at the\n    same time of managable complexity. This model captures just the basic\n    structure of the problem.\n\nParameters:\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte done=0;\n\nchan plt_belt_0 =[0] of {int};\nchan plt_table_0 =[0] of {int};\nchan plt_press_0 =[0] of {int};\nchan plt_deposit_0 =[0] of {int};\nchan plt_belt_1 =[0] of {int};\nchan plt_table_1 =[0] of {int};\nchan plt_press_1 =[0] of {int};\nchan plt_deposit_1 =[0] of {int};\nchan plt_belt_2 =[0] of {int};\nchan plt_table_2 =[0] of {int};\nchan plt_press_2 =[0] of {int};\nchan plt_deposit_2 =[0] of {int};\nchan plt_belt_3 =[0] of {int};\nchan plt_table_3 =[0] of {int};\nchan plt_press_3 =[0] of {int};\nchan plt_deposit_3 =[0] of {int};\nchan plt_belt_4 =[0] of {int};\nchan plt_table_4 =[0] of {int};\nchan plt_press_4 =[0] of {int};\nchan plt_deposit_4 =[0] of {int};\nchan plt_belt_5 =[0] of {int};\nchan plt_table_5 =[0] of {int};\nchan plt_press_5 =[0] of {int};\nchan plt_deposit_5 =[0] of {int};\nchan plt_belt_6 =[0] of {int};\nchan plt_table_6 =[0] of {int};\nchan plt_press_6 =[0] of {int};\nchan plt_deposit_6 =[0] of {int};\nchan plt_belt_7 =[0] of {int};\nchan plt_table_7 =[0] of {int};\nchan plt_press_7 =[0] of {int};\nchan plt_deposit_7 =[0] of {int};\nchan plt_belt_8 =[0] of {int};\nchan plt_table_8 =[0] of {int};\nchan plt_press_8 =[0] of {int};\nchan plt_deposit_8 =[0] of {int};\nchan plt_belt_9 =[0] of {int};\nchan plt_table_9 =[0] of {int};\nchan plt_press_9 =[0] of {int};\nchan plt_deposit_9 =[0] of {int};\nchan new_plate =[0] of {int};\nchan sen =[0] of {int};\nchan read =[0] of {int};\nchan put_table =[0] of {int};\nchan get_table =[0] of {int};\nchan put_press =[0] of {int};\nchan get_press =[0] of {int};\nchan put_deposit =[0] of {int};\n\nactive proctype Plate_0() { \n\nnew: if\n:: new_plate!0; goto wait_belt; \n\nfi;\nwait_belt: if\n:: plt_belt_0!0; goto wait_table; \n\nfi;\nwait_table: if\n:: plt_table_0!0; goto wait_press; \n\nfi;\nwait_press: if\n:: plt_press_0!0; goto wait_deposit; \n\nfi;\nwait_deposit: if\n:: plt_deposit_0!0; goto new; \n\nfi;\n}\n\nactive proctype Plate_1() { \n\nnew: if\n:: new_plate!1; goto wait_belt; \n\nfi;\nwait_belt: if\n:: plt_belt_1!0; goto wait_table; \n\nfi;\nwait_table: if\n:: plt_table_1!0; goto wait_press; \n\nfi;\nwait_press: if\n:: plt_press_1!0; goto wait_deposit; \n\nfi;\nwait_deposit: if\n:: plt_deposit_1!0; goto new; \n\nfi;\n}\n\nactive proctype Plate_2() { \n\nnew: if\n:: new_plate!2; goto wait_belt; \n\nfi;\nwait_belt: if\n:: plt_belt_2!0; goto wait_table; \n\nfi;\nwait_table: if\n:: plt_table_2!0; goto wait_press; \n\nfi;\nwait_press: if\n:: plt_press_2!0; goto wait_deposit; \n\nfi;\nwait_deposit: if\n:: plt_deposit_2!0; goto new; \n\nfi;\n}\n\nactive proctype Plate_3() { \n\nnew: if\n:: new_plate!3; goto wait_belt; \n\nfi;\nwait_belt: if\n:: plt_belt_3!0; goto wait_table; \n\nfi;\nwait_table: if\n:: plt_table_3!0; goto wait_press; \n\nfi;\nwait_press: if\n:: plt_press_3!0; goto wait_deposit; \n\nfi;\nwait_deposit: if\n:: plt_deposit_3!0; goto new; \n\nfi;\n}\n\nactive proctype Plate_4() { \n\nnew: if\n:: new_plate!4; goto wait_belt; \n\nfi;\nwait_belt: if\n:: plt_belt_4!0; goto wait_table; \n\nfi;\nwait_table: if\n:: plt_table_4!0; goto wait_press; \n\nfi;\nwait_press: if\n:: plt_press_4!0; goto wait_deposit; \n\nfi;\nwait_deposit: if\n:: plt_deposit_4!0; goto new; \n\nfi;\n}\n\nactive proctype Plate_5() { \n\nnew: if\n:: new_plate!5; goto wait_belt; \n\nfi;\nwait_belt: if\n:: plt_belt_5!0; goto wait_table; \n\nfi;\nwait_table: if\n:: plt_table_5!0; goto wait_press; \n\nfi;\nwait_press: if\n:: plt_press_5!0; goto wait_deposit; \n\nfi;\nwait_deposit: if\n:: plt_deposit_5!0; goto new; \n\nfi;\n}\n\nactive proctype Plate_6() { \n\nnew: if\n:: new_plate!6; goto wait_belt; \n\nfi;\nwait_belt: if\n:: plt_belt_6!0; goto wait_table; \n\nfi;\nwait_table: if\n:: plt_table_6!0; goto wait_press; \n\nfi;\nwait_press: if\n:: plt_press_6!0; goto wait_deposit; \n\nfi;\nwait_deposit: if\n:: plt_deposit_6!0; goto new; \n\nfi;\n}\n\nactive proctype Plate_7() { \n\nnew: if\n:: new_plate!7; goto wait_belt; \n\nfi;\nwait_belt: if\n:: plt_belt_7!0; goto wait_table; \n\nfi;\nwait_table: if\n:: plt_table_7!0; goto wait_press; \n\nfi;\nwait_press: if\n:: plt_press_7!0; goto wait_deposit; \n\nfi;\nwait_deposit: if\n:: plt_deposit_7!0; goto new; \n\nfi;\n}\n\nactive proctype Plate_8() { \n\nnew: if\n:: new_plate!8; goto wait_belt; \n\nfi;\nwait_belt: if\n:: plt_belt_8!0; goto wait_table; \n\nfi;\nwait_table: if\n:: plt_table_8!0; goto wait_press; \n\nfi;\nwait_press: if\n:: plt_press_8!0; goto wait_deposit; \n\nfi;\nwait_deposit: if\n:: plt_deposit_8!0; goto new; \n\nfi;\n}\n\nactive proctype Plate_9() { \n\nnew: if\n:: new_plate!9; goto wait_belt; \n\nfi;\nwait_belt: if\n:: plt_belt_9!0; goto wait_table; \n\nfi;\nwait_table: if\n:: plt_table_9!0; goto wait_press; \n\nfi;\nwait_press: if\n:: plt_press_9!0; goto wait_deposit; \n\nfi;\nwait_deposit: if\n:: plt_deposit_9!0; goto new; \n\nfi;\n}\n\nactive proctype Belt() { \nbyte k=0;\n\nwait: if\n:: new_plate?k; goto got_new; \n\nfi;\ngot_new: if\n:: sen!0; goto q1; \n\nfi;\nq1: if\n::  atomic {k==0;plt_belt_0?0;}  goto q2; \n\n::  atomic {k==1;plt_belt_1?0;}  goto q2; \n\n::  atomic {k==2;plt_belt_2?0;}  goto q2; \n\n::  atomic {k==3;plt_belt_3?0;}  goto q2; \n\n::  atomic {k==4;plt_belt_4?0;}  goto q2; \n\n::  atomic {k==5;plt_belt_5?0;}  goto q2; \n\n::  atomic {k==6;plt_belt_6?0;}  goto q2; \n\n::  atomic {k==7;plt_belt_7?0;}  goto q2; \n\n::  atomic {k==8;plt_belt_8?0;}  goto q2; \n\n::  atomic {k==9;plt_belt_9?0;}  goto q2; \n\nfi;\nq2: if\n:: put_table!k; goto wait; \n\nfi;\n}\n\nactive proctype Sensor() { \nbyte count=0;\n\nq: if\n::  atomic {sen?0;count = count+1;}  goto q; \n\n::  atomic {count>0;read!0;count = count-1;}  goto q; \n\nfi;\n}\n\nactive proctype Table() { \nbyte k=0;\n\ndown_empty: if\n:: put_table?k; goto down_full; \n\nfi;\ndown_full: if\n::  atomic {k==0;plt_table_0?0;}  goto up_full; \n\n::  atomic {k==1;plt_table_1?0;}  goto up_full; \n\n::  atomic {k==2;plt_table_2?0;}  goto up_full; \n\n::  atomic {k==3;plt_table_3?0;}  goto up_full; \n\n::  atomic {k==4;plt_table_4?0;}  goto up_full; \n\n::  atomic {k==5;plt_table_5?0;}  goto up_full; \n\n::  atomic {k==6;plt_table_6?0;}  goto up_full; \n\n::  atomic {k==7;plt_table_7?0;}  goto up_full; \n\n::  atomic {k==8;plt_table_8?0;}  goto up_full; \n\n::  atomic {k==9;plt_table_9?0;}  goto up_full; \n\nfi;\nup_empty: if\n::  goto down_empty; \n\nfi;\nup_full: if\n:: get_table!k; goto up_empty; \n\nfi;\n}\n\nactive proctype Press() { \nbyte k=0;\n\nwait: if\n:: put_press?k; goto pressing; \n\nfi;\npressing: if\n::  atomic {k==0;plt_press_0?0;}  goto done; \n\n::  atomic {k==1;plt_press_1?0;}  goto done; \n\n::  atomic {k==2;plt_press_2?0;}  goto done; \n\n::  atomic {k==3;plt_press_3?0;}  goto done; \n\n::  atomic {k==4;plt_press_4?0;}  goto done; \n\n::  atomic {k==5;plt_press_5?0;}  goto done; \n\n::  atomic {k==6;plt_press_6?0;}  goto done; \n\n::  atomic {k==7;plt_press_7?0;}  goto done; \n\n::  atomic {k==8;plt_press_8?0;}  goto done; \n\n::  atomic {k==9;plt_press_9?0;}  goto done; \n\nfi;\ndone: if\n:: get_press!k; goto wait; \n\nfi;\n}\n\nactive proctype Deposit() { \nbyte k=0;\n\nwait: if\n:: put_deposit?k; goto loaded; \n\nfi;\nloaded: if\n::  atomic {k==0;plt_deposit_0?0;}  goto wait; \n\n::  atomic {k==1;plt_deposit_1?0;}  goto wait; \n\n::  atomic {k==2;plt_deposit_2?0;}  goto wait; \n\n::  atomic {k==3;plt_deposit_3?0;}  goto wait; \n\n::  atomic {k==4;plt_deposit_4?0;}  goto wait; \n\n::  atomic {k==5;plt_deposit_5?0;}  goto wait; \n\n::  atomic {k==6;plt_deposit_6?0;}  goto wait; \n\n::  atomic {k==7;plt_deposit_7?0;}  goto wait; \n\n::  atomic {k==8;plt_deposit_8?0;}  goto wait; \n\n::  atomic {k==9;plt_deposit_9?0;}  goto wait; \n\nfi;\n}\n\nactive proctype Robot() { \nbyte at_press=0;\nbyte at_table=0;\nbyte A=255;\nbyte B=255;\n\nwait: if\n:: (B==255 && at_press==1) || (A==255 && at_table==1); goto Bpress; \n\n::  atomic {at_table==0;read?0;at_table = 1;}  goto wait; \n\n:: (A!=255 && at_press==0) || B!=255; goto Apress; \n\nfi;\nAtable: if\n::  atomic {at_table==1 && A==255;get_table?A;at_table = 0;}  goto Atable; \n\n:: A!=255; goto Bpress; \n\nfi;\nBpress: if\n::  atomic {B==255 && at_press==1;get_press?B;at_press = 0;}  goto Bpress; \n\n:: A==255 && at_table==1; goto Atable; \n\n:: (A!=255 && at_press==0) || (B!=255 && (A!=255 || at_table==0)); goto wait; \n\nfi;\nApress: if\n::  atomic {A!=255 && at_press==0;put_press!A;A = 255;at_press = 1;}  goto Apress; \n\n:: B!=255; goto Bdeposit; \n\n:: (A==255 || at_press==1) && B==255; goto wait; \n\nfi;\nBdeposit: if\n::  atomic {B!=255;put_deposit!B;B = 255;}  goto Bdeposit; \n\n:: B==255; goto Apress; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Simple model of some basic  protocol for communication\n    over loosy channel (some simple faulty ones, alternating bit protocol, and\n    simple version of bounded retransmission protocol).\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "chan K_in =[0] of {int};\nchan K_out =[0] of {int};\nchan L_in =[0] of {int};\nchan L_out =[0] of {int};\nchan send =[0] of {int};\nchan receive =[0] of {int};\n\nactive proctype chnlnel_K() { \nbyte v=0;\nbyte lost=0;\n\nready: if\n:: K_in?v; goto tr; \n\nfi;\ntr: if\n::  d_step {lost<3;lost = lost+1;}  goto ready; \n\n::  atomic {K_out!v;lost = 0;}  goto ready; \n\nfi;\ndata_lost: \n false; }\n\nactive proctype chnlnel_L() { \nbyte v=0;\nbyte lost=0;\n\nready: if\n:: L_in?v; goto tr; \n\nfi;\ntr: if\n::  d_step {lost<3;lost = lost+1;}  goto ready; \n\n::  atomic {L_out!v;lost = 0;}  goto ready; \n\nfi;\ndataOK: \n false; }\n\nactive proctype Producer() { \n\nready: if\n::  goto produce0; \n\n::  goto produce1; \n\nfi;\nproduce0: if\n:: send!0; goto ready; \n\nfi;\nproduce1: if\n:: send!1; goto ready; \n\nfi;\n}\n\nactive proctype Consumer() { \nbyte value=0;\n\nready: if\n:: receive?value; goto got_msg; \n\nfi;\ngot_msg: if\n:: value==0; goto consume0; \n\n:: value==1; goto consume1; \n\nfi;\nconsume0: if\n::  goto ready; \n\nfi;\nconsume1: if\n::  goto ready; \n\nfi;\n}\n\nactive proctype Sender() { \nbyte value=0;\n\nready: if\n:: send?value; goto sending; \n\nfi;\nsending: if\n:: K_in!value; goto ready; \n\nfi;\n}\n\nactive proctype Receiver() { \nbyte value=0;\n\nwait_msg: if\n:: K_out?value; goto got_msg; \n\nfi;\ngot_msg: if\n:: receive!value; goto wait_msg; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Simple model of some basic  protocol for communication\n    over loosy channel (some simple faulty ones, alternating bit protocol, and\n    simple version of bounded retransmission protocol).\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "chan K_in =[0] of {int};\nchan K_out =[0] of {int};\nchan L_in =[0] of {int};\nchan L_out =[0] of {int};\nchan send =[0] of {int};\nchan receive =[0] of {int};\n\nactive proctype chnlnel_K() { \nbyte v=0;\n\nready: if\n:: K_in?v; goto tr; \n\nfi;\ntr: if\n::  goto ready; \n\n:: K_out!v; goto ready; \n\nfi;\ndata_lost: \n false; }\n\nactive proctype chnlnel_L() { \nbyte v=0;\n\nready: if\n:: L_in?v; goto tr; \n\nfi;\ntr: if\n::  goto ready; \n\n:: L_out!v; goto ready; \n\nfi;\ndataOK: \n false; }\n\nactive proctype Producer() { \n\nready: if\n::  goto produce0; \n\n::  goto produce1; \n\nfi;\nproduce0: if\n:: send!0; goto ready; \n\nfi;\nproduce1: if\n:: send!1; goto ready; \n\nfi;\n}\n\nactive proctype Consumer() { \nbyte value=0;\n\nready: if\n:: receive?value; goto got_msg; \n\nfi;\ngot_msg: if\n:: value==0; goto consume0; \n\n:: value==1; goto consume1; \n\nfi;\nconsume0: if\n::  goto ready; \n\nfi;\nconsume1: if\n::  goto ready; \n\nfi;\n}\n\nactive proctype Sender() { \nbyte value=0;\nbyte sab=0;\nbyte ack=0;\n\nready: if\n:: send?value; goto sending; \n\nfi;\nsending: if\n:: K_in!value; goto sending; \n\n:: L_out?ack; goto wait_ack; \n\nfi;\nwait_ack: if\n:: ack!=sab; goto sending; \n\n::  d_step {ack==sab;sab = 1-sab;}  goto ready; \n\nfi;\n}\n\nactive proctype Receiver() { \nbyte value=0;\nbyte rab=1;\n\nwait_msg: if\n:: L_in!rab; goto wait_msg; \n\n:: K_out?value; goto got_msg; \n\nfi;\ngot_msg: if\n::  atomic {receive!value;rab = 1-rab;}  goto wait_msg; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Simple model of some basic  protocol for communication\n    over loosy channel (some simple faulty ones, alternating bit protocol, and\n    simple version of bounded retransmission protocol).\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "chan K_in =[0] of {int};\nchan K_out =[0] of {int};\nchan L_in =[0] of {int};\nchan L_out =[0] of {int};\nchan send =[0] of {int};\nchan receive =[0] of {int};\n\nactive proctype chnlnel_K() { \nbyte v=0;\nbyte lost=0;\n\nready: if\n:: K_in?v; goto tr; \n\nfi;\ntr: if\n::  d_step {lost<0;lost = lost+1;}  goto ready; \n\n::  atomic {K_out!v;lost = 0;}  goto ready; \n\nfi;\ndata_lost: \n false; }\n\nactive proctype chnlnel_L() { \nbyte v=0;\nbyte lost=0;\n\nready: if\n:: L_in?v; goto tr; \n\nfi;\ntr: if\n::  d_step {lost<0;lost = lost+1;}  goto ready; \n\n::  atomic {L_out!v;lost = 0;}  goto ready; \n\nfi;\ndataOK: \n false; }\n\nactive proctype Producer() { \n\nready: if\n::  goto produce0; \n\n::  goto produce1; \n\nfi;\nproduce0: if\n:: send!0; goto ready; \n\nfi;\nproduce1: if\n:: send!1; goto ready; \n\nfi;\n}\n\nactive proctype Consumer() { \nbyte value=0;\n\nready: if\n:: receive?value; goto got_msg; \n\nfi;\ngot_msg: if\n:: value==0; goto consume0; \n\n:: value==1; goto consume1; \n\nfi;\nconsume0: if\n::  goto ready; \n\nfi;\nconsume1: if\n::  goto ready; \n\nfi;\n}\n\nactive proctype Sender() { \nbyte value=0;\nbyte sab=0;\nbyte retry=0;\n\nready: if\n::  atomic {send?value;sab = 1-sab;}  goto sending; \n\nfi;\nsending: if\n::  atomic {K_in!(value*2+sab);retry = 1;}  goto wait_ack; \n\nfi;\nwait_ack: if\n::  atomic {retry<5;K_in!(value*2+sab);retry = retry+1;}  goto wait_ack; \n\n:: L_out?value; goto ready; \n\n:: retry==5; goto failed; \n\nfi;\nfailed: \n false; }\n\nactive proctype Receiver() { \nbyte value=0;\nbyte rab=1;\n\nwaiting: if\n:: K_out?value; goto got_msg; \n\nfi;\ngot_msg: if\n:: value%2!=rab; goto waiting; \n\n::  atomic {value%2==rab;receive!(value/2);}  goto send_ack; \n\nfi;\nsend_ack: if\n::  atomic {L_in!0;rab = 1-rab;}  goto waiting; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Simple model of some basic  protocol for communication\n    over loosy channel (some simple faulty ones, alternating bit protocol, and\n    simple version of bounded retransmission protocol).\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "chan K_in =[0] of {int};\nchan K_out =[0] of {int};\nchan L_in =[0] of {int};\nchan L_out =[0] of {int};\nchan send =[0] of {int};\nchan receive =[0] of {int};\n\nactive proctype chnlnel_K() { \nbyte v=0;\nbyte lost=0;\n\nready: if\n:: K_in?v; goto tr; \n\nfi;\ntr: if\n::  d_step {lost<20;lost = lost+1;}  goto ready; \n\n::  atomic {K_out!v;lost = 0;}  goto ready; \n\nfi;\ndata_lost: \n false; }\n\nactive proctype chnlnel_L() { \nbyte v=0;\nbyte lost=0;\n\nready: if\n:: L_in?v; goto tr; \n\nfi;\ntr: if\n::  d_step {lost<20;lost = lost+1;}  goto ready; \n\n::  atomic {L_out!v;lost = 0;}  goto ready; \n\nfi;\ndataOK: \n false; }\n\nactive proctype Producer() { \n\nready: if\n::  goto produce0; \n\n::  goto produce1; \n\nfi;\nproduce0: if\n:: send!0; goto ready; \n\nfi;\nproduce1: if\n:: send!1; goto ready; \n\nfi;\n}\n\nactive proctype Consumer() { \nbyte value=0;\n\nready: if\n:: receive?value; goto got_msg; \n\nfi;\ngot_msg: if\n:: value==0; goto consume0; \n\n:: value==1; goto consume1; \n\nfi;\nconsume0: if\n::  goto ready; \n\nfi;\nconsume1: if\n::  goto ready; \n\nfi;\n}\n\nactive proctype Sender() { \nbyte value=0;\nbyte sab=0;\nbyte retry=0;\n\nready: if\n::  atomic {send?value;sab = 1-sab;}  goto sending; \n\nfi;\nsending: if\n::  atomic {K_in!(value*2+sab);retry = 1;}  goto wait_ack; \n\nfi;\nwait_ack: if\n::  atomic {retry<30;K_in!(value*2+sab);retry = retry+1;}  goto wait_ack; \n\n:: L_out?value; goto ready; \n\n:: retry==30; goto failed; \n\nfi;\nfailed: \n false; }\n\nactive proctype Receiver() { \nbyte value=0;\nbyte rab=1;\n\nwaiting: if\n:: K_out?value; goto got_msg; \n\nfi;\ngot_msg: if\n:: value%2!=rab; goto waiting; \n\n::  atomic {value%2==rab;receive!(value/2);}  goto send_ack; \n\nfi;\nsend_ack: if\n::  atomic {L_in!0;rab = 1-rab;}  goto waiting; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Simple model of some basic  protocol for communication\n    over loosy channel (some simple faulty ones, alternating bit protocol, and\n    simple version of bounded retransmission protocol).\n\nParameters:\n\n\n\n\nAtomic propositions:\n, , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "chan K_in =[0] of {int};\nchan K_out =[0] of {int};\nchan L_in =[0] of {int};\nchan L_out =[0] of {int};\nchan send =[0] of {int};\nchan receive =[0] of {int};\n\nactive proctype chnlnel_K() { \nbyte v=0;\nbyte lost=0;\n\nready: if\n:: K_in?v; goto tr; \n\nfi;\ntr: if\n::  d_step {lost<40;lost = lost+1;}  goto ready; \n\n::  atomic {K_out!v;lost = 0;}  goto ready; \n\nfi;\ndata_lost: \n false; }\n\nactive proctype chnlnel_L() { \nbyte v=0;\nbyte lost=0;\n\nready: if\n:: L_in?v; goto tr; \n\nfi;\ntr: if\n::  d_step {lost<40;lost = lost+1;}  goto ready; \n\n::  atomic {L_out!v;lost = 0;}  goto ready; \n\nfi;\ndataOK: \n false; }\n\nactive proctype Producer() { \n\nready: if\n::  goto produce0; \n\n::  goto produce1; \n\nfi;\nproduce0: if\n:: send!0; goto ready; \n\nfi;\nproduce1: if\n:: send!1; goto ready; \n\nfi;\n}\n\nactive proctype Consumer() { \nbyte value=0;\n\nready: if\n:: receive?value; goto got_msg; \n\nfi;\ngot_msg: if\n:: value==0; goto consume0; \n\n:: value==1; goto consume1; \n\nfi;\nconsume0: if\n::  goto ready; \n\nfi;\nconsume1: if\n::  goto ready; \n\nfi;\n}\n\nactive proctype Sender() { \nbyte value=0;\nbyte sab=0;\nbyte retry=0;\n\nready: if\n::  atomic {send?value;sab = 1-sab;}  goto sending; \n\nfi;\nsending: if\n::  atomic {K_in!(value*2+sab);retry = 1;}  goto wait_ack; \n\nfi;\nwait_ack: if\n::  atomic {retry<40;K_in!(value*2+sab);retry = retry+1;}  goto wait_ack; \n\n:: L_out?value; goto ready; \n\n:: retry==40; goto failed; \n\nfi;\nfailed: \n false; }\n\nactive proctype Receiver() { \nbyte value=0;\nbyte rab=1;\n\nwaiting: if\n:: K_out?value; goto got_msg; \n\nfi;\ngot_msg: if\n:: value%2!=rab; goto waiting; \n\n::  atomic {value%2==rab;receive!(value/2);}  goto send_ack; \n\nfi;\nsend_ack: if\n::  atomic {L_in!0;rab = 1-rab;}  goto waiting; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Abstract specification (model) of the groupware protocol underlying thinkteam augmented with a publish/subscribe notification service.\n\nParameters:\n\n\n\nProperties to verify:"}, {"role": "assistant", "content": "chan userToCC =[0] of {int};\nchan ccToUser_0_in =[0] of {int};\nchan ccToUser_0_out =[0] of {int};\nchan ccToUserAdmin_0 =[0] of {int};\nchan ccToVault =[0] of {int};\nchan vaultToCC =[0] of {int};\nchan msgSync =[0] of {int};\n\nactive proctype User_0() { \nbyte cmd=0;\nbyte edit[3];\nbyte registered[3];\nbyte waitingForCheckedOut=0;\n\nready: if\n::  atomic {waitingForCheckedOut==0;userToCC!(0*16+0);}  goto doneGet; \n\n::  atomic {registered[0]==0 && edit[0]==0;userToCC!(9*16+0);registered[0] = 1;}  goto doneRegister; \n\n::  atomic {registered[0]==1 && edit[0]==0;userToCC!(10*16+0);registered[0] = 0;}  goto doneUnRegister; \n\n::  atomic {edit[0]==0 && waitingForCheckedOut==0;userToCC!(2*16+0);waitingForCheckedOut = 1;}  goto ready; \n\n:: edit[0]==1; goto editing; \n\n:: ccToUser_0_out?cmd; goto cmdReceived; \n\nfi;\ndoneGet: if\n:: ccToUser_0_out?cmd; goto getCmdReceived; \n\nfi;\ngetCmdReceived: if\n::  d_step {cmd==1;registered[0] = 1;}  goto ready; \n\nfi;\ndoneRegister: if\n::  goto ready; \n\nfi;\ndoneUnRegister: if\n::  goto ready; \n\nfi;\nediting: if\n::  atomic {userToCC!(5*16+0);edit[0] = 0;}  goto ready; \n\n::  atomic {userToCC!(7*16+0);edit[0] = 0;}  goto ready; \n\n:: userToCC!(8*16+0); goto ready; \n\nfi;\ncmdReceived: if\n::  d_step {cmd==3;edit[0] = 1;waitingForCheckedOut = 0;}  goto ready; \n\n::  d_step {cmd==4;waitingForCheckedOut = 0;}  goto ready; \n\nfi;\n}\n\nactive proctype UserAdmin_0() { \nbyte cmd=0;\n\nready: if\n:: ccToUserAdmin_0?cmd; goto cmdReceived; \n\nfi;\ncmdReceived: if\n::  atomic {cmd==12;msgSync!0;}  goto doneNotify; \n\n::  atomic {cmd==11;msgSync!0;}  goto doneUpdate; \n\nfi;\ndoneNotify: if\n::  goto ready; \n\nfi;\ndoneUpdate: if\n::  goto ready; \n\nfi;\n}\n\nactive proctype CC() { \nbyte cmd=0;\nbyte ID=0;\nbyte registered[1];\nbyte writeLock=0;\n\nready: if\n:: userToCC?cmd; goto cmdReceived; \n\nfi;\ncmdReceived: if\n:: cmd/16==0 && cmd%16==0; goto doneGet0; \n\n:: cmd/16==9 && cmd%16==0; goto doneRegister0; \n\n:: cmd/16==10 && cmd%16==0; goto doneUnRegister0; \n\n:: cmd/16==2; goto doneCheckOut; \n\n:: cmd/16==5; goto doneUnCheckOut; \n\n:: cmd/16==7; goto doneCheckIn; \n\n:: cmd/16==8; goto doneCheckInOut; \n\nfi;\ndoneGet0: if\n:: registered[cmd%16] = 1; goto get_step1; \n\nfi;\ndoneRegister0: if\n:: registered[0] = 1; goto ready; \n\nfi;\ndoneUnRegister0: if\n:: registered[0] = 0; goto ready; \n\nfi;\ndoneCheckedOut0: if\n:: ID = 0; goto checkOut_step4; \n\nfi;\ndoneNotify0: if\n:: ID = ID+1; goto checkOut_step4; \n\nfi;\nnotifyCmdSent0: if\n:: msgSync?0; goto doneNotify0; \n\nfi;\nupdateCmdSent0: if\n:: msgSync?0; goto doneUpdate0; \n\nfi;\ndoneUnCheckOut0: if\n:: writeLock = 0; goto Update; \n\n::  goto Update; \n\nfi;\ndoneCheckInOut0: if\n:: writeLock==1; goto checkWriteLockTrue; \n\n:: writeLock==0; goto checkWriteLockFalse; \n\nfi;\ndoneUpdate0: if\n:: ID = ID+1; goto update_cycle; \n\nfi;\nget_step1: if\n:: ccToVault!cmd; goto get_step2; \n\nfi;\nget_step2: if\n:: vaultToCC?cmd; goto get_step3; \n\nfi;\nget_step3: if\n::  atomic {cmd/16==1 && cmd%16==0;ccToUser_0_in!1;}  goto ready; \n\nfi;\ndoneCheckOut: if\n:: writeLock==0; goto checkOut_step1; \n\n::  atomic {writeLock==1 && cmd%16==0;ccToUser_0_in!4;}  goto doneNotAvailable; \n\nfi;\ncheckOut_step1: if\n::  atomic {ccToVault!cmd;writeLock = 1;}  goto checkOut_step2; \n\nfi;\ncheckOut_step2: if\n:: vaultToCC?cmd; goto checkOut_step3; \n\nfi;\ncheckOut_step3: if\n::  atomic {cmd/16==3 && cmd%16==0;ccToUser_0_in!3;}  goto doneCheckedOut; \n\nfi;\ncheckOut_step4: if\n:: ID<1; goto checkOut_step5; \n\n:: ID>=1; goto ready; \n\nfi;\ncheckOut_step5: if\n::  atomic {ID==0 && ID!=cmd%16 && registered[ID]==1;ccToUserAdmin_0!12;}  goto notifyCmdSent0; \n\n::  d_step {ID==cmd%16 || registered[ID]==0;ID = ID+1;}  goto checkOut_step4; \n\nfi;\ndoneNotAvailable: if\n::  goto ready; \n\nfi;\ndoneCheckedOut: if\n:: cmd%16==0; goto doneCheckedOut0; \n\nfi;\ndoneUnCheckOut: if\n:: cmd%16==0; goto doneUnCheckOut0; \n\nfi;\ndoneCheckIn: if\n::  atomic {ccToVault!cmd;writeLock = 0;}  goto checkIn_step1; \n\nfi;\ncheckIn_step1: if\n:: ccToVault?cmd; goto checkIn_step2; \n\nfi;\ncheckIn_step2: if\n:: cmd%16==0; goto doneUnCheckOut0; \n\nfi;\ndoneCheckInOut: if\n:: ccToVault!(7*16+cmd%16); goto checkInOut_step1; \n\nfi;\ncheckInOut_step1: if\n:: vaultToCC?cmd; goto checkInOut_step2; \n\nfi;\ncheckInOut_step2: if\n:: cmd/16==11 && cmd%16==0; goto doneCheckInOut0; \n\nfi;\nUpdate: if\n:: ID = 0; goto update_cycle; \n\nfi;\ncheckWriteLockTrue: if\n::  goto Update; \n\nfi;\ncheckWriteLockFalse: if\n::  goto Update; \n\nfi;\nupdate_cycle: if\n:: ID<1; goto update_step1; \n\n:: ID>=1; goto ready; \n\nfi;\nupdate_step1: if\n::  atomic {ID==0 && ID!=cmd%16 && registered[ID]==1;ccToUserAdmin_0!11;}  goto updateCmdSent0; \n\n::  d_step {ID==cmd%16 || registered[ID]==0;ID = ID+1;}  goto update_cycle; \n\nfi;\ndoneCheckIn0: \n false; }\n\nactive proctype Vault() { \nbyte cmd=0;\n\nready: if\n:: ccToVault?cmd; goto cmdReceived; \n\nfi;\ncmdReceived: if\n::  atomic {cmd/16==0;vaultToCC!(1*16+cmd%16);}  goto ready; \n\n::  atomic {cmd/16==2;vaultToCC!(3*16+cmd%16);}  goto ready; \n\n::  atomic {cmd/16==7;vaultToCC!(7*16+cmd%16);}  goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_ccToUser_0() { \nbyte v=0;\n\nready: if\n:: ccToUser_0_in?v; goto tr; \n\nfi;\ntr: if\n:: ccToUser_0_out!v; goto ready; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Abstract specification (model) of the groupware protocol underlying thinkteam augmented with a publish/subscribe notification service.\n\nParameters:\n\n\n\nProperties to verify:"}, {"role": "assistant", "content": "chan userToCC =[0] of {int};\nchan ccToUser_0_in =[0] of {int};\nchan ccToUser_0_out =[0] of {int};\nchan ccToUser_1_in =[0] of {int};\nchan ccToUser_1_out =[0] of {int};\nchan ccToUserAdmin_0 =[0] of {int};\nchan ccToUserAdmin_1 =[0] of {int};\nchan ccToVault =[0] of {int};\nchan vaultToCC =[0] of {int};\nchan msgSync =[0] of {int};\n\nactive proctype User_0() { \nbyte cmd=0;\nbyte edit[1];\nbyte registered[1];\nbyte waitingForCheckedOut=0;\n\nready: if\n::  atomic {waitingForCheckedOut==0;userToCC!(0*16+0);}  goto doneGet; \n\n::  atomic {registered[0]==0 && edit[0]==0;userToCC!(9*16+0);registered[0] = 1;}  goto doneRegister; \n\n::  atomic {registered[0]==1 && edit[0]==0;userToCC!(10*16+0);registered[0] = 0;}  goto doneUnRegister; \n\n::  atomic {edit[0]==0 && waitingForCheckedOut==0;userToCC!(2*16+0);waitingForCheckedOut = 1;}  goto ready; \n\n:: edit[0]==1; goto editing; \n\n:: ccToUser_0_out?cmd; goto cmdReceived; \n\nfi;\ndoneGet: if\n:: ccToUser_0_out?cmd; goto getCmdReceived; \n\nfi;\ngetCmdReceived: if\n::  d_step {cmd==1;registered[0] = 1;}  goto ready; \n\nfi;\ndoneRegister: if\n::  goto ready; \n\nfi;\ndoneUnRegister: if\n::  goto ready; \n\nfi;\nediting: if\n::  atomic {userToCC!(5*16+0);edit[0] = 0;}  goto ready; \n\n::  atomic {userToCC!(7*16+0);edit[0] = 0;}  goto ready; \n\n:: userToCC!(8*16+0); goto ready; \n\nfi;\ncmdReceived: if\n::  d_step {cmd==3;edit[0] = 1;waitingForCheckedOut = 0;}  goto ready; \n\n::  d_step {cmd==4;waitingForCheckedOut = 0;}  goto ready; \n\nfi;\n}\n\nactive proctype User_1() { \nbyte cmd=0;\nbyte edit[1];\nbyte registered[1];\nbyte waitingForCheckedOut=0;\n\nready: if\n::  atomic {waitingForCheckedOut==0;userToCC!(0*16+1);}  goto doneGet; \n\n::  atomic {registered[0]==0 && edit[0]==0;userToCC!(9*16+1);registered[0] = 1;}  goto doneRegister; \n\n::  atomic {registered[0]==1 && edit[0]==0;userToCC!(10*16+1);registered[0] = 0;}  goto doneUnRegister; \n\n::  atomic {edit[0]==0 && waitingForCheckedOut==0;userToCC!(2*16+1);waitingForCheckedOut = 1;}  goto ready; \n\n:: edit[0]==1; goto editing; \n\n:: ccToUser_1_out?cmd; goto cmdReceived; \n\nfi;\ndoneGet: if\n:: ccToUser_1_out?cmd; goto getCmdReceived; \n\nfi;\ngetCmdReceived: if\n::  d_step {cmd==1;registered[0] = 1;}  goto ready; \n\nfi;\ndoneRegister: if\n::  goto ready; \n\nfi;\ndoneUnRegister: if\n::  goto ready; \n\nfi;\nediting: if\n::  atomic {userToCC!(5*16+1);edit[0] = 0;}  goto ready; \n\n::  atomic {userToCC!(7*16+1);edit[0] = 0;}  goto ready; \n\n:: userToCC!(8*16+1); goto ready; \n\nfi;\ncmdReceived: if\n::  d_step {cmd==3;edit[0] = 1;waitingForCheckedOut = 0;}  goto ready; \n\n::  d_step {cmd==4;waitingForCheckedOut = 0;}  goto ready; \n\nfi;\n}\n\nactive proctype UserAdmin_0() { \nbyte cmd=0;\n\nready: if\n:: ccToUserAdmin_0?cmd; goto cmdReceived; \n\nfi;\ncmdReceived: if\n::  atomic {cmd==12;msgSync!0;}  goto doneNotify; \n\n::  atomic {cmd==11;msgSync!0;}  goto doneUpdate; \n\nfi;\ndoneNotify: if\n::  goto ready; \n\nfi;\ndoneUpdate: if\n::  goto ready; \n\nfi;\n}\n\nactive proctype UserAdmin_1() { \nbyte cmd=0;\n\nready: if\n:: ccToUserAdmin_1?cmd; goto cmdReceived; \n\nfi;\ncmdReceived: if\n::  atomic {cmd==12;msgSync!0;}  goto doneNotify; \n\n::  atomic {cmd==11;msgSync!0;}  goto doneUpdate; \n\nfi;\ndoneNotify: if\n::  goto ready; \n\nfi;\ndoneUpdate: if\n::  goto ready; \n\nfi;\n}\n\nactive proctype CC() { \nbyte cmd=0;\nbyte ID=0;\nbyte registered[2];\nbyte writeLock=0;\n\nready: if\n:: userToCC?cmd; goto cmdReceived; \n\nfi;\ncmdReceived: if\n:: cmd/16==0 && cmd%16==0; goto doneGet0; \n\n:: cmd/16==0 && cmd%16==1; goto doneGet1; \n\n:: cmd/16==9 && cmd%16==0; goto doneRegister0; \n\n:: cmd/16==9 && cmd%16==1; goto doneRegister1; \n\n:: cmd/16==10 && cmd%16==0; goto doneUnRegister0; \n\n:: cmd/16==10 && cmd%16==1; goto doneUnRegister1; \n\n:: cmd/16==2; goto doneCheckOut; \n\n:: cmd/16==5; goto doneUnCheckOut; \n\n:: cmd/16==7; goto doneCheckIn; \n\n:: cmd/16==8; goto doneCheckInOut; \n\nfi;\ndoneGet0: if\n:: registered[cmd%16] = 1; goto get_step1; \n\nfi;\ndoneRegister0: if\n:: registered[0] = 1; goto ready; \n\nfi;\ndoneUnRegister0: if\n:: registered[0] = 0; goto ready; \n\nfi;\ndoneCheckedOut0: if\n:: ID = 0; goto checkOut_step4; \n\nfi;\ndoneNotify0: if\n:: ID = ID+1; goto checkOut_step4; \n\nfi;\nnotifyCmdSent0: if\n:: msgSync?0; goto doneNotify0; \n\nfi;\nupdateCmdSent0: if\n:: msgSync?0; goto doneUpdate0; \n\nfi;\ndoneUnCheckOut0: if\n:: writeLock = 0; goto Update; \n\n::  goto Update; \n\nfi;\ndoneCheckInOut0: if\n:: writeLock==1; goto checkWriteLockTrue; \n\n:: writeLock==0; goto checkWriteLockFalse; \n\nfi;\ndoneUpdate0: if\n:: ID = ID+1; goto update_cycle; \n\nfi;\ndoneGet1: if\n:: registered[cmd%16] = 1; goto get_step1; \n\nfi;\ndoneRegister1: if\n:: registered[1] = 1; goto ready; \n\nfi;\ndoneUnRegister1: if\n:: registered[1] = 0; goto ready; \n\nfi;\ndoneCheckedOut1: if\n:: ID = 0; goto checkOut_step4; \n\nfi;\ndoneNotify1: if\n:: ID = ID+1; goto checkOut_step4; \n\nfi;\nnotifyCmdSent1: if\n:: msgSync?0; goto doneNotify1; \n\nfi;\nupdateCmdSent1: if\n:: msgSync?0; goto doneUpdate1; \n\nfi;\ndoneUnCheckOut1: if\n:: writeLock = 0; goto Update; \n\n::  goto Update; \n\nfi;\ndoneCheckInOut1: if\n:: writeLock==1; goto checkWriteLockTrue; \n\n:: writeLock==0; goto checkWriteLockFalse; \n\nfi;\ndoneUpdate1: if\n:: ID = ID+1; goto update_cycle; \n\nfi;\nget_step1: if\n:: ccToVault!cmd; goto get_step2; \n\nfi;\nget_step2: if\n:: vaultToCC?cmd; goto get_step3; \n\nfi;\nget_step3: if\n::  atomic {cmd/16==1 && cmd%16==0;ccToUser_0_in!1;}  goto ready; \n\n::  atomic {cmd/16==1 && cmd%16==1;ccToUser_1_in!1;}  goto ready; \n\nfi;\ndoneCheckOut: if\n:: writeLock==0; goto checkOut_step1; \n\n::  atomic {writeLock==1 && cmd%16==0;ccToUser_0_in!4;}  goto doneNotAvailable; \n\n::  atomic {writeLock==1 && cmd%16==1;ccToUser_1_in!4;}  goto doneNotAvailable; \n\nfi;\ncheckOut_step1: if\n::  atomic {ccToVault!cmd;writeLock = 1;}  goto checkOut_step2; \n\nfi;\ncheckOut_step2: if\n:: vaultToCC?cmd; goto checkOut_step3; \n\nfi;\ncheckOut_step3: if\n::  atomic {cmd/16==3 && cmd%16==0;ccToUser_0_in!3;}  goto doneCheckedOut; \n\n::  atomic {cmd/16==3 && cmd%16==1;ccToUser_1_in!3;}  goto doneCheckedOut; \n\nfi;\ncheckOut_step4: if\n:: ID<2; goto checkOut_step5; \n\n:: ID>=2; goto ready; \n\nfi;\ncheckOut_step5: if\n::  atomic {ID==0 && ID!=cmd%16 && registered[ID]==1;ccToUserAdmin_0!12;}  goto notifyCmdSent0; \n\n::  atomic {ID==1 && ID!=cmd%16 && registered[ID]==1;ccToUserAdmin_1!12;}  goto notifyCmdSent1; \n\n::  d_step {ID==cmd%16 || registered[ID]==0;ID = ID+1;}  goto checkOut_step4; \n\nfi;\ndoneNotAvailable: if\n::  goto ready; \n\nfi;\ndoneCheckedOut: if\n:: cmd%16==0; goto doneCheckedOut0; \n\n:: cmd%16==1; goto doneCheckedOut1; \n\nfi;\ndoneUnCheckOut: if\n:: cmd%16==0; goto doneUnCheckOut0; \n\n:: cmd%16==1; goto doneUnCheckOut1; \n\nfi;\ndoneCheckIn: if\n::  atomic {ccToVault!cmd;writeLock = 0;}  goto checkIn_step1; \n\nfi;\ncheckIn_step1: if\n:: ccToVault?cmd; goto checkIn_step2; \n\nfi;\ncheckIn_step2: if\n:: cmd%16==0; goto doneUnCheckOut0; \n\n:: cmd%16==1; goto doneUnCheckOut1; \n\nfi;\ndoneCheckInOut: if\n:: ccToVault!(7*16+cmd%16); goto checkInOut_step1; \n\nfi;\ncheckInOut_step1: if\n:: vaultToCC?cmd; goto checkInOut_step2; \n\nfi;\ncheckInOut_step2: if\n:: cmd/16==11 && cmd%16==0; goto doneCheckInOut0; \n\n:: cmd/16==11 && cmd%16==1; goto doneCheckInOut1; \n\nfi;\nUpdate: if\n:: ID = 0; goto update_cycle; \n\nfi;\ncheckWriteLockTrue: if\n::  goto Update; \n\n::  goto Update; \n\nfi;\ncheckWriteLockFalse: if\n::  goto Update; \n\n::  goto Update; \n\nfi;\nupdate_cycle: if\n:: ID<2; goto update_step1; \n\n:: ID>=2; goto ready; \n\nfi;\nupdate_step1: if\n::  atomic {ID==0 && ID!=cmd%16 && registered[ID]==1;ccToUserAdmin_0!11;}  goto updateCmdSent0; \n\n::  atomic {ID==1 && ID!=cmd%16 && registered[ID]==1;ccToUserAdmin_1!11;}  goto updateCmdSent1; \n\n::  d_step {ID==cmd%16 || registered[ID]==0;ID = ID+1;}  goto update_cycle; \n\nfi;\ndoneCheckIn0: \ndoneCheckIn1: \n false; }\n\nactive proctype Vault() { \nbyte cmd=0;\n\nready: if\n:: ccToVault?cmd; goto cmdReceived; \n\nfi;\ncmdReceived: if\n::  atomic {cmd/16==0;vaultToCC!(1*16+cmd%16);}  goto ready; \n\n::  atomic {cmd/16==2;vaultToCC!(3*16+cmd%16);}  goto ready; \n\n::  atomic {cmd/16==7;vaultToCC!(7*16+cmd%16);}  goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_ccToUser_0() { \nbyte v=0;\n\nready: if\n:: ccToUser_0_in?v; goto tr; \n\nfi;\ntr: if\n:: ccToUser_0_out!v; goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_ccToUser_1() { \nbyte v=0;\n\nready: if\n:: ccToUser_1_in?v; goto tr; \n\nfi;\ntr: if\n:: ccToUser_1_out!v; goto ready; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Abstract specification (model) of the groupware protocol underlying thinkteam augmented with a publish/subscribe notification service.\n\nParameters:\n\n\n\nProperties to verify:"}, {"role": "assistant", "content": "chan userToCC =[0] of {int};\nchan ccToUser_0_in =[0] of {int};\nchan ccToUser_0_out =[0] of {int};\nchan ccToUser_1_in =[0] of {int};\nchan ccToUser_1_out =[0] of {int};\nchan ccToUserAdmin_0 =[0] of {int};\nchan ccToUserAdmin_1 =[0] of {int};\nchan ccToVault =[0] of {int};\nchan vaultToCC =[0] of {int};\nchan msgSync =[0] of {int};\n\nactive proctype User_0() { \nbyte cmd=0;\nbyte edit[2];\nbyte registered[2];\nbyte waitingForCheckedOut=0;\n\nready: if\n::  atomic {waitingForCheckedOut==0;userToCC!(0*16+0);}  goto doneGet; \n\n::  atomic {registered[0]==0 && edit[0]==0;userToCC!(9*16+0);registered[0] = 1;}  goto doneRegister; \n\n::  atomic {registered[0]==1 && edit[0]==0;userToCC!(10*16+0);registered[0] = 0;}  goto doneUnRegister; \n\n::  atomic {edit[0]==0 && waitingForCheckedOut==0;userToCC!(2*16+0);waitingForCheckedOut = 1;}  goto ready; \n\n:: edit[0]==1; goto editing; \n\n:: ccToUser_0_out?cmd; goto cmdReceived; \n\nfi;\ndoneGet: if\n:: ccToUser_0_out?cmd; goto getCmdReceived; \n\nfi;\ngetCmdReceived: if\n::  d_step {cmd==1;registered[0] = 1;}  goto ready; \n\nfi;\ndoneRegister: if\n::  goto ready; \n\nfi;\ndoneUnRegister: if\n::  goto ready; \n\nfi;\nediting: if\n::  atomic {userToCC!(5*16+0);edit[0] = 0;}  goto ready; \n\n::  atomic {userToCC!(7*16+0);edit[0] = 0;}  goto ready; \n\n:: userToCC!(8*16+0); goto ready; \n\nfi;\ncmdReceived: if\n::  d_step {cmd==3;edit[0] = 1;waitingForCheckedOut = 0;}  goto ready; \n\n::  d_step {cmd==4;waitingForCheckedOut = 0;}  goto ready; \n\nfi;\n}\n\nactive proctype User_1() { \nbyte cmd=0;\nbyte edit[2];\nbyte registered[2];\nbyte waitingForCheckedOut=0;\n\nready: if\n::  atomic {waitingForCheckedOut==0;userToCC!(0*16+1);}  goto doneGet; \n\n::  atomic {registered[0]==0 && edit[0]==0;userToCC!(9*16+1);registered[0] = 1;}  goto doneRegister; \n\n::  atomic {registered[0]==1 && edit[0]==0;userToCC!(10*16+1);registered[0] = 0;}  goto doneUnRegister; \n\n::  atomic {edit[0]==0 && waitingForCheckedOut==0;userToCC!(2*16+1);waitingForCheckedOut = 1;}  goto ready; \n\n:: edit[0]==1; goto editing; \n\n:: ccToUser_1_out?cmd; goto cmdReceived; \n\nfi;\ndoneGet: if\n:: ccToUser_1_out?cmd; goto getCmdReceived; \n\nfi;\ngetCmdReceived: if\n::  d_step {cmd==1;registered[0] = 1;}  goto ready; \n\nfi;\ndoneRegister: if\n::  goto ready; \n\nfi;\ndoneUnRegister: if\n::  goto ready; \n\nfi;\nediting: if\n::  atomic {userToCC!(5*16+1);edit[0] = 0;}  goto ready; \n\n::  atomic {userToCC!(7*16+1);edit[0] = 0;}  goto ready; \n\n:: userToCC!(8*16+1); goto ready; \n\nfi;\ncmdReceived: if\n::  d_step {cmd==3;edit[0] = 1;waitingForCheckedOut = 0;}  goto ready; \n\n::  d_step {cmd==4;waitingForCheckedOut = 0;}  goto ready; \n\nfi;\n}\n\nactive proctype UserAdmin_0() { \nbyte cmd=0;\n\nready: if\n:: ccToUserAdmin_0?cmd; goto cmdReceived; \n\nfi;\ncmdReceived: if\n::  atomic {cmd==12;msgSync!0;}  goto doneNotify; \n\n::  atomic {cmd==11;msgSync!0;}  goto doneUpdate; \n\nfi;\ndoneNotify: if\n::  goto ready; \n\nfi;\ndoneUpdate: if\n::  goto ready; \n\nfi;\n}\n\nactive proctype UserAdmin_1() { \nbyte cmd=0;\n\nready: if\n:: ccToUserAdmin_1?cmd; goto cmdReceived; \n\nfi;\ncmdReceived: if\n::  atomic {cmd==12;msgSync!0;}  goto doneNotify; \n\n::  atomic {cmd==11;msgSync!0;}  goto doneUpdate; \n\nfi;\ndoneNotify: if\n::  goto ready; \n\nfi;\ndoneUpdate: if\n::  goto ready; \n\nfi;\n}\n\nactive proctype CC() { \nbyte cmd=0;\nbyte ID=0;\nbyte registered[2];\nbyte writeLock=0;\n\nready: if\n:: userToCC?cmd; goto cmdReceived; \n\nfi;\ncmdReceived: if\n:: cmd/16==0 && cmd%16==0; goto doneGet0; \n\n:: cmd/16==0 && cmd%16==1; goto doneGet1; \n\n:: cmd/16==9 && cmd%16==0; goto doneRegister0; \n\n:: cmd/16==9 && cmd%16==1; goto doneRegister1; \n\n:: cmd/16==10 && cmd%16==0; goto doneUnRegister0; \n\n:: cmd/16==10 && cmd%16==1; goto doneUnRegister1; \n\n:: cmd/16==2; goto doneCheckOut; \n\n:: cmd/16==5; goto doneUnCheckOut; \n\n:: cmd/16==7; goto doneCheckIn; \n\n:: cmd/16==8; goto doneCheckInOut; \n\nfi;\ndoneGet0: if\n:: registered[cmd%16] = 1; goto get_step1; \n\nfi;\ndoneRegister0: if\n:: registered[0] = 1; goto ready; \n\nfi;\ndoneUnRegister0: if\n:: registered[0] = 0; goto ready; \n\nfi;\ndoneCheckedOut0: if\n:: ID = 0; goto checkOut_step4; \n\nfi;\ndoneNotify0: if\n:: ID = ID+1; goto checkOut_step4; \n\nfi;\nnotifyCmdSent0: if\n:: msgSync?0; goto doneNotify0; \n\nfi;\nupdateCmdSent0: if\n:: msgSync?0; goto doneUpdate0; \n\nfi;\ndoneUnCheckOut0: if\n:: writeLock = 0; goto Update; \n\n::  goto Update; \n\nfi;\ndoneCheckInOut0: if\n:: writeLock==1; goto checkWriteLockTrue; \n\n:: writeLock==0; goto checkWriteLockFalse; \n\nfi;\ndoneUpdate0: if\n:: ID = ID+1; goto update_cycle; \n\nfi;\ndoneGet1: if\n:: registered[cmd%16] = 1; goto get_step1; \n\nfi;\ndoneRegister1: if\n:: registered[1] = 1; goto ready; \n\nfi;\ndoneUnRegister1: if\n:: registered[1] = 0; goto ready; \n\nfi;\ndoneCheckedOut1: if\n:: ID = 0; goto checkOut_step4; \n\nfi;\ndoneNotify1: if\n:: ID = ID+1; goto checkOut_step4; \n\nfi;\nnotifyCmdSent1: if\n:: msgSync?0; goto doneNotify1; \n\nfi;\nupdateCmdSent1: if\n:: msgSync?0; goto doneUpdate1; \n\nfi;\ndoneUnCheckOut1: if\n:: writeLock = 0; goto Update; \n\n::  goto Update; \n\nfi;\ndoneCheckInOut1: if\n:: writeLock==1; goto checkWriteLockTrue; \n\n:: writeLock==0; goto checkWriteLockFalse; \n\nfi;\ndoneUpdate1: if\n:: ID = ID+1; goto update_cycle; \n\nfi;\nget_step1: if\n:: ccToVault!cmd; goto get_step2; \n\nfi;\nget_step2: if\n:: vaultToCC?cmd; goto get_step3; \n\nfi;\nget_step3: if\n::  atomic {cmd/16==1 && cmd%16==0;ccToUser_0_in!1;}  goto ready; \n\n::  atomic {cmd/16==1 && cmd%16==1;ccToUser_1_in!1;}  goto ready; \n\nfi;\ndoneCheckOut: if\n:: writeLock==0; goto checkOut_step1; \n\n::  atomic {writeLock==1 && cmd%16==0;ccToUser_0_in!4;}  goto doneNotAvailable; \n\n::  atomic {writeLock==1 && cmd%16==1;ccToUser_1_in!4;}  goto doneNotAvailable; \n\nfi;\ncheckOut_step1: if\n::  atomic {ccToVault!cmd;writeLock = 1;}  goto checkOut_step2; \n\nfi;\ncheckOut_step2: if\n:: vaultToCC?cmd; goto checkOut_step3; \n\nfi;\ncheckOut_step3: if\n::  atomic {cmd/16==3 && cmd%16==0;ccToUser_0_in!3;}  goto doneCheckedOut; \n\n::  atomic {cmd/16==3 && cmd%16==1;ccToUser_1_in!3;}  goto doneCheckedOut; \n\nfi;\ncheckOut_step4: if\n:: ID<2; goto checkOut_step5; \n\n:: ID>=2; goto ready; \n\nfi;\ncheckOut_step5: if\n::  atomic {ID==0 && ID!=cmd%16 && registered[ID]==1;ccToUserAdmin_0!12;}  goto notifyCmdSent0; \n\n::  atomic {ID==1 && ID!=cmd%16 && registered[ID]==1;ccToUserAdmin_1!12;}  goto notifyCmdSent1; \n\n::  d_step {ID==cmd%16 || registered[ID]==0;ID = ID+1;}  goto checkOut_step4; \n\nfi;\ndoneNotAvailable: if\n::  goto ready; \n\nfi;\ndoneCheckedOut: if\n:: cmd%16==0; goto doneCheckedOut0; \n\n:: cmd%16==1; goto doneCheckedOut1; \n\nfi;\ndoneUnCheckOut: if\n:: cmd%16==0; goto doneUnCheckOut0; \n\n:: cmd%16==1; goto doneUnCheckOut1; \n\nfi;\ndoneCheckIn: if\n::  atomic {ccToVault!cmd;writeLock = 0;}  goto checkIn_step1; \n\nfi;\ncheckIn_step1: if\n:: ccToVault?cmd; goto checkIn_step2; \n\nfi;\ncheckIn_step2: if\n:: cmd%16==0; goto doneUnCheckOut0; \n\n:: cmd%16==1; goto doneUnCheckOut1; \n\nfi;\ndoneCheckInOut: if\n:: ccToVault!(7*16+cmd%16); goto checkInOut_step1; \n\nfi;\ncheckInOut_step1: if\n:: vaultToCC?cmd; goto checkInOut_step2; \n\nfi;\ncheckInOut_step2: if\n:: cmd/16==11 && cmd%16==0; goto doneCheckInOut0; \n\n:: cmd/16==11 && cmd%16==1; goto doneCheckInOut1; \n\nfi;\nUpdate: if\n:: ID = 0; goto update_cycle; \n\nfi;\ncheckWriteLockTrue: if\n::  goto Update; \n\n::  goto Update; \n\nfi;\ncheckWriteLockFalse: if\n::  goto Update; \n\n::  goto Update; \n\nfi;\nupdate_cycle: if\n:: ID<2; goto update_step1; \n\n:: ID>=2; goto ready; \n\nfi;\nupdate_step1: if\n::  atomic {ID==0 && ID!=cmd%16 && registered[ID]==1;ccToUserAdmin_0!11;}  goto updateCmdSent0; \n\n::  atomic {ID==1 && ID!=cmd%16 && registered[ID]==1;ccToUserAdmin_1!11;}  goto updateCmdSent1; \n\n::  d_step {ID==cmd%16 || registered[ID]==0;ID = ID+1;}  goto update_cycle; \n\nfi;\ndoneCheckIn0: \ndoneCheckIn1: \n false; }\n\nactive proctype Vault() { \nbyte cmd=0;\n\nready: if\n:: ccToVault?cmd; goto cmdReceived; \n\nfi;\ncmdReceived: if\n::  atomic {cmd/16==0;vaultToCC!(1*16+cmd%16);}  goto ready; \n\n::  atomic {cmd/16==2;vaultToCC!(3*16+cmd%16);}  goto ready; \n\n::  atomic {cmd/16==7;vaultToCC!(7*16+cmd%16);}  goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_ccToUser_0() { \nbyte v=0;\n\nready: if\n:: ccToUser_0_in?v; goto tr; \n\nfi;\ntr: if\n:: ccToUser_0_out!v; goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_ccToUser_1() { \nbyte v=0;\n\nready: if\n:: ccToUser_1_in?v; goto tr; \n\nfi;\ntr: if\n:: ccToUser_1_out!v; goto ready; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Abstract specification (model) of the groupware protocol underlying thinkteam augmented with a publish/subscribe notification service.\n\nParameters:\n\n\n\nProperties to verify:"}, {"role": "assistant", "content": "chan userToCC =[0] of {int};\nchan ccToUser_0_in =[0] of {int};\nchan ccToUser_0_out =[0] of {int};\nchan ccToUser_1_in =[0] of {int};\nchan ccToUser_1_out =[0] of {int};\nchan ccToUserAdmin_0 =[0] of {int};\nchan ccToUserAdmin_1 =[0] of {int};\nchan ccToVault =[0] of {int};\nchan vaultToCC =[0] of {int};\nchan msgSync =[0] of {int};\n\nactive proctype User_0() { \nbyte cmd=0;\nbyte edit[3];\nbyte registered[3];\nbyte waitingForCheckedOut=0;\n\nready: if\n::  atomic {waitingForCheckedOut==0;userToCC!(0*16+0);}  goto doneGet; \n\n::  atomic {registered[0]==0 && edit[0]==0;userToCC!(9*16+0);registered[0] = 1;}  goto doneRegister; \n\n::  atomic {registered[0]==1 && edit[0]==0;userToCC!(10*16+0);registered[0] = 0;}  goto doneUnRegister; \n\n::  atomic {edit[0]==0 && waitingForCheckedOut==0;userToCC!(2*16+0);waitingForCheckedOut = 1;}  goto ready; \n\n:: edit[0]==1; goto editing; \n\n:: ccToUser_0_out?cmd; goto cmdReceived; \n\nfi;\ndoneGet: if\n:: ccToUser_0_out?cmd; goto getCmdReceived; \n\nfi;\ngetCmdReceived: if\n::  d_step {cmd==1;registered[0] = 1;}  goto ready; \n\nfi;\ndoneRegister: if\n::  goto ready; \n\nfi;\ndoneUnRegister: if\n::  goto ready; \n\nfi;\nediting: if\n::  atomic {userToCC!(5*16+0);edit[0] = 0;}  goto ready; \n\n::  atomic {userToCC!(7*16+0);edit[0] = 0;}  goto ready; \n\n:: userToCC!(8*16+0); goto ready; \n\nfi;\ncmdReceived: if\n::  d_step {cmd==3;edit[0] = 1;waitingForCheckedOut = 0;}  goto ready; \n\n::  d_step {cmd==4;waitingForCheckedOut = 0;}  goto ready; \n\nfi;\n}\n\nactive proctype User_1() { \nbyte cmd=0;\nbyte edit[3];\nbyte registered[3];\nbyte waitingForCheckedOut=0;\n\nready: if\n::  atomic {waitingForCheckedOut==0;userToCC!(0*16+1);}  goto doneGet; \n\n::  atomic {registered[0]==0 && edit[0]==0;userToCC!(9*16+1);registered[0] = 1;}  goto doneRegister; \n\n::  atomic {registered[0]==1 && edit[0]==0;userToCC!(10*16+1);registered[0] = 0;}  goto doneUnRegister; \n\n::  atomic {edit[0]==0 && waitingForCheckedOut==0;userToCC!(2*16+1);waitingForCheckedOut = 1;}  goto ready; \n\n:: edit[0]==1; goto editing; \n\n:: ccToUser_1_out?cmd; goto cmdReceived; \n\nfi;\ndoneGet: if\n:: ccToUser_1_out?cmd; goto getCmdReceived; \n\nfi;\ngetCmdReceived: if\n::  d_step {cmd==1;registered[0] = 1;}  goto ready; \n\nfi;\ndoneRegister: if\n::  goto ready; \n\nfi;\ndoneUnRegister: if\n::  goto ready; \n\nfi;\nediting: if\n::  atomic {userToCC!(5*16+1);edit[0] = 0;}  goto ready; \n\n::  atomic {userToCC!(7*16+1);edit[0] = 0;}  goto ready; \n\n:: userToCC!(8*16+1); goto ready; \n\nfi;\ncmdReceived: if\n::  d_step {cmd==3;edit[0] = 1;waitingForCheckedOut = 0;}  goto ready; \n\n::  d_step {cmd==4;waitingForCheckedOut = 0;}  goto ready; \n\nfi;\n}\n\nactive proctype UserAdmin_0() { \nbyte cmd=0;\n\nready: if\n:: ccToUserAdmin_0?cmd; goto cmdReceived; \n\nfi;\ncmdReceived: if\n::  atomic {cmd==12;msgSync!0;}  goto doneNotify; \n\n::  atomic {cmd==11;msgSync!0;}  goto doneUpdate; \n\nfi;\ndoneNotify: if\n::  goto ready; \n\nfi;\ndoneUpdate: if\n::  goto ready; \n\nfi;\n}\n\nactive proctype UserAdmin_1() { \nbyte cmd=0;\n\nready: if\n:: ccToUserAdmin_1?cmd; goto cmdReceived; \n\nfi;\ncmdReceived: if\n::  atomic {cmd==12;msgSync!0;}  goto doneNotify; \n\n::  atomic {cmd==11;msgSync!0;}  goto doneUpdate; \n\nfi;\ndoneNotify: if\n::  goto ready; \n\nfi;\ndoneUpdate: if\n::  goto ready; \n\nfi;\n}\n\nactive proctype CC() { \nbyte cmd=0;\nbyte ID=0;\nbyte registered[2];\nbyte writeLock=0;\n\nready: if\n:: userToCC?cmd; goto cmdReceived; \n\nfi;\ncmdReceived: if\n:: cmd/16==0 && cmd%16==0; goto doneGet0; \n\n:: cmd/16==0 && cmd%16==1; goto doneGet1; \n\n:: cmd/16==9 && cmd%16==0; goto doneRegister0; \n\n:: cmd/16==9 && cmd%16==1; goto doneRegister1; \n\n:: cmd/16==10 && cmd%16==0; goto doneUnRegister0; \n\n:: cmd/16==10 && cmd%16==1; goto doneUnRegister1; \n\n:: cmd/16==2; goto doneCheckOut; \n\n:: cmd/16==5; goto doneUnCheckOut; \n\n:: cmd/16==7; goto doneCheckIn; \n\n:: cmd/16==8; goto doneCheckInOut; \n\nfi;\ndoneGet0: if\n:: registered[cmd%16] = 1; goto get_step1; \n\nfi;\ndoneRegister0: if\n:: registered[0] = 1; goto ready; \n\nfi;\ndoneUnRegister0: if\n:: registered[0] = 0; goto ready; \n\nfi;\ndoneCheckedOut0: if\n:: ID = 0; goto checkOut_step4; \n\nfi;\ndoneNotify0: if\n:: ID = ID+1; goto checkOut_step4; \n\nfi;\nnotifyCmdSent0: if\n:: msgSync?0; goto doneNotify0; \n\nfi;\nupdateCmdSent0: if\n:: msgSync?0; goto doneUpdate0; \n\nfi;\ndoneUnCheckOut0: if\n:: writeLock = 0; goto Update; \n\n::  goto Update; \n\nfi;\ndoneCheckInOut0: if\n:: writeLock==1; goto checkWriteLockTrue; \n\n:: writeLock==0; goto checkWriteLockFalse; \n\nfi;\ndoneUpdate0: if\n:: ID = ID+1; goto update_cycle; \n\nfi;\ndoneGet1: if\n:: registered[cmd%16] = 1; goto get_step1; \n\nfi;\ndoneRegister1: if\n:: registered[1] = 1; goto ready; \n\nfi;\ndoneUnRegister1: if\n:: registered[1] = 0; goto ready; \n\nfi;\ndoneCheckedOut1: if\n:: ID = 0; goto checkOut_step4; \n\nfi;\ndoneNotify1: if\n:: ID = ID+1; goto checkOut_step4; \n\nfi;\nnotifyCmdSent1: if\n:: msgSync?0; goto doneNotify1; \n\nfi;\nupdateCmdSent1: if\n:: msgSync?0; goto doneUpdate1; \n\nfi;\ndoneUnCheckOut1: if\n:: writeLock = 0; goto Update; \n\n::  goto Update; \n\nfi;\ndoneCheckInOut1: if\n:: writeLock==1; goto checkWriteLockTrue; \n\n:: writeLock==0; goto checkWriteLockFalse; \n\nfi;\ndoneUpdate1: if\n:: ID = ID+1; goto update_cycle; \n\nfi;\nget_step1: if\n:: ccToVault!cmd; goto get_step2; \n\nfi;\nget_step2: if\n:: vaultToCC?cmd; goto get_step3; \n\nfi;\nget_step3: if\n::  atomic {cmd/16==1 && cmd%16==0;ccToUser_0_in!1;}  goto ready; \n\n::  atomic {cmd/16==1 && cmd%16==1;ccToUser_1_in!1;}  goto ready; \n\nfi;\ndoneCheckOut: if\n:: writeLock==0; goto checkOut_step1; \n\n::  atomic {writeLock==1 && cmd%16==0;ccToUser_0_in!4;}  goto doneNotAvailable; \n\n::  atomic {writeLock==1 && cmd%16==1;ccToUser_1_in!4;}  goto doneNotAvailable; \n\nfi;\ncheckOut_step1: if\n::  atomic {ccToVault!cmd;writeLock = 1;}  goto checkOut_step2; \n\nfi;\ncheckOut_step2: if\n:: vaultToCC?cmd; goto checkOut_step3; \n\nfi;\ncheckOut_step3: if\n::  atomic {cmd/16==3 && cmd%16==0;ccToUser_0_in!3;}  goto doneCheckedOut; \n\n::  atomic {cmd/16==3 && cmd%16==1;ccToUser_1_in!3;}  goto doneCheckedOut; \n\nfi;\ncheckOut_step4: if\n:: ID<2; goto checkOut_step5; \n\n:: ID>=2; goto ready; \n\nfi;\ncheckOut_step5: if\n::  atomic {ID==0 && ID!=cmd%16 && registered[ID]==1;ccToUserAdmin_0!12;}  goto notifyCmdSent0; \n\n::  atomic {ID==1 && ID!=cmd%16 && registered[ID]==1;ccToUserAdmin_1!12;}  goto notifyCmdSent1; \n\n::  d_step {ID==cmd%16 || registered[ID]==0;ID = ID+1;}  goto checkOut_step4; \n\nfi;\ndoneNotAvailable: if\n::  goto ready; \n\nfi;\ndoneCheckedOut: if\n:: cmd%16==0; goto doneCheckedOut0; \n\n:: cmd%16==1; goto doneCheckedOut1; \n\nfi;\ndoneUnCheckOut: if\n:: cmd%16==0; goto doneUnCheckOut0; \n\n:: cmd%16==1; goto doneUnCheckOut1; \n\nfi;\ndoneCheckIn: if\n::  atomic {ccToVault!cmd;writeLock = 0;}  goto checkIn_step1; \n\nfi;\ncheckIn_step1: if\n:: ccToVault?cmd; goto checkIn_step2; \n\nfi;\ncheckIn_step2: if\n:: cmd%16==0; goto doneUnCheckOut0; \n\n:: cmd%16==1; goto doneUnCheckOut1; \n\nfi;\ndoneCheckInOut: if\n:: ccToVault!(7*16+cmd%16); goto checkInOut_step1; \n\nfi;\ncheckInOut_step1: if\n:: vaultToCC?cmd; goto checkInOut_step2; \n\nfi;\ncheckInOut_step2: if\n:: cmd/16==11 && cmd%16==0; goto doneCheckInOut0; \n\n:: cmd/16==11 && cmd%16==1; goto doneCheckInOut1; \n\nfi;\nUpdate: if\n:: ID = 0; goto update_cycle; \n\nfi;\ncheckWriteLockTrue: if\n::  goto Update; \n\n::  goto Update; \n\nfi;\ncheckWriteLockFalse: if\n::  goto Update; \n\n::  goto Update; \n\nfi;\nupdate_cycle: if\n:: ID<2; goto update_step1; \n\n:: ID>=2; goto ready; \n\nfi;\nupdate_step1: if\n::  atomic {ID==0 && ID!=cmd%16 && registered[ID]==1;ccToUserAdmin_0!11;}  goto updateCmdSent0; \n\n::  atomic {ID==1 && ID!=cmd%16 && registered[ID]==1;ccToUserAdmin_1!11;}  goto updateCmdSent1; \n\n::  d_step {ID==cmd%16 || registered[ID]==0;ID = ID+1;}  goto update_cycle; \n\nfi;\ndoneCheckIn0: \ndoneCheckIn1: \n false; }\n\nactive proctype Vault() { \nbyte cmd=0;\n\nready: if\n:: ccToVault?cmd; goto cmdReceived; \n\nfi;\ncmdReceived: if\n::  atomic {cmd/16==0;vaultToCC!(1*16+cmd%16);}  goto ready; \n\n::  atomic {cmd/16==2;vaultToCC!(3*16+cmd%16);}  goto ready; \n\n::  atomic {cmd/16==7;vaultToCC!(7*16+cmd%16);}  goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_ccToUser_0() { \nbyte v=0;\n\nready: if\n:: ccToUser_0_in?v; goto tr; \n\nfi;\ntr: if\n:: ccToUser_0_out!v; goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_ccToUser_1() { \nbyte v=0;\n\nready: if\n:: ccToUser_1_in?v; goto tr; \n\nfi;\ntr: if\n:: ccToUser_1_out!v; goto ready; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Abstract specification (model) of the groupware protocol underlying thinkteam augmented with a publish/subscribe notification service.\n\nParameters:\n\n\n\nProperties to verify:"}, {"role": "assistant", "content": "chan userToCC =[0] of {int};\nchan ccToUser_0_in =[0] of {int};\nchan ccToUser_0_out =[0] of {int};\nchan ccToUser_1_in =[0] of {int};\nchan ccToUser_1_out =[0] of {int};\nchan ccToUser_2_in =[0] of {int};\nchan ccToUser_2_out =[0] of {int};\nchan ccToUserAdmin_0 =[0] of {int};\nchan ccToUserAdmin_1 =[0] of {int};\nchan ccToUserAdmin_2 =[0] of {int};\nchan ccToVault =[0] of {int};\nchan vaultToCC =[0] of {int};\nchan msgSync =[0] of {int};\n\nactive proctype User_0() { \nbyte cmd=0;\nbyte edit[1];\nbyte registered[1];\nbyte waitingForCheckedOut=0;\n\nready: if\n::  atomic {waitingForCheckedOut==0;userToCC!(0*16+0);}  goto doneGet; \n\n::  atomic {registered[0]==0 && edit[0]==0;userToCC!(9*16+0);registered[0] = 1;}  goto doneRegister; \n\n::  atomic {registered[0]==1 && edit[0]==0;userToCC!(10*16+0);registered[0] = 0;}  goto doneUnRegister; \n\n::  atomic {edit[0]==0 && waitingForCheckedOut==0;userToCC!(2*16+0);waitingForCheckedOut = 1;}  goto ready; \n\n:: edit[0]==1; goto editing; \n\n:: ccToUser_0_out?cmd; goto cmdReceived; \n\nfi;\ndoneGet: if\n:: ccToUser_0_out?cmd; goto getCmdReceived; \n\nfi;\ngetCmdReceived: if\n::  d_step {cmd==1;registered[0] = 1;}  goto ready; \n\nfi;\ndoneRegister: if\n::  goto ready; \n\nfi;\ndoneUnRegister: if\n::  goto ready; \n\nfi;\nediting: if\n::  atomic {userToCC!(5*16+0);edit[0] = 0;}  goto ready; \n\n::  atomic {userToCC!(7*16+0);edit[0] = 0;}  goto ready; \n\n:: userToCC!(8*16+0); goto ready; \n\nfi;\ncmdReceived: if\n::  d_step {cmd==3;edit[0] = 1;waitingForCheckedOut = 0;}  goto ready; \n\n::  d_step {cmd==4;waitingForCheckedOut = 0;}  goto ready; \n\nfi;\n}\n\nactive proctype User_1() { \nbyte cmd=0;\nbyte edit[1];\nbyte registered[1];\nbyte waitingForCheckedOut=0;\n\nready: if\n::  atomic {waitingForCheckedOut==0;userToCC!(0*16+1);}  goto doneGet; \n\n::  atomic {registered[0]==0 && edit[0]==0;userToCC!(9*16+1);registered[0] = 1;}  goto doneRegister; \n\n::  atomic {registered[0]==1 && edit[0]==0;userToCC!(10*16+1);registered[0] = 0;}  goto doneUnRegister; \n\n::  atomic {edit[0]==0 && waitingForCheckedOut==0;userToCC!(2*16+1);waitingForCheckedOut = 1;}  goto ready; \n\n:: edit[0]==1; goto editing; \n\n:: ccToUser_1_out?cmd; goto cmdReceived; \n\nfi;\ndoneGet: if\n:: ccToUser_1_out?cmd; goto getCmdReceived; \n\nfi;\ngetCmdReceived: if\n::  d_step {cmd==1;registered[0] = 1;}  goto ready; \n\nfi;\ndoneRegister: if\n::  goto ready; \n\nfi;\ndoneUnRegister: if\n::  goto ready; \n\nfi;\nediting: if\n::  atomic {userToCC!(5*16+1);edit[0] = 0;}  goto ready; \n\n::  atomic {userToCC!(7*16+1);edit[0] = 0;}  goto ready; \n\n:: userToCC!(8*16+1); goto ready; \n\nfi;\ncmdReceived: if\n::  d_step {cmd==3;edit[0] = 1;waitingForCheckedOut = 0;}  goto ready; \n\n::  d_step {cmd==4;waitingForCheckedOut = 0;}  goto ready; \n\nfi;\n}\n\nactive proctype User_2() { \nbyte cmd=0;\nbyte edit[1];\nbyte registered[1];\nbyte waitingForCheckedOut=0;\n\nready: if\n::  atomic {waitingForCheckedOut==0;userToCC!(0*16+2);}  goto doneGet; \n\n::  atomic {registered[0]==0 && edit[0]==0;userToCC!(9*16+2);registered[0] = 1;}  goto doneRegister; \n\n::  atomic {registered[0]==1 && edit[0]==0;userToCC!(10*16+2);registered[0] = 0;}  goto doneUnRegister; \n\n::  atomic {edit[0]==0 && waitingForCheckedOut==0;userToCC!(2*16+2);waitingForCheckedOut = 1;}  goto ready; \n\n:: edit[0]==1; goto editing; \n\n:: ccToUser_2_out?cmd; goto cmdReceived; \n\nfi;\ndoneGet: if\n:: ccToUser_2_out?cmd; goto getCmdReceived; \n\nfi;\ngetCmdReceived: if\n::  d_step {cmd==1;registered[0] = 1;}  goto ready; \n\nfi;\ndoneRegister: if\n::  goto ready; \n\nfi;\ndoneUnRegister: if\n::  goto ready; \n\nfi;\nediting: if\n::  atomic {userToCC!(5*16+2);edit[0] = 0;}  goto ready; \n\n::  atomic {userToCC!(7*16+2);edit[0] = 0;}  goto ready; \n\n:: userToCC!(8*16+2); goto ready; \n\nfi;\ncmdReceived: if\n::  d_step {cmd==3;edit[0] = 1;waitingForCheckedOut = 0;}  goto ready; \n\n::  d_step {cmd==4;waitingForCheckedOut = 0;}  goto ready; \n\nfi;\n}\n\nactive proctype UserAdmin_0() { \nbyte cmd=0;\n\nready: if\n:: ccToUserAdmin_0?cmd; goto cmdReceived; \n\nfi;\ncmdReceived: if\n::  atomic {cmd==12;msgSync!0;}  goto doneNotify; \n\n::  atomic {cmd==11;msgSync!0;}  goto doneUpdate; \n\nfi;\ndoneNotify: if\n::  goto ready; \n\nfi;\ndoneUpdate: if\n::  goto ready; \n\nfi;\n}\n\nactive proctype UserAdmin_1() { \nbyte cmd=0;\n\nready: if\n:: ccToUserAdmin_1?cmd; goto cmdReceived; \n\nfi;\ncmdReceived: if\n::  atomic {cmd==12;msgSync!0;}  goto doneNotify; \n\n::  atomic {cmd==11;msgSync!0;}  goto doneUpdate; \n\nfi;\ndoneNotify: if\n::  goto ready; \n\nfi;\ndoneUpdate: if\n::  goto ready; \n\nfi;\n}\n\nactive proctype UserAdmin_2() { \nbyte cmd=0;\n\nready: if\n:: ccToUserAdmin_2?cmd; goto cmdReceived; \n\nfi;\ncmdReceived: if\n::  atomic {cmd==12;msgSync!0;}  goto doneNotify; \n\n::  atomic {cmd==11;msgSync!0;}  goto doneUpdate; \n\nfi;\ndoneNotify: if\n::  goto ready; \n\nfi;\ndoneUpdate: if\n::  goto ready; \n\nfi;\n}\n\nactive proctype CC() { \nbyte cmd=0;\nbyte ID=0;\nbyte registered[3];\nbyte writeLock=0;\n\nready: if\n:: userToCC?cmd; goto cmdReceived; \n\nfi;\ncmdReceived: if\n:: cmd/16==0 && cmd%16==0; goto doneGet0; \n\n:: cmd/16==0 && cmd%16==1; goto doneGet1; \n\n:: cmd/16==0 && cmd%16==2; goto doneGet2; \n\n:: cmd/16==9 && cmd%16==0; goto doneRegister0; \n\n:: cmd/16==9 && cmd%16==1; goto doneRegister1; \n\n:: cmd/16==9 && cmd%16==2; goto doneRegister2; \n\n:: cmd/16==10 && cmd%16==0; goto doneUnRegister0; \n\n:: cmd/16==10 && cmd%16==1; goto doneUnRegister1; \n\n:: cmd/16==10 && cmd%16==2; goto doneUnRegister2; \n\n:: cmd/16==2; goto doneCheckOut; \n\n:: cmd/16==5; goto doneUnCheckOut; \n\n:: cmd/16==7; goto doneCheckIn; \n\n:: cmd/16==8; goto doneCheckInOut; \n\nfi;\ndoneGet0: if\n:: registered[cmd%16] = 1; goto get_step1; \n\nfi;\ndoneRegister0: if\n:: registered[0] = 1; goto ready; \n\nfi;\ndoneUnRegister0: if\n:: registered[0] = 0; goto ready; \n\nfi;\ndoneCheckedOut0: if\n:: ID = 0; goto checkOut_step4; \n\nfi;\ndoneNotify0: if\n:: ID = ID+1; goto checkOut_step4; \n\nfi;\nnotifyCmdSent0: if\n:: msgSync?0; goto doneNotify0; \n\nfi;\nupdateCmdSent0: if\n:: msgSync?0; goto doneUpdate0; \n\nfi;\ndoneUnCheckOut0: if\n:: writeLock = 0; goto Update; \n\n::  goto Update; \n\nfi;\ndoneCheckInOut0: if\n:: writeLock==1; goto checkWriteLockTrue; \n\n:: writeLock==0; goto checkWriteLockFalse; \n\nfi;\ndoneUpdate0: if\n:: ID = ID+1; goto update_cycle; \n\nfi;\ndoneGet1: if\n:: registered[cmd%16] = 1; goto get_step1; \n\nfi;\ndoneRegister1: if\n:: registered[1] = 1; goto ready; \n\nfi;\ndoneUnRegister1: if\n:: registered[1] = 0; goto ready; \n\nfi;\ndoneCheckedOut1: if\n:: ID = 0; goto checkOut_step4; \n\nfi;\ndoneNotify1: if\n:: ID = ID+1; goto checkOut_step4; \n\nfi;\nnotifyCmdSent1: if\n:: msgSync?0; goto doneNotify1; \n\nfi;\nupdateCmdSent1: if\n:: msgSync?0; goto doneUpdate1; \n\nfi;\ndoneUnCheckOut1: if\n:: writeLock = 0; goto Update; \n\n::  goto Update; \n\nfi;\ndoneCheckInOut1: if\n:: writeLock==1; goto checkWriteLockTrue; \n\n:: writeLock==0; goto checkWriteLockFalse; \n\nfi;\ndoneUpdate1: if\n:: ID = ID+1; goto update_cycle; \n\nfi;\ndoneGet2: if\n:: registered[cmd%16] = 1; goto get_step1; \n\nfi;\ndoneRegister2: if\n:: registered[2] = 1; goto ready; \n\nfi;\ndoneUnRegister2: if\n:: registered[2] = 0; goto ready; \n\nfi;\ndoneCheckedOut2: if\n:: ID = 0; goto checkOut_step4; \n\nfi;\ndoneNotify2: if\n:: ID = ID+1; goto checkOut_step4; \n\nfi;\nnotifyCmdSent2: if\n:: msgSync?0; goto doneNotify2; \n\nfi;\nupdateCmdSent2: if\n:: msgSync?0; goto doneUpdate2; \n\nfi;\ndoneUnCheckOut2: if\n:: writeLock = 0; goto Update; \n\n::  goto Update; \n\nfi;\ndoneCheckInOut2: if\n:: writeLock==1; goto checkWriteLockTrue; \n\n:: writeLock==0; goto checkWriteLockFalse; \n\nfi;\ndoneUpdate2: if\n:: ID = ID+1; goto update_cycle; \n\nfi;\nget_step1: if\n:: ccToVault!cmd; goto get_step2; \n\nfi;\nget_step2: if\n:: vaultToCC?cmd; goto get_step3; \n\nfi;\nget_step3: if\n::  atomic {cmd/16==1 && cmd%16==0;ccToUser_0_in!1;}  goto ready; \n\n::  atomic {cmd/16==1 && cmd%16==1;ccToUser_1_in!1;}  goto ready; \n\n::  atomic {cmd/16==1 && cmd%16==2;ccToUser_2_in!1;}  goto ready; \n\nfi;\ndoneCheckOut: if\n:: writeLock==0; goto checkOut_step1; \n\n::  atomic {writeLock==1 && cmd%16==0;ccToUser_0_in!4;}  goto doneNotAvailable; \n\n::  atomic {writeLock==1 && cmd%16==1;ccToUser_1_in!4;}  goto doneNotAvailable; \n\n::  atomic {writeLock==1 && cmd%16==2;ccToUser_2_in!4;}  goto doneNotAvailable; \n\nfi;\ncheckOut_step1: if\n::  atomic {ccToVault!cmd;writeLock = 1;}  goto checkOut_step2; \n\nfi;\ncheckOut_step2: if\n:: vaultToCC?cmd; goto checkOut_step3; \n\nfi;\ncheckOut_step3: if\n::  atomic {cmd/16==3 && cmd%16==0;ccToUser_0_in!3;}  goto doneCheckedOut; \n\n::  atomic {cmd/16==3 && cmd%16==1;ccToUser_1_in!3;}  goto doneCheckedOut; \n\n::  atomic {cmd/16==3 && cmd%16==2;ccToUser_2_in!3;}  goto doneCheckedOut; \n\nfi;\ncheckOut_step4: if\n:: ID<3; goto checkOut_step5; \n\n:: ID>=3; goto ready; \n\nfi;\ncheckOut_step5: if\n::  atomic {ID==0 && ID!=cmd%16 && registered[ID]==1;ccToUserAdmin_0!12;}  goto notifyCmdSent0; \n\n::  atomic {ID==1 && ID!=cmd%16 && registered[ID]==1;ccToUserAdmin_1!12;}  goto notifyCmdSent1; \n\n::  atomic {ID==2 && ID!=cmd%16 && registered[ID]==1;ccToUserAdmin_2!12;}  goto notifyCmdSent2; \n\n::  d_step {ID==cmd%16 || registered[ID]==0;ID = ID+1;}  goto checkOut_step4; \n\nfi;\ndoneNotAvailable: if\n::  goto ready; \n\nfi;\ndoneCheckedOut: if\n:: cmd%16==0; goto doneCheckedOut0; \n\n:: cmd%16==1; goto doneCheckedOut1; \n\n:: cmd%16==2; goto doneCheckedOut2; \n\nfi;\ndoneUnCheckOut: if\n:: cmd%16==0; goto doneUnCheckOut0; \n\n:: cmd%16==1; goto doneUnCheckOut1; \n\n:: cmd%16==2; goto doneUnCheckOut2; \n\nfi;\ndoneCheckIn: if\n::  atomic {ccToVault!cmd;writeLock = 0;}  goto checkIn_step1; \n\nfi;\ncheckIn_step1: if\n:: ccToVault?cmd; goto checkIn_step2; \n\nfi;\ncheckIn_step2: if\n:: cmd%16==0; goto doneUnCheckOut0; \n\n:: cmd%16==1; goto doneUnCheckOut1; \n\n:: cmd%16==2; goto doneUnCheckOut2; \n\nfi;\ndoneCheckInOut: if\n:: ccToVault!(7*16+cmd%16); goto checkInOut_step1; \n\nfi;\ncheckInOut_step1: if\n:: vaultToCC?cmd; goto checkInOut_step2; \n\nfi;\ncheckInOut_step2: if\n:: cmd/16==11 && cmd%16==0; goto doneCheckInOut0; \n\n:: cmd/16==11 && cmd%16==1; goto doneCheckInOut1; \n\n:: cmd/16==11 && cmd%16==2; goto doneCheckInOut2; \n\nfi;\nUpdate: if\n:: ID = 0; goto update_cycle; \n\nfi;\ncheckWriteLockTrue: if\n::  goto Update; \n\n::  goto Update; \n\n::  goto Update; \n\nfi;\ncheckWriteLockFalse: if\n::  goto Update; \n\n::  goto Update; \n\n::  goto Update; \n\nfi;\nupdate_cycle: if\n:: ID<3; goto update_step1; \n\n:: ID>=3; goto ready; \n\nfi;\nupdate_step1: if\n::  atomic {ID==0 && ID!=cmd%16 && registered[ID]==1;ccToUserAdmin_0!11;}  goto updateCmdSent0; \n\n::  atomic {ID==1 && ID!=cmd%16 && registered[ID]==1;ccToUserAdmin_1!11;}  goto updateCmdSent1; \n\n::  atomic {ID==2 && ID!=cmd%16 && registered[ID]==1;ccToUserAdmin_2!11;}  goto updateCmdSent2; \n\n::  d_step {ID==cmd%16 || registered[ID]==0;ID = ID+1;}  goto update_cycle; \n\nfi;\ndoneCheckIn0: \ndoneCheckIn1: \ndoneCheckIn2: \n false; }\n\nactive proctype Vault() { \nbyte cmd=0;\n\nready: if\n:: ccToVault?cmd; goto cmdReceived; \n\nfi;\ncmdReceived: if\n::  atomic {cmd/16==0;vaultToCC!(1*16+cmd%16);}  goto ready; \n\n::  atomic {cmd/16==2;vaultToCC!(3*16+cmd%16);}  goto ready; \n\n::  atomic {cmd/16==7;vaultToCC!(7*16+cmd%16);}  goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_ccToUser_0() { \nbyte v=0;\n\nready: if\n:: ccToUser_0_in?v; goto tr; \n\nfi;\ntr: if\n:: ccToUser_0_out!v; goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_ccToUser_1() { \nbyte v=0;\n\nready: if\n:: ccToUser_1_in?v; goto tr; \n\nfi;\ntr: if\n:: ccToUser_1_out!v; goto ready; \n\nfi;\n}\n\nactive proctype chnlnel_ccToUser_2() { \nbyte v=0;\n\nready: if\n:: ccToUser_2_in?v; goto tr; \n\nfi;\ntr: if\n:: ccToUser_2_out!v; goto ready; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Simple protocol for coordination of readers and writers\n  accessing shared resource. Several readers can read concurrently, writers\n  require exclusive access.\n\nParameters:\n\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte actvR=0;\n\nchan start_read =[0] of {int};\nchan stop_read =[0] of {int};\nchan start_write =[0] of {int};\nchan stop_write =[0] of {int};\n\nactive proctype reader_0() { \n\nidle: if\n:: start_read!0; goto reading; \n\nfi;\nreading: if\n:: stop_read!0; goto idle; \n\nfi;\n}\n\nactive proctype reader_1() { \n\nidle: if\n:: start_read!0; goto reading; \n\nfi;\nreading: if\n:: stop_read!0; goto idle; \n\nfi;\n}\n\nactive proctype reader_2() { \n\nidle: if\n:: start_read!0; goto reading; \n\nfi;\nreading: if\n:: stop_read!0; goto idle; \n\nfi;\n}\n\nactive proctype reader_3() { \n\nidle: if\n:: start_read!0; goto reading; \n\nfi;\nreading: if\n:: stop_read!0; goto idle; \n\nfi;\n}\n\nactive proctype reader_4() { \n\nidle: if\n:: start_read!0; goto reading; \n\nfi;\nreading: if\n:: stop_read!0; goto idle; \n\nfi;\n}\n\nactive proctype reader_5() { \n\nidle: if\n:: start_read!0; goto reading; \n\nfi;\nreading: if\n:: stop_read!0; goto idle; \n\nfi;\n}\n\nactive proctype reader_6() { \n\nidle: if\n:: start_read!0; goto reading; \n\nfi;\nreading: if\n:: stop_read!0; goto idle; \n\nfi;\n}\n\nactive proctype writer_0() { \n\nidle: if\n:: start_write!0; goto writing; \n\nfi;\nwriting: if\n:: stop_write!0; goto idle; \n\nfi;\n}\n\nactive proctype writer_1() { \n\nidle: if\n:: start_write!0; goto writing; \n\nfi;\nwriting: if\n:: stop_write!0; goto idle; \n\nfi;\n}\n\nactive proctype writer_2() { \n\nidle: if\n:: start_write!0; goto writing; \n\nfi;\nwriting: if\n:: stop_write!0; goto idle; \n\nfi;\n}\n\nactive proctype writer_3() { \n\nidle: if\n:: start_write!0; goto writing; \n\nfi;\nwriting: if\n:: stop_write!0; goto idle; \n\nfi;\n}\n\nactive proctype writer_4() { \n\nidle: if\n:: start_write!0; goto writing; \n\nfi;\nwriting: if\n:: stop_write!0; goto idle; \n\nfi;\n}\n\nactive proctype writer_5() { \n\nidle: if\n:: start_write!0; goto writing; \n\nfi;\nwriting: if\n:: stop_write!0; goto idle; \n\nfi;\n}\n\nactive proctype writer_6() { \n\nidle: if\n:: start_write!0; goto writing; \n\nfi;\nwriting: if\n:: stop_write!0; goto idle; \n\nfi;\n}\n\nactive proctype writer_7() { \n\nidle: if\n:: start_write!0; goto writing; \n\nfi;\nwriting: if\n:: stop_write!0; goto idle; \n\nfi;\n}\n\nactive proctype writer_8() { \n\nidle: if\n:: start_write!0; goto writing; \n\nfi;\nwriting: if\n:: stop_write!0; goto idle; \n\nfi;\n}\n\nactive proctype control() { \n\nready: if\n::  atomic {start_read?0;actvR = 1;}  goto readers_actv; \n\n:: start_write?0; goto writer_actv; \n\nfi;\nreaders_actv: if\n::  atomic {start_read?0;actvR = actvR+1;}  goto readers_actv; \n\n::  atomic {actvR>0;stop_read?0;actvR = 1;}  goto readers_actv; \n\n::  atomic {actvR==1;stop_read?0;actvR = 0;}  goto ready; \n\n:: stop_write?0; goto q_error; \n\nfi;\nwriter_actv: if\n:: stop_write?0; goto ready; \n\n:: stop_read?0; goto q_error; \n\nfi;\nq_error: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Simple protocol for coordination of readers and writers\n  accessing shared resource. Several readers can read concurrently, writers\n  require exclusive access.\n\nParameters:\n\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte actvR=0;\n\nchan start_read =[0] of {int};\nchan stop_read =[0] of {int};\nchan start_write =[0] of {int};\nchan stop_write =[0] of {int};\n\nactive proctype reader_0() { \n\nidle: if\n:: start_read!0; goto reading; \n\nfi;\nreading: if\n:: stop_read!0; goto idle; \n\nfi;\n}\n\nactive proctype reader_1() { \n\nidle: if\n:: start_read!0; goto reading; \n\nfi;\nreading: if\n:: stop_read!0; goto idle; \n\nfi;\n}\n\nactive proctype reader_2() { \n\nidle: if\n:: start_read!0; goto reading; \n\nfi;\nreading: if\n:: stop_read!0; goto idle; \n\nfi;\n}\n\nactive proctype reader_3() { \n\nidle: if\n:: start_read!0; goto reading; \n\nfi;\nreading: if\n:: stop_read!0; goto idle; \n\nfi;\n}\n\nactive proctype reader_4() { \n\nidle: if\n:: start_read!0; goto reading; \n\nfi;\nreading: if\n:: stop_read!0; goto idle; \n\nfi;\n}\n\nactive proctype reader_5() { \n\nidle: if\n:: start_read!0; goto reading; \n\nfi;\nreading: if\n:: stop_read!0; goto idle; \n\nfi;\n}\n\nactive proctype reader_6() { \n\nidle: if\n:: start_read!0; goto reading; \n\nfi;\nreading: if\n:: stop_read!0; goto idle; \n\nfi;\n}\n\nactive proctype reader_7() { \n\nidle: if\n:: start_read!0; goto reading; \n\nfi;\nreading: if\n:: stop_read!0; goto idle; \n\nfi;\n}\n\nactive proctype reader_8() { \n\nidle: if\n:: start_read!0; goto reading; \n\nfi;\nreading: if\n:: stop_read!0; goto idle; \n\nfi;\n}\n\nactive proctype reader_9() { \n\nidle: if\n:: start_read!0; goto reading; \n\nfi;\nreading: if\n:: stop_read!0; goto idle; \n\nfi;\n}\n\nactive proctype reader_10() { \n\nidle: if\n:: start_read!0; goto reading; \n\nfi;\nreading: if\n:: stop_read!0; goto idle; \n\nfi;\n}\n\nactive proctype reader_11() { \n\nidle: if\n:: start_read!0; goto reading; \n\nfi;\nreading: if\n:: stop_read!0; goto idle; \n\nfi;\n}\n\nactive proctype writer_0() { \n\nidle: if\n:: start_write!0; goto writing; \n\nfi;\nwriting: if\n:: stop_write!0; goto idle; \n\nfi;\n}\n\nactive proctype writer_1() { \n\nidle: if\n:: start_write!0; goto writing; \n\nfi;\nwriting: if\n:: stop_write!0; goto idle; \n\nfi;\n}\n\nactive proctype writer_2() { \n\nidle: if\n:: start_write!0; goto writing; \n\nfi;\nwriting: if\n:: stop_write!0; goto idle; \n\nfi;\n}\n\nactive proctype writer_3() { \n\nidle: if\n:: start_write!0; goto writing; \n\nfi;\nwriting: if\n:: stop_write!0; goto idle; \n\nfi;\n}\n\nactive proctype writer_4() { \n\nidle: if\n:: start_write!0; goto writing; \n\nfi;\nwriting: if\n:: stop_write!0; goto idle; \n\nfi;\n}\n\nactive proctype writer_5() { \n\nidle: if\n:: start_write!0; goto writing; \n\nfi;\nwriting: if\n:: stop_write!0; goto idle; \n\nfi;\n}\n\nactive proctype writer_6() { \n\nidle: if\n:: start_write!0; goto writing; \n\nfi;\nwriting: if\n:: stop_write!0; goto idle; \n\nfi;\n}\n\nactive proctype control() { \n\nready: if\n::  atomic {start_read?0;actvR = 1;}  goto readers_actv; \n\n:: start_write?0; goto writer_actv; \n\nfi;\nreaders_actv: if\n::  atomic {start_read?0;actvR = actvR+1;}  goto readers_actv; \n\n::  atomic {actvR>0;stop_read?0;actvR = actvR-1;}  goto readers_actv; \n\n::  atomic {actvR==1;stop_read?0;actvR = 0;}  goto ready; \n\n:: stop_write?0; goto q_error; \n\nfi;\nwriter_actv: if\n:: stop_write?0; goto ready; \n\n:: stop_read?0; goto q_error; \n\nfi;\nq_error: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Simple protocol for coordination of readers and writers\n  accessing shared resource. Several readers can read concurrently, writers\n  require exclusive access.\n\nParameters:\n\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte actvR=0;\n\nchan start_read =[0] of {int};\nchan stop_read =[0] of {int};\nchan start_write =[0] of {int};\nchan stop_write =[0] of {int};\n\nactive proctype reader_0() { \n\nidle: if\n:: start_read!0; goto reading; \n\nfi;\nreading: if\n:: stop_read!0; goto idle; \n\nfi;\n}\n\nactive proctype reader_1() { \n\nidle: if\n:: start_read!0; goto reading; \n\nfi;\nreading: if\n:: stop_read!0; goto idle; \n\nfi;\n}\n\nactive proctype reader_2() { \n\nidle: if\n:: start_read!0; goto reading; \n\nfi;\nreading: if\n:: stop_read!0; goto idle; \n\nfi;\n}\n\nactive proctype reader_3() { \n\nidle: if\n:: start_read!0; goto reading; \n\nfi;\nreading: if\n:: stop_read!0; goto idle; \n\nfi;\n}\n\nactive proctype reader_4() { \n\nidle: if\n:: start_read!0; goto reading; \n\nfi;\nreading: if\n:: stop_read!0; goto idle; \n\nfi;\n}\n\nactive proctype reader_5() { \n\nidle: if\n:: start_read!0; goto reading; \n\nfi;\nreading: if\n:: stop_read!0; goto idle; \n\nfi;\n}\n\nactive proctype reader_6() { \n\nidle: if\n:: start_read!0; goto reading; \n\nfi;\nreading: if\n:: stop_read!0; goto idle; \n\nfi;\n}\n\nactive proctype reader_7() { \n\nidle: if\n:: start_read!0; goto reading; \n\nfi;\nreading: if\n:: stop_read!0; goto idle; \n\nfi;\n}\n\nactive proctype reader_8() { \n\nidle: if\n:: start_read!0; goto reading; \n\nfi;\nreading: if\n:: stop_read!0; goto idle; \n\nfi;\n}\n\nactive proctype reader_9() { \n\nidle: if\n:: start_read!0; goto reading; \n\nfi;\nreading: if\n:: stop_read!0; goto idle; \n\nfi;\n}\n\nactive proctype reader_10() { \n\nidle: if\n:: start_read!0; goto reading; \n\nfi;\nreading: if\n:: stop_read!0; goto idle; \n\nfi;\n}\n\nactive proctype reader_11() { \n\nidle: if\n:: start_read!0; goto reading; \n\nfi;\nreading: if\n:: stop_read!0; goto idle; \n\nfi;\n}\n\nactive proctype reader_12() { \n\nidle: if\n:: start_read!0; goto reading; \n\nfi;\nreading: if\n:: stop_read!0; goto idle; \n\nfi;\n}\n\nactive proctype reader_13() { \n\nidle: if\n:: start_read!0; goto reading; \n\nfi;\nreading: if\n:: stop_read!0; goto idle; \n\nfi;\n}\n\nactive proctype writer_0() { \n\nidle: if\n:: start_write!0; goto writing; \n\nfi;\nwriting: if\n:: stop_write!0; goto idle; \n\nfi;\n}\n\nactive proctype writer_1() { \n\nidle: if\n:: start_write!0; goto writing; \n\nfi;\nwriting: if\n:: stop_write!0; goto idle; \n\nfi;\n}\n\nactive proctype writer_2() { \n\nidle: if\n:: start_write!0; goto writing; \n\nfi;\nwriting: if\n:: stop_write!0; goto idle; \n\nfi;\n}\n\nactive proctype writer_3() { \n\nidle: if\n:: start_write!0; goto writing; \n\nfi;\nwriting: if\n:: stop_write!0; goto idle; \n\nfi;\n}\n\nactive proctype writer_4() { \n\nidle: if\n:: start_write!0; goto writing; \n\nfi;\nwriting: if\n:: stop_write!0; goto idle; \n\nfi;\n}\n\nactive proctype writer_5() { \n\nidle: if\n:: start_write!0; goto writing; \n\nfi;\nwriting: if\n:: stop_write!0; goto idle; \n\nfi;\n}\n\nactive proctype writer_6() { \n\nidle: if\n:: start_write!0; goto writing; \n\nfi;\nwriting: if\n:: stop_write!0; goto idle; \n\nfi;\n}\n\nactive proctype writer_7() { \n\nidle: if\n:: start_write!0; goto writing; \n\nfi;\nwriting: if\n:: stop_write!0; goto idle; \n\nfi;\n}\n\nactive proctype writer_8() { \n\nidle: if\n:: start_write!0; goto writing; \n\nfi;\nwriting: if\n:: stop_write!0; goto idle; \n\nfi;\n}\n\nactive proctype writer_9() { \n\nidle: if\n:: start_write!0; goto writing; \n\nfi;\nwriting: if\n:: stop_write!0; goto idle; \n\nfi;\n}\n\nactive proctype writer_10() { \n\nidle: if\n:: start_write!0; goto writing; \n\nfi;\nwriting: if\n:: stop_write!0; goto idle; \n\nfi;\n}\n\nactive proctype writer_11() { \n\nidle: if\n:: start_write!0; goto writing; \n\nfi;\nwriting: if\n:: stop_write!0; goto idle; \n\nfi;\n}\n\nactive proctype writer_12() { \n\nidle: if\n:: start_write!0; goto writing; \n\nfi;\nwriting: if\n:: stop_write!0; goto idle; \n\nfi;\n}\n\nactive proctype writer_13() { \n\nidle: if\n:: start_write!0; goto writing; \n\nfi;\nwriting: if\n:: stop_write!0; goto idle; \n\nfi;\n}\n\nactive proctype control() { \n\nready: if\n::  atomic {start_read?0;actvR = 1;}  goto readers_actv; \n\n:: start_write?0; goto writer_actv; \n\nfi;\nreaders_actv: if\n::  atomic {start_read?0;actvR = actvR+1;}  goto readers_actv; \n\n::  atomic {actvR>0;stop_read?0;actvR = 1;}  goto readers_actv; \n\n::  atomic {actvR==1;stop_read?0;actvR = 0;}  goto ready; \n\n:: stop_write?0; goto q_error; \n\nfi;\nwriter_actv: if\n:: stop_write?0; goto ready; \n\n:: stop_read?0; goto q_error; \n\nfi;\nq_error: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Software-based, real-time Ethernet protocol developed at\n    SUNY. Its purpose is to provide guaranteed bandwidth and deterministic,\n    periodic network access to multimedia applications over commodity Ethernet\n    hardware. It is a contention-free token bus protocol for the datalink layer\n    of the ISO protocol stack.\n\nParameters:\n\n\n\n\n\nAtomic propositions:\n, , , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte in_RT[3];\nbyte RT_count=0;\n\nchan reserve =[0] of {int};\nchan release =[0] of {int};\nchan grant =[0] of {int};\nchan no_grant =[0] of {int};\nchan done =[0] of {int};\nchan visit_0 =[0] of {int};\nchan visit_1 =[0] of {int};\nchan visit_2 =[0] of {int};\nchan ok =[0] of {int};\n\nactive proctype Bandwidth() { \nbyte i=0;\n\nidle: if\n:: reserve?i; goto res; \n\n:: release?i; goto rel; \n\nfi;\nrel: if\n::  atomic {in_RT[i]==1;ok!0;in_RT[i] = 0;RT_count = RT_count-1;}  goto idle; \n\n:: in_RT[i]==0; goto error_st; \n\nfi;\nres: if\n::  atomic {RT_count>=2;no_grant!0;}  goto idle; \n\n::  atomic {RT_count<2;grant!0;RT_count = RT_count+1;in_RT[i] = 1;}  goto idle; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_0() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_0?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!0;granted = 0;}  goto wait_ok; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!0;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nwait_ok: if\n:: ok?0; goto finish; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_1() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_1?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!1;granted = 0;}  goto wait_ok; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!1;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nwait_ok: if\n:: ok?0; goto finish; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_2() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_2?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!2;granted = 0;}  goto wait_ok; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!2;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nwait_ok: if\n:: ok?0; goto finish; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Token() { \nbyte i=0;\nbyte NRT_count=5;\nbyte next=0;\n\nstart: if\n:: i = 0; goto RT_phase; \n\nfi;\nRT_phase: if\n::  d_step {i<3 && in_RT[i]==0;i = i+1;}  goto RT_phase; \n\n::  atomic {i==0 && in_RT[i]==1;visit_0!1;}  goto RT_wait; \n\n::  atomic {i==1 && in_RT[i]==1;visit_1!1;}  goto RT_wait; \n\n::  atomic {i==2 && in_RT[i]==1;visit_2!1;}  goto RT_wait; \n\n:: i==3; goto NRT_phase; \n\nfi;\nRT_wait: if\n::  atomic {done?0;i = i+1;}  goto RT_phase; \n\nfi;\nNRT_phase: if\n::  atomic {NRT_count>0 && next==0;visit_0!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==1;visit_1!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==2;visit_2!0;}  goto NRT_wait; \n\n:: NRT_count==0; goto cycle_end; \n\nfi;\nNRT_wait: if\n::  atomic {done?0;next = (next+1)%3;NRT_count = NRT_count-1;}  goto NRT_phase; \n\nfi;\ncycle_end: if\n:: NRT_count = 5-RT_count; goto start; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Software-based, real-time Ethernet protocol developed at\n    SUNY. Its purpose is to provide guaranteed bandwidth and deterministic,\n    periodic network access to multimedia applications over commodity Ethernet\n    hardware. It is a contention-free token bus protocol for the datalink layer\n    of the ISO protocol stack.\n\nParameters:\n\n\n\n\n\nAtomic propositions:\n, , , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte in_RT[4];\nbyte RT_count=0;\n\nchan reserve =[0] of {int};\nchan release =[0] of {int};\nchan grant =[0] of {int};\nchan no_grant =[0] of {int};\nchan done =[0] of {int};\nchan visit_0 =[0] of {int};\nchan visit_1 =[0] of {int};\nchan visit_2 =[0] of {int};\nchan visit_3 =[0] of {int};\nchan ok =[0] of {int};\n\nactive proctype Bandwidth() { \nbyte i=0;\n\nidle: if\n:: reserve?i; goto res; \n\n:: release?i; goto rel; \n\nfi;\nrel: if\n::  atomic {in_RT[i]==1;ok!0;in_RT[i] = 0;RT_count = RT_count-1;}  goto idle; \n\n:: in_RT[i]==0; goto error_st; \n\nfi;\nres: if\n::  atomic {RT_count>=2;no_grant!0;}  goto idle; \n\n::  atomic {RT_count<2;grant!0;RT_count = RT_count+1;in_RT[i] = 1;}  goto idle; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_0() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_0?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!0;granted = 0;}  goto wait_ok; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!0;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nwait_ok: if\n:: ok?0; goto finish; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_1() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_1?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!1;granted = 0;}  goto wait_ok; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!1;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nwait_ok: if\n:: ok?0; goto finish; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_2() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_2?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!2;granted = 0;}  goto wait_ok; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!2;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nwait_ok: if\n:: ok?0; goto finish; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_3() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_3?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!3;granted = 0;}  goto wait_ok; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!3;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nwait_ok: if\n:: ok?0; goto finish; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Token() { \nbyte i=0;\nbyte NRT_count=4;\nbyte next=0;\n\nstart: if\n:: i = 0; goto RT_phase; \n\nfi;\nRT_phase: if\n::  d_step {i<4 && in_RT[i]==0;i = i+1;}  goto RT_phase; \n\n::  atomic {i==0 && in_RT[i]==1;visit_0!1;}  goto RT_wait; \n\n::  atomic {i==1 && in_RT[i]==1;visit_1!1;}  goto RT_wait; \n\n::  atomic {i==2 && in_RT[i]==1;visit_2!1;}  goto RT_wait; \n\n::  atomic {i==3 && in_RT[i]==1;visit_3!1;}  goto RT_wait; \n\n:: i==4; goto NRT_phase; \n\nfi;\nRT_wait: if\n::  atomic {done?0;i = i+1;}  goto RT_phase; \n\nfi;\nNRT_phase: if\n::  atomic {NRT_count>0 && next==0;visit_0!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==1;visit_1!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==2;visit_2!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==3;visit_3!0;}  goto NRT_wait; \n\n:: NRT_count==0; goto cycle_end; \n\nfi;\nNRT_wait: if\n::  atomic {done?0;next = (next+1)%4;NRT_count = NRT_count-1;}  goto NRT_phase; \n\nfi;\ncycle_end: if\n:: NRT_count = 4-RT_count; goto start; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Software-based, real-time Ethernet protocol developed at\n    SUNY. Its purpose is to provide guaranteed bandwidth and deterministic,\n    periodic network access to multimedia applications over commodity Ethernet\n    hardware. It is a contention-free token bus protocol for the datalink layer\n    of the ISO protocol stack.\n\nParameters:\n\n\n\n\n\nAtomic propositions:\n, , , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte in_RT[7];\nbyte RT_count=0;\n\nchan reserve =[0] of {int};\nchan release =[0] of {int};\nchan grant =[0] of {int};\nchan no_grant =[0] of {int};\nchan done =[0] of {int};\nchan visit_0 =[0] of {int};\nchan visit_1 =[0] of {int};\nchan visit_2 =[0] of {int};\nchan visit_3 =[0] of {int};\nchan visit_4 =[0] of {int};\nchan visit_5 =[0] of {int};\nchan visit_6 =[0] of {int};\nchan ok =[0] of {int};\n\nactive proctype Bandwidth() { \nbyte i=0;\n\nidle: if\n:: reserve?i; goto res; \n\n:: release?i; goto rel; \n\nfi;\nrel: if\n::  atomic {in_RT[i]==1;ok!0;in_RT[i] = 0;RT_count = RT_count-1;}  goto idle; \n\n:: in_RT[i]==0; goto error_st; \n\nfi;\nres: if\n::  atomic {RT_count>=2;no_grant!0;}  goto idle; \n\n::  atomic {RT_count<2;grant!0;RT_count = RT_count+1;in_RT[i] = 1;}  goto idle; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_0() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_0?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!0;granted = 0;}  goto wait_ok; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!0;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nwait_ok: if\n:: ok?0; goto finish; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_1() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_1?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!1;granted = 0;}  goto wait_ok; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!1;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nwait_ok: if\n:: ok?0; goto finish; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_2() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_2?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!2;granted = 0;}  goto wait_ok; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!2;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nwait_ok: if\n:: ok?0; goto finish; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_3() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_3?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!3;granted = 0;}  goto wait_ok; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!3;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nwait_ok: if\n:: ok?0; goto finish; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_4() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_4?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!4;granted = 0;}  goto wait_ok; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!4;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nwait_ok: if\n:: ok?0; goto finish; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_5() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_5?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!5;granted = 0;}  goto wait_ok; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!5;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nwait_ok: if\n:: ok?0; goto finish; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_6() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_6?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!6;granted = 0;}  goto wait_ok; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!6;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nwait_ok: if\n:: ok?0; goto finish; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Token() { \nbyte i=0;\nbyte NRT_count=3;\nbyte next=0;\n\nstart: if\n:: i = 0; goto RT_phase; \n\nfi;\nRT_phase: if\n::  d_step {i<7 && in_RT[i]==0;i = i+1;}  goto RT_phase; \n\n::  atomic {i==0 && in_RT[i]==1;visit_0!1;}  goto RT_wait; \n\n::  atomic {i==1 && in_RT[i]==1;visit_1!1;}  goto RT_wait; \n\n::  atomic {i==2 && in_RT[i]==1;visit_2!1;}  goto RT_wait; \n\n::  atomic {i==3 && in_RT[i]==1;visit_3!1;}  goto RT_wait; \n\n::  atomic {i==4 && in_RT[i]==1;visit_4!1;}  goto RT_wait; \n\n::  atomic {i==5 && in_RT[i]==1;visit_5!1;}  goto RT_wait; \n\n::  atomic {i==6 && in_RT[i]==1;visit_6!1;}  goto RT_wait; \n\n:: i==7; goto NRT_phase; \n\nfi;\nRT_wait: if\n::  atomic {done?0;i = i+1;}  goto RT_phase; \n\nfi;\nNRT_phase: if\n::  atomic {NRT_count>0 && next==0;visit_0!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==1;visit_1!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==2;visit_2!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==3;visit_3!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==4;visit_4!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==5;visit_5!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==6;visit_6!0;}  goto NRT_wait; \n\n:: NRT_count==0; goto cycle_end; \n\nfi;\nNRT_wait: if\n::  atomic {done?0;next = (next+1)%7;NRT_count = NRT_count-1;}  goto NRT_phase; \n\nfi;\ncycle_end: if\n:: NRT_count = 3-RT_count; goto start; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Software-based, real-time Ethernet protocol developed at\n    SUNY. Its purpose is to provide guaranteed bandwidth and deterministic,\n    periodic network access to multimedia applications over commodity Ethernet\n    hardware. It is a contention-free token bus protocol for the datalink layer\n    of the ISO protocol stack.\n\nParameters:\n\n\n\n\n\nAtomic propositions:\n, , , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte in_RT[9];\nbyte RT_count=0;\n\nchan reserve =[0] of {int};\nchan release =[0] of {int};\nchan grant =[0] of {int};\nchan no_grant =[0] of {int};\nchan done =[0] of {int};\nchan visit_0 =[0] of {int};\nchan visit_1 =[0] of {int};\nchan visit_2 =[0] of {int};\nchan visit_3 =[0] of {int};\nchan visit_4 =[0] of {int};\nchan visit_5 =[0] of {int};\nchan visit_6 =[0] of {int};\nchan visit_7 =[0] of {int};\nchan visit_8 =[0] of {int};\n\nactive proctype Bandwidth() { \nbyte i=0;\n\nidle: if\n:: reserve?i; goto res; \n\n:: release?i; goto rel; \n\nfi;\nrel: if\n::  d_step {in_RT[i]==1;in_RT[i] = 0;RT_count = RT_count-1;}  goto idle; \n\n:: in_RT[i]==0; goto error_st; \n\nfi;\nres: if\n::  atomic {RT_count>=2;no_grant!0;}  goto idle; \n\n::  atomic {RT_count<2;grant!0;RT_count = RT_count+1;in_RT[i] = 1;}  goto idle; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_0() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_0?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!0;granted = 0;}  goto finish; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!0;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_1() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_1?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!1;granted = 0;}  goto finish; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!1;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_2() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_2?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!2;granted = 0;}  goto finish; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!2;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_3() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_3?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!3;granted = 0;}  goto finish; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!3;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_4() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_4?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!4;granted = 0;}  goto finish; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!4;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_5() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_5?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!5;granted = 0;}  goto finish; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!5;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_6() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_6?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!6;granted = 0;}  goto finish; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!6;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_7() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_7?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!7;granted = 0;}  goto finish; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!7;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_8() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_8?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!8;granted = 0;}  goto finish; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!8;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Token() { \nbyte i=0;\nbyte NRT_count=5;\nbyte next=0;\n\nstart: if\n:: i = 0; goto RT_phase; \n\nfi;\nRT_phase: if\n::  d_step {i<9 && in_RT[i]==0;i = i+1;}  goto RT_phase; \n\n::  atomic {i==0 && in_RT[i]==1;visit_0!1;}  goto RT_wait; \n\n::  atomic {i==1 && in_RT[i]==1;visit_1!1;}  goto RT_wait; \n\n::  atomic {i==2 && in_RT[i]==1;visit_2!1;}  goto RT_wait; \n\n::  atomic {i==3 && in_RT[i]==1;visit_3!1;}  goto RT_wait; \n\n::  atomic {i==4 && in_RT[i]==1;visit_4!1;}  goto RT_wait; \n\n::  atomic {i==5 && in_RT[i]==1;visit_5!1;}  goto RT_wait; \n\n::  atomic {i==6 && in_RT[i]==1;visit_6!1;}  goto RT_wait; \n\n::  atomic {i==7 && in_RT[i]==1;visit_7!1;}  goto RT_wait; \n\n::  atomic {i==8 && in_RT[i]==1;visit_8!1;}  goto RT_wait; \n\n:: i==9; goto NRT_phase; \n\nfi;\nRT_wait: if\n::  atomic {done?0;i = i+1;}  goto RT_phase; \n\nfi;\nNRT_phase: if\n::  atomic {NRT_count>0 && next==0;visit_0!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==1;visit_1!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==2;visit_2!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==3;visit_3!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==4;visit_4!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==5;visit_5!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==6;visit_6!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==7;visit_7!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==8;visit_8!0;}  goto NRT_wait; \n\n:: NRT_count==0; goto cycle_end; \n\nfi;\nNRT_wait: if\n::  atomic {done?0;next = (next+1)%9;NRT_count = NRT_count-1;}  goto NRT_phase; \n\nfi;\ncycle_end: if\n:: NRT_count = 5-RT_count; goto start; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Software-based, real-time Ethernet protocol developed at\n    SUNY. Its purpose is to provide guaranteed bandwidth and deterministic,\n    periodic network access to multimedia applications over commodity Ethernet\n    hardware. It is a contention-free token bus protocol for the datalink layer\n    of the ISO protocol stack.\n\nParameters:\n\n\n\n\n\nAtomic propositions:\n, , , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte in_RT[10];\nbyte RT_count=0;\n\nchan reserve =[0] of {int};\nchan release =[0] of {int};\nchan grant =[0] of {int};\nchan no_grant =[0] of {int};\nchan done =[0] of {int};\nchan visit_0 =[0] of {int};\nchan visit_1 =[0] of {int};\nchan visit_2 =[0] of {int};\nchan visit_3 =[0] of {int};\nchan visit_4 =[0] of {int};\nchan visit_5 =[0] of {int};\nchan visit_6 =[0] of {int};\nchan visit_7 =[0] of {int};\nchan visit_8 =[0] of {int};\nchan visit_9 =[0] of {int};\nchan ok =[0] of {int};\n\nactive proctype Bandwidth() { \nbyte i=0;\n\nidle: if\n:: reserve?i; goto res; \n\n:: release?i; goto rel; \n\nfi;\nrel: if\n::  atomic {in_RT[i]==1;ok!0;in_RT[i] = 0;RT_count = RT_count-1;}  goto idle; \n\n:: in_RT[i]==0; goto error_st; \n\nfi;\nres: if\n::  atomic {RT_count>=2;no_grant!0;}  goto idle; \n\n::  atomic {RT_count<2;grant!0;RT_count = RT_count+1;in_RT[i] = 1;}  goto idle; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_0() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_0?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!0;granted = 0;}  goto wait_ok; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!0;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nwait_ok: if\n:: ok?0; goto finish; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_1() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_1?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!1;granted = 0;}  goto wait_ok; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!1;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nwait_ok: if\n:: ok?0; goto finish; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_2() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_2?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!2;granted = 0;}  goto wait_ok; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!2;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nwait_ok: if\n:: ok?0; goto finish; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_3() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_3?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!3;granted = 0;}  goto wait_ok; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!3;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nwait_ok: if\n:: ok?0; goto finish; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_4() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_4?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!4;granted = 0;}  goto wait_ok; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!4;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nwait_ok: if\n:: ok?0; goto finish; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_5() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_5?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!5;granted = 0;}  goto wait_ok; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!5;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nwait_ok: if\n:: ok?0; goto finish; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_6() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_6?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!6;granted = 0;}  goto wait_ok; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!6;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nwait_ok: if\n:: ok?0; goto finish; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_7() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_7?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!7;granted = 0;}  goto wait_ok; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!7;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nwait_ok: if\n:: ok?0; goto finish; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_8() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_8?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!8;granted = 0;}  goto wait_ok; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!8;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nwait_ok: if\n:: ok?0; goto finish; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_9() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_9?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!9;granted = 0;}  goto wait_ok; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!9;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nwait_ok: if\n:: ok?0; goto finish; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Token() { \nbyte i=0;\nbyte NRT_count=4;\nbyte next=0;\n\nstart: if\n:: i = 0; goto RT_phase; \n\nfi;\nRT_phase: if\n::  d_step {i<10 && in_RT[i]==0;i = i+1;}  goto RT_phase; \n\n::  atomic {i==0 && in_RT[i]==1;visit_0!1;}  goto RT_wait; \n\n::  atomic {i==1 && in_RT[i]==1;visit_1!1;}  goto RT_wait; \n\n::  atomic {i==2 && in_RT[i]==1;visit_2!1;}  goto RT_wait; \n\n::  atomic {i==3 && in_RT[i]==1;visit_3!1;}  goto RT_wait; \n\n::  atomic {i==4 && in_RT[i]==1;visit_4!1;}  goto RT_wait; \n\n::  atomic {i==5 && in_RT[i]==1;visit_5!1;}  goto RT_wait; \n\n::  atomic {i==6 && in_RT[i]==1;visit_6!1;}  goto RT_wait; \n\n::  atomic {i==7 && in_RT[i]==1;visit_7!1;}  goto RT_wait; \n\n::  atomic {i==8 && in_RT[i]==1;visit_8!1;}  goto RT_wait; \n\n::  atomic {i==9 && in_RT[i]==1;visit_9!1;}  goto RT_wait; \n\n:: i==10; goto NRT_phase; \n\nfi;\nRT_wait: if\n::  atomic {done?0;i = i+1;}  goto RT_phase; \n\nfi;\nNRT_phase: if\n::  atomic {NRT_count>0 && next==0;visit_0!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==1;visit_1!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==2;visit_2!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==3;visit_3!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==4;visit_4!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==5;visit_5!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==6;visit_6!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==7;visit_7!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==8;visit_8!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==9;visit_9!0;}  goto NRT_wait; \n\n:: NRT_count==0; goto cycle_end; \n\nfi;\nNRT_wait: if\n::  atomic {done?0;next = (next+1)%10;NRT_count = NRT_count-1;}  goto NRT_phase; \n\nfi;\ncycle_end: if\n:: NRT_count = 4-RT_count; goto start; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Software-based, real-time Ethernet protocol developed at\n    SUNY. Its purpose is to provide guaranteed bandwidth and deterministic,\n    periodic network access to multimedia applications over commodity Ethernet\n    hardware. It is a contention-free token bus protocol for the datalink layer\n    of the ISO protocol stack.\n\nParameters:\n\n\n\n\n\nAtomic propositions:\n, , , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte in_RT[11];\nbyte RT_count=0;\n\nchan reserve =[0] of {int};\nchan release =[0] of {int};\nchan grant =[0] of {int};\nchan no_grant =[0] of {int};\nchan done =[0] of {int};\nchan visit_0 =[0] of {int};\nchan visit_1 =[0] of {int};\nchan visit_2 =[0] of {int};\nchan visit_3 =[0] of {int};\nchan visit_4 =[0] of {int};\nchan visit_5 =[0] of {int};\nchan visit_6 =[0] of {int};\nchan visit_7 =[0] of {int};\nchan visit_8 =[0] of {int};\nchan visit_9 =[0] of {int};\nchan visit_10 =[0] of {int};\n\nactive proctype Bandwidth() { \nbyte i=0;\n\nidle: if\n:: reserve?i; goto res; \n\n:: release?i; goto rel; \n\nfi;\nrel: if\n::  d_step {in_RT[i]==1;in_RT[i] = 0;RT_count = RT_count-1;}  goto idle; \n\n:: in_RT[i]==0; goto error_st; \n\nfi;\nres: if\n::  atomic {RT_count>=2;no_grant!0;}  goto idle; \n\n::  atomic {RT_count<2;grant!0;RT_count = RT_count+1;in_RT[i] = 1;}  goto idle; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_0() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_0?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!0;granted = 0;}  goto finish; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!0;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_1() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_1?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!1;granted = 0;}  goto finish; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!1;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_2() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_2?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!2;granted = 0;}  goto finish; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!2;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_3() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_3?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!3;granted = 0;}  goto finish; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!3;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_4() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_4?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!4;granted = 0;}  goto finish; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!4;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_5() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_5?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!5;granted = 0;}  goto finish; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!5;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_6() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_6?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!6;granted = 0;}  goto finish; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!6;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_7() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_7?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!7;granted = 0;}  goto finish; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!7;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_8() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_8?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!8;granted = 0;}  goto finish; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!8;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_9() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_9?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!9;granted = 0;}  goto finish; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!9;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_10() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_10?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!10;granted = 0;}  goto finish; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!10;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Token() { \nbyte i=0;\nbyte NRT_count=5;\nbyte next=0;\n\nstart: if\n:: i = 0; goto RT_phase; \n\nfi;\nRT_phase: if\n::  d_step {i<11 && in_RT[i]==0;i = i+1;}  goto RT_phase; \n\n::  atomic {i==0 && in_RT[i]==1;visit_0!1;}  goto RT_wait; \n\n::  atomic {i==1 && in_RT[i]==1;visit_1!1;}  goto RT_wait; \n\n::  atomic {i==2 && in_RT[i]==1;visit_2!1;}  goto RT_wait; \n\n::  atomic {i==3 && in_RT[i]==1;visit_3!1;}  goto RT_wait; \n\n::  atomic {i==4 && in_RT[i]==1;visit_4!1;}  goto RT_wait; \n\n::  atomic {i==5 && in_RT[i]==1;visit_5!1;}  goto RT_wait; \n\n::  atomic {i==6 && in_RT[i]==1;visit_6!1;}  goto RT_wait; \n\n::  atomic {i==7 && in_RT[i]==1;visit_7!1;}  goto RT_wait; \n\n::  atomic {i==8 && in_RT[i]==1;visit_8!1;}  goto RT_wait; \n\n::  atomic {i==9 && in_RT[i]==1;visit_9!1;}  goto RT_wait; \n\n::  atomic {i==10 && in_RT[i]==1;visit_10!1;}  goto RT_wait; \n\n:: i==11; goto NRT_phase; \n\nfi;\nRT_wait: if\n::  atomic {done?0;i = i+1;}  goto RT_phase; \n\nfi;\nNRT_phase: if\n::  atomic {NRT_count>0 && next==0;visit_0!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==1;visit_1!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==2;visit_2!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==3;visit_3!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==4;visit_4!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==5;visit_5!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==6;visit_6!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==7;visit_7!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==8;visit_8!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==9;visit_9!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==10;visit_10!0;}  goto NRT_wait; \n\n:: NRT_count==0; goto cycle_end; \n\nfi;\nNRT_wait: if\n::  atomic {done?0;next = (next+1)%11;NRT_count = NRT_count-1;}  goto NRT_phase; \n\nfi;\ncycle_end: if\n:: NRT_count = 5-RT_count; goto start; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Software-based, real-time Ethernet protocol developed at\n    SUNY. Its purpose is to provide guaranteed bandwidth and deterministic,\n    periodic network access to multimedia applications over commodity Ethernet\n    hardware. It is a contention-free token bus protocol for the datalink layer\n    of the ISO protocol stack.\n\nParameters:\n\n\n\n\n\nAtomic propositions:\n, , , , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte in_RT[12];\nbyte RT_count=0;\n\nchan reserve =[0] of {int};\nchan release =[0] of {int};\nchan grant =[0] of {int};\nchan no_grant =[0] of {int};\nchan done =[0] of {int};\nchan visit_0 =[0] of {int};\nchan visit_1 =[0] of {int};\nchan visit_2 =[0] of {int};\nchan visit_3 =[0] of {int};\nchan visit_4 =[0] of {int};\nchan visit_5 =[0] of {int};\nchan visit_6 =[0] of {int};\nchan visit_7 =[0] of {int};\nchan visit_8 =[0] of {int};\nchan visit_9 =[0] of {int};\nchan visit_10 =[0] of {int};\nchan visit_11 =[0] of {int};\nchan ok =[0] of {int};\n\nactive proctype Bandwidth() { \nbyte i=0;\n\nidle: if\n:: reserve?i; goto res; \n\n:: release?i; goto rel; \n\nfi;\nrel: if\n::  atomic {in_RT[i]==1;ok!0;in_RT[i] = 0;RT_count = RT_count-1;}  goto idle; \n\n:: in_RT[i]==0; goto error_st; \n\nfi;\nres: if\n::  atomic {RT_count>=2;no_grant!0;}  goto idle; \n\n::  atomic {RT_count<2;grant!0;RT_count = RT_count+1;in_RT[i] = 1;}  goto idle; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_0() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_0?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!0;granted = 0;}  goto wait_ok; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!0;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nwait_ok: if\n:: ok?0; goto finish; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_1() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_1?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!1;granted = 0;}  goto wait_ok; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!1;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nwait_ok: if\n:: ok?0; goto finish; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_2() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_2?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!2;granted = 0;}  goto wait_ok; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!2;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nwait_ok: if\n:: ok?0; goto finish; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_3() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_3?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!3;granted = 0;}  goto wait_ok; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!3;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nwait_ok: if\n:: ok?0; goto finish; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_4() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_4?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!4;granted = 0;}  goto wait_ok; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!4;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nwait_ok: if\n:: ok?0; goto finish; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_5() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_5?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!5;granted = 0;}  goto wait_ok; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!5;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nwait_ok: if\n:: ok?0; goto finish; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_6() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_6?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!6;granted = 0;}  goto wait_ok; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!6;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nwait_ok: if\n:: ok?0; goto finish; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_7() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_7?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!7;granted = 0;}  goto wait_ok; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!7;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nwait_ok: if\n:: ok?0; goto finish; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_8() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_8?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!8;granted = 0;}  goto wait_ok; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!8;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nwait_ok: if\n:: ok?0; goto finish; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_9() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_9?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!9;granted = 0;}  goto wait_ok; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!9;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nwait_ok: if\n:: ok?0; goto finish; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_10() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_10?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!10;granted = 0;}  goto wait_ok; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!10;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nwait_ok: if\n:: ok?0; goto finish; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Node_11() { \nbyte rt=0;\nbyte granted=0;\n\nidle: if\n:: visit_11?rt; goto start; \n\nfi;\nstart: if\n:: rt==1; goto RT_action; \n\n:: rt==0; goto NRT_action; \n\nfi;\nRT_action: if\n:: granted==0; goto error_st; \n\n::  goto finish; \n\n::  atomic {release!11;granted = 0;}  goto wait_ok; \n\nfi;\nNRT_action: if\n::  goto finish; \n\n::  atomic {granted==0;reserve!11;}  goto want_RT; \n\nfi;\nwant_RT: if\n:: grant?0; goto reserved; \n\n:: no_grant?0; goto finish; \n\nfi;\nreserved: if\n:: granted = 1; goto finish; \n\nfi;\nfinish: if\n:: done!0; goto idle; \n\nfi;\nwait_ok: if\n:: ok?0; goto finish; \n\nfi;\nerror_st: \n false; }\n\nactive proctype Token() { \nbyte i=0;\nbyte NRT_count=6;\nbyte next=0;\n\nstart: if\n:: i = 0; goto RT_phase; \n\nfi;\nRT_phase: if\n::  d_step {i<12 && in_RT[i]==0;i = i+1;}  goto RT_phase; \n\n::  atomic {i==0 && in_RT[i]==1;visit_0!1;}  goto RT_wait; \n\n::  atomic {i==1 && in_RT[i]==1;visit_1!1;}  goto RT_wait; \n\n::  atomic {i==2 && in_RT[i]==1;visit_2!1;}  goto RT_wait; \n\n::  atomic {i==3 && in_RT[i]==1;visit_3!1;}  goto RT_wait; \n\n::  atomic {i==4 && in_RT[i]==1;visit_4!1;}  goto RT_wait; \n\n::  atomic {i==5 && in_RT[i]==1;visit_5!1;}  goto RT_wait; \n\n::  atomic {i==6 && in_RT[i]==1;visit_6!1;}  goto RT_wait; \n\n::  atomic {i==7 && in_RT[i]==1;visit_7!1;}  goto RT_wait; \n\n::  atomic {i==8 && in_RT[i]==1;visit_8!1;}  goto RT_wait; \n\n::  atomic {i==9 && in_RT[i]==1;visit_9!1;}  goto RT_wait; \n\n::  atomic {i==10 && in_RT[i]==1;visit_10!1;}  goto RT_wait; \n\n::  atomic {i==11 && in_RT[i]==1;visit_11!1;}  goto RT_wait; \n\n:: i==12; goto NRT_phase; \n\nfi;\nRT_wait: if\n::  atomic {done?0;i = i+1;}  goto RT_phase; \n\nfi;\nNRT_phase: if\n::  atomic {NRT_count>0 && next==0;visit_0!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==1;visit_1!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==2;visit_2!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==3;visit_3!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==4;visit_4!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==5;visit_5!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==6;visit_6!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==7;visit_7!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==8;visit_8!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==9;visit_9!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==10;visit_10!0;}  goto NRT_wait; \n\n::  atomic {NRT_count>0 && next==11;visit_11!0;}  goto NRT_wait; \n\n:: NRT_count==0; goto cycle_end; \n\nfi;\nNRT_wait: if\n::  atomic {done?0;next = (next+1)%12;NRT_count = NRT_count-1;}  goto NRT_phase; \n\nfi;\ncycle_end: if\n:: NRT_count = 6-RT_count; goto start; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "\"Rush hour\" is a sliding block puzzles usually played on\n6x6 game plan. The goal of the puzzle is to move cars in such a way that a\ndistinguished red car can escape the trafic jam.\n\nParameters:\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte A[36];\n\n\ninit { \n d_step { \nA[0] =1; A[1] =1; A[2] =1; A[3] =1; A[4] =0; A[5] =0; A[6] =1; A[7] =0; A[8] =1; A[9] =1; A[10] =0; A[11] =0; A[12] =1; A[13] =1; A[14] =1; A[15] =1; A[16] =0; A[17] =0; A[18] =1; A[19] =1; A[20] =1; A[21] =1; A[22] =0; A[23] =0; A[24] =0; A[25] =0; A[26] =0; A[27] =0; A[28] =0; A[29] =0; A[30] =0; A[31] =0; A[32] =0; A[33] =1; A[34] =1; A[35] =1; }\natomic { \nrun Car_hor_1();\nrun Red_car();\nrun Car_hor_3();\nrun Car_hor_4();\nrun Car_ver_1();\nrun Car_ver_2();\nrun Car_ver_3();\n} }\n\nproctype Car_hor_1() { \nbyte x=0;\nbyte y=0;\nbyte lngth=2;\n\nq: if\n::  d_step {x>0 && A[((y)*6+x-1)]==0;A[((y)*6+x+lngth-1)] = 0;A[((y)*6+x-1)] = 1;x = x-1;}  goto q; \n\n::  d_step {x+lngth<6 && A[((y)*6+x+lngth)]==0;A[((y)*6+x)] = 0;A[((y)*6+x+lngth)] = 1;x = x+1;}  goto q; \n\nfi;\n}\n\nproctype Red_car() { \nbyte x=1;\nbyte y=2;\nbyte lngth=2;\n\nq: if\n::  d_step {x>0 && A[((y)*6+x-1)]==0;A[((y)*6+x+lngth-1)] = 0;A[((y)*6+x-1)] = 1;x = x-1;}  goto q; \n\n::  d_step {x+lngth<6 && A[((y)*6+x+lngth)]==0;A[((y)*6+x)] = 0;A[((y)*6+x+lngth)] = 1;x = x+1;}  goto q; \n\n:: x==4; goto out; \n\nfi;\nout: \n false; }\n\nproctype Car_hor_3() { \nbyte x=1;\nbyte y=3;\nbyte lngth=3;\n\nq: if\n::  d_step {x>0 && A[((y)*6+x-1)]==0;A[((y)*6+x+lngth-1)] = 0;A[((y)*6+x-1)] = 1;x = x-1;}  goto q; \n\n::  d_step {x+lngth<6 && A[((y)*6+x+lngth)]==0;A[((y)*6+x)] = 0;A[((y)*6+x+lngth)] = 1;x = x+1;}  goto q; \n\nfi;\n}\n\nproctype Car_hor_4() { \nbyte x=3;\nbyte y=5;\nbyte lngth=3;\n\nq: if\n::  d_step {x>0 && A[((y)*6+x-1)]==0;A[((y)*6+x+lngth-1)] = 0;A[((y)*6+x-1)] = 1;x = x-1;}  goto q; \n\n::  d_step {x+lngth<6 && A[((y)*6+x+lngth)]==0;A[((y)*6+x)] = 0;A[((y)*6+x+lngth)] = 1;x = x+1;}  goto q; \n\nfi;\n}\n\nproctype Car_ver_1() { \nbyte x=0;\nbyte y=1;\nbyte lngth=3;\n\nq: if\n::  d_step {y>0 && A[((y-1)*6+x)]==0;A[((y+lngth-1)*6+x)] = 0;A[((y-1)*6+x)] = 1;y = y-1;}  goto q; \n\n::  d_step {y+lngth<6 && A[((y+lngth)*6+x)]==0;A[((y)*6+x)] = 0;A[((y+lngth)*6+x)] = 1;y = y+1;}  goto q; \n\nfi;\n}\n\nproctype Car_ver_2() { \nbyte x=2;\nbyte y=0;\nbyte lngth=2;\n\nq: if\n::  d_step {y>0 && A[((y-1)*6+x)]==0;A[((y+lngth-1)*6+x)] = 0;A[((y-1)*6+x)] = 1;y = y-1;}  goto q; \n\n::  d_step {y+lngth<6 && A[((y+lngth)*6+x)]==0;A[((y)*6+x)] = 0;A[((y+lngth)*6+x)] = 1;y = y+1;}  goto q; \n\nfi;\n}\n\nproctype Car_ver_3() { \nbyte x=3;\nbyte y=0;\nbyte lngth=3;\n\nq: if\n::  d_step {y>0 && A[((y-1)*6+x)]==0;A[((y+lngth-1)*6+x)] = 0;A[((y-1)*6+x)] = 1;y = y-1;}  goto q; \n\n::  d_step {y+lngth<6 && A[((y+lngth)*6+x)]==0;A[((y)*6+x)] = 0;A[((y+lngth)*6+x)] = 1;y = y+1;}  goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "\"Rush hour\" is a sliding block puzzles usually played on\n6x6 game plan. The goal of the puzzle is to move cars in such a way that a\ndistinguished red car can escape the trafic jam.\n\nParameters:\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte A[36];\n\n\ninit { \n d_step { \nA[0] =1; A[1] =1; A[2] =1; A[3] =1; A[4] =0; A[5] =0; A[6] =1; A[7] =0; A[8] =0; A[9] =1; A[10] =0; A[11] =0; A[12] =1; A[13] =1; A[14] =1; A[15] =1; A[16] =0; A[17] =0; A[18] =0; A[19] =0; A[20] =1; A[21] =1; A[22] =1; A[23] =1; A[24] =0; A[25] =0; A[26] =1; A[27] =0; A[28] =0; A[29] =1; A[30] =0; A[31] =0; A[32] =1; A[33] =1; A[34] =1; A[35] =1; }\natomic { \nrun Red_car();\nrun Car_hor_1();\nrun Car_hor_2();\nrun Car_hor_3();\nrun Car_ver_1();\nrun Car_ver_2();\nrun Car_ver_3();\nrun Car_ver_4();\n} }\n\nproctype Red_car() { \nbyte x=1;\nbyte y=2;\nbyte lngth=2;\n\nq: if\n::  d_step {x>0 && A[((y)*6+x-1)]==0;A[((y)*6+x+lngth-1)] = 0;A[((y)*6+x-1)] = 1;x = x-1;}  goto q; \n\n::  d_step {x+lngth<6 && A[((y)*6+x+lngth)]==0;A[((y)*6+x)] = 0;A[((y)*6+x+lngth)] = 1;x = x+1;}  goto q; \n\n:: x==4; goto out; \n\nfi;\nout: \n false; }\n\nproctype Car_hor_1() { \nbyte x=1;\nbyte y=0;\nbyte lngth=2;\n\nq: if\n::  d_step {x>0 && A[((y)*6+x-1)]==0;A[((y)*6+x+lngth-1)] = 0;A[((y)*6+x-1)] = 1;x = x-1;}  goto q; \n\n::  d_step {x+lngth<6 && A[((y)*6+x+lngth)]==0;A[((y)*6+x)] = 0;A[((y)*6+x+lngth)] = 1;x = x+1;}  goto q; \n\nfi;\n}\n\nproctype Car_hor_2() { \nbyte x=3;\nbyte y=3;\nbyte lngth=3;\n\nq: if\n::  d_step {x>0 && A[((y)*6+x-1)]==0;A[((y)*6+x+lngth-1)] = 0;A[((y)*6+x-1)] = 1;x = x-1;}  goto q; \n\n::  d_step {x+lngth<6 && A[((y)*6+x+lngth)]==0;A[((y)*6+x)] = 0;A[((y)*6+x+lngth)] = 1;x = x+1;}  goto q; \n\nfi;\n}\n\nproctype Car_hor_3() { \nbyte x=2;\nbyte y=5;\nbyte lngth=3;\n\nq: if\n::  d_step {x>0 && A[((y)*6+x-1)]==0;A[((y)*6+x+lngth-1)] = 0;A[((y)*6+x-1)] = 1;x = x-1;}  goto q; \n\n::  d_step {x+lngth<6 && A[((y)*6+x+lngth)]==0;A[((y)*6+x)] = 0;A[((y)*6+x+lngth)] = 1;x = x+1;}  goto q; \n\nfi;\n}\n\nproctype Car_ver_1() { \nbyte x=0;\nbyte y=0;\nbyte lngth=3;\n\nq: if\n::  d_step {y>0 && A[((y-1)*6+x)]==0;A[((y+lngth-1)*6+x)] = 0;A[((y-1)*6+x)] = 1;y = y-1;}  goto q; \n\n::  d_step {y+lngth<6 && A[((y+lngth)*6+x)]==0;A[((y)*6+x)] = 0;A[((y+lngth)*6+x)] = 1;y = y+1;}  goto q; \n\nfi;\n}\n\nproctype Car_ver_2() { \nbyte x=2;\nbyte y=3;\nbyte lngth=2;\n\nq: if\n::  d_step {y>0 && A[((y-1)*6+x)]==0;A[((y+lngth-1)*6+x)] = 0;A[((y-1)*6+x)] = 1;y = y-1;}  goto q; \n\n::  d_step {y+lngth<6 && A[((y+lngth)*6+x)]==0;A[((y)*6+x)] = 0;A[((y+lngth)*6+x)] = 1;y = y+1;}  goto q; \n\nfi;\n}\n\nproctype Car_ver_3() { \nbyte x=3;\nbyte y=0;\nbyte lngth=3;\n\nq: if\n::  d_step {y>0 && A[((y-1)*6+x)]==0;A[((y+lngth-1)*6+x)] = 0;A[((y-1)*6+x)] = 1;y = y-1;}  goto q; \n\n::  d_step {y+lngth<6 && A[((y+lngth)*6+x)]==0;A[((y)*6+x)] = 0;A[((y+lngth)*6+x)] = 1;y = y+1;}  goto q; \n\nfi;\n}\n\nproctype Car_ver_4() { \nbyte x=5;\nbyte y=4;\nbyte lngth=2;\n\nq: if\n::  d_step {y>0 && A[((y-1)*6+x)]==0;A[((y+lngth-1)*6+x)] = 0;A[((y-1)*6+x)] = 1;y = y-1;}  goto q; \n\n::  d_step {y+lngth<6 && A[((y+lngth)*6+x)]==0;A[((y)*6+x)] = 0;A[((y+lngth)*6+x)] = 1;y = y+1;}  goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "\"Rush hour\" is a sliding block puzzles usually played on\n6x6 game plan. The goal of the puzzle is to move cars in such a way that a\ndistinguished red car can escape the trafic jam.\n\nParameters:\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte A[49];\n\n\ninit { \n d_step { \nA[0] =0; A[1] =0; A[2] =1; A[3] =0; A[4] =1; A[5] =1; A[6] =0; A[7] =1; A[8] =0; A[9] =1; A[10] =1; A[11] =1; A[12] =1; A[13] =1; A[14] =1; A[15] =1; A[16] =1; A[17] =1; A[18] =1; A[19] =1; A[20] =1; A[21] =0; A[22] =0; A[23] =0; A[24] =1; A[25] =0; A[26] =1; A[27] =0; A[28] =1; A[29] =1; A[30] =1; A[31] =0; A[32] =1; A[33] =1; A[34] =0; A[35] =1; A[36] =1; A[37] =1; A[38] =1; A[39] =1; A[40] =0; A[41] =1; A[42] =0; A[43] =0; A[44] =0; A[45] =0; A[46] =0; A[47] =0; A[48] =1; }\natomic { \nrun Red_car();\nrun Car_hor_1();\nrun Car_hor_2();\nrun Car_hor_3();\nrun Car_hor_4();\nrun Car_ver_1();\nrun Car_ver_2();\nrun Car_ver_3();\nrun Car_ver_4();\nrun Car_ver_5();\nrun Car_ver_6();\nrun Car_ver_7();\nrun Car_ver_8();\n} }\n\nproctype Red_car() { \nbyte x=1;\nbyte y=2;\nbyte lngth=2;\n\nq: if\n::  d_step {x>0 && A[((y)*7+x-1)]==0;A[((y)*7+x+lngth-1)] = 0;A[((y)*7+x-1)] = 1;x = x-1;}  goto q; \n\n::  d_step {x+lngth<7 && A[((y)*7+x+lngth)]==0;A[((y)*7+x)] = 0;A[((y)*7+x+lngth)] = 1;x = x+1;}  goto q; \n\n:: x==5; goto out; \n\nfi;\nout: \n false; }\n\nproctype Car_hor_1() { \nbyte x=4;\nbyte y=0;\nbyte lngth=2;\n\nq: if\n::  d_step {x>0 && A[((y)*7+x-1)]==0;A[((y)*7+x+lngth-1)] = 0;A[((y)*7+x-1)] = 1;x = x-1;}  goto q; \n\n::  d_step {x+lngth<7 && A[((y)*7+x+lngth)]==0;A[((y)*7+x)] = 0;A[((y)*7+x+lngth)] = 1;x = x+1;}  goto q; \n\nfi;\n}\n\nproctype Car_hor_2() { \nbyte x=1;\nbyte y=4;\nbyte lngth=2;\n\nq: if\n::  d_step {x>0 && A[((y)*7+x-1)]==0;A[((y)*7+x+lngth-1)] = 0;A[((y)*7+x-1)] = 1;x = x-1;}  goto q; \n\n::  d_step {x+lngth<7 && A[((y)*7+x+lngth)]==0;A[((y)*7+x)] = 0;A[((y)*7+x+lngth)] = 1;x = x+1;}  goto q; \n\nfi;\n}\n\nproctype Car_hor_3() { \nbyte x=4;\nbyte y=4;\nbyte lngth=2;\n\nq: if\n::  d_step {x>0 && A[((y)*7+x-1)]==0;A[((y)*7+x+lngth-1)] = 0;A[((y)*7+x-1)] = 1;x = x-1;}  goto q; \n\n::  d_step {x+lngth<7 && A[((y)*7+x+lngth)]==0;A[((y)*7+x)] = 0;A[((y)*7+x+lngth)] = 1;x = x+1;}  goto q; \n\nfi;\n}\n\nproctype Car_hor_4() { \nbyte x=1;\nbyte y=5;\nbyte lngth=4;\n\nq: if\n::  d_step {x>0 && A[((y)*7+x-1)]==0;A[((y)*7+x+lngth-1)] = 0;A[((y)*7+x-1)] = 1;x = x-1;}  goto q; \n\n::  d_step {x+lngth<7 && A[((y)*7+x+lngth)]==0;A[((y)*7+x)] = 0;A[((y)*7+x+lngth)] = 1;x = x+1;}  goto q; \n\nfi;\n}\n\nproctype Car_ver_1() { \nbyte x=0;\nbyte y=1;\nbyte lngth=2;\n\nq: if\n::  d_step {y>0 && A[((y-1)*7+x)]==0;A[((y+lngth-1)*7+x)] = 0;A[((y-1)*7+x)] = 1;y = y-1;}  goto q; \n\n::  d_step {y+lngth<7 && A[((y+lngth)*7+x)]==0;A[((y)*7+x)] = 0;A[((y+lngth)*7+x)] = 1;y = y+1;}  goto q; \n\nfi;\n}\n\nproctype Car_ver_2() { \nbyte x=0;\nbyte y=4;\nbyte lngth=2;\n\nq: if\n::  d_step {y>0 && A[((y-1)*7+x)]==0;A[((y+lngth-1)*7+x)] = 0;A[((y-1)*7+x)] = 1;y = y-1;}  goto q; \n\n::  d_step {y+lngth<7 && A[((y+lngth)*7+x)]==0;A[((y)*7+x)] = 0;A[((y+lngth)*7+x)] = 1;y = y+1;}  goto q; \n\nfi;\n}\n\nproctype Car_ver_3() { \nbyte x=2;\nbyte y=0;\nbyte lngth=2;\n\nq: if\n::  d_step {y>0 && A[((y-1)*7+x)]==0;A[((y+lngth-1)*7+x)] = 0;A[((y-1)*7+x)] = 1;y = y-1;}  goto q; \n\n::  d_step {y+lngth<7 && A[((y+lngth)*7+x)]==0;A[((y)*7+x)] = 0;A[((y+lngth)*7+x)] = 1;y = y+1;}  goto q; \n\nfi;\n}\n\nproctype Car_ver_4() { \nbyte x=3;\nbyte y=1;\nbyte lngth=3;\n\nq: if\n::  d_step {y>0 && A[((y-1)*7+x)]==0;A[((y+lngth-1)*7+x)] = 0;A[((y-1)*7+x)] = 1;y = y-1;}  goto q; \n\n::  d_step {y+lngth<7 && A[((y+lngth)*7+x)]==0;A[((y)*7+x)] = 0;A[((y+lngth)*7+x)] = 1;y = y+1;}  goto q; \n\nfi;\n}\n\nproctype Car_ver_5() { \nbyte x=4;\nbyte y=1;\nbyte lngth=2;\n\nq: if\n::  d_step {y>0 && A[((y-1)*7+x)]==0;A[((y+lngth-1)*7+x)] = 0;A[((y-1)*7+x)] = 1;y = y-1;}  goto q; \n\n::  d_step {y+lngth<7 && A[((y+lngth)*7+x)]==0;A[((y)*7+x)] = 0;A[((y+lngth)*7+x)] = 1;y = y+1;}  goto q; \n\nfi;\n}\n\nproctype Car_ver_6() { \nbyte x=5;\nbyte y=1;\nbyte lngth=3;\n\nq: if\n::  d_step {y>0 && A[((y-1)*7+x)]==0;A[((y+lngth-1)*7+x)] = 0;A[((y-1)*7+x)] = 1;y = y-1;}  goto q; \n\n::  d_step {y+lngth<7 && A[((y+lngth)*7+x)]==0;A[((y)*7+x)] = 0;A[((y+lngth)*7+x)] = 1;y = y+1;}  goto q; \n\nfi;\n}\n\nproctype Car_ver_7() { \nbyte x=6;\nbyte y=1;\nbyte lngth=2;\n\nq: if\n::  d_step {y>0 && A[((y-1)*7+x)]==0;A[((y+lngth-1)*7+x)] = 0;A[((y-1)*7+x)] = 1;y = y-1;}  goto q; \n\n::  d_step {y+lngth<7 && A[((y+lngth)*7+x)]==0;A[((y)*7+x)] = 0;A[((y+lngth)*7+x)] = 1;y = y+1;}  goto q; \n\nfi;\n}\n\nproctype Car_ver_8() { \nbyte x=6;\nbyte y=5;\nbyte lngth=2;\n\nq: if\n::  d_step {y>0 && A[((y-1)*7+x)]==0;A[((y+lngth-1)*7+x)] = 0;A[((y-1)*7+x)] = 1;y = y-1;}  goto q; \n\n::  d_step {y+lngth<7 && A[((y+lngth)*7+x)]==0;A[((y)*7+x)] = 0;A[((y+lngth)*7+x)] = 1;y = y+1;}  goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "\"Rush hour\" is a sliding block puzzles usually played on\n6x6 game plan. The goal of the puzzle is to move cars in such a way that a\ndistinguished red car can escape the trafic jam.\n\nParameters:\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte A[49];\n\n\ninit { \n d_step { \nA[0] =0; A[1] =0; A[2] =1; A[3] =0; A[4] =1; A[5] =1; A[6] =0; A[7] =1; A[8] =0; A[9] =1; A[10] =1; A[11] =1; A[12] =1; A[13] =1; A[14] =1; A[15] =1; A[16] =1; A[17] =1; A[18] =1; A[19] =1; A[20] =1; A[21] =0; A[22] =0; A[23] =0; A[24] =1; A[25] =0; A[26] =1; A[27] =0; A[28] =1; A[29] =1; A[30] =1; A[31] =0; A[32] =1; A[33] =1; A[34] =0; A[35] =1; A[36] =0; A[37] =1; A[38] =1; A[39] =1; A[40] =0; A[41] =1; A[42] =0; A[43] =0; A[44] =0; A[45] =0; A[46] =0; A[47] =0; A[48] =1; }\natomic { \nrun Red_car();\nrun Car_hor_1();\nrun Car_hor_2();\nrun Car_hor_3();\nrun Car_hor_4();\nrun Car_ver_1();\nrun Car_ver_2();\nrun Car_ver_3();\nrun Car_ver_4();\nrun Car_ver_5();\nrun Car_ver_6();\nrun Car_ver_7();\nrun Car_ver_8();\n} }\n\nproctype Red_car() { \nbyte x=1;\nbyte y=2;\nbyte lngth=2;\n\nq: if\n::  d_step {x>0 && A[((y)*7+x-1)]==0;A[((y)*7+x+lngth-1)] = 0;A[((y)*7+x-1)] = 1;x = x-1;}  goto q; \n\n::  d_step {x+lngth<7 && A[((y)*7+x+lngth)]==0;A[((y)*7+x)] = 0;A[((y)*7+x+lngth)] = 1;x = x+1;}  goto q; \n\n:: x==5; goto out; \n\nfi;\nout: \n false; }\n\nproctype Car_hor_1() { \nbyte x=4;\nbyte y=0;\nbyte lngth=2;\n\nq: if\n::  d_step {x>0 && A[((y)*7+x-1)]==0;A[((y)*7+x+lngth-1)] = 0;A[((y)*7+x-1)] = 1;x = x-1;}  goto q; \n\n::  d_step {x+lngth<7 && A[((y)*7+x+lngth)]==0;A[((y)*7+x)] = 0;A[((y)*7+x+lngth)] = 1;x = x+1;}  goto q; \n\nfi;\n}\n\nproctype Car_hor_2() { \nbyte x=1;\nbyte y=4;\nbyte lngth=2;\n\nq: if\n::  d_step {x>0 && A[((y)*7+x-1)]==0;A[((y)*7+x+lngth-1)] = 0;A[((y)*7+x-1)] = 1;x = x-1;}  goto q; \n\n::  d_step {x+lngth<7 && A[((y)*7+x+lngth)]==0;A[((y)*7+x)] = 0;A[((y)*7+x+lngth)] = 1;x = x+1;}  goto q; \n\nfi;\n}\n\nproctype Car_hor_3() { \nbyte x=4;\nbyte y=4;\nbyte lngth=2;\n\nq: if\n::  d_step {x>0 && A[((y)*7+x-1)]==0;A[((y)*7+x+lngth-1)] = 0;A[((y)*7+x-1)] = 1;x = x-1;}  goto q; \n\n::  d_step {x+lngth<7 && A[((y)*7+x+lngth)]==0;A[((y)*7+x)] = 0;A[((y)*7+x+lngth)] = 1;x = x+1;}  goto q; \n\nfi;\n}\n\nproctype Car_hor_4() { \nbyte x=2;\nbyte y=5;\nbyte lngth=3;\n\nq: if\n::  d_step {x>0 && A[((y)*7+x-1)]==0;A[((y)*7+x+lngth-1)] = 0;A[((y)*7+x-1)] = 1;x = x-1;}  goto q; \n\n::  d_step {x+lngth<7 && A[((y)*7+x+lngth)]==0;A[((y)*7+x)] = 0;A[((y)*7+x+lngth)] = 1;x = x+1;}  goto q; \n\nfi;\n}\n\nproctype Car_ver_1() { \nbyte x=0;\nbyte y=1;\nbyte lngth=2;\n\nq: if\n::  d_step {y>0 && A[((y-1)*7+x)]==0;A[((y+lngth-1)*7+x)] = 0;A[((y-1)*7+x)] = 1;y = y-1;}  goto q; \n\n::  d_step {y+lngth<7 && A[((y+lngth)*7+x)]==0;A[((y)*7+x)] = 0;A[((y+lngth)*7+x)] = 1;y = y+1;}  goto q; \n\nfi;\n}\n\nproctype Car_ver_2() { \nbyte x=0;\nbyte y=4;\nbyte lngth=2;\n\nq: if\n::  d_step {y>0 && A[((y-1)*7+x)]==0;A[((y+lngth-1)*7+x)] = 0;A[((y-1)*7+x)] = 1;y = y-1;}  goto q; \n\n::  d_step {y+lngth<7 && A[((y+lngth)*7+x)]==0;A[((y)*7+x)] = 0;A[((y+lngth)*7+x)] = 1;y = y+1;}  goto q; \n\nfi;\n}\n\nproctype Car_ver_3() { \nbyte x=2;\nbyte y=0;\nbyte lngth=2;\n\nq: if\n::  d_step {y>0 && A[((y-1)*7+x)]==0;A[((y+lngth-1)*7+x)] = 0;A[((y-1)*7+x)] = 1;y = y-1;}  goto q; \n\n::  d_step {y+lngth<7 && A[((y+lngth)*7+x)]==0;A[((y)*7+x)] = 0;A[((y+lngth)*7+x)] = 1;y = y+1;}  goto q; \n\nfi;\n}\n\nproctype Car_ver_4() { \nbyte x=3;\nbyte y=1;\nbyte lngth=3;\n\nq: if\n::  d_step {y>0 && A[((y-1)*7+x)]==0;A[((y+lngth-1)*7+x)] = 0;A[((y-1)*7+x)] = 1;y = y-1;}  goto q; \n\n::  d_step {y+lngth<7 && A[((y+lngth)*7+x)]==0;A[((y)*7+x)] = 0;A[((y+lngth)*7+x)] = 1;y = y+1;}  goto q; \n\nfi;\n}\n\nproctype Car_ver_5() { \nbyte x=4;\nbyte y=1;\nbyte lngth=2;\n\nq: if\n::  d_step {y>0 && A[((y-1)*7+x)]==0;A[((y+lngth-1)*7+x)] = 0;A[((y-1)*7+x)] = 1;y = y-1;}  goto q; \n\n::  d_step {y+lngth<7 && A[((y+lngth)*7+x)]==0;A[((y)*7+x)] = 0;A[((y+lngth)*7+x)] = 1;y = y+1;}  goto q; \n\nfi;\n}\n\nproctype Car_ver_6() { \nbyte x=5;\nbyte y=1;\nbyte lngth=3;\n\nq: if\n::  d_step {y>0 && A[((y-1)*7+x)]==0;A[((y+lngth-1)*7+x)] = 0;A[((y-1)*7+x)] = 1;y = y-1;}  goto q; \n\n::  d_step {y+lngth<7 && A[((y+lngth)*7+x)]==0;A[((y)*7+x)] = 0;A[((y+lngth)*7+x)] = 1;y = y+1;}  goto q; \n\nfi;\n}\n\nproctype Car_ver_7() { \nbyte x=6;\nbyte y=1;\nbyte lngth=2;\n\nq: if\n::  d_step {y>0 && A[((y-1)*7+x)]==0;A[((y+lngth-1)*7+x)] = 0;A[((y-1)*7+x)] = 1;y = y-1;}  goto q; \n\n::  d_step {y+lngth<7 && A[((y+lngth)*7+x)]==0;A[((y)*7+x)] = 0;A[((y+lngth)*7+x)] = 1;y = y+1;}  goto q; \n\nfi;\n}\n\nproctype Car_ver_8() { \nbyte x=6;\nbyte y=5;\nbyte lngth=2;\n\nq: if\n::  d_step {y>0 && A[((y-1)*7+x)]==0;A[((y+lngth-1)*7+x)] = 0;A[((y-1)*7+x)] = 1;y = y-1;}  goto q; \n\n::  d_step {y+lngth<7 && A[((y+lngth)*7+x)]==0;A[((y)*7+x)] = 0;A[((y+lngth)*7+x)] = 1;y = y+1;}  goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Simplified model of 'schedule world' example from AIPS\n    2000 contest. The model contains lot of rather independent and sometimes\n    irelevant things, thus the state explosion is really\n    big.\n\nParameters:\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte temperature[2];\nbyte surface[2];\nbyte shape[2];\nbyte painted[2];\nbyte hashole[2];\nbyte busy[8];\nbyte scheduled[2];\nbyte objscheduled=0;\n\n\ninit { \n d_step { \ntemperature[0] =0; temperature[1] =0; surface[0] =1; surface[1] =1; shape[0] =1; shape[1] =1; painted[0] =0; painted[1] =1; hashole[0] =0; hashole[1] =0; busy[0] =0; busy[1] =0; busy[2] =0; busy[3] =0; busy[4] =0; busy[5] =0; busy[6] =0; busy[7] =0; scheduled[0] =0; scheduled[1] =0; }\natomic { \nrun P();\n} }\n\nproctype P() { \n\nq: if\n:: shape[1]==1 && surface[0]==0 && surface[1]==0 && hashole[1]==1 && shape[0]==0; goto done; \n\n::  d_step {busy[0]==0 && scheduled[0]==0 && temperature[0]==0;objscheduled = 1;busy[0] = 1;scheduled[0] = 1;surface[0] = 0;}  goto q; \n\n::  d_step {busy[0]==0 && scheduled[1]==0 && temperature[1]==0;objscheduled = 1;busy[0] = 1;scheduled[1] = 1;surface[1] = 0;}  goto q; \n\n::  d_step {busy[1]==0 && scheduled[0]==0;objscheduled = 1;busy[1] = 1;scheduled[0] = 1;shape[0] = 0;temperature[0] = 1;painted[0] = 255;hashole[0] = 255;surface[0] = 255;}  goto q; \n\n::  d_step {busy[1]==0 && scheduled[1]==0;objscheduled = 1;busy[1] = 1;scheduled[1] = 1;shape[1] = 0;temperature[1] = 1;painted[1] = 255;hashole[1] = 255;surface[1] = 255;}  goto q; \n\n::  d_step {busy[2]==0 && scheduled[0]==0;objscheduled = 1;busy[2] = 1;scheduled[0] = 1;surface[0] = 2;shape[0] = 0;painted[0] = 255;}  goto q; \n\n::  d_step {busy[2]==0 && scheduled[1]==0;objscheduled = 1;busy[2] = 1;scheduled[1] = 1;surface[1] = 2;shape[1] = 0;painted[1] = 255;}  goto q; \n\n::  d_step {busy[3]==0 && scheduled[0]==0;objscheduled = 1;busy[3] = 1;scheduled[0] = 1;surface[0] = 1;painted[0] = 255;}  goto q; \n\n::  d_step {busy[3]==0 && scheduled[1]==0;objscheduled = 1;busy[3] = 1;scheduled[1] = 1;surface[1] = 1;painted[1] = 255;}  goto q; \n\n::  d_step {busy[4]==0 && scheduled[0]==0 && temperature[0]==0 && hashole[0]!=0;objscheduled = 1;busy[4] = 1;scheduled[0] = 1;surface[0] = 2;hashole[0] = 0;}  goto q; \n\n::  d_step {busy[4]==0 && scheduled[1]==0 && temperature[1]==0 && hashole[1]!=0;objscheduled = 1;busy[4] = 1;scheduled[1] = 1;surface[1] = 2;hashole[1] = 0;}  goto q; \n\n::  d_step {busy[4]==0 && scheduled[0]==0 && temperature[0]==0 && hashole[0]!=1;objscheduled = 1;busy[4] = 1;scheduled[0] = 1;surface[0] = 2;hashole[0] = 1;}  goto q; \n\n::  d_step {busy[4]==0 && scheduled[1]==0 && temperature[1]==0 && hashole[1]!=1;objscheduled = 1;busy[4] = 1;scheduled[1] = 1;surface[1] = 2;hashole[1] = 1;}  goto q; \n\n::  d_step {busy[5]==0 && scheduled[0]==0 && temperature[0]==0 && hashole[0]!=0;objscheduled = 1;busy[5] = 1;scheduled[0] = 1;hashole[0] = 0;}  goto q; \n\n::  d_step {busy[5]==0 && scheduled[1]==0 && temperature[1]==0 && hashole[1]!=0;objscheduled = 1;busy[5] = 1;scheduled[1] = 1;hashole[1] = 0;}  goto q; \n\n::  d_step {busy[5]==0 && scheduled[0]==0 && temperature[0]==0 && hashole[0]!=1;objscheduled = 1;busy[5] = 1;scheduled[0] = 1;hashole[0] = 1;}  goto q; \n\n::  d_step {busy[5]==0 && scheduled[1]==0 && temperature[1]==0 && hashole[1]!=1;objscheduled = 1;busy[5] = 1;scheduled[1] = 1;hashole[1] = 1;}  goto q; \n\n::  d_step {busy[6]==0 && scheduled[0]==0 && temperature[0]==0;objscheduled = 1;busy[6] = 1;scheduled[0] = 1;painted[0] = 0;}  goto q; \n\n::  d_step {busy[6]==0 && scheduled[1]==0 && temperature[1]==0;objscheduled = 1;busy[6] = 1;scheduled[1] = 1;painted[1] = 0;}  goto q; \n\n::  d_step {busy[6]==0 && scheduled[0]==0 && temperature[0]==0;objscheduled = 1;busy[6] = 1;scheduled[0] = 1;painted[0] = 1;}  goto q; \n\n::  d_step {busy[6]==0 && scheduled[1]==0 && temperature[1]==0;objscheduled = 1;busy[6] = 1;scheduled[1] = 1;painted[1] = 1;}  goto q; \n\n::  d_step {busy[7]==0 && scheduled[0]==0;objscheduled = 1;busy[7] = 1;scheduled[0] = 1;painted[0] = 0;}  goto q; \n\n::  d_step {busy[7]==0 && scheduled[1]==0;objscheduled = 1;busy[7] = 1;scheduled[1] = 1;painted[1] = 0;}  goto q; \n\n::  d_step {busy[7]==0 && scheduled[0]==0;objscheduled = 1;busy[7] = 1;scheduled[0] = 1;painted[0] = 1;}  goto q; \n\n::  d_step {busy[7]==0 && scheduled[1]==0;objscheduled = 1;busy[7] = 1;scheduled[1] = 1;painted[1] = 1;}  goto q; \n\n::  d_step {objscheduled==1;scheduled[0] = 0;scheduled[1] = 0;busy[0] = 0;busy[1] = 0;busy[2] = 0;busy[3] = 0;busy[4] = 0;busy[5] = 0;busy[6] = 0;busy[7] = 0;objscheduled = 0;}  goto q; \n\nfi;\ndone: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Simplified model of 'schedule world' example from AIPS\n    2000 contest. The model contains lot of rather independent and sometimes\n    irelevant things, thus the state explosion is really\n    big.\n\nParameters:\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte temperature[3];\nbyte surface[3];\nbyte shape[3];\nbyte painted[3];\nbyte hashole[3];\nbyte busy[8];\nbyte scheduled[3];\nbyte objscheduled=0;\n\n\ninit { \n d_step { \ntemperature[0] =0; temperature[1] =0; temperature[2] =0; surface[0] =0; surface[1] =1; surface[2] =2; shape[0] =0; shape[1] =1; shape[2] =1; painted[0] =0; painted[1] =1; painted[2] =1; hashole[0] =1; hashole[1] =1; hashole[2] =0; busy[0] =0; busy[1] =0; busy[2] =0; busy[3] =0; busy[4] =0; busy[5] =0; busy[6] =0; busy[7] =0; scheduled[0] =0; scheduled[1] =0; scheduled[2] =0; }\natomic { \nrun P();\n} }\n\nproctype P() { \n\nq: if\n:: shape[1]==1 && surface[0]==0 && surface[1]==0 && hashole[1]==1 && shape[0]==0; goto done; \n\n::  d_step {busy[0]==0 && scheduled[0]==0 && temperature[0]==0;objscheduled = 1;busy[0] = 1;scheduled[0] = 1;surface[0] = 0;}  goto q; \n\n::  d_step {busy[0]==0 && scheduled[1]==0 && temperature[1]==0;objscheduled = 1;busy[0] = 1;scheduled[1] = 1;surface[1] = 0;}  goto q; \n\n::  d_step {busy[0]==0 && scheduled[2]==0 && temperature[2]==0;objscheduled = 1;busy[0] = 1;scheduled[2] = 1;surface[2] = 0;}  goto q; \n\n::  d_step {busy[1]==0 && scheduled[0]==0;objscheduled = 1;busy[1] = 1;scheduled[0] = 1;shape[0] = 0;temperature[0] = 1;painted[0] = 255;hashole[0] = 255;surface[0] = 255;}  goto q; \n\n::  d_step {busy[1]==0 && scheduled[1]==0;objscheduled = 1;busy[1] = 1;scheduled[1] = 1;shape[1] = 0;temperature[1] = 1;painted[1] = 255;hashole[1] = 255;surface[1] = 255;}  goto q; \n\n::  d_step {busy[1]==0 && scheduled[2]==0;objscheduled = 1;busy[1] = 1;scheduled[2] = 1;shape[2] = 0;temperature[2] = 1;painted[2] = 255;hashole[2] = 255;surface[2] = 255;}  goto q; \n\n::  d_step {busy[2]==0 && scheduled[0]==0;objscheduled = 1;busy[2] = 1;scheduled[0] = 1;surface[0] = 2;shape[0] = 0;painted[0] = 255;}  goto q; \n\n::  d_step {busy[2]==0 && scheduled[1]==0;objscheduled = 1;busy[2] = 1;scheduled[1] = 1;surface[1] = 2;shape[1] = 0;painted[1] = 255;}  goto q; \n\n::  d_step {busy[2]==0 && scheduled[2]==0;objscheduled = 1;busy[2] = 1;scheduled[2] = 1;surface[2] = 2;shape[2] = 0;painted[2] = 255;}  goto q; \n\n::  d_step {busy[3]==0 && scheduled[0]==0;objscheduled = 1;busy[3] = 1;scheduled[0] = 1;surface[0] = 1;painted[0] = 255;}  goto q; \n\n::  d_step {busy[3]==0 && scheduled[1]==0;objscheduled = 1;busy[3] = 1;scheduled[1] = 1;surface[1] = 1;painted[1] = 255;}  goto q; \n\n::  d_step {busy[3]==0 && scheduled[2]==0;objscheduled = 1;busy[3] = 1;scheduled[2] = 1;surface[2] = 1;painted[2] = 255;}  goto q; \n\n::  d_step {busy[4]==0 && scheduled[0]==0 && temperature[0]==0 && hashole[0]!=0;objscheduled = 1;busy[4] = 1;scheduled[0] = 1;surface[0] = 2;hashole[0] = 0;}  goto q; \n\n::  d_step {busy[4]==0 && scheduled[1]==0 && temperature[1]==0 && hashole[1]!=0;objscheduled = 1;busy[4] = 1;scheduled[1] = 1;surface[1] = 2;hashole[1] = 0;}  goto q; \n\n::  d_step {busy[4]==0 && scheduled[2]==0 && temperature[2]==0 && hashole[2]!=0;objscheduled = 1;busy[4] = 1;scheduled[2] = 1;surface[2] = 2;hashole[2] = 0;}  goto q; \n\n::  d_step {busy[4]==0 && scheduled[0]==0 && temperature[0]==0 && hashole[0]!=1;objscheduled = 1;busy[4] = 1;scheduled[0] = 1;surface[0] = 2;hashole[0] = 1;}  goto q; \n\n::  d_step {busy[4]==0 && scheduled[1]==0 && temperature[1]==0 && hashole[1]!=1;objscheduled = 1;busy[4] = 1;scheduled[1] = 1;surface[1] = 2;hashole[1] = 1;}  goto q; \n\n::  d_step {busy[4]==0 && scheduled[2]==0 && temperature[2]==0 && hashole[2]!=1;objscheduled = 1;busy[4] = 1;scheduled[2] = 1;surface[2] = 2;hashole[2] = 1;}  goto q; \n\n::  d_step {busy[5]==0 && scheduled[0]==0 && temperature[0]==0 && hashole[0]!=0;objscheduled = 1;busy[5] = 1;scheduled[0] = 1;hashole[0] = 0;}  goto q; \n\n::  d_step {busy[5]==0 && scheduled[1]==0 && temperature[1]==0 && hashole[1]!=0;objscheduled = 1;busy[5] = 1;scheduled[1] = 1;hashole[1] = 0;}  goto q; \n\n::  d_step {busy[5]==0 && scheduled[2]==0 && temperature[2]==0 && hashole[2]!=0;objscheduled = 1;busy[5] = 1;scheduled[2] = 1;hashole[2] = 0;}  goto q; \n\n::  d_step {busy[5]==0 && scheduled[0]==0 && temperature[0]==0 && hashole[0]!=1;objscheduled = 1;busy[5] = 1;scheduled[0] = 1;hashole[0] = 1;}  goto q; \n\n::  d_step {busy[5]==0 && scheduled[1]==0 && temperature[1]==0 && hashole[1]!=1;objscheduled = 1;busy[5] = 1;scheduled[1] = 1;hashole[1] = 1;}  goto q; \n\n::  d_step {busy[5]==0 && scheduled[2]==0 && temperature[2]==0 && hashole[2]!=1;objscheduled = 1;busy[5] = 1;scheduled[2] = 1;hashole[2] = 1;}  goto q; \n\n::  d_step {busy[6]==0 && scheduled[0]==0 && temperature[0]==0;objscheduled = 1;busy[6] = 1;scheduled[0] = 1;painted[0] = 0;}  goto q; \n\n::  d_step {busy[6]==0 && scheduled[1]==0 && temperature[1]==0;objscheduled = 1;busy[6] = 1;scheduled[1] = 1;painted[1] = 0;}  goto q; \n\n::  d_step {busy[6]==0 && scheduled[2]==0 && temperature[2]==0;objscheduled = 1;busy[6] = 1;scheduled[2] = 1;painted[2] = 0;}  goto q; \n\n::  d_step {busy[6]==0 && scheduled[0]==0 && temperature[0]==0;objscheduled = 1;busy[6] = 1;scheduled[0] = 1;painted[0] = 1;}  goto q; \n\n::  d_step {busy[6]==0 && scheduled[1]==0 && temperature[1]==0;objscheduled = 1;busy[6] = 1;scheduled[1] = 1;painted[1] = 1;}  goto q; \n\n::  d_step {busy[6]==0 && scheduled[2]==0 && temperature[2]==0;objscheduled = 1;busy[6] = 1;scheduled[2] = 1;painted[2] = 1;}  goto q; \n\n::  d_step {busy[7]==0 && scheduled[0]==0;objscheduled = 1;busy[7] = 1;scheduled[0] = 1;painted[0] = 0;}  goto q; \n\n::  d_step {busy[7]==0 && scheduled[1]==0;objscheduled = 1;busy[7] = 1;scheduled[1] = 1;painted[1] = 0;}  goto q; \n\n::  d_step {busy[7]==0 && scheduled[2]==0;objscheduled = 1;busy[7] = 1;scheduled[2] = 1;painted[2] = 0;}  goto q; \n\n::  d_step {busy[7]==0 && scheduled[0]==0;objscheduled = 1;busy[7] = 1;scheduled[0] = 1;painted[0] = 1;}  goto q; \n\n::  d_step {busy[7]==0 && scheduled[1]==0;objscheduled = 1;busy[7] = 1;scheduled[1] = 1;painted[1] = 1;}  goto q; \n\n::  d_step {busy[7]==0 && scheduled[2]==0;objscheduled = 1;busy[7] = 1;scheduled[2] = 1;painted[2] = 1;}  goto q; \n\n::  d_step {objscheduled==1;scheduled[0] = 0;scheduled[1] = 0;scheduled[2] = 0;busy[0] = 0;busy[1] = 0;busy[2] = 0;busy[3] = 0;busy[4] = 0;busy[5] = 0;busy[6] = 0;busy[7] = 0;objscheduled = 0;}  goto q; \n\nfi;\ndone: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Simplified model of 'schedule world' example from AIPS\n    2000 contest. The model contains lot of rather independent and sometimes\n    irelevant things, thus the state explosion is really\n    big.\n\nParameters:\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte temperature[4];\nbyte surface[4];\nbyte shape[4];\nbyte painted[4];\nbyte hashole[4];\nbyte busy[8];\nbyte scheduled[4];\nbyte objscheduled=0;\n\n\ninit { \n d_step { \ntemperature[0] =0; temperature[1] =0; temperature[2] =0; temperature[3] =0; surface[0] =0; surface[1] =0; surface[2] =1; surface[3] =2; shape[0] =0; shape[1] =1; shape[2] =1; shape[3] =1; painted[0] =0; painted[1] =0; painted[2] =1; painted[3] =1; hashole[0] =1; hashole[1] =1; hashole[2] =1; hashole[3] =0; busy[0] =0; busy[1] =0; busy[2] =0; busy[3] =0; busy[4] =0; busy[5] =0; busy[6] =0; busy[7] =0; scheduled[0] =0; scheduled[1] =0; scheduled[2] =0; scheduled[3] =0; }\natomic { \nrun P();\n} }\n\nproctype P() { \n\nq: if\n:: shape[1]==1 && surface[0]==0 && surface[1]==0 && hashole[1]==1 && shape[0]==0; goto done; \n\n::  d_step {busy[0]==0 && scheduled[0]==0 && temperature[0]==0;objscheduled = 1;busy[0] = 1;scheduled[0] = 1;surface[0] = 0;}  goto q; \n\n::  d_step {busy[0]==0 && scheduled[1]==0 && temperature[1]==0;objscheduled = 1;busy[0] = 1;scheduled[1] = 1;surface[1] = 0;}  goto q; \n\n::  d_step {busy[0]==0 && scheduled[2]==0 && temperature[2]==0;objscheduled = 1;busy[0] = 1;scheduled[2] = 1;surface[2] = 0;}  goto q; \n\n::  d_step {busy[0]==0 && scheduled[3]==0 && temperature[3]==0;objscheduled = 1;busy[0] = 1;scheduled[3] = 1;surface[3] = 0;}  goto q; \n\n::  d_step {busy[1]==0 && scheduled[0]==0;objscheduled = 1;busy[1] = 1;scheduled[0] = 1;shape[0] = 0;temperature[0] = 1;painted[0] = 255;hashole[0] = 255;surface[0] = 255;}  goto q; \n\n::  d_step {busy[1]==0 && scheduled[1]==0;objscheduled = 1;busy[1] = 1;scheduled[1] = 1;shape[1] = 0;temperature[1] = 1;painted[1] = 255;hashole[1] = 255;surface[1] = 255;}  goto q; \n\n::  d_step {busy[1]==0 && scheduled[2]==0;objscheduled = 1;busy[1] = 1;scheduled[2] = 1;shape[2] = 0;temperature[2] = 1;painted[2] = 255;hashole[2] = 255;surface[2] = 255;}  goto q; \n\n::  d_step {busy[1]==0 && scheduled[3]==0;objscheduled = 1;busy[1] = 1;scheduled[3] = 1;shape[3] = 0;temperature[3] = 1;painted[3] = 255;hashole[3] = 255;surface[3] = 255;}  goto q; \n\n::  d_step {busy[2]==0 && scheduled[0]==0;objscheduled = 1;busy[2] = 1;scheduled[0] = 1;surface[0] = 2;shape[0] = 0;painted[0] = 255;}  goto q; \n\n::  d_step {busy[2]==0 && scheduled[1]==0;objscheduled = 1;busy[2] = 1;scheduled[1] = 1;surface[1] = 2;shape[1] = 0;painted[1] = 255;}  goto q; \n\n::  d_step {busy[2]==0 && scheduled[2]==0;objscheduled = 1;busy[2] = 1;scheduled[2] = 1;surface[2] = 2;shape[2] = 0;painted[2] = 255;}  goto q; \n\n::  d_step {busy[2]==0 && scheduled[3]==0;objscheduled = 1;busy[2] = 1;scheduled[3] = 1;surface[3] = 2;shape[3] = 0;painted[3] = 255;}  goto q; \n\n::  d_step {busy[3]==0 && scheduled[0]==0;objscheduled = 1;busy[3] = 1;scheduled[0] = 1;surface[0] = 1;painted[0] = 255;}  goto q; \n\n::  d_step {busy[3]==0 && scheduled[1]==0;objscheduled = 1;busy[3] = 1;scheduled[1] = 1;surface[1] = 1;painted[1] = 255;}  goto q; \n\n::  d_step {busy[3]==0 && scheduled[2]==0;objscheduled = 1;busy[3] = 1;scheduled[2] = 1;surface[2] = 1;painted[2] = 255;}  goto q; \n\n::  d_step {busy[3]==0 && scheduled[3]==0;objscheduled = 1;busy[3] = 1;scheduled[3] = 1;surface[3] = 1;painted[3] = 255;}  goto q; \n\n::  d_step {busy[4]==0 && scheduled[0]==0 && temperature[0]==0 && hashole[0]!=0;objscheduled = 1;busy[4] = 1;scheduled[0] = 1;surface[0] = 2;hashole[0] = 0;}  goto q; \n\n::  d_step {busy[4]==0 && scheduled[1]==0 && temperature[1]==0 && hashole[1]!=0;objscheduled = 1;busy[4] = 1;scheduled[1] = 1;surface[1] = 2;hashole[1] = 0;}  goto q; \n\n::  d_step {busy[4]==0 && scheduled[2]==0 && temperature[2]==0 && hashole[2]!=0;objscheduled = 1;busy[4] = 1;scheduled[2] = 1;surface[2] = 2;hashole[2] = 0;}  goto q; \n\n::  d_step {busy[4]==0 && scheduled[3]==0 && temperature[3]==0 && hashole[3]!=0;objscheduled = 1;busy[4] = 1;scheduled[3] = 1;surface[3] = 2;hashole[3] = 0;}  goto q; \n\n::  d_step {busy[4]==0 && scheduled[0]==0 && temperature[0]==0 && hashole[0]!=1;objscheduled = 1;busy[4] = 1;scheduled[0] = 1;surface[0] = 2;hashole[0] = 1;}  goto q; \n\n::  d_step {busy[4]==0 && scheduled[1]==0 && temperature[1]==0 && hashole[1]!=1;objscheduled = 1;busy[4] = 1;scheduled[1] = 1;surface[1] = 2;hashole[1] = 1;}  goto q; \n\n::  d_step {busy[4]==0 && scheduled[2]==0 && temperature[2]==0 && hashole[2]!=1;objscheduled = 1;busy[4] = 1;scheduled[2] = 1;surface[2] = 2;hashole[2] = 1;}  goto q; \n\n::  d_step {busy[4]==0 && scheduled[3]==0 && temperature[3]==0 && hashole[3]!=1;objscheduled = 1;busy[4] = 1;scheduled[3] = 1;surface[3] = 2;hashole[3] = 1;}  goto q; \n\n::  d_step {busy[5]==0 && scheduled[0]==0 && temperature[0]==0 && hashole[0]!=0;objscheduled = 1;busy[5] = 1;scheduled[0] = 1;hashole[0] = 0;}  goto q; \n\n::  d_step {busy[5]==0 && scheduled[1]==0 && temperature[1]==0 && hashole[1]!=0;objscheduled = 1;busy[5] = 1;scheduled[1] = 1;hashole[1] = 0;}  goto q; \n\n::  d_step {busy[5]==0 && scheduled[2]==0 && temperature[2]==0 && hashole[2]!=0;objscheduled = 1;busy[5] = 1;scheduled[2] = 1;hashole[2] = 0;}  goto q; \n\n::  d_step {busy[5]==0 && scheduled[3]==0 && temperature[3]==0 && hashole[3]!=0;objscheduled = 1;busy[5] = 1;scheduled[3] = 1;hashole[3] = 0;}  goto q; \n\n::  d_step {busy[5]==0 && scheduled[0]==0 && temperature[0]==0 && hashole[0]!=1;objscheduled = 1;busy[5] = 1;scheduled[0] = 1;hashole[0] = 1;}  goto q; \n\n::  d_step {busy[5]==0 && scheduled[1]==0 && temperature[1]==0 && hashole[1]!=1;objscheduled = 1;busy[5] = 1;scheduled[1] = 1;hashole[1] = 1;}  goto q; \n\n::  d_step {busy[5]==0 && scheduled[2]==0 && temperature[2]==0 && hashole[2]!=1;objscheduled = 1;busy[5] = 1;scheduled[2] = 1;hashole[2] = 1;}  goto q; \n\n::  d_step {busy[5]==0 && scheduled[3]==0 && temperature[3]==0 && hashole[3]!=1;objscheduled = 1;busy[5] = 1;scheduled[3] = 1;hashole[3] = 1;}  goto q; \n\n::  d_step {busy[6]==0 && scheduled[0]==0 && temperature[0]==0;objscheduled = 1;busy[6] = 1;scheduled[0] = 1;painted[0] = 0;}  goto q; \n\n::  d_step {busy[6]==0 && scheduled[1]==0 && temperature[1]==0;objscheduled = 1;busy[6] = 1;scheduled[1] = 1;painted[1] = 0;}  goto q; \n\n::  d_step {busy[6]==0 && scheduled[2]==0 && temperature[2]==0;objscheduled = 1;busy[6] = 1;scheduled[2] = 1;painted[2] = 0;}  goto q; \n\n::  d_step {busy[6]==0 && scheduled[3]==0 && temperature[3]==0;objscheduled = 1;busy[6] = 1;scheduled[3] = 1;painted[3] = 0;}  goto q; \n\n::  d_step {busy[6]==0 && scheduled[0]==0 && temperature[0]==0;objscheduled = 1;busy[6] = 1;scheduled[0] = 1;painted[0] = 1;}  goto q; \n\n::  d_step {busy[6]==0 && scheduled[1]==0 && temperature[1]==0;objscheduled = 1;busy[6] = 1;scheduled[1] = 1;painted[1] = 1;}  goto q; \n\n::  d_step {busy[6]==0 && scheduled[2]==0 && temperature[2]==0;objscheduled = 1;busy[6] = 1;scheduled[2] = 1;painted[2] = 1;}  goto q; \n\n::  d_step {busy[6]==0 && scheduled[3]==0 && temperature[3]==0;objscheduled = 1;busy[6] = 1;scheduled[3] = 1;painted[3] = 1;}  goto q; \n\n::  d_step {busy[7]==0 && scheduled[0]==0;objscheduled = 1;busy[7] = 1;scheduled[0] = 1;painted[0] = 0;}  goto q; \n\n::  d_step {busy[7]==0 && scheduled[1]==0;objscheduled = 1;busy[7] = 1;scheduled[1] = 1;painted[1] = 0;}  goto q; \n\n::  d_step {busy[7]==0 && scheduled[2]==0;objscheduled = 1;busy[7] = 1;scheduled[2] = 1;painted[2] = 0;}  goto q; \n\n::  d_step {busy[7]==0 && scheduled[3]==0;objscheduled = 1;busy[7] = 1;scheduled[3] = 1;painted[3] = 0;}  goto q; \n\n::  d_step {busy[7]==0 && scheduled[0]==0;objscheduled = 1;busy[7] = 1;scheduled[0] = 1;painted[0] = 1;}  goto q; \n\n::  d_step {busy[7]==0 && scheduled[1]==0;objscheduled = 1;busy[7] = 1;scheduled[1] = 1;painted[1] = 1;}  goto q; \n\n::  d_step {busy[7]==0 && scheduled[2]==0;objscheduled = 1;busy[7] = 1;scheduled[2] = 1;painted[2] = 1;}  goto q; \n\n::  d_step {busy[7]==0 && scheduled[3]==0;objscheduled = 1;busy[7] = 1;scheduled[3] = 1;painted[3] = 1;}  goto q; \n\n::  d_step {objscheduled==1;scheduled[0] = 0;scheduled[1] = 0;scheduled[2] = 0;scheduled[3] = 0;busy[0] = 0;busy[1] = 0;busy[2] = 0;busy[3] = 0;busy[4] = 0;busy[5] = 0;busy[6] = 0;busy[7] = 0;objscheduled = 0;}  goto q; \n\nfi;\ndone: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "A well-known computer game. The object of Sokoban is to\n  push all stones (or boxes) in a maze, such as the one to the right, to the\n  designated goal areas. The player controls the man and the \"man\" can only\n  push stones and only one at a time.\n\nParameters:\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte a[64];\nbyte x=4;\nbyte y=6;\nbyte done=0;\n\n\ninit { \n d_step { \na[0] =1; a[1] =1; a[2] =1; a[3] =1; a[4] =1; a[5] =1; a[6] =1; a[7] =1; a[8] =1; a[9] =0; a[10] =0; a[11] =0; a[12] =1; a[13] =1; a[14] =1; a[15] =1; a[16] =1; a[17] =2; a[18] =1; a[19] =0; a[20] =1; a[21] =1; a[22] =1; a[23] =1; a[24] =1; a[25] =0; a[26] =0; a[27] =0; a[28] =0; a[29] =0; a[30] =0; a[31] =1; a[32] =1; a[33] =0; a[34] =0; a[35] =2; a[36] =0; a[37] =2; a[38] =0; a[39] =1; a[40] =1; a[41] =0; a[42] =2; a[43] =0; a[44] =1; a[45] =0; a[46] =1; a[47] =1; a[48] =1; a[49] =1; a[50] =1; a[51] =0; a[52] =0; a[53] =0; a[54] =1; a[55] =1; a[56] =1; a[57] =1; a[58] =1; a[59] =1; a[60] =1; a[61] =1; a[62] =1; a[63] =1; }\natomic { \nrun P();\n} }\n\nproctype P() { \n\nq: if\n::  d_step {done==0 && a[25]==2 && a[35]==2 && a[42]==2 && a[37]==2;done = 1;}  goto q; \n\n::  d_step {done==0 && a[((y)*8+x-1)]==0;x = x-1;}  goto q; \n\n::  d_step {done==0 && a[((y)*8+x+1)]==0;x = x+1;}  goto q; \n\n::  d_step {done==0 && a[((y-1)*8+x)]==0;y = y-1;}  goto q; \n\n::  d_step {done==0 && a[((y+1)*8+x)]==0;y = y+1;}  goto q; \n\n::  d_step {done==0 && a[((y)*8+x-1)]==2 && a[((y)*8+x-2)]==0;a[((y)*8+x-2)] = 2;a[((y)*8+x-1)] = 0;x = x-1;}  goto q; \n\n::  d_step {done==0 && a[((y)*8+x+1)]==2 && a[((y)*8+x+2)]==0;a[((y)*8+x+2)] = 2;a[((y)*8+x+1)] = 0;x = x+1;}  goto q; \n\n::  d_step {done==0 && a[((y-1)*8+x)]==2 && a[((y-2)*8+x)]==0;a[((y-2)*8+x)] = 2;a[((y-1)*8+x)] = 0;y = y-1;}  goto q; \n\n::  d_step {done==0 && a[((y+1)*8+x)]==2 && a[((y+2)*8+x)]==0;a[((y+2)*8+x)] = 2;a[((y+1)*8+x)] = 0;y = y+1;}  goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "A well-known computer game. The object of Sokoban is to\n  push all stones (or boxes) in a maze, such as the one to the right, to the\n  designated goal areas. The player controls the man and the \"man\" can only\n  push stones and only one at a time.\n\nParameters:\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte a[60];\nbyte x=1;\nbyte y=1;\nbyte done=0;\n\n\ninit { \n d_step { \na[0] =1; a[1] =1; a[2] =1; a[3] =1; a[4] =1; a[5] =1; a[6] =1; a[7] =1; a[8] =1; a[9] =1; a[10] =1; a[11] =0; a[12] =0; a[13] =0; a[14] =1; a[15] =0; a[16] =0; a[17] =0; a[18] =0; a[19] =1; a[20] =1; a[21] =0; a[22] =2; a[23] =0; a[24] =2; a[25] =0; a[26] =0; a[27] =0; a[28] =0; a[29] =1; a[30] =1; a[31] =0; a[32] =2; a[33] =2; a[34] =2; a[35] =1; a[36] =1; a[37] =0; a[38] =0; a[39] =1; a[40] =1; a[41] =0; a[42] =0; a[43] =0; a[44] =0; a[45] =1; a[46] =1; a[47] =1; a[48] =1; a[49] =1; a[50] =1; a[51] =1; a[52] =1; a[53] =1; a[54] =1; a[55] =1; a[56] =1; a[57] =1; a[58] =1; a[59] =1; }\natomic { \nrun P();\n} }\n\nproctype P() { \n\nq: if\n::  d_step {done==0 && a[18]==2 && a[27]==2 && a[28]==2 && a[37]==2 && a[38]==2;done = 1;}  goto q; \n\n::  d_step {done==0 && a[((y)*10+x-1)]==0;x = x-1;}  goto q; \n\n::  d_step {done==0 && a[((y)*10+x+1)]==0;x = x+1;}  goto q; \n\n::  d_step {done==0 && a[((y-1)*10+x)]==0;y = y-1;}  goto q; \n\n::  d_step {done==0 && a[((y+1)*10+x)]==0;y = y+1;}  goto q; \n\n::  d_step {done==0 && a[((y)*10+x-1)]==2 && a[((y)*10+x-2)]==0;a[((y)*10+x-2)] = 2;a[((y)*10+x-1)] = 0;x = x-1;}  goto q; \n\n::  d_step {done==0 && a[((y)*10+x+1)]==2 && a[((y)*10+x+2)]==0;a[((y)*10+x+2)] = 2;a[((y)*10+x+1)] = 0;x = x+1;}  goto q; \n\n::  d_step {done==0 && a[((y-1)*10+x)]==2 && a[((y-2)*10+x)]==0;a[((y-2)*10+x)] = 2;a[((y-1)*10+x)] = 0;y = y-1;}  goto q; \n\n::  d_step {done==0 && a[((y+1)*10+x)]==2 && a[((y+2)*10+x)]==0;a[((y+2)*10+x)] = 2;a[((y+1)*10+x)] = 0;y = y+1;}  goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "A well-known computer game. The object of Sokoban is to\n  push all stones (or boxes) in a maze, such as the one to the right, to the\n  designated goal areas. The player controls the man and the \"man\" can only\n  push stones and only one at a time.\n\nParameters:\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte a[209];\nbyte x=11;\nbyte y=9;\nbyte done=0;\n\n\ninit { \n d_step { \na[0] =1; a[1] =1; a[2] =1; a[3] =1; a[4] =1; a[5] =1; a[6] =1; a[7] =1; a[8] =1; a[9] =1; a[10] =1; a[11] =1; a[12] =1; a[13] =1; a[14] =1; a[15] =1; a[16] =1; a[17] =1; a[18] =1; a[19] =1; a[20] =1; a[21] =1; a[22] =1; a[23] =0; a[24] =0; a[25] =0; a[26] =1; a[27] =1; a[28] =1; a[29] =1; a[30] =1; a[31] =1; a[32] =1; a[33] =1; a[34] =1; a[35] =1; a[36] =1; a[37] =1; a[38] =1; a[39] =1; a[40] =1; a[41] =1; a[42] =2; a[43] =0; a[44] =0; a[45] =1; a[46] =1; a[47] =1; a[48] =1; a[49] =1; a[50] =1; a[51] =1; a[52] =1; a[53] =1; a[54] =1; a[55] =1; a[56] =1; a[57] =1; a[58] =1; a[59] =1; a[60] =1; a[61] =0; a[62] =0; a[63] =2; a[64] =1; a[65] =1; a[66] =1; a[67] =1; a[68] =1; a[69] =1; a[70] =1; a[71] =1; a[72] =1; a[73] =1; a[74] =1; a[75] =1; a[76] =1; a[77] =1; a[78] =1; a[79] =0; a[80] =2; a[81] =0; a[82] =2; a[83] =0; a[84] =0; a[85] =1; a[86] =1; a[87] =1; a[88] =1; a[89] =1; a[90] =1; a[91] =1; a[92] =1; a[93] =1; a[94] =1; a[95] =1; a[96] =1; a[97] =1; a[98] =0; a[99] =1; a[100] =0; a[101] =1; a[102] =1; a[103] =0; a[104] =1; a[105] =1; a[106] =1; a[107] =1; a[108] =1; a[109] =1; a[110] =1; a[111] =1; a[112] =1; a[113] =1; a[114] =1; a[115] =0; a[116] =0; a[117] =0; a[118] =1; a[119] =0; a[120] =1; a[121] =1; a[122] =0; a[123] =1; a[124] =1; a[125] =1; a[126] =1; a[127] =1; a[128] =0; a[129] =0; a[130] =0; a[131] =0; a[132] =1; a[133] =1; a[134] =0; a[135] =2; a[136] =0; a[137] =0; a[138] =2; a[139] =0; a[140] =0; a[141] =0; a[142] =0; a[143] =0; a[144] =0; a[145] =0; a[146] =0; a[147] =0; a[148] =0; a[149] =0; a[150] =0; a[151] =1; a[152] =1; a[153] =1; a[154] =1; a[155] =1; a[156] =1; a[157] =0; a[158] =1; a[159] =1; a[160] =1; a[161] =0; a[162] =1; a[163] =0; a[164] =1; a[165] =1; a[166] =0; a[167] =0; a[168] =0; a[169] =0; a[170] =1; a[171] =1; a[172] =1; a[173] =1; a[174] =1; a[175] =1; a[176] =0; a[177] =0; a[178] =0; a[179] =0; a[180] =0; a[181] =1; a[182] =0; a[183] =1; a[184] =1; a[185] =1; a[186] =1; a[187] =1; a[188] =1; a[189] =1; a[190] =1; a[191] =1; a[192] =1; a[193] =1; a[194] =1; a[195] =1; a[196] =1; a[197] =1; a[198] =1; a[199] =1; a[200] =1; a[201] =1; a[202] =1; a[203] =1; a[204] =1; a[205] =1; a[206] =1; a[207] =1; a[208] =1; }\natomic { \nrun P();\n} }\n\nproctype P() { \n\nq: if\n::  d_step {done==0 && a[74]==2 && a[75]==2 && a[85]==2 && a[86]==2 && a[96]==2 && a[97]==2;done = 1;}  goto q; \n\n::  d_step {done==0 && a[((y)*19+x-1)]==0;x = x-1;}  goto q; \n\n::  d_step {done==0 && a[((y)*19+x+1)]==0;x = x+1;}  goto q; \n\n::  d_step {done==0 && a[((y-1)*19+x)]==0;y = y-1;}  goto q; \n\n::  d_step {done==0 && a[((y+1)*19+x)]==0;y = y+1;}  goto q; \n\n::  d_step {done==0 && a[((y)*19+x-1)]==2 && a[((y)*19+x-2)]==0;a[((y)*19+x-2)] = 2;a[((y)*19+x-1)] = 0;x = x-1;}  goto q; \n\n::  d_step {done==0 && a[((y)*19+x+1)]==2 && a[((y)*19+x+2)]==0;a[((y)*19+x+2)] = 2;a[((y)*19+x+1)] = 0;x = x+1;}  goto q; \n\n::  d_step {done==0 && a[((y-1)*19+x)]==2 && a[((y-2)*19+x)]==0;a[((y-2)*19+x)] = 2;a[((y-1)*19+x)] = 0;y = y-1;}  goto q; \n\n::  d_step {done==0 && a[((y+1)*19+x)]==2 && a[((y+2)*19+x)]==0;a[((y+2)*19+x)] = 2;a[((y+1)*19+x)] = 0;y = y+1;}  goto q; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The example is a model of a sorter of bricks built using a Lego\n  Mindstorms systems. The Sorter  consists of the following parts:\n 2 belts which are used to transport bricks, a light sensor which can detect passing bricks, an arm which can kick bricks from the belt, a button which is used to \"order\" bricks for processing.\nThe intended behaviour of the system is the following. Bricks are placed by\nthe user on the first belt. Bricks which are too long (length\nis detected with the use of light sensor) are kicked out from the belt by the\narm. Short bricks are transported to the second belt. The second belt\ntransports them either to a \"processing\" side or to a \"not-processing\" side\ndepending on whether a brick has been ordered by pressing the button.\nAlthough the system is rather simple and artificial, it has several features\ntypical for embedded systems. The model is discrete time.\n\nParameters:"}, {"role": "assistant", "content": "byte token=0;\nbyte belt1_moving=1;\nbyte belt2_moving=0;\nbyte arm_kicking=0;\nbyte light_sensor_level=0;\nbyte button_pressed=0;\nbyte put_short_brick=0;\nbyte put_long_brick=0;\nbyte requests=0;\nbyte timer=0;\nbyte brick=0;\n\n\nactive proctype ButtonControler() { \n\nBC: if\n::  d_step {token==0 && button_pressed==0;token = 1;}  goto BC; \n\n::  d_step {token==0 && button_pressed==1 && requests<5;button_pressed = 0;requests = requests+1;token = 1;}  goto BC; \n\n::  d_step {token==0 && button_pressed==1 && requests==5;button_pressed = 0;token = 1;}  goto BC; \n\nfi;\n}\n\nactive proctype ArmControler() { \n\nAC0: if\n::  d_step {token==1 &&  ! (brick==4 && timer>3);token = 2;}  goto AC0; \n\n::  d_step {token==1 && brick==4 && timer>3;brick = 0;arm_kicking = 1;belt1_moving = 0;token = 2;}  goto AC1; \n\nfi;\nAC1: if\n::  d_step {token==1;arm_kicking = 0;belt1_moving = 1;token = 2;}  goto AC0; \n\nfi;\n}\n\nactive proctype Belt2Controler() { \nbyte t1=0;\n\nB2C0: if\n::  d_step {token==2 &&  ! (brick==3 && timer>7);token = 3;}  goto B2C0; \n\n::  d_step {token==2 && (brick==3 && timer>7);t1 = 0;}  goto tmp; \n\nfi;\ntmp: if\n::  d_step {requests>0;belt2_moving = 2;token = 3;}  goto B2C1; \n\n::  d_step {requests==0;belt2_moving = 1;token = 3;}  goto B2C1; \n\nfi;\nB2C1: if\n::  d_step {token==2 && t1<4;t1 = t1+1;token = 3;}  goto B2C1; \n\n::  d_step {token==2 && t1==4;token = 3;}  goto B2C0; \n\nfi;\n}\n\nactive proctype LightControler() { \nbyte x=0;\n\nLC0: if\n::  d_step {token==3 && light_sensor_level==0;token = 4;}  goto LC0; \n\n::  d_step {token==3 && light_sensor_level==1;x = 1;token = 4;}  goto LC1; \n\nfi;\ntmp: if\n::  d_step {x<=2;brick = 3;token = 4;}  goto LC0; \n\n::  d_step {x>2;brick = 4;token = 4;}  goto LC0; \n\nfi;\nLC1: if\n::  d_step {token==3 && light_sensor_level==1;x = x+1;token = 4;}  goto LC1; \n\n::  d_step {token==3 && light_sensor_level==0;timer = 0;}  goto tmp; \n\nfi;\n}\n\nactive proctype TimerStep() { \n\nT0: if\n::  d_step {token==4 && timer<8;timer = timer+1;token = 5;}  goto T0; \n\n::  d_step {token==4 && timer==8;token = 5;}  goto T0; \n\nfi;\n}\n\nactive proctype User() { \nbyte t2=0;\n\nU0: if\n::  d_step {token==5;token = 6;}  goto U0; \n\n::  d_step {token==5;button_pressed = 1;token = 6;}  goto U0; \n\n::  d_step {token==5;put_short_brick = 1;t2 = 1;token = 6;}  goto Wait; \n\n::  d_step {token==5;put_long_brick = 1;t2 = 3;token = 6;}  goto Wait; \n\nfi;\nWait: if\n::  d_step {token==5 && t2>0;t2 = t2-1;token = 6;}  goto Wait; \n\n::  d_step {token==5 && t2==0;token = 6;}  goto U0; \n\nfi;\n}\n\nactive proctype ShortBrick1() { \nbyte location=0;\nbyte position=0;\n\nB: if\n::  d_step {token==6 && location==0 && put_short_brick==0;token = 0;}  goto B; \n\n::  d_step {token==6 && location==0 && put_short_brick==1;put_short_brick = 0;location = 1;token = 0;}  goto B; \n\n::  d_step {token==6 && location==1 && (position<3 || position==4 || (position>5 && position<10)) && belt1_moving==1;position = position+1;token = 0;}  goto B; \n\n::  d_step {token==6 && location==1 && belt1_moving==1 && position==3;light_sensor_level = 1;position = position+1;token = 0;}  goto B; \n\n::  d_step {token==6 && location==1 && belt1_moving==1 && position==5;light_sensor_level = 0;position = position+1;token = 0;}  goto B; \n\n::  d_step {token==6 && location==1 && position==10 && arm_kicking==0 && belt1_moving==1;position = position+1;token = 0;}  goto B; \n\n::  d_step {token==6 && location==1 && position==11 && arm_kicking==0 && belt1_moving==1;location = 2;position = 3;token = 0;}  goto B; \n\n::  d_step {token==6 && location==1 && belt1_moving==0 && position<10;token = 0;}  goto B; \n\n::  d_step {token==6 && location==1 && belt1_moving==0 && (position==10 || position==11) && arm_kicking==0;token = 0;}  goto B; \n\n::  d_step {token==6 && location==1 && (position==10 || position==11) && arm_kicking==1;location = 3;token = 0;}  goto B; \n\n::  d_step {token==6 && location==2 && belt2_moving==1 && position<5;position = position+1;token = 0;}  goto B; \n\n::  d_step {token==6 && location==2 && belt2_moving==2 && position>0;position = position-1;token = 0;}  goto B; \n\n::  d_step {token==6 && location==2 && belt2_moving==0;token = 0;}  goto B; \n\n::  d_step {token==6 && location==2 && belt2_moving==1 && position==5;location = 4;token = 0;}  goto B; \n\n::  d_step {token==6 && location==2 && belt2_moving==2 && position==0;location = 5;token = 0;}  goto B; \n\n::  d_step {location==5 || location==4 || location==3;token = 0;}  goto B; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The example is a model of a sorter of bricks built using a Lego\n  Mindstorms systems. The Sorter  consists of the following parts:\n 2 belts which are used to transport bricks, a light sensor which can detect passing bricks, an arm which can kick bricks from the belt, a button which is used to \"order\" bricks for processing.\nThe intended behaviour of the system is the following. Bricks are placed by\nthe user on the first belt. Bricks which are too long (length\nis detected with the use of light sensor) are kicked out from the belt by the\narm. Short bricks are transported to the second belt. The second belt\ntransports them either to a \"processing\" side or to a \"not-processing\" side\ndepending on whether a brick has been ordered by pressing the button.\nAlthough the system is rather simple and artificial, it has several features\ntypical for embedded systems. The model is discrete time.\n\nParameters:"}, {"role": "assistant", "content": "byte token=0;\nbyte belt1_moving=1;\nbyte belt2_moving=0;\nbyte arm_kicking=0;\nbyte light_sensor_level=0;\nbyte button_pressed=0;\nbyte put_short_brick=0;\nbyte put_long_brick=0;\nbyte requests=0;\nbyte timer=0;\nbyte brick=0;\n\n\nactive proctype ButtonControler() { \n\nBC: if\n::  d_step {token==0 && button_pressed==0;token = 1;}  goto BC; \n\n::  d_step {token==0 && button_pressed==1 && requests<5;button_pressed = 0;requests = requests+1;token = 1;}  goto BC; \n\n::  d_step {token==0 && button_pressed==1 && requests==5;button_pressed = 0;token = 1;}  goto BC; \n\nfi;\n}\n\nactive proctype ArmControler() { \n\nAC0: if\n::  d_step {token==1 &&  ! (brick==4 && timer>3);token = 2;}  goto AC0; \n\n::  d_step {token==1 && brick==4 && timer>3;brick = 0;arm_kicking = 1;belt1_moving = 0;token = 2;}  goto AC1; \n\nfi;\nAC1: if\n::  d_step {token==1;arm_kicking = 0;belt1_moving = 1;token = 2;}  goto AC0; \n\nfi;\n}\n\nactive proctype Belt2Controler() { \nbyte t1=0;\n\nB2C0: if\n::  d_step {token==2 &&  ! (brick==3 && timer>7);token = 3;}  goto B2C0; \n\n::  d_step {token==2 && (brick==3 && timer>7);t1 = 0;}  goto tmp; \n\nfi;\ntmp: if\n::  d_step {requests>0;belt2_moving = 2;token = 3;}  goto B2C1; \n\n::  d_step {requests==0;belt2_moving = 1;token = 3;}  goto B2C1; \n\nfi;\nB2C1: if\n::  d_step {token==2 && t1<4;t1 = t1+1;token = 3;}  goto B2C1; \n\n::  d_step {token==2 && t1==4;token = 3;}  goto B2C0; \n\nfi;\n}\n\nactive proctype LightControler() { \nbyte x=0;\n\nLC0: if\n::  d_step {token==3 && light_sensor_level==0;token = 4;}  goto LC0; \n\n::  d_step {token==3 && light_sensor_level==1;x = 1;token = 4;}  goto LC1; \n\nfi;\ntmp: if\n::  d_step {x<=2;brick = 3;token = 4;}  goto LC0; \n\n::  d_step {x>2;brick = 4;token = 4;}  goto LC0; \n\nfi;\nLC1: if\n::  d_step {token==3 && light_sensor_level==1;x = x+1;token = 4;}  goto LC1; \n\n::  d_step {token==3 && light_sensor_level==0;timer = 0;}  goto tmp; \n\nfi;\n}\n\nactive proctype TimerStep() { \n\nT0: if\n::  d_step {token==4 && timer<8;timer = timer+1;token = 5;}  goto T0; \n\n::  d_step {token==4 && timer==8;token = 5;}  goto T0; \n\nfi;\n}\n\nactive proctype User() { \nbyte t2=0;\n\nU0: if\n::  d_step {token==5;token = 6;}  goto U0; \n\n::  d_step {token==5;button_pressed = 1;token = 6;}  goto U0; \n\n::  d_step {token==5;put_short_brick = 1;t2 = 1;token = 6;}  goto Wait; \n\n::  d_step {token==5;put_long_brick = 1;t2 = 3;token = 6;}  goto Wait; \n\nfi;\nWait: if\n::  d_step {token==5 && t2>0;t2 = t2-1;token = 6;}  goto Wait; \n\n::  d_step {token==5 && t2==0;token = 6;}  goto U0; \n\nfi;\n}\n\nactive proctype LongBrick1() { \nbyte location=0;\nbyte position=0;\n\nB: if\n::  d_step {token==6 && location==0 && put_long_brick==0;token = 0;}  goto B; \n\n::  d_step {token==6 && location==0 && put_long_brick==1;put_long_brick = 0;location = 1;token = 0;}  goto B; \n\n::  d_step {token==6 && location==1 && belt1_moving==1 && (position==0 || (position>1 && position<5) || (position>5 && position<8));position = position+1;token = 0;}  goto B; \n\n::  d_step {token==6 && location==1 && belt1_moving==1 && position==1;light_sensor_level = 1;position = position+1;token = 0;}  goto B; \n\n::  d_step {token==6 && location==1 && belt1_moving==1 && position==5;light_sensor_level = 0;position = position+1;token = 0;}  goto B; \n\n::  d_step {token==6 && location==1 && (position>=8 && position<=10) && arm_kicking==0 && belt1_moving==1;position = position+1;token = 0;}  goto B; \n\n::  d_step {token==6 && location==1 && position==11 && arm_kicking==0 && belt1_moving==1;location = 2;position = 3;token = 0;}  goto B; \n\n::  d_step {token==6 && location==1 && belt1_moving==0 && position<8;token = 0;}  goto B; \n\n::  d_step {token==6 && location==1 && belt1_moving==0 && (position>=8 || position==11) && arm_kicking==0;token = 0;}  goto B; \n\n::  d_step {token==6 && location==1 && position>=8 && arm_kicking==1;location = 3;token = 0;}  goto B; \n\n::  d_step {token==6 && location==2 && belt2_moving==1 && position<5;position = position+1;token = 0;}  goto B; \n\n::  d_step {token==6 && location==2 && belt2_moving==2 && position>0;position = position-1;token = 0;}  goto B; \n\n::  d_step {token==6 && location==2 && belt2_moving==0;token = 0;}  goto B; \n\n::  d_step {token==6 && location==2 && belt2_moving==1 && position==5;location = 4;token = 0;}  goto B; \n\n::  d_step {token==6 && location==2 && belt2_moving==2 && position==0;location = 5;token = 0;}  goto B; \n\n::  d_step {location==5 || location==4 || location==3;token = 0;}  goto B; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The example is a model of a sorter of bricks built using a Lego\n  Mindstorms systems. The Sorter  consists of the following parts:\n 2 belts which are used to transport bricks, a light sensor which can detect passing bricks, an arm which can kick bricks from the belt, a button which is used to \"order\" bricks for processing.\nThe intended behaviour of the system is the following. Bricks are placed by\nthe user on the first belt. Bricks which are too long (length\nis detected with the use of light sensor) are kicked out from the belt by the\narm. Short bricks are transported to the second belt. The second belt\ntransports them either to a \"processing\" side or to a \"not-processing\" side\ndepending on whether a brick has been ordered by pressing the button.\nAlthough the system is rather simple and artificial, it has several features\ntypical for embedded systems. The model is discrete time.\n\nParameters:"}, {"role": "assistant", "content": "byte token=0;\nbyte belt1_moving=1;\nbyte belt2_moving=0;\nbyte arm_kicking=0;\nbyte light_sensor_level=0;\nbyte button_pressed=0;\nbyte put_short_brick=0;\nbyte put_long_brick=0;\nbyte requests=0;\nbyte timer=0;\nbyte brick=0;\n\n\nactive proctype ButtonControler() { \n\nBC: if\n::  d_step {token==0 && button_pressed==0;token = 1;}  goto BC; \n\n::  d_step {token==0 && button_pressed==1 && requests<5;button_pressed = 0;requests = requests+1;token = 1;}  goto BC; \n\n::  d_step {token==0 && button_pressed==1 && requests==5;button_pressed = 0;token = 1;}  goto BC; \n\nfi;\n}\n\nactive proctype ArmControler() { \n\nAC0: if\n::  d_step {token==1 &&  ! (brick==4 && timer>3);token = 2;}  goto AC0; \n\n::  d_step {token==1 && brick==4 && timer>3;brick = 0;arm_kicking = 1;belt1_moving = 0;token = 2;}  goto AC1; \n\nfi;\nAC1: if\n::  d_step {token==1;arm_kicking = 0;belt1_moving = 1;token = 2;}  goto AC0; \n\nfi;\n}\n\nactive proctype Belt2Controler() { \nbyte t1=0;\n\nB2C0: if\n::  d_step {token==2 &&  ! (brick==3 && timer>7);token = 3;}  goto B2C0; \n\n::  d_step {token==2 && (brick==3 && timer>7);t1 = 0;}  goto tmp; \n\nfi;\ntmp: if\n::  d_step {requests>0;belt2_moving = 2;token = 3;}  goto B2C1; \n\n::  d_step {requests==0;belt2_moving = 1;token = 3;}  goto B2C1; \n\nfi;\nB2C1: if\n::  d_step {token==2 && t1<4;t1 = t1+1;token = 3;}  goto B2C1; \n\n::  d_step {token==2 && t1==4;token = 3;}  goto B2C0; \n\nfi;\n}\n\nactive proctype LightControler() { \nbyte x=0;\n\nLC0: if\n::  d_step {token==3 && light_sensor_level==0;token = 4;}  goto LC0; \n\n::  d_step {token==3 && light_sensor_level==1;x = 1;token = 4;}  goto LC1; \n\nfi;\ntmp: if\n::  d_step {x<=2;brick = 3;token = 4;}  goto LC0; \n\n::  d_step {x>2;brick = 4;token = 4;}  goto LC0; \n\nfi;\nLC1: if\n::  d_step {token==3 && light_sensor_level==1;x = x+1;token = 4;}  goto LC1; \n\n::  d_step {token==3 && light_sensor_level==0;timer = 0;}  goto tmp; \n\nfi;\n}\n\nactive proctype TimerStep() { \n\nT0: if\n::  d_step {token==4 && timer<8;timer = timer+1;token = 5;}  goto T0; \n\n::  d_step {token==4 && timer==8;token = 5;}  goto T0; \n\nfi;\n}\n\nactive proctype User() { \nbyte t2=0;\n\nU0: if\n::  d_step {token==5;token = 6;}  goto U0; \n\n::  d_step {token==5;button_pressed = 1;token = 6;}  goto U0; \n\n::  d_step {token==5;put_short_brick = 1;t2 = 1;token = 6;}  goto Wait; \n\n::  d_step {token==5;put_long_brick = 1;t2 = 3;token = 6;}  goto Wait; \n\nfi;\nWait: if\n::  d_step {token==5 && t2>0;t2 = t2-1;token = 6;}  goto Wait; \n\n::  d_step {token==5 && t2==0;token = 6;}  goto U0; \n\nfi;\n}\n\nactive proctype ShortBrick1() { \nbyte location=0;\nbyte position=0;\n\nB: if\n::  d_step {token==6 && location==0 && put_short_brick==0;token = 7;}  goto B; \n\n::  d_step {token==6 && location==0 && put_short_brick==1;put_short_brick = 0;location = 1;token = 7;}  goto B; \n\n::  d_step {token==6 && location==1 && (position<3 || position==4 || (position>5 && position<10)) && belt1_moving==1;position = position+1;token = 7;}  goto B; \n\n::  d_step {token==6 && location==1 && belt1_moving==1 && position==3;light_sensor_level = 1;position = position+1;token = 7;}  goto B; \n\n::  d_step {token==6 && location==1 && belt1_moving==1 && position==5;light_sensor_level = 0;position = position+1;token = 7;}  goto B; \n\n::  d_step {token==6 && location==1 && position==10 && arm_kicking==0 && belt1_moving==1;position = position+1;token = 7;}  goto B; \n\n::  d_step {token==6 && location==1 && position==11 && arm_kicking==0 && belt1_moving==1;location = 2;position = 3;token = 7;}  goto B; \n\n::  d_step {token==6 && location==1 && belt1_moving==0 && position<10;token = 7;}  goto B; \n\n::  d_step {token==6 && location==1 && belt1_moving==0 && (position==10 || position==11) && arm_kicking==0;token = 7;}  goto B; \n\n::  d_step {token==6 && location==1 && (position==10 || position==11) && arm_kicking==1;location = 3;token = 7;}  goto B; \n\n::  d_step {token==6 && location==2 && belt2_moving==1 && position<5;position = position+1;token = 7;}  goto B; \n\n::  d_step {token==6 && location==2 && belt2_moving==2 && position>0;position = position-1;token = 7;}  goto B; \n\n::  d_step {token==6 && location==2 && belt2_moving==0;token = 7;}  goto B; \n\n::  d_step {token==6 && location==2 && belt2_moving==1 && position==5;location = 4;token = 7;}  goto B; \n\n::  d_step {token==6 && location==2 && belt2_moving==2 && position==0;location = 5;token = 7;}  goto B; \n\n::  d_step {location==5 || location==4 || location==3;token = 7;}  goto B; \n\nfi;\n}\n\nactive proctype ShortBrick2() { \nbyte location=0;\nbyte position=0;\n\nB: if\n::  d_step {token==7 && location==0 && put_short_brick==0;token = 0;}  goto B; \n\n::  d_step {token==7 && location==0 && put_short_brick==1;put_short_brick = 0;location = 1;token = 0;}  goto B; \n\n::  d_step {token==7 && location==1 && (position<3 || position==4 || (position>5 && position<10)) && belt1_moving==1;position = position+1;token = 0;}  goto B; \n\n::  d_step {token==7 && location==1 && belt1_moving==1 && position==3;light_sensor_level = 1;position = position+1;token = 0;}  goto B; \n\n::  d_step {token==7 && location==1 && belt1_moving==1 && position==5;light_sensor_level = 0;position = position+1;token = 0;}  goto B; \n\n::  d_step {token==7 && location==1 && position==10 && arm_kicking==0 && belt1_moving==1;position = position+1;token = 0;}  goto B; \n\n::  d_step {token==7 && location==1 && position==11 && arm_kicking==0 && belt1_moving==1;location = 2;position = 3;token = 0;}  goto B; \n\n::  d_step {token==7 && location==1 && belt1_moving==0 && position<10;token = 0;}  goto B; \n\n::  d_step {token==7 && location==1 && belt1_moving==0 && (position==10 || position==11) && arm_kicking==0;token = 0;}  goto B; \n\n::  d_step {token==7 && location==1 && (position==10 || position==11) && arm_kicking==1;location = 3;token = 0;}  goto B; \n\n::  d_step {token==7 && location==2 && belt2_moving==1 && position<5;position = position+1;token = 0;}  goto B; \n\n::  d_step {token==7 && location==2 && belt2_moving==2 && position>0;position = position-1;token = 0;}  goto B; \n\n::  d_step {token==7 && location==2 && belt2_moving==0;token = 0;}  goto B; \n\n::  d_step {token==7 && location==2 && belt2_moving==1 && position==5;location = 4;token = 0;}  goto B; \n\n::  d_step {token==7 && location==2 && belt2_moving==2 && position==0;location = 5;token = 0;}  goto B; \n\n::  d_step {location==5 || location==4 || location==3;token = 0;}  goto B; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The example is a model of a sorter of bricks built using a Lego\n  Mindstorms systems. The Sorter  consists of the following parts:\n 2 belts which are used to transport bricks, a light sensor which can detect passing bricks, an arm which can kick bricks from the belt, a button which is used to \"order\" bricks for processing.\nThe intended behaviour of the system is the following. Bricks are placed by\nthe user on the first belt. Bricks which are too long (length\nis detected with the use of light sensor) are kicked out from the belt by the\narm. Short bricks are transported to the second belt. The second belt\ntransports them either to a \"processing\" side or to a \"not-processing\" side\ndepending on whether a brick has been ordered by pressing the button.\nAlthough the system is rather simple and artificial, it has several features\ntypical for embedded systems. The model is discrete time.\n\nParameters:"}, {"role": "assistant", "content": "byte token=0;\nbyte belt1_moving=1;\nbyte belt2_moving=0;\nbyte arm_kicking=0;\nbyte light_sensor_level=0;\nbyte button_pressed=0;\nbyte put_short_brick=0;\nbyte put_long_brick=0;\nbyte requests=0;\nbyte timer=0;\nbyte brick=0;\n\n\nactive proctype ButtonControler() { \n\nBC: if\n::  d_step {token==0 && button_pressed==0;token = 1;}  goto BC; \n\n::  d_step {token==0 && button_pressed==1 && requests<5;button_pressed = 0;requests = requests+1;token = 1;}  goto BC; \n\n::  d_step {token==0 && button_pressed==1 && requests==5;button_pressed = 0;token = 1;}  goto BC; \n\nfi;\n}\n\nactive proctype ArmControler() { \n\nAC0: if\n::  d_step {token==1 &&  ! (brick==4 && timer>3);token = 2;}  goto AC0; \n\n::  d_step {token==1 && brick==4 && timer>3;brick = 0;arm_kicking = 1;belt1_moving = 0;token = 2;}  goto AC1; \n\nfi;\nAC1: if\n::  d_step {token==1;arm_kicking = 0;belt1_moving = 1;token = 2;}  goto AC0; \n\nfi;\n}\n\nactive proctype Belt2Controler() { \nbyte t1=0;\n\nB2C0: if\n::  d_step {token==2 &&  ! (brick==3 && timer>7);token = 3;}  goto B2C0; \n\n::  d_step {token==2 && (brick==3 && timer>7);t1 = 0;}  goto tmp; \n\nfi;\ntmp: if\n::  d_step {requests>0;belt2_moving = 2;token = 3;}  goto B2C1; \n\n::  d_step {requests==0;belt2_moving = 1;token = 3;}  goto B2C1; \n\nfi;\nB2C1: if\n::  d_step {token==2 && t1<4;t1 = t1+1;token = 3;}  goto B2C1; \n\n::  d_step {token==2 && t1==4;token = 3;}  goto B2C0; \n\nfi;\n}\n\nactive proctype LightControler() { \nbyte x=0;\n\nLC0: if\n::  d_step {token==3 && light_sensor_level==0;token = 4;}  goto LC0; \n\n::  d_step {token==3 && light_sensor_level==1;x = 1;token = 4;}  goto LC1; \n\nfi;\ntmp: if\n::  d_step {x<=2;brick = 3;token = 4;}  goto LC0; \n\n::  d_step {x>2;brick = 4;token = 4;}  goto LC0; \n\nfi;\nLC1: if\n::  d_step {token==3 && light_sensor_level==1;x = x+1;token = 4;}  goto LC1; \n\n::  d_step {token==3 && light_sensor_level==0;timer = 0;}  goto tmp; \n\nfi;\n}\n\nactive proctype TimerStep() { \n\nT0: if\n::  d_step {token==4 && timer<8;timer = timer+1;token = 5;}  goto T0; \n\n::  d_step {token==4 && timer==8;token = 5;}  goto T0; \n\nfi;\n}\n\nactive proctype User() { \nbyte t2=0;\n\nU0: if\n::  d_step {token==5;token = 6;}  goto U0; \n\n::  d_step {token==5;button_pressed = 1;token = 6;}  goto U0; \n\n::  d_step {token==5;put_short_brick = 1;t2 = 1;token = 6;}  goto Wait; \n\n::  d_step {token==5;put_long_brick = 1;t2 = 3;token = 6;}  goto Wait; \n\nfi;\nWait: if\n::  d_step {token==5 && t2>0;t2 = t2-1;token = 6;}  goto Wait; \n\n::  d_step {token==5 && t2==0;token = 6;}  goto U0; \n\nfi;\n}\n\nactive proctype ShortBrick1() { \nbyte location=0;\nbyte position=0;\n\nB: if\n::  d_step {token==6 && location==0 && put_short_brick==0;token = 7;}  goto B; \n\n::  d_step {token==6 && location==0 && put_short_brick==1;put_short_brick = 0;location = 1;token = 7;}  goto B; \n\n::  d_step {token==6 && location==1 && (position<3 || position==4 || (position>5 && position<10)) && belt1_moving==1;position = position+1;token = 7;}  goto B; \n\n::  d_step {token==6 && location==1 && belt1_moving==1 && position==3;light_sensor_level = 1;position = position+1;token = 7;}  goto B; \n\n::  d_step {token==6 && location==1 && belt1_moving==1 && position==5;light_sensor_level = 0;position = position+1;token = 7;}  goto B; \n\n::  d_step {token==6 && location==1 && position==10 && arm_kicking==0 && belt1_moving==1;position = position+1;token = 7;}  goto B; \n\n::  d_step {token==6 && location==1 && position==11 && arm_kicking==0 && belt1_moving==1;location = 2;position = 3;token = 7;}  goto B; \n\n::  d_step {token==6 && location==1 && belt1_moving==0 && position<10;token = 7;}  goto B; \n\n::  d_step {token==6 && location==1 && belt1_moving==0 && (position==10 || position==11) && arm_kicking==0;token = 7;}  goto B; \n\n::  d_step {token==6 && location==1 && (position==10 || position==11) && arm_kicking==1;location = 3;token = 7;}  goto B; \n\n::  d_step {token==6 && location==2 && belt2_moving==1 && position<5;position = position+1;token = 7;}  goto B; \n\n::  d_step {token==6 && location==2 && belt2_moving==2 && position>0;position = position-1;token = 7;}  goto B; \n\n::  d_step {token==6 && location==2 && belt2_moving==0;token = 7;}  goto B; \n\n::  d_step {token==6 && location==2 && belt2_moving==1 && position==5;location = 4;token = 7;}  goto B; \n\n::  d_step {token==6 && location==2 && belt2_moving==2 && position==0;location = 5;token = 7;}  goto B; \n\n::  d_step {location==5 || location==4 || location==3;token = 7;}  goto B; \n\nfi;\n}\n\nactive proctype LongBrick2() { \nbyte location=0;\nbyte position=0;\n\nB: if\n::  d_step {token==7 && location==0 && put_long_brick==0;token = 0;}  goto B; \n\n::  d_step {token==7 && location==0 && put_long_brick==1;put_long_brick = 0;location = 1;token = 0;}  goto B; \n\n::  d_step {token==7 && location==1 && belt1_moving==1 && (position==0 || (position>1 && position<5) || (position>5 && position<8));position = position+1;token = 0;}  goto B; \n\n::  d_step {token==7 && location==1 && belt1_moving==1 && position==1;light_sensor_level = 1;position = position+1;token = 0;}  goto B; \n\n::  d_step {token==7 && location==1 && belt1_moving==1 && position==5;light_sensor_level = 0;position = position+1;token = 0;}  goto B; \n\n::  d_step {token==7 && location==1 && (position>=8 && position<=10) && arm_kicking==0 && belt1_moving==1;position = position+1;token = 0;}  goto B; \n\n::  d_step {token==7 && location==1 && position==11 && arm_kicking==0 && belt1_moving==1;location = 2;position = 3;token = 0;}  goto B; \n\n::  d_step {token==7 && location==1 && belt1_moving==0 && position<8;token = 0;}  goto B; \n\n::  d_step {token==7 && location==1 && belt1_moving==0 && (position>=8 || position==11) && arm_kicking==0;token = 0;}  goto B; \n\n::  d_step {token==7 && location==1 && position>=8 && arm_kicking==1;location = 3;token = 0;}  goto B; \n\n::  d_step {token==7 && location==2 && belt2_moving==1 && position<5;position = position+1;token = 0;}  goto B; \n\n::  d_step {token==7 && location==2 && belt2_moving==2 && position>0;position = position-1;token = 0;}  goto B; \n\n::  d_step {token==7 && location==2 && belt2_moving==0;token = 0;}  goto B; \n\n::  d_step {token==7 && location==2 && belt2_moving==1 && position==5;location = 4;token = 0;}  goto B; \n\n::  d_step {token==7 && location==2 && belt2_moving==2 && position==0;location = 5;token = 0;}  goto B; \n\n::  d_step {location==5 || location==4 || location==3;token = 0;}  goto B; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The example is a model of a sorter of bricks built using a Lego\n  Mindstorms systems. The Sorter  consists of the following parts:\n 2 belts which are used to transport bricks, a light sensor which can detect passing bricks, an arm which can kick bricks from the belt, a button which is used to \"order\" bricks for processing.\nThe intended behaviour of the system is the following. Bricks are placed by\nthe user on the first belt. Bricks which are too long (length\nis detected with the use of light sensor) are kicked out from the belt by the\narm. Short bricks are transported to the second belt. The second belt\ntransports them either to a \"processing\" side or to a \"not-processing\" side\ndepending on whether a brick has been ordered by pressing the button.\nAlthough the system is rather simple and artificial, it has several features\ntypical for embedded systems. The model is discrete time.\n\nParameters:"}, {"role": "assistant", "content": "byte token=0;\nbyte belt1_moving=1;\nbyte belt2_moving=0;\nbyte arm_kicking=0;\nbyte light_sensor_level=0;\nbyte button_pressed=0;\nbyte put_short_brick=0;\nbyte put_long_brick=0;\nbyte requests=0;\nbyte timer=0;\nbyte brick=0;\n\n\nactive proctype ButtonControler() { \n\nBC: if\n::  d_step {token==0 && button_pressed==0;token = 1;}  goto BC; \n\n::  d_step {token==0 && button_pressed==1 && requests<5;button_pressed = 0;requests = requests+1;token = 1;}  goto BC; \n\n::  d_step {token==0 && button_pressed==1 && requests==5;button_pressed = 0;token = 1;}  goto BC; \n\nfi;\n}\n\nactive proctype ArmControler() { \n\nAC0: if\n::  d_step {token==1 &&  ! (brick==4 && timer>3);token = 2;}  goto AC0; \n\n::  d_step {token==1 && brick==4 && timer>3;brick = 0;arm_kicking = 1;belt1_moving = 0;token = 2;}  goto AC1; \n\nfi;\nAC1: if\n::  d_step {token==1;arm_kicking = 0;belt1_moving = 1;token = 2;}  goto AC0; \n\nfi;\n}\n\nactive proctype Belt2Controler() { \nbyte t1=0;\n\nB2C0: if\n::  d_step {token==2 &&  ! (brick==3 && timer>7);token = 3;}  goto B2C0; \n\n::  d_step {token==2 && (brick==3 && timer>7);t1 = 0;}  goto tmp; \n\nfi;\ntmp: if\n::  d_step {requests>0;belt2_moving = 2;token = 3;}  goto B2C1; \n\n::  d_step {requests==0;belt2_moving = 1;token = 3;}  goto B2C1; \n\nfi;\nB2C1: if\n::  d_step {token==2 && t1<4;t1 = t1+1;token = 3;}  goto B2C1; \n\n::  d_step {token==2 && t1==4;token = 3;}  goto B2C0; \n\nfi;\n}\n\nactive proctype LightControler() { \nbyte x=0;\n\nLC0: if\n::  d_step {token==3 && light_sensor_level==0;token = 4;}  goto LC0; \n\n::  d_step {token==3 && light_sensor_level==1;x = 1;token = 4;}  goto LC1; \n\nfi;\ntmp: if\n::  d_step {x<=2;brick = 3;token = 4;}  goto LC0; \n\n::  d_step {x>2;brick = 4;token = 4;}  goto LC0; \n\nfi;\nLC1: if\n::  d_step {token==3 && light_sensor_level==1;x = x+1;token = 4;}  goto LC1; \n\n::  d_step {token==3 && light_sensor_level==0;timer = 0;}  goto tmp; \n\nfi;\n}\n\nactive proctype TimerStep() { \n\nT0: if\n::  d_step {token==4 && timer<8;timer = timer+1;token = 5;}  goto T0; \n\n::  d_step {token==4 && timer==8;token = 5;}  goto T0; \n\nfi;\n}\n\nactive proctype User() { \nbyte t2=0;\n\nU0: if\n::  d_step {token==5;token = 6;}  goto U0; \n\n::  d_step {token==5;button_pressed = 1;token = 6;}  goto U0; \n\n::  d_step {token==5;put_short_brick = 1;t2 = 1;token = 6;}  goto Wait; \n\n::  d_step {token==5;put_long_brick = 1;t2 = 3;token = 6;}  goto Wait; \n\nfi;\nWait: if\n::  d_step {token==5 && t2>0;t2 = t2-1;token = 6;}  goto Wait; \n\n::  d_step {token==5 && t2==0;token = 6;}  goto U0; \n\nfi;\n}\n\nactive proctype LongBrick1() { \nbyte location=0;\nbyte position=0;\n\nB: if\n::  d_step {token==6 && location==0 && put_long_brick==0;token = 7;}  goto B; \n\n::  d_step {token==6 && location==0 && put_long_brick==1;put_long_brick = 0;location = 1;token = 7;}  goto B; \n\n::  d_step {token==6 && location==1 && belt1_moving==1 && (position==0 || (position>1 && position<5) || (position>5 && position<8));position = position+1;token = 7;}  goto B; \n\n::  d_step {token==6 && location==1 && belt1_moving==1 && position==1;light_sensor_level = 1;position = position+1;token = 7;}  goto B; \n\n::  d_step {token==6 && location==1 && belt1_moving==1 && position==5;light_sensor_level = 0;position = position+1;token = 7;}  goto B; \n\n::  d_step {token==6 && location==1 && (position>=8 && position<=10) && arm_kicking==0 && belt1_moving==1;position = position+1;token = 7;}  goto B; \n\n::  d_step {token==6 && location==1 && position==11 && arm_kicking==0 && belt1_moving==1;location = 2;position = 3;token = 7;}  goto B; \n\n::  d_step {token==6 && location==1 && belt1_moving==0 && position<8;token = 7;}  goto B; \n\n::  d_step {token==6 && location==1 && belt1_moving==0 && (position>=8 || position==11) && arm_kicking==0;token = 7;}  goto B; \n\n::  d_step {token==6 && location==1 && position>=8 && arm_kicking==1;location = 3;token = 7;}  goto B; \n\n::  d_step {token==6 && location==2 && belt2_moving==1 && position<5;position = position+1;token = 7;}  goto B; \n\n::  d_step {token==6 && location==2 && belt2_moving==2 && position>0;position = position-1;token = 7;}  goto B; \n\n::  d_step {token==6 && location==2 && belt2_moving==0;token = 7;}  goto B; \n\n::  d_step {token==6 && location==2 && belt2_moving==1 && position==5;location = 4;token = 7;}  goto B; \n\n::  d_step {token==6 && location==2 && belt2_moving==2 && position==0;location = 5;token = 7;}  goto B; \n\n::  d_step {location==5 || location==4 || location==3;token = 7;}  goto B; \n\nfi;\n}\n\nactive proctype LongBrick2() { \nbyte location=0;\nbyte position=0;\n\nB: if\n::  d_step {token==7 && location==0 && put_long_brick==0;token = 0;}  goto B; \n\n::  d_step {token==7 && location==0 && put_long_brick==1;put_long_brick = 0;location = 1;token = 0;}  goto B; \n\n::  d_step {token==7 && location==1 && belt1_moving==1 && (position==0 || (position>1 && position<5) || (position>5 && position<8));position = position+1;token = 0;}  goto B; \n\n::  d_step {token==7 && location==1 && belt1_moving==1 && position==1;light_sensor_level = 1;position = position+1;token = 0;}  goto B; \n\n::  d_step {token==7 && location==1 && belt1_moving==1 && position==5;light_sensor_level = 0;position = position+1;token = 0;}  goto B; \n\n::  d_step {token==7 && location==1 && (position>=8 && position<=10) && arm_kicking==0 && belt1_moving==1;position = position+1;token = 0;}  goto B; \n\n::  d_step {token==7 && location==1 && position==11 && arm_kicking==0 && belt1_moving==1;location = 2;position = 3;token = 0;}  goto B; \n\n::  d_step {token==7 && location==1 && belt1_moving==0 && position<8;token = 0;}  goto B; \n\n::  d_step {token==7 && location==1 && belt1_moving==0 && (position>=8 || position==11) && arm_kicking==0;token = 0;}  goto B; \n\n::  d_step {token==7 && location==1 && position>=8 && arm_kicking==1;location = 3;token = 0;}  goto B; \n\n::  d_step {token==7 && location==2 && belt2_moving==1 && position<5;position = position+1;token = 0;}  goto B; \n\n::  d_step {token==7 && location==2 && belt2_moving==2 && position>0;position = position-1;token = 0;}  goto B; \n\n::  d_step {token==7 && location==2 && belt2_moving==0;token = 0;}  goto B; \n\n::  d_step {token==7 && location==2 && belt2_moving==1 && position==5;location = 4;token = 0;}  goto B; \n\n::  d_step {token==7 && location==2 && belt2_moving==2 && position==0;location = 5;token = 0;}  goto B; \n\n::  d_step {location==5 || location==4 || location==3;token = 0;}  goto B; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually. This is szymanski's three-bit linear wait algorithm for\n    mutual exclusion. See also other mutex examples.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte a[3];\nbyte w[3];\nbyte s[3];\n\n\nactive proctype P_0() { \nbyte j=0;\n\nNCS: if\n::  d_step {a[0] = 1;j = 0;}  goto p2; \n\nfi;\np2: if\n::  d_step {j<3 && s[j]==0;j = j+1;}  goto p2; \n\n:: j==3; goto p3; \n\nfi;\np3: if\n::  d_step {w[0] = 1;a[0] = 0;}  goto p4; \n\nfi;\np4: if\n::  d_step {s[0]==1;j = 0;}  goto p9; \n\n::  d_step {s[0]==0;j = 0;}  goto p5; \n\nfi;\np5: if\n::  d_step {j<3 && a[j]==0;j = j+1;}  goto p5; \n\n::  ! (j<3 && a[j]==0); goto p6; \n\nfi;\np6: if\n:: j<3; goto p7; \n\n::  d_step {j==3;s[0] = 1;j = 0;}  goto p61; \n\nfi;\np61: if\n::  d_step {j<3 && a[j]==0;j = j+1;}  goto p61; \n\n::  d_step {j<3 && a[j]==1;s[0] = 0;}  goto p7; \n\n::  d_step {j==3;w[0] = 0;j = 0;}  goto p64; \n\nfi;\np64: if\n::  d_step {j<3 && w[j]==0;j = j+1;}  goto p64; \n\n:: j==3; goto p7; \n\nfi;\np7: if\n:: j==3; goto p8; \n\n::  d_step {j<3;j = 0;}  goto p71; \n\nfi;\np71: if\n::  d_step {j<3 && (w[j]==1 || s[j]==0);j = j+1;}  goto p71; \n\n::  ! (j<3 && (w[j]==1 || s[j]==0)); goto p8; \n\nfi;\np8: if\n::  d_step {j!=0 && j<3;s[0] = 1;w[0] = 0;}  goto p4; \n\n::  ! (j!=0 && j<3); goto p4; \n\nfi;\np9: if\n::  d_step {j<0 && w[j]==0 && s[j]==0;j = j+1;}  goto p9; \n\n:: j==0; goto CS; \n\nfi;\nCS: if\n:: s[0] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte j=0;\n\nNCS: if\n::  d_step {a[1] = 1;j = 0;}  goto p2; \n\nfi;\np2: if\n::  d_step {j<3 && s[j]==0;j = j+1;}  goto p2; \n\n:: j==3; goto p3; \n\nfi;\np3: if\n::  d_step {w[1] = 1;a[1] = 0;}  goto p4; \n\nfi;\np4: if\n::  d_step {s[1]==1;j = 0;}  goto p9; \n\n::  d_step {s[1]==0;j = 0;}  goto p5; \n\nfi;\np5: if\n::  d_step {j<3 && a[j]==0;j = j+1;}  goto p5; \n\n::  ! (j<3 && a[j]==0); goto p6; \n\nfi;\np6: if\n:: j<3; goto p7; \n\n::  d_step {j==3;s[1] = 1;j = 0;}  goto p61; \n\nfi;\np61: if\n::  d_step {j<3 && a[j]==0;j = j+1;}  goto p61; \n\n::  d_step {j<3 && a[j]==1;s[1] = 0;}  goto p7; \n\n::  d_step {j==3;w[1] = 0;j = 0;}  goto p64; \n\nfi;\np64: if\n::  d_step {j<3 && w[j]==0;j = j+1;}  goto p64; \n\n:: j==3; goto p7; \n\nfi;\np7: if\n:: j==3; goto p8; \n\n::  d_step {j<3;j = 0;}  goto p71; \n\nfi;\np71: if\n::  d_step {j<3 && (w[j]==1 || s[j]==0);j = j+1;}  goto p71; \n\n::  ! (j<3 && (w[j]==1 || s[j]==0)); goto p8; \n\nfi;\np8: if\n::  d_step {j!=1 && j<3;s[1] = 1;w[1] = 0;}  goto p4; \n\n::  ! (j!=1 && j<3); goto p4; \n\nfi;\np9: if\n::  d_step {j<1 && w[j]==0 && s[j]==0;j = j+1;}  goto p9; \n\n:: j==1; goto CS; \n\nfi;\nCS: if\n:: s[1] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte j=0;\n\nNCS: if\n::  d_step {a[2] = 1;j = 0;}  goto p2; \n\nfi;\np2: if\n::  d_step {j<3 && s[j]==0;j = j+1;}  goto p2; \n\n:: j==3; goto p3; \n\nfi;\np3: if\n::  d_step {w[2] = 1;a[2] = 0;}  goto p4; \n\nfi;\np4: if\n::  d_step {s[2]==1;j = 0;}  goto p9; \n\n::  d_step {s[2]==0;j = 0;}  goto p5; \n\nfi;\np5: if\n::  d_step {j<3 && a[j]==0;j = j+1;}  goto p5; \n\n::  ! (j<3 && a[j]==0); goto p6; \n\nfi;\np6: if\n:: j<3; goto p7; \n\n::  d_step {j==3;s[2] = 1;j = 0;}  goto p61; \n\nfi;\np61: if\n::  d_step {j<3 && a[j]==0;j = j+1;}  goto p61; \n\n::  d_step {j<3 && a[j]==1;s[2] = 0;}  goto p7; \n\n::  d_step {j==3;w[2] = 0;j = 0;}  goto p64; \n\nfi;\np64: if\n::  d_step {j<3 && w[j]==0;j = j+1;}  goto p64; \n\n:: j==3; goto p7; \n\nfi;\np7: if\n:: j==3; goto p8; \n\n::  d_step {j<3;j = 0;}  goto p71; \n\nfi;\np71: if\n::  d_step {j<3 && (w[j]==1 || s[j]==0);j = j+1;}  goto p71; \n\n::  ! (j<3 && (w[j]==1 || s[j]==0)); goto p8; \n\nfi;\np8: if\n::  d_step {j!=2 && j<3;s[2] = 1;w[2] = 0;}  goto p4; \n\n::  ! (j!=2 && j<3); goto p4; \n\nfi;\np9: if\n::  d_step {j<2 && w[j]==0 && s[j]==0;j = j+1;}  goto p9; \n\n:: j==2; goto CS; \n\nfi;\nCS: if\n:: s[2] = 0; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually. This is szymanski's three-bit linear wait algorithm for\n    mutual exclusion. See also other mutex examples.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte a[3];\nbyte w[3];\nbyte s[3];\n\n\nactive proctype P_0() { \nbyte j=0;\n\nNCS: if\n::  d_step {a[0] = 1;j = 0;}  goto p2; \n\nfi;\np2: if\n::  d_step {j<3 && s[j]==0;j = j+1;}  goto p2; \n\n:: j==3; goto p3; \n\nfi;\np3: if\n::  d_step {w[0] = 1;a[0] = 0;}  goto p4; \n\nfi;\np4: if\n::  d_step {s[0]==1;j = 0;}  goto p9; \n\n::  d_step {s[0]==0;j = 0;}  goto p5; \n\nfi;\np5: if\n::  d_step {j<3 && a[j]==0;j = j+1;}  goto p5; \n\n::  ! (j<3 && a[j]==0); goto p6; \n\nfi;\np6: if\n:: j<3; goto p7; \n\n::  d_step {j==3;s[0] = 1;j = 0;}  goto p61; \n\nfi;\np61: if\n::  d_step {j<3 && a[j]==0;j = j+1;}  goto p61; \n\n::  d_step {j<3 && a[j]==1;s[0] = 0;}  goto p7; \n\n::  d_step {j==3;w[0] = 0;j = 0;}  goto p64; \n\nfi;\np64: if\n::  d_step {j<3 && w[j]==0;j = j+1;}  goto p64; \n\n:: j==3; goto p7; \n\nfi;\np7: if\n:: j==3; goto p8; \n\n::  d_step {j<3;j = 0;}  goto p71; \n\nfi;\np71: if\n::  d_step {j<3 && w[j]==1 && s[j]==0;j = j+1;}  goto p71; \n\n::  ! (j<3 && (w[j]==1 && s[j]==0)); goto p8; \n\nfi;\np8: if\n::  d_step {j!=0 && j<3;s[0] = 1;w[0] = 0;}  goto p4; \n\n::  ! (j!=0 && j<3); goto p4; \n\nfi;\np9: if\n::  d_step {j<0 && w[j]==0 && s[j]==0;j = j+1;}  goto p9; \n\n:: j==0; goto CS; \n\nfi;\nCS: if\n:: s[0] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte j=0;\n\nNCS: if\n::  d_step {a[1] = 1;j = 0;}  goto p2; \n\nfi;\np2: if\n::  d_step {j<3 && s[j]==0;j = j+1;}  goto p2; \n\n:: j==3; goto p3; \n\nfi;\np3: if\n::  d_step {w[1] = 1;a[1] = 0;}  goto p4; \n\nfi;\np4: if\n::  d_step {s[1]==1;j = 0;}  goto p9; \n\n::  d_step {s[1]==0;j = 0;}  goto p5; \n\nfi;\np5: if\n::  d_step {j<3 && a[j]==0;j = j+1;}  goto p5; \n\n::  ! (j<3 && a[j]==0); goto p6; \n\nfi;\np6: if\n:: j<3; goto p7; \n\n::  d_step {j==3;s[1] = 1;j = 0;}  goto p61; \n\nfi;\np61: if\n::  d_step {j<3 && a[j]==0;j = j+1;}  goto p61; \n\n::  d_step {j<3 && a[j]==1;s[1] = 0;}  goto p7; \n\n::  d_step {j==3;w[1] = 0;j = 0;}  goto p64; \n\nfi;\np64: if\n::  d_step {j<3 && w[j]==0;j = j+1;}  goto p64; \n\n:: j==3; goto p7; \n\nfi;\np7: if\n:: j==3; goto p8; \n\n::  d_step {j<3;j = 0;}  goto p71; \n\nfi;\np71: if\n::  d_step {j<3 && w[j]==1 && s[j]==0;j = j+1;}  goto p71; \n\n::  ! (j<3 && (w[j]==1 && s[j]==0)); goto p8; \n\nfi;\np8: if\n::  d_step {j!=1 && j<3;s[1] = 1;w[1] = 0;}  goto p4; \n\n::  ! (j!=1 && j<3); goto p4; \n\nfi;\np9: if\n::  d_step {j<1 && w[j]==0 && s[j]==0;j = j+1;}  goto p9; \n\n:: j==1; goto CS; \n\nfi;\nCS: if\n:: s[1] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte j=0;\n\nNCS: if\n::  d_step {a[2] = 1;j = 0;}  goto p2; \n\nfi;\np2: if\n::  d_step {j<3 && s[j]==0;j = j+1;}  goto p2; \n\n:: j==3; goto p3; \n\nfi;\np3: if\n::  d_step {w[2] = 1;a[2] = 0;}  goto p4; \n\nfi;\np4: if\n::  d_step {s[2]==1;j = 0;}  goto p9; \n\n::  d_step {s[2]==0;j = 0;}  goto p5; \n\nfi;\np5: if\n::  d_step {j<3 && a[j]==0;j = j+1;}  goto p5; \n\n::  ! (j<3 && a[j]==0); goto p6; \n\nfi;\np6: if\n:: j<3; goto p7; \n\n::  d_step {j==3;s[2] = 1;j = 0;}  goto p61; \n\nfi;\np61: if\n::  d_step {j<3 && a[j]==0;j = j+1;}  goto p61; \n\n::  d_step {j<3 && a[j]==1;s[2] = 0;}  goto p7; \n\n::  d_step {j==3;w[2] = 0;j = 0;}  goto p64; \n\nfi;\np64: if\n::  d_step {j<3 && w[j]==0;j = j+1;}  goto p64; \n\n:: j==3; goto p7; \n\nfi;\np7: if\n:: j==3; goto p8; \n\n::  d_step {j<3;j = 0;}  goto p71; \n\nfi;\np71: if\n::  d_step {j<3 && w[j]==1 && s[j]==0;j = j+1;}  goto p71; \n\n::  ! (j<3 && (w[j]==1 && s[j]==0)); goto p8; \n\nfi;\np8: if\n::  d_step {j!=2 && j<3;s[2] = 1;w[2] = 0;}  goto p4; \n\n::  ! (j!=2 && j<3); goto p4; \n\nfi;\np9: if\n::  d_step {j<2 && w[j]==0 && s[j]==0;j = j+1;}  goto p9; \n\n:: j==2; goto CS; \n\nfi;\nCS: if\n:: s[2] = 0; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually. This is szymanski's three-bit linear wait algorithm for\n    mutual exclusion. See also other mutex examples.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte a[4];\nbyte w[4];\nbyte s[4];\n\n\nactive proctype P_0() { \nbyte j=0;\n\nNCS: if\n::  d_step {a[0] = 1;j = 0;}  goto p2; \n\nfi;\np2: if\n::  d_step {j<4 && s[j]==0;j = j+1;}  goto p2; \n\n:: j==4; goto p3; \n\nfi;\np3: if\n::  d_step {w[0] = 1;a[0] = 0;}  goto p4; \n\nfi;\np4: if\n::  d_step {s[0]==1;j = 0;}  goto p9; \n\n::  d_step {s[0]==0;j = 0;}  goto p5; \n\nfi;\np5: if\n::  d_step {j<4 && a[j]==0;j = j+1;}  goto p5; \n\n::  ! (j<4 && a[j]==0); goto p6; \n\nfi;\np6: if\n:: j<4; goto p7; \n\n::  d_step {j==4;s[0] = 1;j = 0;}  goto p61; \n\nfi;\np61: if\n::  d_step {j<4 && a[j]==0;j = j+1;}  goto p61; \n\n::  d_step {j<4 && a[j]==1;s[0] = 0;}  goto p7; \n\n::  d_step {j==4;w[0] = 0;j = 0;}  goto p64; \n\nfi;\np64: if\n::  d_step {j<4 && w[j]==0;j = j+1;}  goto p64; \n\n:: j==4; goto p7; \n\nfi;\np7: if\n:: j==4; goto p8; \n\n::  d_step {j<4;j = 0;}  goto p71; \n\nfi;\np71: if\n::  d_step {j<4 && (w[j]==1 || s[j]==0);j = j+1;}  goto p71; \n\n::  ! (j<4 && (w[j]==1 || s[j]==0)); goto p8; \n\nfi;\np8: if\n::  d_step {j!=0 && j<4;s[0] = 1;w[0] = 0;}  goto p4; \n\n::  ! (j!=0 && j<4); goto p4; \n\nfi;\np9: if\n::  d_step {j<0 && w[j]==0 && s[j]==0;j = j+1;}  goto p9; \n\n:: j==0; goto CS; \n\nfi;\nCS: if\n:: s[0] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte j=0;\n\nNCS: if\n::  d_step {a[1] = 1;j = 0;}  goto p2; \n\nfi;\np2: if\n::  d_step {j<4 && s[j]==0;j = j+1;}  goto p2; \n\n:: j==4; goto p3; \n\nfi;\np3: if\n::  d_step {w[1] = 1;a[1] = 0;}  goto p4; \n\nfi;\np4: if\n::  d_step {s[1]==1;j = 0;}  goto p9; \n\n::  d_step {s[1]==0;j = 0;}  goto p5; \n\nfi;\np5: if\n::  d_step {j<4 && a[j]==0;j = j+1;}  goto p5; \n\n::  ! (j<4 && a[j]==0); goto p6; \n\nfi;\np6: if\n:: j<4; goto p7; \n\n::  d_step {j==4;s[1] = 1;j = 0;}  goto p61; \n\nfi;\np61: if\n::  d_step {j<4 && a[j]==0;j = j+1;}  goto p61; \n\n::  d_step {j<4 && a[j]==1;s[1] = 0;}  goto p7; \n\n::  d_step {j==4;w[1] = 0;j = 0;}  goto p64; \n\nfi;\np64: if\n::  d_step {j<4 && w[j]==0;j = j+1;}  goto p64; \n\n:: j==4; goto p7; \n\nfi;\np7: if\n:: j==4; goto p8; \n\n::  d_step {j<4;j = 0;}  goto p71; \n\nfi;\np71: if\n::  d_step {j<4 && (w[j]==1 || s[j]==0);j = j+1;}  goto p71; \n\n::  ! (j<4 && (w[j]==1 || s[j]==0)); goto p8; \n\nfi;\np8: if\n::  d_step {j!=1 && j<4;s[1] = 1;w[1] = 0;}  goto p4; \n\n::  ! (j!=1 && j<4); goto p4; \n\nfi;\np9: if\n::  d_step {j<1 && w[j]==0 && s[j]==0;j = j+1;}  goto p9; \n\n:: j==1; goto CS; \n\nfi;\nCS: if\n:: s[1] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte j=0;\n\nNCS: if\n::  d_step {a[2] = 1;j = 0;}  goto p2; \n\nfi;\np2: if\n::  d_step {j<4 && s[j]==0;j = j+1;}  goto p2; \n\n:: j==4; goto p3; \n\nfi;\np3: if\n::  d_step {w[2] = 1;a[2] = 0;}  goto p4; \n\nfi;\np4: if\n::  d_step {s[2]==1;j = 0;}  goto p9; \n\n::  d_step {s[2]==0;j = 0;}  goto p5; \n\nfi;\np5: if\n::  d_step {j<4 && a[j]==0;j = j+1;}  goto p5; \n\n::  ! (j<4 && a[j]==0); goto p6; \n\nfi;\np6: if\n:: j<4; goto p7; \n\n::  d_step {j==4;s[2] = 1;j = 0;}  goto p61; \n\nfi;\np61: if\n::  d_step {j<4 && a[j]==0;j = j+1;}  goto p61; \n\n::  d_step {j<4 && a[j]==1;s[2] = 0;}  goto p7; \n\n::  d_step {j==4;w[2] = 0;j = 0;}  goto p64; \n\nfi;\np64: if\n::  d_step {j<4 && w[j]==0;j = j+1;}  goto p64; \n\n:: j==4; goto p7; \n\nfi;\np7: if\n:: j==4; goto p8; \n\n::  d_step {j<4;j = 0;}  goto p71; \n\nfi;\np71: if\n::  d_step {j<4 && (w[j]==1 || s[j]==0);j = j+1;}  goto p71; \n\n::  ! (j<4 && (w[j]==1 || s[j]==0)); goto p8; \n\nfi;\np8: if\n::  d_step {j!=2 && j<4;s[2] = 1;w[2] = 0;}  goto p4; \n\n::  ! (j!=2 && j<4); goto p4; \n\nfi;\np9: if\n::  d_step {j<2 && w[j]==0 && s[j]==0;j = j+1;}  goto p9; \n\n:: j==2; goto CS; \n\nfi;\nCS: if\n:: s[2] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_3() { \nbyte j=0;\n\nNCS: if\n::  d_step {a[3] = 1;j = 0;}  goto p2; \n\nfi;\np2: if\n::  d_step {j<4 && s[j]==0;j = j+1;}  goto p2; \n\n:: j==4; goto p3; \n\nfi;\np3: if\n::  d_step {w[3] = 1;a[3] = 0;}  goto p4; \n\nfi;\np4: if\n::  d_step {s[3]==1;j = 0;}  goto p9; \n\n::  d_step {s[3]==0;j = 0;}  goto p5; \n\nfi;\np5: if\n::  d_step {j<4 && a[j]==0;j = j+1;}  goto p5; \n\n::  ! (j<4 && a[j]==0); goto p6; \n\nfi;\np6: if\n:: j<4; goto p7; \n\n::  d_step {j==4;s[3] = 1;j = 0;}  goto p61; \n\nfi;\np61: if\n::  d_step {j<4 && a[j]==0;j = j+1;}  goto p61; \n\n::  d_step {j<4 && a[j]==1;s[3] = 0;}  goto p7; \n\n::  d_step {j==4;w[3] = 0;j = 0;}  goto p64; \n\nfi;\np64: if\n::  d_step {j<4 && w[j]==0;j = j+1;}  goto p64; \n\n:: j==4; goto p7; \n\nfi;\np7: if\n:: j==4; goto p8; \n\n::  d_step {j<4;j = 0;}  goto p71; \n\nfi;\np71: if\n::  d_step {j<4 && (w[j]==1 || s[j]==0);j = j+1;}  goto p71; \n\n::  ! (j<4 && (w[j]==1 || s[j]==0)); goto p8; \n\nfi;\np8: if\n::  d_step {j!=3 && j<4;s[3] = 1;w[3] = 0;}  goto p4; \n\n::  ! (j!=3 && j<4); goto p4; \n\nfi;\np9: if\n::  d_step {j<3 && w[j]==0 && s[j]==0;j = j+1;}  goto p9; \n\n:: j==3; goto CS; \n\nfi;\nCS: if\n:: s[3] = 0; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually. This is szymanski's three-bit linear wait algorithm for\n    mutual exclusion. See also other mutex examples.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte a[4];\nbyte w[4];\nbyte s[4];\n\n\nactive proctype P_0() { \nbyte j=0;\n\nNCS: if\n::  d_step {a[0] = 1;j = 0;}  goto p2; \n\nfi;\np2: if\n::  d_step {j<4 && s[j]==0;j = j+1;}  goto p2; \n\n:: j==4; goto p3; \n\nfi;\np3: if\n::  d_step {w[0] = 1;a[0] = 0;}  goto p4; \n\nfi;\np4: if\n::  d_step {s[0]==1;j = 0;}  goto p9; \n\n::  d_step {s[0]==0;j = 0;}  goto p5; \n\nfi;\np5: if\n::  d_step {j<4 && a[j]==0;j = j+1;}  goto p5; \n\n::  ! (j<4 && a[j]==0); goto p6; \n\nfi;\np6: if\n:: j<4; goto p7; \n\n::  d_step {j==4;s[0] = 1;j = 0;}  goto p61; \n\nfi;\np61: if\n::  d_step {j<4 && a[j]==0;j = j+1;}  goto p61; \n\n::  d_step {j<4 && a[j]==1;s[0] = 0;}  goto p7; \n\n::  d_step {j==4;w[0] = 0;j = 0;}  goto p64; \n\nfi;\np64: if\n::  d_step {j<4 && w[j]==0;j = j+1;}  goto p64; \n\n:: j==4; goto p7; \n\nfi;\np7: if\n:: j==4; goto p8; \n\n::  d_step {j<4;j = 0;}  goto p71; \n\nfi;\np71: if\n::  d_step {j<4 && w[j]==1 && s[j]==0;j = j+1;}  goto p71; \n\n::  ! (j<4 && (w[j]==1 && s[j]==0)); goto p8; \n\nfi;\np8: if\n::  d_step {j!=0 && j<4;s[0] = 1;w[0] = 0;}  goto p4; \n\n::  ! (j!=0 && j<4); goto p4; \n\nfi;\np9: if\n::  d_step {j<0 && w[j]==0 && s[j]==0;j = j+1;}  goto p9; \n\n:: j==0; goto CS; \n\nfi;\nCS: if\n:: s[0] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte j=0;\n\nNCS: if\n::  d_step {a[1] = 1;j = 0;}  goto p2; \n\nfi;\np2: if\n::  d_step {j<4 && s[j]==0;j = j+1;}  goto p2; \n\n:: j==4; goto p3; \n\nfi;\np3: if\n::  d_step {w[1] = 1;a[1] = 0;}  goto p4; \n\nfi;\np4: if\n::  d_step {s[1]==1;j = 0;}  goto p9; \n\n::  d_step {s[1]==0;j = 0;}  goto p5; \n\nfi;\np5: if\n::  d_step {j<4 && a[j]==0;j = j+1;}  goto p5; \n\n::  ! (j<4 && a[j]==0); goto p6; \n\nfi;\np6: if\n:: j<4; goto p7; \n\n::  d_step {j==4;s[1] = 1;j = 0;}  goto p61; \n\nfi;\np61: if\n::  d_step {j<4 && a[j]==0;j = j+1;}  goto p61; \n\n::  d_step {j<4 && a[j]==1;s[1] = 0;}  goto p7; \n\n::  d_step {j==4;w[1] = 0;j = 0;}  goto p64; \n\nfi;\np64: if\n::  d_step {j<4 && w[j]==0;j = j+1;}  goto p64; \n\n:: j==4; goto p7; \n\nfi;\np7: if\n:: j==4; goto p8; \n\n::  d_step {j<4;j = 0;}  goto p71; \n\nfi;\np71: if\n::  d_step {j<4 && w[j]==1 && s[j]==0;j = j+1;}  goto p71; \n\n::  ! (j<4 && (w[j]==1 && s[j]==0)); goto p8; \n\nfi;\np8: if\n::  d_step {j!=1 && j<4;s[1] = 1;w[1] = 0;}  goto p4; \n\n::  ! (j!=1 && j<4); goto p4; \n\nfi;\np9: if\n::  d_step {j<1 && w[j]==0 && s[j]==0;j = j+1;}  goto p9; \n\n:: j==1; goto CS; \n\nfi;\nCS: if\n:: s[1] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte j=0;\n\nNCS: if\n::  d_step {a[2] = 1;j = 0;}  goto p2; \n\nfi;\np2: if\n::  d_step {j<4 && s[j]==0;j = j+1;}  goto p2; \n\n:: j==4; goto p3; \n\nfi;\np3: if\n::  d_step {w[2] = 1;a[2] = 0;}  goto p4; \n\nfi;\np4: if\n::  d_step {s[2]==1;j = 0;}  goto p9; \n\n::  d_step {s[2]==0;j = 0;}  goto p5; \n\nfi;\np5: if\n::  d_step {j<4 && a[j]==0;j = j+1;}  goto p5; \n\n::  ! (j<4 && a[j]==0); goto p6; \n\nfi;\np6: if\n:: j<4; goto p7; \n\n::  d_step {j==4;s[2] = 1;j = 0;}  goto p61; \n\nfi;\np61: if\n::  d_step {j<4 && a[j]==0;j = j+1;}  goto p61; \n\n::  d_step {j<4 && a[j]==1;s[2] = 0;}  goto p7; \n\n::  d_step {j==4;w[2] = 0;j = 0;}  goto p64; \n\nfi;\np64: if\n::  d_step {j<4 && w[j]==0;j = j+1;}  goto p64; \n\n:: j==4; goto p7; \n\nfi;\np7: if\n:: j==4; goto p8; \n\n::  d_step {j<4;j = 0;}  goto p71; \n\nfi;\np71: if\n::  d_step {j<4 && w[j]==1 && s[j]==0;j = j+1;}  goto p71; \n\n::  ! (j<4 && (w[j]==1 && s[j]==0)); goto p8; \n\nfi;\np8: if\n::  d_step {j!=2 && j<4;s[2] = 1;w[2] = 0;}  goto p4; \n\n::  ! (j!=2 && j<4); goto p4; \n\nfi;\np9: if\n::  d_step {j<2 && w[j]==0 && s[j]==0;j = j+1;}  goto p9; \n\n:: j==2; goto CS; \n\nfi;\nCS: if\n:: s[2] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_3() { \nbyte j=0;\n\nNCS: if\n::  d_step {a[3] = 1;j = 0;}  goto p2; \n\nfi;\np2: if\n::  d_step {j<4 && s[j]==0;j = j+1;}  goto p2; \n\n:: j==4; goto p3; \n\nfi;\np3: if\n::  d_step {w[3] = 1;a[3] = 0;}  goto p4; \n\nfi;\np4: if\n::  d_step {s[3]==1;j = 0;}  goto p9; \n\n::  d_step {s[3]==0;j = 0;}  goto p5; \n\nfi;\np5: if\n::  d_step {j<4 && a[j]==0;j = j+1;}  goto p5; \n\n::  ! (j<4 && a[j]==0); goto p6; \n\nfi;\np6: if\n:: j<4; goto p7; \n\n::  d_step {j==4;s[3] = 1;j = 0;}  goto p61; \n\nfi;\np61: if\n::  d_step {j<4 && a[j]==0;j = j+1;}  goto p61; \n\n::  d_step {j<4 && a[j]==1;s[3] = 0;}  goto p7; \n\n::  d_step {j==4;w[3] = 0;j = 0;}  goto p64; \n\nfi;\np64: if\n::  d_step {j<4 && w[j]==0;j = j+1;}  goto p64; \n\n:: j==4; goto p7; \n\nfi;\np7: if\n:: j==4; goto p8; \n\n::  d_step {j<4;j = 0;}  goto p71; \n\nfi;\np71: if\n::  d_step {j<4 && w[j]==1 && s[j]==0;j = j+1;}  goto p71; \n\n::  ! (j<4 && (w[j]==1 && s[j]==0)); goto p8; \n\nfi;\np8: if\n::  d_step {j!=3 && j<4;s[3] = 1;w[3] = 0;}  goto p4; \n\n::  ! (j!=3 && j<4); goto p4; \n\nfi;\np9: if\n::  d_step {j<3 && w[j]==0 && s[j]==0;j = j+1;}  goto p9; \n\n:: j==3; goto CS; \n\nfi;\nCS: if\n:: s[3] = 0; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Situations, where two or more processes are reading\n    and/or writing some shared data and the final result depends on who runs\n    precisely when, are called race conditions. Code sections containing race\n    conditions can be regarded as \"critical\", because such code can lead to\n    inconsistent data. To avoid inconsistence in critical sections, exclusive\n    access to shared data must be granted. This is called mutual exclusion,\n    because if two processes compete for access then they have to exclude each\n    other mutually. This is szymanski's three-bit linear wait algorithm for\n    mutual exclusion. See also other mutex examples.\n\nParameters:\n\n\n\nAtomic propositions:\n, , , \n\nProperties to verify:"}, {"role": "assistant", "content": "byte a[5];\nbyte w[5];\nbyte s[5];\n\n\nactive proctype P_0() { \nbyte j=0;\n\nNCS: if\n::  d_step {a[0] = 1;j = 0;}  goto p2; \n\nfi;\np2: if\n::  d_step {j<5 && s[j]==0;j = j+1;}  goto p2; \n\n:: j==5; goto p3; \n\nfi;\np3: if\n::  d_step {w[0] = 1;a[0] = 0;}  goto p4; \n\nfi;\np4: if\n::  d_step {s[0]==1;j = 0;}  goto p9; \n\n::  d_step {s[0]==0;j = 0;}  goto p5; \n\nfi;\np5: if\n::  d_step {j<5 && a[j]==0;j = j+1;}  goto p5; \n\n::  ! (j<5 && a[j]==0); goto p6; \n\nfi;\np6: if\n:: j<5; goto p7; \n\n::  d_step {j==5;s[0] = 1;j = 0;}  goto p61; \n\nfi;\np61: if\n::  d_step {j<5 && a[j]==0;j = j+1;}  goto p61; \n\n::  d_step {j<5 && a[j]==1;s[0] = 0;}  goto p7; \n\n::  d_step {j==5;w[0] = 0;j = 0;}  goto p64; \n\nfi;\np64: if\n::  d_step {j<5 && w[j]==0;j = j+1;}  goto p64; \n\n:: j==5; goto p7; \n\nfi;\np7: if\n:: j==5; goto p8; \n\n::  d_step {j<5;j = 0;}  goto p71; \n\nfi;\np71: if\n::  d_step {j<5 && (w[j]==1 || s[j]==0);j = j+1;}  goto p71; \n\n::  ! (j<5 && (w[j]==1 || s[j]==0)); goto p8; \n\nfi;\np8: if\n::  d_step {j!=0 && j<5;s[0] = 1;w[0] = 0;}  goto p4; \n\n::  ! (j!=0 && j<5); goto p4; \n\nfi;\np9: if\n::  d_step {j<0 && w[j]==0 && s[j]==0;j = j+1;}  goto p9; \n\n:: j==0; goto CS; \n\nfi;\nCS: if\n:: s[0] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_1() { \nbyte j=0;\n\nNCS: if\n::  d_step {a[1] = 1;j = 0;}  goto p2; \n\nfi;\np2: if\n::  d_step {j<5 && s[j]==0;j = j+1;}  goto p2; \n\n:: j==5; goto p3; \n\nfi;\np3: if\n::  d_step {w[1] = 1;a[1] = 0;}  goto p4; \n\nfi;\np4: if\n::  d_step {s[1]==1;j = 0;}  goto p9; \n\n::  d_step {s[1]==0;j = 0;}  goto p5; \n\nfi;\np5: if\n::  d_step {j<5 && a[j]==0;j = j+1;}  goto p5; \n\n::  ! (j<5 && a[j]==0); goto p6; \n\nfi;\np6: if\n:: j<5; goto p7; \n\n::  d_step {j==5;s[1] = 1;j = 0;}  goto p61; \n\nfi;\np61: if\n::  d_step {j<5 && a[j]==0;j = j+1;}  goto p61; \n\n::  d_step {j<5 && a[j]==1;s[1] = 0;}  goto p7; \n\n::  d_step {j==5;w[1] = 0;j = 0;}  goto p64; \n\nfi;\np64: if\n::  d_step {j<5 && w[j]==0;j = j+1;}  goto p64; \n\n:: j==5; goto p7; \n\nfi;\np7: if\n:: j==5; goto p8; \n\n::  d_step {j<5;j = 0;}  goto p71; \n\nfi;\np71: if\n::  d_step {j<5 && (w[j]==1 || s[j]==0);j = j+1;}  goto p71; \n\n::  ! (j<5 && (w[j]==1 || s[j]==0)); goto p8; \n\nfi;\np8: if\n::  d_step {j!=1 && j<5;s[1] = 1;w[1] = 0;}  goto p4; \n\n::  ! (j!=1 && j<5); goto p4; \n\nfi;\np9: if\n::  d_step {j<1 && w[j]==0 && s[j]==0;j = j+1;}  goto p9; \n\n:: j==1; goto CS; \n\nfi;\nCS: if\n:: s[1] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_2() { \nbyte j=0;\n\nNCS: if\n::  d_step {a[2] = 1;j = 0;}  goto p2; \n\nfi;\np2: if\n::  d_step {j<5 && s[j]==0;j = j+1;}  goto p2; \n\n:: j==5; goto p3; \n\nfi;\np3: if\n::  d_step {w[2] = 1;a[2] = 0;}  goto p4; \n\nfi;\np4: if\n::  d_step {s[2]==1;j = 0;}  goto p9; \n\n::  d_step {s[2]==0;j = 0;}  goto p5; \n\nfi;\np5: if\n::  d_step {j<5 && a[j]==0;j = j+1;}  goto p5; \n\n::  ! (j<5 && a[j]==0); goto p6; \n\nfi;\np6: if\n:: j<5; goto p7; \n\n::  d_step {j==5;s[2] = 1;j = 0;}  goto p61; \n\nfi;\np61: if\n::  d_step {j<5 && a[j]==0;j = j+1;}  goto p61; \n\n::  d_step {j<5 && a[j]==1;s[2] = 0;}  goto p7; \n\n::  d_step {j==5;w[2] = 0;j = 0;}  goto p64; \n\nfi;\np64: if\n::  d_step {j<5 && w[j]==0;j = j+1;}  goto p64; \n\n:: j==5; goto p7; \n\nfi;\np7: if\n:: j==5; goto p8; \n\n::  d_step {j<5;j = 0;}  goto p71; \n\nfi;\np71: if\n::  d_step {j<5 && (w[j]==1 || s[j]==0);j = j+1;}  goto p71; \n\n::  ! (j<5 && (w[j]==1 || s[j]==0)); goto p8; \n\nfi;\np8: if\n::  d_step {j!=2 && j<5;s[2] = 1;w[2] = 0;}  goto p4; \n\n::  ! (j!=2 && j<5); goto p4; \n\nfi;\np9: if\n::  d_step {j<2 && w[j]==0 && s[j]==0;j = j+1;}  goto p9; \n\n:: j==2; goto CS; \n\nfi;\nCS: if\n:: s[2] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_3() { \nbyte j=0;\n\nNCS: if\n::  d_step {a[3] = 1;j = 0;}  goto p2; \n\nfi;\np2: if\n::  d_step {j<5 && s[j]==0;j = j+1;}  goto p2; \n\n:: j==5; goto p3; \n\nfi;\np3: if\n::  d_step {w[3] = 1;a[3] = 0;}  goto p4; \n\nfi;\np4: if\n::  d_step {s[3]==1;j = 0;}  goto p9; \n\n::  d_step {s[3]==0;j = 0;}  goto p5; \n\nfi;\np5: if\n::  d_step {j<5 && a[j]==0;j = j+1;}  goto p5; \n\n::  ! (j<5 && a[j]==0); goto p6; \n\nfi;\np6: if\n:: j<5; goto p7; \n\n::  d_step {j==5;s[3] = 1;j = 0;}  goto p61; \n\nfi;\np61: if\n::  d_step {j<5 && a[j]==0;j = j+1;}  goto p61; \n\n::  d_step {j<5 && a[j]==1;s[3] = 0;}  goto p7; \n\n::  d_step {j==5;w[3] = 0;j = 0;}  goto p64; \n\nfi;\np64: if\n::  d_step {j<5 && w[j]==0;j = j+1;}  goto p64; \n\n:: j==5; goto p7; \n\nfi;\np7: if\n:: j==5; goto p8; \n\n::  d_step {j<5;j = 0;}  goto p71; \n\nfi;\np71: if\n::  d_step {j<5 && (w[j]==1 || s[j]==0);j = j+1;}  goto p71; \n\n::  ! (j<5 && (w[j]==1 || s[j]==0)); goto p8; \n\nfi;\np8: if\n::  d_step {j!=3 && j<5;s[3] = 1;w[3] = 0;}  goto p4; \n\n::  ! (j!=3 && j<5); goto p4; \n\nfi;\np9: if\n::  d_step {j<3 && w[j]==0 && s[j]==0;j = j+1;}  goto p9; \n\n:: j==3; goto CS; \n\nfi;\nCS: if\n:: s[3] = 0; goto NCS; \n\nfi;\n}\n\nactive proctype P_4() { \nbyte j=0;\n\nNCS: if\n::  d_step {a[4] = 1;j = 0;}  goto p2; \n\nfi;\np2: if\n::  d_step {j<5 && s[j]==0;j = j+1;}  goto p2; \n\n:: j==5; goto p3; \n\nfi;\np3: if\n::  d_step {w[4] = 1;a[4] = 0;}  goto p4; \n\nfi;\np4: if\n::  d_step {s[4]==1;j = 0;}  goto p9; \n\n::  d_step {s[4]==0;j = 0;}  goto p5; \n\nfi;\np5: if\n::  d_step {j<5 && a[j]==0;j = j+1;}  goto p5; \n\n::  ! (j<5 && a[j]==0); goto p6; \n\nfi;\np6: if\n:: j<5; goto p7; \n\n::  d_step {j==5;s[4] = 1;j = 0;}  goto p61; \n\nfi;\np61: if\n::  d_step {j<5 && a[j]==0;j = j+1;}  goto p61; \n\n::  d_step {j<5 && a[j]==1;s[4] = 0;}  goto p7; \n\n::  d_step {j==5;w[4] = 0;j = 0;}  goto p64; \n\nfi;\np64: if\n::  d_step {j<5 && w[j]==0;j = j+1;}  goto p64; \n\n:: j==5; goto p7; \n\nfi;\np7: if\n:: j==5; goto p8; \n\n::  d_step {j<5;j = 0;}  goto p71; \n\nfi;\np71: if\n::  d_step {j<5 && (w[j]==1 || s[j]==0);j = j+1;}  goto p71; \n\n::  ! (j<5 && (w[j]==1 || s[j]==0)); goto p8; \n\nfi;\np8: if\n::  d_step {j!=4 && j<5;s[4] = 1;w[4] = 0;}  goto p4; \n\n::  ! (j!=4 && j<5); goto p4; \n\nfi;\np9: if\n::  d_step {j<4 && w[j]==0 && s[j]==0;j = j+1;}  goto p9; \n\n:: j==4; goto CS; \n\nfi;\nCS: if\n:: s[4] = 0; goto NCS; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Model of a telecommunication service with some features\n    (call forward when busy, ring back when free).\n\nParameters:\n\n\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte chnl[2];\nbyte partner[2];\nbyte call_forward_busy[2];\nbyte record[2];\n\n\ninit { \n d_step { \nchnl[0] =255; chnl[1] =255; partner[0] =255; partner[1] =255; call_forward_busy[0] =1; call_forward_busy[1] =255; record[0] =255; record[1] =255; }\natomic { \nrun User_0();\nrun User_1();\n} }\n\nproctype User_0() { \nbyte dev=1;\nbyte mbit=0;\n\nidle: if\n::  d_step {chnl[0]==255;dev = 0;chnl[0] = ((0)+(0)*20);}  goto dialing; \n\n::  d_step {chnl[0]!=255;partner[0] = ((chnl[0])%20);}  goto q_i; \n\nfi;\ndialing: if\n::  d_step {dev = 1;chnl[0] = 255;}  goto idle; \n\n:: partner[0] = 0; goto calling; \n\n:: partner[0] = 1; goto calling; \n\n:: partner[0] = 2; goto calling; \n\nfi;\ncalling: if\n:: partner[0]==0; goto busy; \n\n:: partner[0]==2; goto unobtainable; \n\n:: partner[0]==2; goto ringback; \n\n::  d_step {partner[0]!=0 && partner[0]!=2 && chnl[partner[0]]!=255 && call_forward_busy[partner[0]]==255;record[partner[0]] = 0;}  goto busy; \n\n::  d_step {partner[0]!=0 && partner[0]!=2 && chnl[partner[0]]!=255 && call_forward_busy[partner[0]]!=255;record[partner[0]] = 0;partner[0] = call_forward_busy[partner[0]];}  goto calling; \n\n::  d_step {partner[0]!=0 && partner[0]!=2 && chnl[partner[0]]==255;record[partner[0]] = 0;chnl[partner[0]] = ((0)+(0)*20);chnl[0] = ((partner[0])+(0)*20);}  goto oalert; \n\nfi;\nbusy: if\n::  d_step {chnl[0] = 255;partner[0] = 255;dev = 1;}  goto idle; \n\nfi;\nq_i: if\n:: ((chnl[partner[0]])%20)==0; goto talert; \n\n::  d_step {((chnl[partner[0]])%20)!=0;partner[0] = 255;}  goto idle; \n\nfi;\ntalert: if\n:: dev!=1 || chnl[0]==255; goto error_state; \n\n:: ((chnl[partner[0]])%20)==0; goto tpickup; \n\n:: ((chnl[partner[0]])%20)!=0; goto idle; \n\nfi;\nunobtainable: if\n::  d_step {chnl[0] = 255;partner[0] = 255;dev = 1;}  goto idle; \n\nfi;\noalert: if\n:: ((chnl[0])%20)!=partner[0]; goto error_state; \n\n:: ((chnl[0])%20)==partner[0] && ((chnl[0])/20)==1; goto oconnected; \n\n:: ((chnl[0])%20)==partner[0] && ((chnl[0])/20)==0; goto oringout; \n\nfi;\noconnected: if\n::  d_step {dev = 1;chnl[0] = 255;chnl[partner[0]] = 255;}  goto idle; \n\nfi;\noringout: if\n::  d_step {dev = 1;chnl[0] = 255;partner[0] = ((((partner[0])%20))+(0)*20);}  goto idle; \n\nfi;\ntpickup: if\n::  d_step {((chnl[partner[0]])%20)==0 && ((chnl[partner[0]])/20)==0;dev = 0;chnl[partner[0]] = ((0)+(1)*20);chnl[0] = ((partner[0])+(1)*20);}  goto tconnected; \n\n::  d_step {chnl[partner[0]]==255 || ((chnl[partner[0]])%20)!=0;dev = 1;partner[0] = 255;chnl[0] = 255;}  goto idle; \n\nfi;\ntconnected: if\n::  d_step {((chnl[0])/20)==1 && dev==0;dev = 1;}  goto tconnected; \n\n::  d_step {((chnl[0])/20)==1 && dev==1;dev = 0;}  goto tconnected; \n\n::  d_step {((chnl[0])/20)==0;partner[0] = 255;chnl[0] = 255;}  goto idle; \n\nfi;\nringback: if\n::  d_step {chnl[0] = 255;partner[0] = 255;dev = 1;}  goto idle; \n\n::  d_step {record[0]!=255;partner[0] = record[0];}  goto calling; \n\nfi;\nerror_state: \n false; }\n\nproctype User_1() { \nbyte dev=1;\nbyte mbit=0;\n\nidle: if\n::  d_step {chnl[1]==255;dev = 0;chnl[1] = ((1)+(0)*20);}  goto dialing; \n\n::  d_step {chnl[1]!=255;partner[1] = ((chnl[1])%20);}  goto q_i; \n\nfi;\ndialing: if\n::  d_step {dev = 1;chnl[1] = 255;}  goto idle; \n\n:: partner[1] = 0; goto calling; \n\n:: partner[1] = 1; goto calling; \n\n:: partner[1] = 2; goto calling; \n\nfi;\ncalling: if\n:: partner[1]==1; goto busy; \n\n:: partner[1]==2; goto unobtainable; \n\n:: partner[1]==2; goto ringback; \n\n::  d_step {partner[1]!=1 && partner[1]!=2 && chnl[partner[1]]!=255 && call_forward_busy[partner[1]]==255;record[partner[1]] = 1;}  goto busy; \n\n::  d_step {partner[1]!=1 && partner[1]!=2 && chnl[partner[1]]!=255 && call_forward_busy[partner[1]]!=255;record[partner[1]] = 1;partner[1] = call_forward_busy[partner[1]];}  goto calling; \n\n::  d_step {partner[1]!=1 && partner[1]!=2 && chnl[partner[1]]==255;record[partner[1]] = 1;chnl[partner[1]] = ((1)+(0)*20);chnl[1] = ((partner[1])+(0)*20);}  goto oalert; \n\nfi;\nbusy: if\n::  d_step {chnl[1] = 255;partner[1] = 255;dev = 1;}  goto idle; \n\nfi;\nq_i: if\n:: ((chnl[partner[1]])%20)==1; goto talert; \n\n::  d_step {((chnl[partner[1]])%20)!=1;partner[1] = 255;}  goto idle; \n\nfi;\ntalert: if\n:: dev!=1 || chnl[1]==255; goto error_state; \n\n:: ((chnl[partner[1]])%20)==1; goto tpickup; \n\n:: ((chnl[partner[1]])%20)!=1; goto idle; \n\nfi;\nunobtainable: if\n::  d_step {chnl[1] = 255;partner[1] = 255;dev = 1;}  goto idle; \n\nfi;\noalert: if\n:: ((chnl[1])%20)!=partner[1]; goto error_state; \n\n:: ((chnl[1])%20)==partner[1] && ((chnl[1])/20)==1; goto oconnected; \n\n:: ((chnl[1])%20)==partner[1] && ((chnl[1])/20)==0; goto oringout; \n\nfi;\noconnected: if\n::  d_step {dev = 1;chnl[1] = 255;chnl[partner[1]] = 255;}  goto idle; \n\nfi;\noringout: if\n::  d_step {dev = 1;chnl[1] = 255;partner[1] = ((((partner[1])%20))+(0)*20);}  goto idle; \n\nfi;\ntpickup: if\n::  d_step {((chnl[partner[1]])%20)==1 && ((chnl[partner[1]])/20)==0;dev = 0;chnl[partner[1]] = ((1)+(1)*20);chnl[1] = ((partner[1])+(1)*20);}  goto tconnected; \n\n::  d_step {chnl[partner[1]]==255 || ((chnl[partner[1]])%20)!=1;dev = 1;partner[1] = 255;chnl[1] = 255;}  goto idle; \n\nfi;\ntconnected: if\n::  d_step {((chnl[1])/20)==1 && dev==0;dev = 1;}  goto tconnected; \n\n::  d_step {((chnl[1])/20)==1 && dev==1;dev = 0;}  goto tconnected; \n\n::  d_step {((chnl[1])/20)==0;partner[1] = 255;chnl[1] = 255;}  goto idle; \n\nfi;\nringback: if\n::  d_step {chnl[1] = 255;partner[1] = 255;dev = 1;}  goto idle; \n\n::  d_step {record[1]!=255;partner[1] = record[1];}  goto calling; \n\nfi;\nerror_state: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Model of a telecommunication service with some features\n    (call forward when busy, ring back when free).\n\nParameters:\n\n\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte chnl[3];\nbyte partner[3];\n\n\ninit { \n d_step { \nchnl[0] =255; chnl[1] =255; chnl[2] =255; partner[0] =255; partner[1] =255; partner[2] =255; }\natomic { \nrun User_0();\nrun User_1();\nrun User_2();\n} }\n\nproctype User_0() { \nbyte dev=1;\nbyte mbit=0;\n\nidle: if\n::  d_step {chnl[0]==255;dev = 0;chnl[0] = ((0)+(0)*20);}  goto dialing; \n\n::  d_step {chnl[0]!=255;partner[0] = ((chnl[0])%20);}  goto q_i; \n\nfi;\ndialing: if\n::  d_step {dev = 1;chnl[0] = 255;}  goto idle; \n\n:: partner[0] = 0; goto calling; \n\n:: partner[0] = 1; goto calling; \n\n:: partner[0] = 2; goto calling; \n\n:: partner[0] = 3; goto calling; \n\nfi;\ncalling: if\n:: partner[0]==0; goto busy; \n\n:: partner[0]==3; goto unobtainable; \n\n:: partner[0]!=0 && partner[0]!=3 && chnl[partner[0]]!=255; goto busy; \n\n::  d_step {partner[0]!=0 && partner[0]!=3 && chnl[partner[0]]==255;chnl[partner[0]] = ((0)+(0)*20);chnl[0] = ((partner[0])+(0)*20);}  goto oalert; \n\nfi;\nbusy: if\n::  d_step {chnl[0] = 255;partner[0] = 255;dev = 1;}  goto idle; \n\nfi;\nq_i: if\n:: ((chnl[partner[0]])%20)==0; goto talert; \n\n::  d_step {((chnl[partner[0]])%20)!=0;partner[0] = 255;}  goto idle; \n\nfi;\ntalert: if\n:: dev!=1 || chnl[0]==255; goto error_state; \n\n:: ((chnl[partner[0]])%20)==0; goto tpickup; \n\n:: ((chnl[partner[0]])%20)!=0; goto idle; \n\nfi;\nunobtainable: if\n::  d_step {chnl[0] = 255;partner[0] = 255;dev = 1;}  goto idle; \n\nfi;\noalert: if\n:: ((chnl[0])%20)!=partner[0]; goto error_state; \n\n:: ((chnl[0])%20)==partner[0] && ((chnl[0])/20)==1; goto oconnected; \n\n:: ((chnl[0])%20)==partner[0] && ((chnl[0])/20)==0; goto oringout; \n\nfi;\noconnected: if\n::  d_step {dev = 1;chnl[0] = 255;chnl[partner[0]] = 255;}  goto idle; \n\nfi;\noringout: if\n::  d_step {dev = 1;chnl[0] = 255;partner[0] = ((((partner[0])%20))+(0)*20);}  goto idle; \n\nfi;\ntpickup: if\n::  d_step {((chnl[partner[0]])%20)==0 && ((chnl[partner[0]])/20)==0;dev = 0;chnl[partner[0]] = ((0)+(1)*20);chnl[0] = ((partner[0])+(1)*20);}  goto tconnected; \n\n::  d_step {chnl[partner[0]]==255 || ((chnl[partner[0]])%20)!=0;dev = 1;partner[0] = 255;chnl[0] = 255;}  goto idle; \n\nfi;\ntconnected: if\n::  d_step {((chnl[0])/20)==1 && dev==0;dev = 1;}  goto tconnected; \n\n::  d_step {((chnl[0])/20)==1 && dev==1;dev = 0;}  goto tconnected; \n\n::  d_step {((chnl[0])/20)==0;partner[0] = 255;chnl[0] = 255;dev = 1;}  goto idle; \n\nfi;\nerror_state: \nringback: \n false; }\n\nproctype User_1() { \nbyte dev=1;\nbyte mbit=0;\n\nidle: if\n::  d_step {chnl[1]==255;dev = 0;chnl[1] = ((1)+(0)*20);}  goto dialing; \n\n::  d_step {chnl[1]!=255;partner[1] = ((chnl[1])%20);}  goto q_i; \n\nfi;\ndialing: if\n::  d_step {dev = 1;chnl[1] = 255;}  goto idle; \n\n:: partner[1] = 0; goto calling; \n\n:: partner[1] = 1; goto calling; \n\n:: partner[1] = 2; goto calling; \n\n:: partner[1] = 3; goto calling; \n\nfi;\ncalling: if\n:: partner[1]==1; goto busy; \n\n:: partner[1]==3; goto unobtainable; \n\n:: partner[1]!=1 && partner[1]!=3 && chnl[partner[1]]!=255; goto busy; \n\n::  d_step {partner[1]!=1 && partner[1]!=3 && chnl[partner[1]]==255;chnl[partner[1]] = ((1)+(0)*20);chnl[1] = ((partner[1])+(0)*20);}  goto oalert; \n\nfi;\nbusy: if\n::  d_step {chnl[1] = 255;partner[1] = 255;dev = 1;}  goto idle; \n\nfi;\nq_i: if\n:: ((chnl[partner[1]])%20)==1; goto talert; \n\n::  d_step {((chnl[partner[1]])%20)!=1;partner[1] = 255;}  goto idle; \n\nfi;\ntalert: if\n:: dev!=1 || chnl[1]==255; goto error_state; \n\n:: ((chnl[partner[1]])%20)==1; goto tpickup; \n\n:: ((chnl[partner[1]])%20)!=1; goto idle; \n\nfi;\nunobtainable: if\n::  d_step {chnl[1] = 255;partner[1] = 255;dev = 1;}  goto idle; \n\nfi;\noalert: if\n:: ((chnl[1])%20)!=partner[1]; goto error_state; \n\n:: ((chnl[1])%20)==partner[1] && ((chnl[1])/20)==1; goto oconnected; \n\n:: ((chnl[1])%20)==partner[1] && ((chnl[1])/20)==0; goto oringout; \n\nfi;\noconnected: if\n::  d_step {dev = 1;chnl[1] = 255;chnl[partner[1]] = 255;}  goto idle; \n\nfi;\noringout: if\n::  d_step {dev = 1;chnl[1] = 255;partner[1] = ((((partner[1])%20))+(0)*20);}  goto idle; \n\nfi;\ntpickup: if\n::  d_step {((chnl[partner[1]])%20)==1 && ((chnl[partner[1]])/20)==0;dev = 0;chnl[partner[1]] = ((1)+(1)*20);chnl[1] = ((partner[1])+(1)*20);}  goto tconnected; \n\n::  d_step {chnl[partner[1]]==255 || ((chnl[partner[1]])%20)!=1;dev = 1;partner[1] = 255;chnl[1] = 255;}  goto idle; \n\nfi;\ntconnected: if\n::  d_step {((chnl[1])/20)==1 && dev==0;dev = 1;}  goto tconnected; \n\n::  d_step {((chnl[1])/20)==1 && dev==1;dev = 0;}  goto tconnected; \n\n::  d_step {((chnl[1])/20)==0;partner[1] = 255;chnl[1] = 255;dev = 1;}  goto idle; \n\nfi;\nerror_state: \nringback: \n false; }\n\nproctype User_2() { \nbyte dev=1;\nbyte mbit=0;\n\nidle: if\n::  d_step {chnl[2]==255;dev = 0;chnl[2] = ((2)+(0)*20);}  goto dialing; \n\n::  d_step {chnl[2]!=255;partner[2] = ((chnl[2])%20);}  goto q_i; \n\nfi;\ndialing: if\n::  d_step {dev = 1;chnl[2] = 255;}  goto idle; \n\n:: partner[2] = 0; goto calling; \n\n:: partner[2] = 1; goto calling; \n\n:: partner[2] = 2; goto calling; \n\n:: partner[2] = 3; goto calling; \n\nfi;\ncalling: if\n:: partner[2]==2; goto busy; \n\n:: partner[2]==3; goto unobtainable; \n\n:: partner[2]!=2 && partner[2]!=3 && chnl[partner[2]]!=255; goto busy; \n\n::  d_step {partner[2]!=2 && partner[2]!=3 && chnl[partner[2]]==255;chnl[partner[2]] = ((2)+(0)*20);chnl[2] = ((partner[2])+(0)*20);}  goto oalert; \n\nfi;\nbusy: if\n::  d_step {chnl[2] = 255;partner[2] = 255;dev = 1;}  goto idle; \n\nfi;\nq_i: if\n:: ((chnl[partner[2]])%20)==2; goto talert; \n\n::  d_step {((chnl[partner[2]])%20)!=2;partner[2] = 255;}  goto idle; \n\nfi;\ntalert: if\n:: dev!=1 || chnl[2]==255; goto error_state; \n\n:: ((chnl[partner[2]])%20)==2; goto tpickup; \n\n:: ((chnl[partner[2]])%20)!=2; goto idle; \n\nfi;\nunobtainable: if\n::  d_step {chnl[2] = 255;partner[2] = 255;dev = 1;}  goto idle; \n\nfi;\noalert: if\n:: ((chnl[2])%20)!=partner[2]; goto error_state; \n\n:: ((chnl[2])%20)==partner[2] && ((chnl[2])/20)==1; goto oconnected; \n\n:: ((chnl[2])%20)==partner[2] && ((chnl[2])/20)==0; goto oringout; \n\nfi;\noconnected: if\n::  d_step {dev = 1;chnl[2] = 255;chnl[partner[2]] = 255;}  goto idle; \n\nfi;\noringout: if\n::  d_step {dev = 1;chnl[2] = 255;partner[2] = ((((partner[2])%20))+(0)*20);}  goto idle; \n\nfi;\ntpickup: if\n::  d_step {((chnl[partner[2]])%20)==2 && ((chnl[partner[2]])/20)==0;dev = 0;chnl[partner[2]] = ((2)+(1)*20);chnl[2] = ((partner[2])+(1)*20);}  goto tconnected; \n\n::  d_step {chnl[partner[2]]==255 || ((chnl[partner[2]])%20)!=2;dev = 1;partner[2] = 255;chnl[2] = 255;}  goto idle; \n\nfi;\ntconnected: if\n::  d_step {((chnl[2])/20)==1 && dev==0;dev = 1;}  goto tconnected; \n\n::  d_step {((chnl[2])/20)==1 && dev==1;dev = 0;}  goto tconnected; \n\n::  d_step {((chnl[2])/20)==0;partner[2] = 255;chnl[2] = 255;dev = 1;}  goto idle; \n\nfi;\nerror_state: \nringback: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Model of a telecommunication service with some features\n    (call forward when busy, ring back when free).\n\nParameters:\n\n\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte chnl[3];\nbyte partner[3];\nbyte call_forward_busy[3];\nbyte record[3];\n\n\ninit { \n d_step { \nchnl[0] =255; chnl[1] =255; chnl[2] =255; partner[0] =255; partner[1] =255; partner[2] =255; call_forward_busy[0] =1; call_forward_busy[1] =2; call_forward_busy[2] =255; record[0] =255; record[1] =255; record[2] =255; }\natomic { \nrun User_0();\nrun User_1();\nrun User_2();\n} }\n\nproctype User_0() { \nbyte dev=1;\nbyte mbit=0;\n\nidle: if\n::  d_step {chnl[0]==255;dev = 0;chnl[0] = ((0)+(0)*20);}  goto dialing; \n\n::  d_step {chnl[0]!=255;partner[0] = ((chnl[0])%20);}  goto q_i; \n\nfi;\ndialing: if\n::  d_step {dev = 1;chnl[0] = 255;}  goto idle; \n\n:: partner[0] = 0; goto calling; \n\n:: partner[0] = 1; goto calling; \n\n:: partner[0] = 2; goto calling; \n\n:: partner[0] = 3; goto calling; \n\nfi;\ncalling: if\n:: partner[0]==0; goto busy; \n\n:: partner[0]==3; goto unobtainable; \n\n:: partner[0]==3; goto ringback; \n\n::  d_step {partner[0]!=0 && partner[0]!=3 && chnl[partner[0]]!=255 && call_forward_busy[partner[0]]==255;record[partner[0]] = 0;}  goto busy; \n\n::  d_step {partner[0]!=0 && partner[0]!=3 && chnl[partner[0]]!=255 && call_forward_busy[partner[0]]!=255;record[partner[0]] = 0;partner[0] = call_forward_busy[partner[0]];}  goto calling; \n\n::  d_step {partner[0]!=0 && partner[0]!=3 && chnl[partner[0]]==255;record[partner[0]] = 0;chnl[partner[0]] = ((0)+(0)*20);chnl[0] = ((partner[0])+(0)*20);}  goto oalert; \n\nfi;\nbusy: if\n::  d_step {chnl[0] = 255;partner[0] = 255;dev = 1;}  goto idle; \n\nfi;\nq_i: if\n:: ((chnl[partner[0]])%20)==0; goto talert; \n\n::  d_step {((chnl[partner[0]])%20)!=0;partner[0] = 255;}  goto idle; \n\nfi;\ntalert: if\n:: dev!=1 || chnl[0]==255; goto error_state; \n\n:: ((chnl[partner[0]])%20)==0; goto tpickup; \n\n:: ((chnl[partner[0]])%20)!=0; goto idle; \n\nfi;\nunobtainable: if\n::  d_step {chnl[0] = 255;partner[0] = 255;dev = 1;}  goto idle; \n\nfi;\noalert: if\n:: ((chnl[0])%20)!=partner[0]; goto error_state; \n\n:: ((chnl[0])%20)==partner[0] && ((chnl[0])/20)==1; goto oconnected; \n\n:: ((chnl[0])%20)==partner[0] && ((chnl[0])/20)==0; goto oringout; \n\nfi;\noconnected: if\n::  d_step {dev = 1;chnl[0] = 255;chnl[partner[0]] = 255;}  goto idle; \n\nfi;\noringout: if\n::  d_step {dev = 1;chnl[0] = 255;partner[0] = ((((partner[0])%20))+(0)*20);}  goto idle; \n\nfi;\ntpickup: if\n::  d_step {((chnl[partner[0]])%20)==0 && ((chnl[partner[0]])/20)==0;dev = 0;chnl[partner[0]] = ((0)+(1)*20);chnl[0] = ((partner[0])+(1)*20);}  goto tconnected; \n\n::  d_step {chnl[partner[0]]==255 || ((chnl[partner[0]])%20)!=0;dev = 1;partner[0] = 255;chnl[0] = 255;}  goto idle; \n\nfi;\ntconnected: if\n::  d_step {((chnl[0])/20)==1 && dev==0;dev = 1;}  goto tconnected; \n\n::  d_step {((chnl[0])/20)==1 && dev==1;dev = 0;}  goto tconnected; \n\n::  d_step {((chnl[0])/20)==0;partner[0] = 255;chnl[0] = 255;}  goto idle; \n\nfi;\nringback: if\n::  d_step {chnl[0] = 255;partner[0] = 255;dev = 1;}  goto idle; \n\n::  d_step {record[0]!=255;partner[0] = record[0];}  goto calling; \n\nfi;\nerror_state: \n false; }\n\nproctype User_1() { \nbyte dev=1;\nbyte mbit=0;\n\nidle: if\n::  d_step {chnl[1]==255;dev = 0;chnl[1] = ((1)+(0)*20);}  goto dialing; \n\n::  d_step {chnl[1]!=255;partner[1] = ((chnl[1])%20);}  goto q_i; \n\nfi;\ndialing: if\n::  d_step {dev = 1;chnl[1] = 255;}  goto idle; \n\n:: partner[1] = 0; goto calling; \n\n:: partner[1] = 1; goto calling; \n\n:: partner[1] = 2; goto calling; \n\n:: partner[1] = 3; goto calling; \n\nfi;\ncalling: if\n:: partner[1]==1; goto busy; \n\n:: partner[1]==3; goto unobtainable; \n\n:: partner[1]==3; goto ringback; \n\n::  d_step {partner[1]!=1 && partner[1]!=3 && chnl[partner[1]]!=255 && call_forward_busy[partner[1]]==255;record[partner[1]] = 1;}  goto busy; \n\n::  d_step {partner[1]!=1 && partner[1]!=3 && chnl[partner[1]]!=255 && call_forward_busy[partner[1]]!=255;record[partner[1]] = 1;partner[1] = call_forward_busy[partner[1]];}  goto calling; \n\n::  d_step {partner[1]!=1 && partner[1]!=3 && chnl[partner[1]]==255;record[partner[1]] = 1;chnl[partner[1]] = ((1)+(0)*20);chnl[1] = ((partner[1])+(0)*20);}  goto oalert; \n\nfi;\nbusy: if\n::  d_step {chnl[1] = 255;partner[1] = 255;dev = 1;}  goto idle; \n\nfi;\nq_i: if\n:: ((chnl[partner[1]])%20)==1; goto talert; \n\n::  d_step {((chnl[partner[1]])%20)!=1;partner[1] = 255;}  goto idle; \n\nfi;\ntalert: if\n:: dev!=1 || chnl[1]==255; goto error_state; \n\n:: ((chnl[partner[1]])%20)==1; goto tpickup; \n\n:: ((chnl[partner[1]])%20)!=1; goto idle; \n\nfi;\nunobtainable: if\n::  d_step {chnl[1] = 255;partner[1] = 255;dev = 1;}  goto idle; \n\nfi;\noalert: if\n:: ((chnl[1])%20)!=partner[1]; goto error_state; \n\n:: ((chnl[1])%20)==partner[1] && ((chnl[1])/20)==1; goto oconnected; \n\n:: ((chnl[1])%20)==partner[1] && ((chnl[1])/20)==0; goto oringout; \n\nfi;\noconnected: if\n::  d_step {dev = 1;chnl[1] = 255;chnl[partner[1]] = 255;}  goto idle; \n\nfi;\noringout: if\n::  d_step {dev = 1;chnl[1] = 255;partner[1] = ((((partner[1])%20))+(0)*20);}  goto idle; \n\nfi;\ntpickup: if\n::  d_step {((chnl[partner[1]])%20)==1 && ((chnl[partner[1]])/20)==0;dev = 0;chnl[partner[1]] = ((1)+(1)*20);chnl[1] = ((partner[1])+(1)*20);}  goto tconnected; \n\n::  d_step {chnl[partner[1]]==255 || ((chnl[partner[1]])%20)!=1;dev = 1;partner[1] = 255;chnl[1] = 255;}  goto idle; \n\nfi;\ntconnected: if\n::  d_step {((chnl[1])/20)==1 && dev==0;dev = 1;}  goto tconnected; \n\n::  d_step {((chnl[1])/20)==1 && dev==1;dev = 0;}  goto tconnected; \n\n::  d_step {((chnl[1])/20)==0;partner[1] = 255;chnl[1] = 255;}  goto idle; \n\nfi;\nringback: if\n::  d_step {chnl[1] = 255;partner[1] = 255;dev = 1;}  goto idle; \n\n::  d_step {record[1]!=255;partner[1] = record[1];}  goto calling; \n\nfi;\nerror_state: \n false; }\n\nproctype User_2() { \nbyte dev=1;\nbyte mbit=0;\n\nidle: if\n::  d_step {chnl[2]==255;dev = 0;chnl[2] = ((2)+(0)*20);}  goto dialing; \n\n::  d_step {chnl[2]!=255;partner[2] = ((chnl[2])%20);}  goto q_i; \n\nfi;\ndialing: if\n::  d_step {dev = 1;chnl[2] = 255;}  goto idle; \n\n:: partner[2] = 0; goto calling; \n\n:: partner[2] = 1; goto calling; \n\n:: partner[2] = 2; goto calling; \n\n:: partner[2] = 3; goto calling; \n\nfi;\ncalling: if\n:: partner[2]==2; goto busy; \n\n:: partner[2]==3; goto unobtainable; \n\n:: partner[2]==3; goto ringback; \n\n::  d_step {partner[2]!=2 && partner[2]!=3 && chnl[partner[2]]!=255 && call_forward_busy[partner[2]]==255;record[partner[2]] = 2;}  goto busy; \n\n::  d_step {partner[2]!=2 && partner[2]!=3 && chnl[partner[2]]!=255 && call_forward_busy[partner[2]]!=255;record[partner[2]] = 2;partner[2] = call_forward_busy[partner[2]];}  goto calling; \n\n::  d_step {partner[2]!=2 && partner[2]!=3 && chnl[partner[2]]==255;record[partner[2]] = 2;chnl[partner[2]] = ((2)+(0)*20);chnl[2] = ((partner[2])+(0)*20);}  goto oalert; \n\nfi;\nbusy: if\n::  d_step {chnl[2] = 255;partner[2] = 255;dev = 1;}  goto idle; \n\nfi;\nq_i: if\n:: ((chnl[partner[2]])%20)==2; goto talert; \n\n::  d_step {((chnl[partner[2]])%20)!=2;partner[2] = 255;}  goto idle; \n\nfi;\ntalert: if\n:: dev!=1 || chnl[2]==255; goto error_state; \n\n:: ((chnl[partner[2]])%20)==2; goto tpickup; \n\n:: ((chnl[partner[2]])%20)!=2; goto idle; \n\nfi;\nunobtainable: if\n::  d_step {chnl[2] = 255;partner[2] = 255;dev = 1;}  goto idle; \n\nfi;\noalert: if\n:: ((chnl[2])%20)!=partner[2]; goto error_state; \n\n:: ((chnl[2])%20)==partner[2] && ((chnl[2])/20)==1; goto oconnected; \n\n:: ((chnl[2])%20)==partner[2] && ((chnl[2])/20)==0; goto oringout; \n\nfi;\noconnected: if\n::  d_step {dev = 1;chnl[2] = 255;chnl[partner[2]] = 255;}  goto idle; \n\nfi;\noringout: if\n::  d_step {dev = 1;chnl[2] = 255;partner[2] = ((((partner[2])%20))+(0)*20);}  goto idle; \n\nfi;\ntpickup: if\n::  d_step {((chnl[partner[2]])%20)==2 && ((chnl[partner[2]])/20)==0;dev = 0;chnl[partner[2]] = ((2)+(1)*20);chnl[2] = ((partner[2])+(1)*20);}  goto tconnected; \n\n::  d_step {chnl[partner[2]]==255 || ((chnl[partner[2]])%20)!=2;dev = 1;partner[2] = 255;chnl[2] = 255;}  goto idle; \n\nfi;\ntconnected: if\n::  d_step {((chnl[2])/20)==1 && dev==0;dev = 1;}  goto tconnected; \n\n::  d_step {((chnl[2])/20)==1 && dev==1;dev = 0;}  goto tconnected; \n\n::  d_step {((chnl[2])/20)==0;partner[2] = 255;chnl[2] = 255;}  goto idle; \n\nfi;\nringback: if\n::  d_step {chnl[2] = 255;partner[2] = 255;dev = 1;}  goto idle; \n\n::  d_step {record[2]!=255;partner[2] = record[2];}  goto calling; \n\nfi;\nerror_state: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Model of a telecommunication service with some features\n    (call forward when busy, ring back when free).\n\nParameters:\n\n\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte chnl[4];\nbyte partner[4];\n\n\ninit { \n d_step { \nchnl[0] =255; chnl[1] =255; chnl[2] =255; chnl[3] =255; partner[0] =255; partner[1] =255; partner[2] =255; partner[3] =255; }\natomic { \nrun User_0();\nrun User_1();\nrun User_2();\nrun User_3();\n} }\n\nproctype User_0() { \nbyte dev=1;\nbyte mbit=0;\n\nidle: if\n::  d_step {chnl[0]==255;dev = 0;chnl[0] = ((0)+(0)*20);}  goto dialing; \n\n::  d_step {chnl[0]!=255;partner[0] = ((chnl[0])%20);}  goto q_i; \n\nfi;\ndialing: if\n::  d_step {dev = 1;chnl[0] = 255;}  goto idle; \n\n:: partner[0] = 0; goto calling; \n\n:: partner[0] = 1; goto calling; \n\n:: partner[0] = 2; goto calling; \n\n:: partner[0] = 3; goto calling; \n\n:: partner[0] = 4; goto calling; \n\nfi;\ncalling: if\n:: partner[0]==0; goto busy; \n\n:: partner[0]==4; goto unobtainable; \n\n:: partner[0]!=0 && partner[0]!=4 && chnl[partner[0]]!=255; goto busy; \n\n::  d_step {partner[0]!=0 && partner[0]!=4 && chnl[partner[0]]==255;chnl[partner[0]] = ((0)+(0)*20);chnl[0] = ((partner[0])+(0)*20);}  goto oalert; \n\nfi;\nbusy: if\n::  d_step {chnl[0] = 255;partner[0] = 255;dev = 1;}  goto idle; \n\nfi;\nq_i: if\n:: ((chnl[partner[0]])%20)==0; goto talert; \n\n::  d_step {((chnl[partner[0]])%20)!=0;partner[0] = 255;}  goto idle; \n\nfi;\ntalert: if\n:: dev!=1 || chnl[0]==255; goto error_state; \n\n:: ((chnl[partner[0]])%20)==0; goto tpickup; \n\n:: ((chnl[partner[0]])%20)!=0; goto idle; \n\nfi;\nunobtainable: if\n::  d_step {chnl[0] = 255;partner[0] = 255;dev = 1;}  goto idle; \n\nfi;\noalert: if\n:: ((chnl[0])%20)!=partner[0]; goto error_state; \n\n:: ((chnl[0])%20)==partner[0] && ((chnl[0])/20)==1; goto oconnected; \n\n:: ((chnl[0])%20)==partner[0] && ((chnl[0])/20)==0; goto oringout; \n\nfi;\noconnected: if\n::  d_step {dev = 1;chnl[0] = 255;chnl[partner[0]] = 255;}  goto idle; \n\nfi;\noringout: if\n::  d_step {dev = 1;chnl[0] = 255;partner[0] = ((((partner[0])%20))+(0)*20);}  goto idle; \n\nfi;\ntpickup: if\n::  d_step {((chnl[partner[0]])%20)==0 && ((chnl[partner[0]])/20)==0;dev = 0;chnl[partner[0]] = ((0)+(1)*20);chnl[0] = ((partner[0])+(1)*20);}  goto tconnected; \n\n::  d_step {chnl[partner[0]]==255 || ((chnl[partner[0]])%20)!=0;dev = 1;partner[0] = 255;chnl[0] = 255;}  goto idle; \n\nfi;\ntconnected: if\n::  d_step {((chnl[0])/20)==1 && dev==0;dev = 1;}  goto tconnected; \n\n::  d_step {((chnl[0])/20)==1 && dev==1;dev = 0;}  goto tconnected; \n\n::  d_step {((chnl[0])/20)==0;partner[0] = 255;chnl[0] = 255;dev = 1;}  goto idle; \n\nfi;\nerror_state: \nringback: \n false; }\n\nproctype User_1() { \nbyte dev=1;\nbyte mbit=0;\n\nidle: if\n::  d_step {chnl[1]==255;dev = 0;chnl[1] = ((1)+(0)*20);}  goto dialing; \n\n::  d_step {chnl[1]!=255;partner[1] = ((chnl[1])%20);}  goto q_i; \n\nfi;\ndialing: if\n::  d_step {dev = 1;chnl[1] = 255;}  goto idle; \n\n:: partner[1] = 0; goto calling; \n\n:: partner[1] = 1; goto calling; \n\n:: partner[1] = 2; goto calling; \n\n:: partner[1] = 3; goto calling; \n\n:: partner[1] = 4; goto calling; \n\nfi;\ncalling: if\n:: partner[1]==1; goto busy; \n\n:: partner[1]==4; goto unobtainable; \n\n:: partner[1]!=1 && partner[1]!=4 && chnl[partner[1]]!=255; goto busy; \n\n::  d_step {partner[1]!=1 && partner[1]!=4 && chnl[partner[1]]==255;chnl[partner[1]] = ((1)+(0)*20);chnl[1] = ((partner[1])+(0)*20);}  goto oalert; \n\nfi;\nbusy: if\n::  d_step {chnl[1] = 255;partner[1] = 255;dev = 1;}  goto idle; \n\nfi;\nq_i: if\n:: ((chnl[partner[1]])%20)==1; goto talert; \n\n::  d_step {((chnl[partner[1]])%20)!=1;partner[1] = 255;}  goto idle; \n\nfi;\ntalert: if\n:: dev!=1 || chnl[1]==255; goto error_state; \n\n:: ((chnl[partner[1]])%20)==1; goto tpickup; \n\n:: ((chnl[partner[1]])%20)!=1; goto idle; \n\nfi;\nunobtainable: if\n::  d_step {chnl[1] = 255;partner[1] = 255;dev = 1;}  goto idle; \n\nfi;\noalert: if\n:: ((chnl[1])%20)!=partner[1]; goto error_state; \n\n:: ((chnl[1])%20)==partner[1] && ((chnl[1])/20)==1; goto oconnected; \n\n:: ((chnl[1])%20)==partner[1] && ((chnl[1])/20)==0; goto oringout; \n\nfi;\noconnected: if\n::  d_step {dev = 1;chnl[1] = 255;chnl[partner[1]] = 255;}  goto idle; \n\nfi;\noringout: if\n::  d_step {dev = 1;chnl[1] = 255;partner[1] = ((((partner[1])%20))+(0)*20);}  goto idle; \n\nfi;\ntpickup: if\n::  d_step {((chnl[partner[1]])%20)==1 && ((chnl[partner[1]])/20)==0;dev = 0;chnl[partner[1]] = ((1)+(1)*20);chnl[1] = ((partner[1])+(1)*20);}  goto tconnected; \n\n::  d_step {chnl[partner[1]]==255 || ((chnl[partner[1]])%20)!=1;dev = 1;partner[1] = 255;chnl[1] = 255;}  goto idle; \n\nfi;\ntconnected: if\n::  d_step {((chnl[1])/20)==1 && dev==0;dev = 1;}  goto tconnected; \n\n::  d_step {((chnl[1])/20)==1 && dev==1;dev = 0;}  goto tconnected; \n\n::  d_step {((chnl[1])/20)==0;partner[1] = 255;chnl[1] = 255;dev = 1;}  goto idle; \n\nfi;\nerror_state: \nringback: \n false; }\n\nproctype User_2() { \nbyte dev=1;\nbyte mbit=0;\n\nidle: if\n::  d_step {chnl[2]==255;dev = 0;chnl[2] = ((2)+(0)*20);}  goto dialing; \n\n::  d_step {chnl[2]!=255;partner[2] = ((chnl[2])%20);}  goto q_i; \n\nfi;\ndialing: if\n::  d_step {dev = 1;chnl[2] = 255;}  goto idle; \n\n:: partner[2] = 0; goto calling; \n\n:: partner[2] = 1; goto calling; \n\n:: partner[2] = 2; goto calling; \n\n:: partner[2] = 3; goto calling; \n\n:: partner[2] = 4; goto calling; \n\nfi;\ncalling: if\n:: partner[2]==2; goto busy; \n\n:: partner[2]==4; goto unobtainable; \n\n:: partner[2]!=2 && partner[2]!=4 && chnl[partner[2]]!=255; goto busy; \n\n::  d_step {partner[2]!=2 && partner[2]!=4 && chnl[partner[2]]==255;chnl[partner[2]] = ((2)+(0)*20);chnl[2] = ((partner[2])+(0)*20);}  goto oalert; \n\nfi;\nbusy: if\n::  d_step {chnl[2] = 255;partner[2] = 255;dev = 1;}  goto idle; \n\nfi;\nq_i: if\n:: ((chnl[partner[2]])%20)==2; goto talert; \n\n::  d_step {((chnl[partner[2]])%20)!=2;partner[2] = 255;}  goto idle; \n\nfi;\ntalert: if\n:: dev!=1 || chnl[2]==255; goto error_state; \n\n:: ((chnl[partner[2]])%20)==2; goto tpickup; \n\n:: ((chnl[partner[2]])%20)!=2; goto idle; \n\nfi;\nunobtainable: if\n::  d_step {chnl[2] = 255;partner[2] = 255;dev = 1;}  goto idle; \n\nfi;\noalert: if\n:: ((chnl[2])%20)!=partner[2]; goto error_state; \n\n:: ((chnl[2])%20)==partner[2] && ((chnl[2])/20)==1; goto oconnected; \n\n:: ((chnl[2])%20)==partner[2] && ((chnl[2])/20)==0; goto oringout; \n\nfi;\noconnected: if\n::  d_step {dev = 1;chnl[2] = 255;chnl[partner[2]] = 255;}  goto idle; \n\nfi;\noringout: if\n::  d_step {dev = 1;chnl[2] = 255;partner[2] = ((((partner[2])%20))+(0)*20);}  goto idle; \n\nfi;\ntpickup: if\n::  d_step {((chnl[partner[2]])%20)==2 && ((chnl[partner[2]])/20)==0;dev = 0;chnl[partner[2]] = ((2)+(1)*20);chnl[2] = ((partner[2])+(1)*20);}  goto tconnected; \n\n::  d_step {chnl[partner[2]]==255 || ((chnl[partner[2]])%20)!=2;dev = 1;partner[2] = 255;chnl[2] = 255;}  goto idle; \n\nfi;\ntconnected: if\n::  d_step {((chnl[2])/20)==1 && dev==0;dev = 1;}  goto tconnected; \n\n::  d_step {((chnl[2])/20)==1 && dev==1;dev = 0;}  goto tconnected; \n\n::  d_step {((chnl[2])/20)==0;partner[2] = 255;chnl[2] = 255;dev = 1;}  goto idle; \n\nfi;\nerror_state: \nringback: \n false; }\n\nproctype User_3() { \nbyte dev=1;\nbyte mbit=0;\n\nidle: if\n::  d_step {chnl[3]==255;dev = 0;chnl[3] = ((3)+(0)*20);}  goto dialing; \n\n::  d_step {chnl[3]!=255;partner[3] = ((chnl[3])%20);}  goto q_i; \n\nfi;\ndialing: if\n::  d_step {dev = 1;chnl[3] = 255;}  goto idle; \n\n:: partner[3] = 0; goto calling; \n\n:: partner[3] = 1; goto calling; \n\n:: partner[3] = 2; goto calling; \n\n:: partner[3] = 3; goto calling; \n\n:: partner[3] = 4; goto calling; \n\nfi;\ncalling: if\n:: partner[3]==3; goto busy; \n\n:: partner[3]==4; goto unobtainable; \n\n:: partner[3]!=3 && partner[3]!=4 && chnl[partner[3]]!=255; goto busy; \n\n::  d_step {partner[3]!=3 && partner[3]!=4 && chnl[partner[3]]==255;chnl[partner[3]] = ((3)+(0)*20);chnl[3] = ((partner[3])+(0)*20);}  goto oalert; \n\nfi;\nbusy: if\n::  d_step {chnl[3] = 255;partner[3] = 255;dev = 1;}  goto idle; \n\nfi;\nq_i: if\n:: ((chnl[partner[3]])%20)==3; goto talert; \n\n::  d_step {((chnl[partner[3]])%20)!=3;partner[3] = 255;}  goto idle; \n\nfi;\ntalert: if\n:: dev!=1 || chnl[3]==255; goto error_state; \n\n:: ((chnl[partner[3]])%20)==3; goto tpickup; \n\n:: ((chnl[partner[3]])%20)!=3; goto idle; \n\nfi;\nunobtainable: if\n::  d_step {chnl[3] = 255;partner[3] = 255;dev = 1;}  goto idle; \n\nfi;\noalert: if\n:: ((chnl[3])%20)!=partner[3]; goto error_state; \n\n:: ((chnl[3])%20)==partner[3] && ((chnl[3])/20)==1; goto oconnected; \n\n:: ((chnl[3])%20)==partner[3] && ((chnl[3])/20)==0; goto oringout; \n\nfi;\noconnected: if\n::  d_step {dev = 1;chnl[3] = 255;chnl[partner[3]] = 255;}  goto idle; \n\nfi;\noringout: if\n::  d_step {dev = 1;chnl[3] = 255;partner[3] = ((((partner[3])%20))+(0)*20);}  goto idle; \n\nfi;\ntpickup: if\n::  d_step {((chnl[partner[3]])%20)==3 && ((chnl[partner[3]])/20)==0;dev = 0;chnl[partner[3]] = ((3)+(1)*20);chnl[3] = ((partner[3])+(1)*20);}  goto tconnected; \n\n::  d_step {chnl[partner[3]]==255 || ((chnl[partner[3]])%20)!=3;dev = 1;partner[3] = 255;chnl[3] = 255;}  goto idle; \n\nfi;\ntconnected: if\n::  d_step {((chnl[3])/20)==1 && dev==0;dev = 1;}  goto tconnected; \n\n::  d_step {((chnl[3])/20)==1 && dev==1;dev = 0;}  goto tconnected; \n\n::  d_step {((chnl[3])/20)==0;partner[3] = 255;chnl[3] = 255;dev = 1;}  goto idle; \n\nfi;\nerror_state: \nringback: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Model of a telecommunication service with some features\n    (call forward when busy, ring back when free).\n\nParameters:\n\n\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte chnl[4];\nbyte partner[4];\nbyte call_forward_busy[4];\nbyte record[4];\n\n\ninit { \n d_step { \nchnl[0] =255; chnl[1] =255; chnl[2] =255; chnl[3] =255; partner[0] =255; partner[1] =255; partner[2] =255; partner[3] =255; call_forward_busy[0] =1; call_forward_busy[1] =2; call_forward_busy[2] =3; call_forward_busy[3] =255; record[0] =255; record[1] =255; record[2] =255; record[3] =255; }\natomic { \nrun User_0();\nrun User_1();\nrun User_2();\nrun User_3();\n} }\n\nproctype User_0() { \nbyte dev=1;\nbyte mbit=0;\n\nidle: if\n::  d_step {chnl[0]==255;dev = 0;chnl[0] = ((0)+(0)*20);}  goto dialing; \n\n::  d_step {chnl[0]!=255;partner[0] = ((chnl[0])%20);}  goto q_i; \n\nfi;\ndialing: if\n::  d_step {dev = 1;chnl[0] = 255;}  goto idle; \n\n:: partner[0] = 0; goto calling; \n\n:: partner[0] = 1; goto calling; \n\n:: partner[0] = 2; goto calling; \n\n:: partner[0] = 3; goto calling; \n\n:: partner[0] = 4; goto calling; \n\nfi;\ncalling: if\n:: partner[0]==0; goto busy; \n\n:: partner[0]==4; goto unobtainable; \n\n:: partner[0]==4; goto ringback; \n\n::  d_step {partner[0]!=0 && partner[0]!=4 && chnl[partner[0]]!=255 && call_forward_busy[partner[0]]==255;record[partner[0]] = 0;}  goto busy; \n\n::  d_step {partner[0]!=0 && partner[0]!=4 && chnl[partner[0]]!=255 && call_forward_busy[partner[0]]!=255;record[partner[0]] = 0;partner[0] = call_forward_busy[partner[0]];}  goto calling; \n\n::  d_step {partner[0]!=0 && partner[0]!=4 && chnl[partner[0]]==255;record[partner[0]] = 0;chnl[partner[0]] = ((0)+(0)*20);chnl[0] = ((partner[0])+(0)*20);}  goto oalert; \n\nfi;\nbusy: if\n::  d_step {chnl[0] = 255;partner[0] = 255;dev = 1;}  goto idle; \n\nfi;\nq_i: if\n:: ((chnl[partner[0]])%20)==0; goto talert; \n\n::  d_step {((chnl[partner[0]])%20)!=0;partner[0] = 255;}  goto idle; \n\nfi;\ntalert: if\n:: dev!=1 || chnl[0]==255; goto error_state; \n\n:: ((chnl[partner[0]])%20)==0; goto tpickup; \n\n:: ((chnl[partner[0]])%20)!=0; goto idle; \n\nfi;\nunobtainable: if\n::  d_step {chnl[0] = 255;partner[0] = 255;dev = 1;}  goto idle; \n\nfi;\noalert: if\n:: ((chnl[0])%20)!=partner[0]; goto error_state; \n\n:: ((chnl[0])%20)==partner[0] && ((chnl[0])/20)==1; goto oconnected; \n\n:: ((chnl[0])%20)==partner[0] && ((chnl[0])/20)==0; goto oringout; \n\nfi;\noconnected: if\n::  d_step {dev = 1;chnl[0] = 255;chnl[partner[0]] = 255;}  goto idle; \n\nfi;\noringout: if\n::  d_step {dev = 1;chnl[0] = 255;partner[0] = ((((partner[0])%20))+(0)*20);}  goto idle; \n\nfi;\ntpickup: if\n::  d_step {((chnl[partner[0]])%20)==0 && ((chnl[partner[0]])/20)==0;dev = 0;chnl[partner[0]] = ((0)+(1)*20);chnl[0] = ((partner[0])+(1)*20);}  goto tconnected; \n\n::  d_step {chnl[partner[0]]==255 || ((chnl[partner[0]])%20)!=0;dev = 1;partner[0] = 255;chnl[0] = 255;}  goto idle; \n\nfi;\ntconnected: if\n::  d_step {((chnl[0])/20)==1 && dev==0;dev = 1;}  goto tconnected; \n\n::  d_step {((chnl[0])/20)==1 && dev==1;dev = 0;}  goto tconnected; \n\n::  d_step {((chnl[0])/20)==0;partner[0] = 255;chnl[0] = 255;dev = 1;}  goto idle; \n\nfi;\nringback: if\n::  d_step {chnl[0] = 255;partner[0] = 255;dev = 1;}  goto idle; \n\n::  d_step {record[0]!=255;partner[0] = record[0];}  goto calling; \n\nfi;\nerror_state: \n false; }\n\nproctype User_1() { \nbyte dev=1;\nbyte mbit=0;\n\nidle: if\n::  d_step {chnl[1]==255;dev = 0;chnl[1] = ((1)+(0)*20);}  goto dialing; \n\n::  d_step {chnl[1]!=255;partner[1] = ((chnl[1])%20);}  goto q_i; \n\nfi;\ndialing: if\n::  d_step {dev = 1;chnl[1] = 255;}  goto idle; \n\n:: partner[1] = 0; goto calling; \n\n:: partner[1] = 1; goto calling; \n\n:: partner[1] = 2; goto calling; \n\n:: partner[1] = 3; goto calling; \n\n:: partner[1] = 4; goto calling; \n\nfi;\ncalling: if\n:: partner[1]==1; goto busy; \n\n:: partner[1]==4; goto unobtainable; \n\n:: partner[1]==4; goto ringback; \n\n::  d_step {partner[1]!=1 && partner[1]!=4 && chnl[partner[1]]!=255 && call_forward_busy[partner[1]]==255;record[partner[1]] = 1;}  goto busy; \n\n::  d_step {partner[1]!=1 && partner[1]!=4 && chnl[partner[1]]!=255 && call_forward_busy[partner[1]]!=255;record[partner[1]] = 1;partner[1] = call_forward_busy[partner[1]];}  goto calling; \n\n::  d_step {partner[1]!=1 && partner[1]!=4 && chnl[partner[1]]==255;record[partner[1]] = 1;chnl[partner[1]] = ((1)+(0)*20);chnl[1] = ((partner[1])+(0)*20);}  goto oalert; \n\nfi;\nbusy: if\n::  d_step {chnl[1] = 255;partner[1] = 255;dev = 1;}  goto idle; \n\nfi;\nq_i: if\n:: ((chnl[partner[1]])%20)==1; goto talert; \n\n::  d_step {((chnl[partner[1]])%20)!=1;partner[1] = 255;}  goto idle; \n\nfi;\ntalert: if\n:: dev!=1 || chnl[1]==255; goto error_state; \n\n:: ((chnl[partner[1]])%20)==1; goto tpickup; \n\n:: ((chnl[partner[1]])%20)!=1; goto idle; \n\nfi;\nunobtainable: if\n::  d_step {chnl[1] = 255;partner[1] = 255;dev = 1;}  goto idle; \n\nfi;\noalert: if\n:: ((chnl[1])%20)!=partner[1]; goto error_state; \n\n:: ((chnl[1])%20)==partner[1] && ((chnl[1])/20)==1; goto oconnected; \n\n:: ((chnl[1])%20)==partner[1] && ((chnl[1])/20)==0; goto oringout; \n\nfi;\noconnected: if\n::  d_step {dev = 1;chnl[1] = 255;chnl[partner[1]] = 255;}  goto idle; \n\nfi;\noringout: if\n::  d_step {dev = 1;chnl[1] = 255;partner[1] = ((((partner[1])%20))+(0)*20);}  goto idle; \n\nfi;\ntpickup: if\n::  d_step {((chnl[partner[1]])%20)==1 && ((chnl[partner[1]])/20)==0;dev = 0;chnl[partner[1]] = ((1)+(1)*20);chnl[1] = ((partner[1])+(1)*20);}  goto tconnected; \n\n::  d_step {chnl[partner[1]]==255 || ((chnl[partner[1]])%20)!=1;dev = 1;partner[1] = 255;chnl[1] = 255;}  goto idle; \n\nfi;\ntconnected: if\n::  d_step {((chnl[1])/20)==1 && dev==0;dev = 1;}  goto tconnected; \n\n::  d_step {((chnl[1])/20)==1 && dev==1;dev = 0;}  goto tconnected; \n\n::  d_step {((chnl[1])/20)==0;partner[1] = 255;chnl[1] = 255;dev = 1;}  goto idle; \n\nfi;\nringback: if\n::  d_step {chnl[1] = 255;partner[1] = 255;dev = 1;}  goto idle; \n\n::  d_step {record[1]!=255;partner[1] = record[1];}  goto calling; \n\nfi;\nerror_state: \n false; }\n\nproctype User_2() { \nbyte dev=1;\nbyte mbit=0;\n\nidle: if\n::  d_step {chnl[2]==255;dev = 0;chnl[2] = ((2)+(0)*20);}  goto dialing; \n\n::  d_step {chnl[2]!=255;partner[2] = ((chnl[2])%20);}  goto q_i; \n\nfi;\ndialing: if\n::  d_step {dev = 1;chnl[2] = 255;}  goto idle; \n\n:: partner[2] = 0; goto calling; \n\n:: partner[2] = 1; goto calling; \n\n:: partner[2] = 2; goto calling; \n\n:: partner[2] = 3; goto calling; \n\n:: partner[2] = 4; goto calling; \n\nfi;\ncalling: if\n:: partner[2]==2; goto busy; \n\n:: partner[2]==4; goto unobtainable; \n\n:: partner[2]==4; goto ringback; \n\n::  d_step {partner[2]!=2 && partner[2]!=4 && chnl[partner[2]]!=255 && call_forward_busy[partner[2]]==255;record[partner[2]] = 2;}  goto busy; \n\n::  d_step {partner[2]!=2 && partner[2]!=4 && chnl[partner[2]]!=255 && call_forward_busy[partner[2]]!=255;record[partner[2]] = 2;partner[2] = call_forward_busy[partner[2]];}  goto calling; \n\n::  d_step {partner[2]!=2 && partner[2]!=4 && chnl[partner[2]]==255;record[partner[2]] = 2;chnl[partner[2]] = ((2)+(0)*20);chnl[2] = ((partner[2])+(0)*20);}  goto oalert; \n\nfi;\nbusy: if\n::  d_step {chnl[2] = 255;partner[2] = 255;dev = 1;}  goto idle; \n\nfi;\nq_i: if\n:: ((chnl[partner[2]])%20)==2; goto talert; \n\n::  d_step {((chnl[partner[2]])%20)!=2;partner[2] = 255;}  goto idle; \n\nfi;\ntalert: if\n:: dev!=1 || chnl[2]==255; goto error_state; \n\n:: ((chnl[partner[2]])%20)==2; goto tpickup; \n\n:: ((chnl[partner[2]])%20)!=2; goto idle; \n\nfi;\nunobtainable: if\n::  d_step {chnl[2] = 255;partner[2] = 255;dev = 1;}  goto idle; \n\nfi;\noalert: if\n:: ((chnl[2])%20)!=partner[2]; goto error_state; \n\n:: ((chnl[2])%20)==partner[2] && ((chnl[2])/20)==1; goto oconnected; \n\n:: ((chnl[2])%20)==partner[2] && ((chnl[2])/20)==0; goto oringout; \n\nfi;\noconnected: if\n::  d_step {dev = 1;chnl[2] = 255;chnl[partner[2]] = 255;}  goto idle; \n\nfi;\noringout: if\n::  d_step {dev = 1;chnl[2] = 255;partner[2] = ((((partner[2])%20))+(0)*20);}  goto idle; \n\nfi;\ntpickup: if\n::  d_step {((chnl[partner[2]])%20)==2 && ((chnl[partner[2]])/20)==0;dev = 0;chnl[partner[2]] = ((2)+(1)*20);chnl[2] = ((partner[2])+(1)*20);}  goto tconnected; \n\n::  d_step {chnl[partner[2]]==255 || ((chnl[partner[2]])%20)!=2;dev = 1;partner[2] = 255;chnl[2] = 255;}  goto idle; \n\nfi;\ntconnected: if\n::  d_step {((chnl[2])/20)==1 && dev==0;dev = 1;}  goto tconnected; \n\n::  d_step {((chnl[2])/20)==1 && dev==1;dev = 0;}  goto tconnected; \n\n::  d_step {((chnl[2])/20)==0;partner[2] = 255;chnl[2] = 255;dev = 1;}  goto idle; \n\nfi;\nringback: if\n::  d_step {chnl[2] = 255;partner[2] = 255;dev = 1;}  goto idle; \n\n::  d_step {record[2]!=255;partner[2] = record[2];}  goto calling; \n\nfi;\nerror_state: \n false; }\n\nproctype User_3() { \nbyte dev=1;\nbyte mbit=0;\n\nidle: if\n::  d_step {chnl[3]==255;dev = 0;chnl[3] = ((3)+(0)*20);}  goto dialing; \n\n::  d_step {chnl[3]!=255;partner[3] = ((chnl[3])%20);}  goto q_i; \n\nfi;\ndialing: if\n::  d_step {dev = 1;chnl[3] = 255;}  goto idle; \n\n:: partner[3] = 0; goto calling; \n\n:: partner[3] = 1; goto calling; \n\n:: partner[3] = 2; goto calling; \n\n:: partner[3] = 3; goto calling; \n\n:: partner[3] = 4; goto calling; \n\nfi;\ncalling: if\n:: partner[3]==3; goto busy; \n\n:: partner[3]==4; goto unobtainable; \n\n:: partner[3]==4; goto ringback; \n\n::  d_step {partner[3]!=3 && partner[3]!=4 && chnl[partner[3]]!=255 && call_forward_busy[partner[3]]==255;record[partner[3]] = 3;}  goto busy; \n\n::  d_step {partner[3]!=3 && partner[3]!=4 && chnl[partner[3]]!=255 && call_forward_busy[partner[3]]!=255;record[partner[3]] = 3;partner[3] = call_forward_busy[partner[3]];}  goto calling; \n\n::  d_step {partner[3]!=3 && partner[3]!=4 && chnl[partner[3]]==255;record[partner[3]] = 3;chnl[partner[3]] = ((3)+(0)*20);chnl[3] = ((partner[3])+(0)*20);}  goto oalert; \n\nfi;\nbusy: if\n::  d_step {chnl[3] = 255;partner[3] = 255;dev = 1;}  goto idle; \n\nfi;\nq_i: if\n:: ((chnl[partner[3]])%20)==3; goto talert; \n\n::  d_step {((chnl[partner[3]])%20)!=3;partner[3] = 255;}  goto idle; \n\nfi;\ntalert: if\n:: dev!=1 || chnl[3]==255; goto error_state; \n\n:: ((chnl[partner[3]])%20)==3; goto tpickup; \n\n:: ((chnl[partner[3]])%20)!=3; goto idle; \n\nfi;\nunobtainable: if\n::  d_step {chnl[3] = 255;partner[3] = 255;dev = 1;}  goto idle; \n\nfi;\noalert: if\n:: ((chnl[3])%20)!=partner[3]; goto error_state; \n\n:: ((chnl[3])%20)==partner[3] && ((chnl[3])/20)==1; goto oconnected; \n\n:: ((chnl[3])%20)==partner[3] && ((chnl[3])/20)==0; goto oringout; \n\nfi;\noconnected: if\n::  d_step {dev = 1;chnl[3] = 255;chnl[partner[3]] = 255;}  goto idle; \n\nfi;\noringout: if\n::  d_step {dev = 1;chnl[3] = 255;partner[3] = ((((partner[3])%20))+(0)*20);}  goto idle; \n\nfi;\ntpickup: if\n::  d_step {((chnl[partner[3]])%20)==3 && ((chnl[partner[3]])/20)==0;dev = 0;chnl[partner[3]] = ((3)+(1)*20);chnl[3] = ((partner[3])+(1)*20);}  goto tconnected; \n\n::  d_step {chnl[partner[3]]==255 || ((chnl[partner[3]])%20)!=3;dev = 1;partner[3] = 255;chnl[3] = 255;}  goto idle; \n\nfi;\ntconnected: if\n::  d_step {((chnl[3])/20)==1 && dev==0;dev = 1;}  goto tconnected; \n\n::  d_step {((chnl[3])/20)==1 && dev==1;dev = 0;}  goto tconnected; \n\n::  d_step {((chnl[3])/20)==0;partner[3] = 255;chnl[3] = 255;dev = 1;}  goto idle; \n\nfi;\nringback: if\n::  d_step {chnl[3] = 255;partner[3] = 255;dev = 1;}  goto idle; \n\n::  d_step {record[3]!=255;partner[3] = record[3];}  goto calling; \n\nfi;\nerror_state: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Model of a telecommunication service with some features\n    (call forward when busy, ring back when free).\n\nParameters:\n\n\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte chnl[4];\nbyte partner[4];\nbyte record[4];\n\n\ninit { \n d_step { \nchnl[0] =255; chnl[1] =255; chnl[2] =255; chnl[3] =255; partner[0] =255; partner[1] =255; partner[2] =255; partner[3] =255; record[0] =255; record[1] =255; record[2] =255; record[3] =255; }\natomic { \nrun User_0();\nrun User_1();\nrun User_2();\nrun User_3();\n} }\n\nproctype User_0() { \nbyte dev=1;\nbyte mbit=0;\n\nidle: if\n::  d_step {chnl[0]==255;dev = 0;chnl[0] = ((0)+(0)*20);}  goto dialing; \n\n::  d_step {chnl[0]!=255;partner[0] = ((chnl[0])%20);}  goto q_i; \n\nfi;\ndialing: if\n::  d_step {dev = 1;chnl[0] = 255;}  goto idle; \n\n:: partner[0] = 0; goto calling; \n\n:: partner[0] = 1; goto calling; \n\n:: partner[0] = 2; goto calling; \n\n:: partner[0] = 3; goto calling; \n\n:: partner[0] = 4; goto calling; \n\nfi;\ncalling: if\n:: partner[0]==0; goto busy; \n\n:: partner[0]==4; goto unobtainable; \n\n:: partner[0]==4; goto ringback; \n\n::  d_step {partner[0]!=0 && partner[0]!=4 && chnl[partner[0]]!=255;record[partner[0]] = 0;}  goto busy; \n\n::  d_step {partner[0]!=0 && partner[0]!=4 && chnl[partner[0]]==255;record[partner[0]] = 0;chnl[partner[0]] = ((0)+(0)*20);chnl[0] = ((partner[0])+(0)*20);}  goto oalert; \n\nfi;\nbusy: if\n::  d_step {chnl[0] = 255;partner[0] = 255;dev = 1;}  goto idle; \n\nfi;\nq_i: if\n:: ((chnl[partner[0]])%20)==0; goto talert; \n\n::  d_step {((chnl[partner[0]])%20)!=0;partner[0] = 255;}  goto idle; \n\nfi;\ntalert: if\n:: dev!=1 || chnl[0]==255; goto error_state; \n\n:: ((chnl[partner[0]])%20)==0; goto tpickup; \n\n:: ((chnl[partner[0]])%20)!=0; goto idle; \n\nfi;\nunobtainable: if\n::  d_step {chnl[0] = 255;partner[0] = 255;dev = 1;}  goto idle; \n\nfi;\noalert: if\n:: ((chnl[0])%20)!=partner[0]; goto error_state; \n\n:: ((chnl[0])%20)==partner[0] && ((chnl[0])/20)==1; goto oconnected; \n\n:: ((chnl[0])%20)==partner[0] && ((chnl[0])/20)==0; goto oringout; \n\nfi;\noconnected: if\n::  d_step {dev = 1;chnl[0] = 255;chnl[partner[0]] = 255;}  goto idle; \n\nfi;\noringout: if\n::  d_step {dev = 1;chnl[0] = 255;partner[0] = ((((partner[0])%20))+(0)*20);}  goto idle; \n\nfi;\ntpickup: if\n::  d_step {((chnl[partner[0]])%20)==0 && ((chnl[partner[0]])/20)==0;dev = 0;chnl[partner[0]] = ((0)+(1)*20);chnl[0] = ((partner[0])+(1)*20);}  goto tconnected; \n\n::  d_step {chnl[partner[0]]==255 || ((chnl[partner[0]])%20)!=0;dev = 1;partner[0] = 255;chnl[0] = 255;}  goto idle; \n\nfi;\ntconnected: if\n::  d_step {((chnl[0])/20)==1 && dev==0;dev = 1;}  goto tconnected; \n\n::  d_step {((chnl[0])/20)==1 && dev==1;dev = 0;}  goto tconnected; \n\n::  d_step {((chnl[0])/20)==0;partner[0] = 255;chnl[0] = 255;}  goto idle; \n\nfi;\nringback: if\n::  d_step {chnl[0] = 255;partner[0] = 255;dev = 1;}  goto idle; \n\n::  d_step {record[0]!=255;partner[0] = record[0];}  goto calling; \n\nfi;\nerror_state: \n false; }\n\nproctype User_1() { \nbyte dev=1;\nbyte mbit=0;\n\nidle: if\n::  d_step {chnl[1]==255;dev = 0;chnl[1] = ((1)+(0)*20);}  goto dialing; \n\n::  d_step {chnl[1]!=255;partner[1] = ((chnl[1])%20);}  goto q_i; \n\nfi;\ndialing: if\n::  d_step {dev = 1;chnl[1] = 255;}  goto idle; \n\n:: partner[1] = 0; goto calling; \n\n:: partner[1] = 1; goto calling; \n\n:: partner[1] = 2; goto calling; \n\n:: partner[1] = 3; goto calling; \n\n:: partner[1] = 4; goto calling; \n\nfi;\ncalling: if\n:: partner[1]==1; goto busy; \n\n:: partner[1]==4; goto unobtainable; \n\n:: partner[1]==4; goto ringback; \n\n::  d_step {partner[1]!=1 && partner[1]!=4 && chnl[partner[1]]!=255;record[partner[1]] = 1;}  goto busy; \n\n::  d_step {partner[1]!=1 && partner[1]!=4 && chnl[partner[1]]==255;record[partner[1]] = 1;chnl[partner[1]] = ((1)+(0)*20);chnl[1] = ((partner[1])+(0)*20);}  goto oalert; \n\nfi;\nbusy: if\n::  d_step {chnl[1] = 255;partner[1] = 255;dev = 1;}  goto idle; \n\nfi;\nq_i: if\n:: ((chnl[partner[1]])%20)==1; goto talert; \n\n::  d_step {((chnl[partner[1]])%20)!=1;partner[1] = 255;}  goto idle; \n\nfi;\ntalert: if\n:: dev!=1 || chnl[1]==255; goto error_state; \n\n:: ((chnl[partner[1]])%20)==1; goto tpickup; \n\n:: ((chnl[partner[1]])%20)!=1; goto idle; \n\nfi;\nunobtainable: if\n::  d_step {chnl[1] = 255;partner[1] = 255;dev = 1;}  goto idle; \n\nfi;\noalert: if\n:: ((chnl[1])%20)!=partner[1]; goto error_state; \n\n:: ((chnl[1])%20)==partner[1] && ((chnl[1])/20)==1; goto oconnected; \n\n:: ((chnl[1])%20)==partner[1] && ((chnl[1])/20)==0; goto oringout; \n\nfi;\noconnected: if\n::  d_step {dev = 1;chnl[1] = 255;chnl[partner[1]] = 255;}  goto idle; \n\nfi;\noringout: if\n::  d_step {dev = 1;chnl[1] = 255;partner[1] = ((((partner[1])%20))+(0)*20);}  goto idle; \n\nfi;\ntpickup: if\n::  d_step {((chnl[partner[1]])%20)==1 && ((chnl[partner[1]])/20)==0;dev = 0;chnl[partner[1]] = ((1)+(1)*20);chnl[1] = ((partner[1])+(1)*20);}  goto tconnected; \n\n::  d_step {chnl[partner[1]]==255 || ((chnl[partner[1]])%20)!=1;dev = 1;partner[1] = 255;chnl[1] = 255;}  goto idle; \n\nfi;\ntconnected: if\n::  d_step {((chnl[1])/20)==1 && dev==0;dev = 1;}  goto tconnected; \n\n::  d_step {((chnl[1])/20)==1 && dev==1;dev = 0;}  goto tconnected; \n\n::  d_step {((chnl[1])/20)==0;partner[1] = 255;chnl[1] = 255;}  goto idle; \n\nfi;\nringback: if\n::  d_step {chnl[1] = 255;partner[1] = 255;dev = 1;}  goto idle; \n\n::  d_step {record[1]!=255;partner[1] = record[1];}  goto calling; \n\nfi;\nerror_state: \n false; }\n\nproctype User_2() { \nbyte dev=1;\nbyte mbit=0;\n\nidle: if\n::  d_step {chnl[2]==255;dev = 0;chnl[2] = ((2)+(0)*20);}  goto dialing; \n\n::  d_step {chnl[2]!=255;partner[2] = ((chnl[2])%20);}  goto q_i; \n\nfi;\ndialing: if\n::  d_step {dev = 1;chnl[2] = 255;}  goto idle; \n\n:: partner[2] = 0; goto calling; \n\n:: partner[2] = 1; goto calling; \n\n:: partner[2] = 2; goto calling; \n\n:: partner[2] = 3; goto calling; \n\n:: partner[2] = 4; goto calling; \n\nfi;\ncalling: if\n:: partner[2]==2; goto busy; \n\n:: partner[2]==4; goto unobtainable; \n\n:: partner[2]==4; goto ringback; \n\n::  d_step {partner[2]!=2 && partner[2]!=4 && chnl[partner[2]]!=255;record[partner[2]] = 2;}  goto busy; \n\n::  d_step {partner[2]!=2 && partner[2]!=4 && chnl[partner[2]]==255;record[partner[2]] = 2;chnl[partner[2]] = ((2)+(0)*20);chnl[2] = ((partner[2])+(0)*20);}  goto oalert; \n\nfi;\nbusy: if\n::  d_step {chnl[2] = 255;partner[2] = 255;dev = 1;}  goto idle; \n\nfi;\nq_i: if\n:: ((chnl[partner[2]])%20)==2; goto talert; \n\n::  d_step {((chnl[partner[2]])%20)!=2;partner[2] = 255;}  goto idle; \n\nfi;\ntalert: if\n:: dev!=1 || chnl[2]==255; goto error_state; \n\n:: ((chnl[partner[2]])%20)==2; goto tpickup; \n\n:: ((chnl[partner[2]])%20)!=2; goto idle; \n\nfi;\nunobtainable: if\n::  d_step {chnl[2] = 255;partner[2] = 255;dev = 1;}  goto idle; \n\nfi;\noalert: if\n:: ((chnl[2])%20)!=partner[2]; goto error_state; \n\n:: ((chnl[2])%20)==partner[2] && ((chnl[2])/20)==1; goto oconnected; \n\n:: ((chnl[2])%20)==partner[2] && ((chnl[2])/20)==0; goto oringout; \n\nfi;\noconnected: if\n::  d_step {dev = 1;chnl[2] = 255;chnl[partner[2]] = 255;}  goto idle; \n\nfi;\noringout: if\n::  d_step {dev = 1;chnl[2] = 255;partner[2] = ((((partner[2])%20))+(0)*20);}  goto idle; \n\nfi;\ntpickup: if\n::  d_step {((chnl[partner[2]])%20)==2 && ((chnl[partner[2]])/20)==0;dev = 0;chnl[partner[2]] = ((2)+(1)*20);chnl[2] = ((partner[2])+(1)*20);}  goto tconnected; \n\n::  d_step {chnl[partner[2]]==255 || ((chnl[partner[2]])%20)!=2;dev = 1;partner[2] = 255;chnl[2] = 255;}  goto idle; \n\nfi;\ntconnected: if\n::  d_step {((chnl[2])/20)==1 && dev==0;dev = 1;}  goto tconnected; \n\n::  d_step {((chnl[2])/20)==1 && dev==1;dev = 0;}  goto tconnected; \n\n::  d_step {((chnl[2])/20)==0;partner[2] = 255;chnl[2] = 255;}  goto idle; \n\nfi;\nringback: if\n::  d_step {chnl[2] = 255;partner[2] = 255;dev = 1;}  goto idle; \n\n::  d_step {record[2]!=255;partner[2] = record[2];}  goto calling; \n\nfi;\nerror_state: \n false; }\n\nproctype User_3() { \nbyte dev=1;\nbyte mbit=0;\n\nidle: if\n::  d_step {chnl[3]==255;dev = 0;chnl[3] = ((3)+(0)*20);}  goto dialing; \n\n::  d_step {chnl[3]!=255;partner[3] = ((chnl[3])%20);}  goto q_i; \n\nfi;\ndialing: if\n::  d_step {dev = 1;chnl[3] = 255;}  goto idle; \n\n:: partner[3] = 0; goto calling; \n\n:: partner[3] = 1; goto calling; \n\n:: partner[3] = 2; goto calling; \n\n:: partner[3] = 3; goto calling; \n\n:: partner[3] = 4; goto calling; \n\nfi;\ncalling: if\n:: partner[3]==3; goto busy; \n\n:: partner[3]==4; goto unobtainable; \n\n:: partner[3]==4; goto ringback; \n\n::  d_step {partner[3]!=3 && partner[3]!=4 && chnl[partner[3]]!=255;record[partner[3]] = 3;}  goto busy; \n\n::  d_step {partner[3]!=3 && partner[3]!=4 && chnl[partner[3]]==255;record[partner[3]] = 3;chnl[partner[3]] = ((3)+(0)*20);chnl[3] = ((partner[3])+(0)*20);}  goto oalert; \n\nfi;\nbusy: if\n::  d_step {chnl[3] = 255;partner[3] = 255;dev = 1;}  goto idle; \n\nfi;\nq_i: if\n:: ((chnl[partner[3]])%20)==3; goto talert; \n\n::  d_step {((chnl[partner[3]])%20)!=3;partner[3] = 255;}  goto idle; \n\nfi;\ntalert: if\n:: dev!=1 || chnl[3]==255; goto error_state; \n\n:: ((chnl[partner[3]])%20)==3; goto tpickup; \n\n:: ((chnl[partner[3]])%20)!=3; goto idle; \n\nfi;\nunobtainable: if\n::  d_step {chnl[3] = 255;partner[3] = 255;dev = 1;}  goto idle; \n\nfi;\noalert: if\n:: ((chnl[3])%20)!=partner[3]; goto error_state; \n\n:: ((chnl[3])%20)==partner[3] && ((chnl[3])/20)==1; goto oconnected; \n\n:: ((chnl[3])%20)==partner[3] && ((chnl[3])/20)==0; goto oringout; \n\nfi;\noconnected: if\n::  d_step {dev = 1;chnl[3] = 255;chnl[partner[3]] = 255;}  goto idle; \n\nfi;\noringout: if\n::  d_step {dev = 1;chnl[3] = 255;partner[3] = ((((partner[3])%20))+(0)*20);}  goto idle; \n\nfi;\ntpickup: if\n::  d_step {((chnl[partner[3]])%20)==3 && ((chnl[partner[3]])/20)==0;dev = 0;chnl[partner[3]] = ((3)+(1)*20);chnl[3] = ((partner[3])+(1)*20);}  goto tconnected; \n\n::  d_step {chnl[partner[3]]==255 || ((chnl[partner[3]])%20)!=3;dev = 1;partner[3] = 255;chnl[3] = 255;}  goto idle; \n\nfi;\ntconnected: if\n::  d_step {((chnl[3])/20)==1 && dev==0;dev = 1;}  goto tconnected; \n\n::  d_step {((chnl[3])/20)==1 && dev==1;dev = 0;}  goto tconnected; \n\n::  d_step {((chnl[3])/20)==0;partner[3] = 255;chnl[3] = 255;}  goto idle; \n\nfi;\nringback: if\n::  d_step {chnl[3] = 255;partner[3] = 255;dev = 1;}  goto idle; \n\n::  d_step {record[3]!=255;partner[3] = record[3];}  goto calling; \n\nfi;\nerror_state: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Model of a telecommunication service with some features\n    (call forward when busy, ring back when free).\n\nParameters:\n\n\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte chnl[4];\nbyte partner[4];\nbyte call_forward_busy[4];\n\n\ninit { \n d_step { \nchnl[0] =255; chnl[1] =255; chnl[2] =255; chnl[3] =255; partner[0] =255; partner[1] =255; partner[2] =255; partner[3] =255; call_forward_busy[0] =1; call_forward_busy[1] =2; call_forward_busy[2] =3; call_forward_busy[3] =255; }\natomic { \nrun User_0();\nrun User_1();\nrun User_2();\nrun User_3();\n} }\n\nproctype User_0() { \nbyte dev=1;\nbyte mbit=0;\n\nidle: if\n::  d_step {chnl[0]==255;dev = 0;chnl[0] = ((0)+(0)*20);}  goto dialing; \n\n::  d_step {chnl[0]!=255;partner[0] = ((chnl[0])%20);}  goto q_i; \n\nfi;\ndialing: if\n::  d_step {dev = 1;chnl[0] = 255;}  goto idle; \n\n:: partner[0] = 0; goto calling; \n\n:: partner[0] = 1; goto calling; \n\n:: partner[0] = 2; goto calling; \n\n:: partner[0] = 3; goto calling; \n\n:: partner[0] = 4; goto calling; \n\nfi;\ncalling: if\n:: partner[0]==0; goto busy; \n\n:: partner[0]==4; goto unobtainable; \n\n:: partner[0]!=0 && partner[0]!=4 && chnl[partner[0]]!=255 && call_forward_busy[partner[0]]==255; goto busy; \n\n::  d_step {partner[0]!=0 && partner[0]!=4 && chnl[partner[0]]!=255 && call_forward_busy[partner[0]]!=255;partner[0] = call_forward_busy[partner[0]];}  goto calling; \n\n::  d_step {partner[0]!=0 && partner[0]!=4 && chnl[partner[0]]==255;chnl[partner[0]] = ((0)+(0)*20);chnl[0] = ((partner[0])+(0)*20);}  goto oalert; \n\nfi;\nbusy: if\n::  d_step {chnl[0] = 255;partner[0] = 255;dev = 1;}  goto idle; \n\nfi;\nq_i: if\n:: ((chnl[partner[0]])%20)==0; goto talert; \n\n::  d_step {((chnl[partner[0]])%20)!=0;partner[0] = 255;}  goto idle; \n\nfi;\ntalert: if\n:: dev!=1 || chnl[0]==255; goto error_state; \n\n:: ((chnl[partner[0]])%20)==0; goto tpickup; \n\n:: ((chnl[partner[0]])%20)!=0; goto idle; \n\nfi;\nunobtainable: if\n::  d_step {chnl[0] = 255;partner[0] = 255;dev = 1;}  goto idle; \n\nfi;\noalert: if\n:: ((chnl[0])%20)!=partner[0]; goto error_state; \n\n:: ((chnl[0])%20)==partner[0] && ((chnl[0])/20)==1; goto oconnected; \n\n:: ((chnl[0])%20)==partner[0] && ((chnl[0])/20)==0; goto oringout; \n\nfi;\noconnected: if\n::  d_step {dev = 1;chnl[0] = 255;chnl[partner[0]] = 255;}  goto idle; \n\nfi;\noringout: if\n::  d_step {dev = 1;chnl[0] = 255;partner[0] = ((((partner[0])%20))+(0)*20);}  goto idle; \n\nfi;\ntpickup: if\n::  d_step {((chnl[partner[0]])%20)==0 && ((chnl[partner[0]])/20)==0;dev = 0;chnl[partner[0]] = ((0)+(1)*20);chnl[0] = ((partner[0])+(1)*20);}  goto tconnected; \n\n::  d_step {chnl[partner[0]]==255 || ((chnl[partner[0]])%20)!=0;dev = 1;partner[0] = 255;chnl[0] = 255;}  goto idle; \n\nfi;\ntconnected: if\n::  d_step {((chnl[0])/20)==1 && dev==0;dev = 1;}  goto tconnected; \n\n::  d_step {((chnl[0])/20)==1 && dev==1;dev = 0;}  goto tconnected; \n\n::  d_step {((chnl[0])/20)==0;partner[0] = 255;chnl[0] = 255;}  goto idle; \n\nfi;\nerror_state: \nringback: \n false; }\n\nproctype User_1() { \nbyte dev=1;\nbyte mbit=0;\n\nidle: if\n::  d_step {chnl[1]==255;dev = 0;chnl[1] = ((1)+(0)*20);}  goto dialing; \n\n::  d_step {chnl[1]!=255;partner[1] = ((chnl[1])%20);}  goto q_i; \n\nfi;\ndialing: if\n::  d_step {dev = 1;chnl[1] = 255;}  goto idle; \n\n:: partner[1] = 0; goto calling; \n\n:: partner[1] = 1; goto calling; \n\n:: partner[1] = 2; goto calling; \n\n:: partner[1] = 3; goto calling; \n\n:: partner[1] = 4; goto calling; \n\nfi;\ncalling: if\n:: partner[1]==1; goto busy; \n\n:: partner[1]==4; goto unobtainable; \n\n:: partner[1]!=1 && partner[1]!=4 && chnl[partner[1]]!=255 && call_forward_busy[partner[1]]==255; goto busy; \n\n::  d_step {partner[1]!=1 && partner[1]!=4 && chnl[partner[1]]!=255 && call_forward_busy[partner[1]]!=255;partner[1] = call_forward_busy[partner[1]];}  goto calling; \n\n::  d_step {partner[1]!=1 && partner[1]!=4 && chnl[partner[1]]==255;chnl[partner[1]] = ((1)+(0)*20);chnl[1] = ((partner[1])+(0)*20);}  goto oalert; \n\nfi;\nbusy: if\n::  d_step {chnl[1] = 255;partner[1] = 255;dev = 1;}  goto idle; \n\nfi;\nq_i: if\n:: ((chnl[partner[1]])%20)==1; goto talert; \n\n::  d_step {((chnl[partner[1]])%20)!=1;partner[1] = 255;}  goto idle; \n\nfi;\ntalert: if\n:: dev!=1 || chnl[1]==255; goto error_state; \n\n:: ((chnl[partner[1]])%20)==1; goto tpickup; \n\n:: ((chnl[partner[1]])%20)!=1; goto idle; \n\nfi;\nunobtainable: if\n::  d_step {chnl[1] = 255;partner[1] = 255;dev = 1;}  goto idle; \n\nfi;\noalert: if\n:: ((chnl[1])%20)!=partner[1]; goto error_state; \n\n:: ((chnl[1])%20)==partner[1] && ((chnl[1])/20)==1; goto oconnected; \n\n:: ((chnl[1])%20)==partner[1] && ((chnl[1])/20)==0; goto oringout; \n\nfi;\noconnected: if\n::  d_step {dev = 1;chnl[1] = 255;chnl[partner[1]] = 255;}  goto idle; \n\nfi;\noringout: if\n::  d_step {dev = 1;chnl[1] = 255;partner[1] = ((((partner[1])%20))+(0)*20);}  goto idle; \n\nfi;\ntpickup: if\n::  d_step {((chnl[partner[1]])%20)==1 && ((chnl[partner[1]])/20)==0;dev = 0;chnl[partner[1]] = ((1)+(1)*20);chnl[1] = ((partner[1])+(1)*20);}  goto tconnected; \n\n::  d_step {chnl[partner[1]]==255 || ((chnl[partner[1]])%20)!=1;dev = 1;partner[1] = 255;chnl[1] = 255;}  goto idle; \n\nfi;\ntconnected: if\n::  d_step {((chnl[1])/20)==1 && dev==0;dev = 1;}  goto tconnected; \n\n::  d_step {((chnl[1])/20)==1 && dev==1;dev = 0;}  goto tconnected; \n\n::  d_step {((chnl[1])/20)==0;partner[1] = 255;chnl[1] = 255;}  goto idle; \n\nfi;\nerror_state: \nringback: \n false; }\n\nproctype User_2() { \nbyte dev=1;\nbyte mbit=0;\n\nidle: if\n::  d_step {chnl[2]==255;dev = 0;chnl[2] = ((2)+(0)*20);}  goto dialing; \n\n::  d_step {chnl[2]!=255;partner[2] = ((chnl[2])%20);}  goto q_i; \n\nfi;\ndialing: if\n::  d_step {dev = 1;chnl[2] = 255;}  goto idle; \n\n:: partner[2] = 0; goto calling; \n\n:: partner[2] = 1; goto calling; \n\n:: partner[2] = 2; goto calling; \n\n:: partner[2] = 3; goto calling; \n\n:: partner[2] = 4; goto calling; \n\nfi;\ncalling: if\n:: partner[2]==2; goto busy; \n\n:: partner[2]==4; goto unobtainable; \n\n:: partner[2]!=2 && partner[2]!=4 && chnl[partner[2]]!=255 && call_forward_busy[partner[2]]==255; goto busy; \n\n::  d_step {partner[2]!=2 && partner[2]!=4 && chnl[partner[2]]!=255 && call_forward_busy[partner[2]]!=255;partner[2] = call_forward_busy[partner[2]];}  goto calling; \n\n::  d_step {partner[2]!=2 && partner[2]!=4 && chnl[partner[2]]==255;chnl[partner[2]] = ((2)+(0)*20);chnl[2] = ((partner[2])+(0)*20);}  goto oalert; \n\nfi;\nbusy: if\n::  d_step {chnl[2] = 255;partner[2] = 255;dev = 1;}  goto idle; \n\nfi;\nq_i: if\n:: ((chnl[partner[2]])%20)==2; goto talert; \n\n::  d_step {((chnl[partner[2]])%20)!=2;partner[2] = 255;}  goto idle; \n\nfi;\ntalert: if\n:: dev!=1 || chnl[2]==255; goto error_state; \n\n:: ((chnl[partner[2]])%20)==2; goto tpickup; \n\n:: ((chnl[partner[2]])%20)!=2; goto idle; \n\nfi;\nunobtainable: if\n::  d_step {chnl[2] = 255;partner[2] = 255;dev = 1;}  goto idle; \n\nfi;\noalert: if\n:: ((chnl[2])%20)!=partner[2]; goto error_state; \n\n:: ((chnl[2])%20)==partner[2] && ((chnl[2])/20)==1; goto oconnected; \n\n:: ((chnl[2])%20)==partner[2] && ((chnl[2])/20)==0; goto oringout; \n\nfi;\noconnected: if\n::  d_step {dev = 1;chnl[2] = 255;chnl[partner[2]] = 255;}  goto idle; \n\nfi;\noringout: if\n::  d_step {dev = 1;chnl[2] = 255;partner[2] = ((((partner[2])%20))+(0)*20);}  goto idle; \n\nfi;\ntpickup: if\n::  d_step {((chnl[partner[2]])%20)==2 && ((chnl[partner[2]])/20)==0;dev = 0;chnl[partner[2]] = ((2)+(1)*20);chnl[2] = ((partner[2])+(1)*20);}  goto tconnected; \n\n::  d_step {chnl[partner[2]]==255 || ((chnl[partner[2]])%20)!=2;dev = 1;partner[2] = 255;chnl[2] = 255;}  goto idle; \n\nfi;\ntconnected: if\n::  d_step {((chnl[2])/20)==1 && dev==0;dev = 1;}  goto tconnected; \n\n::  d_step {((chnl[2])/20)==1 && dev==1;dev = 0;}  goto tconnected; \n\n::  d_step {((chnl[2])/20)==0;partner[2] = 255;chnl[2] = 255;}  goto idle; \n\nfi;\nerror_state: \nringback: \n false; }\n\nproctype User_3() { \nbyte dev=1;\nbyte mbit=0;\n\nidle: if\n::  d_step {chnl[3]==255;dev = 0;chnl[3] = ((3)+(0)*20);}  goto dialing; \n\n::  d_step {chnl[3]!=255;partner[3] = ((chnl[3])%20);}  goto q_i; \n\nfi;\ndialing: if\n::  d_step {dev = 1;chnl[3] = 255;}  goto idle; \n\n:: partner[3] = 0; goto calling; \n\n:: partner[3] = 1; goto calling; \n\n:: partner[3] = 2; goto calling; \n\n:: partner[3] = 3; goto calling; \n\n:: partner[3] = 4; goto calling; \n\nfi;\ncalling: if\n:: partner[3]==3; goto busy; \n\n:: partner[3]==4; goto unobtainable; \n\n:: partner[3]!=3 && partner[3]!=4 && chnl[partner[3]]!=255 && call_forward_busy[partner[3]]==255; goto busy; \n\n::  d_step {partner[3]!=3 && partner[3]!=4 && chnl[partner[3]]!=255 && call_forward_busy[partner[3]]!=255;partner[3] = call_forward_busy[partner[3]];}  goto calling; \n\n::  d_step {partner[3]!=3 && partner[3]!=4 && chnl[partner[3]]==255;chnl[partner[3]] = ((3)+(0)*20);chnl[3] = ((partner[3])+(0)*20);}  goto oalert; \n\nfi;\nbusy: if\n::  d_step {chnl[3] = 255;partner[3] = 255;dev = 1;}  goto idle; \n\nfi;\nq_i: if\n:: ((chnl[partner[3]])%20)==3; goto talert; \n\n::  d_step {((chnl[partner[3]])%20)!=3;partner[3] = 255;}  goto idle; \n\nfi;\ntalert: if\n:: dev!=1 || chnl[3]==255; goto error_state; \n\n:: ((chnl[partner[3]])%20)==3; goto tpickup; \n\n:: ((chnl[partner[3]])%20)!=3; goto idle; \n\nfi;\nunobtainable: if\n::  d_step {chnl[3] = 255;partner[3] = 255;dev = 1;}  goto idle; \n\nfi;\noalert: if\n:: ((chnl[3])%20)!=partner[3]; goto error_state; \n\n:: ((chnl[3])%20)==partner[3] && ((chnl[3])/20)==1; goto oconnected; \n\n:: ((chnl[3])%20)==partner[3] && ((chnl[3])/20)==0; goto oringout; \n\nfi;\noconnected: if\n::  d_step {dev = 1;chnl[3] = 255;chnl[partner[3]] = 255;}  goto idle; \n\nfi;\noringout: if\n::  d_step {dev = 1;chnl[3] = 255;partner[3] = ((((partner[3])%20))+(0)*20);}  goto idle; \n\nfi;\ntpickup: if\n::  d_step {((chnl[partner[3]])%20)==3 && ((chnl[partner[3]])/20)==0;dev = 0;chnl[partner[3]] = ((3)+(1)*20);chnl[3] = ((partner[3])+(1)*20);}  goto tconnected; \n\n::  d_step {chnl[partner[3]]==255 || ((chnl[partner[3]])%20)!=3;dev = 1;partner[3] = 255;chnl[3] = 255;}  goto idle; \n\nfi;\ntconnected: if\n::  d_step {((chnl[3])/20)==1 && dev==0;dev = 1;}  goto tconnected; \n\n::  d_step {((chnl[3])/20)==1 && dev==1;dev = 0;}  goto tconnected; \n\n::  d_step {((chnl[3])/20)==0;partner[3] = 255;chnl[3] = 255;}  goto idle; \n\nfi;\nerror_state: \nringback: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "Model of a telecommunication service with some features\n    (call forward when busy, ring back when free).\n\nParameters:\n\n\n\n\n\nAtomic propositions:\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte chnl[4];\nbyte partner[4];\nbyte call_forward_busy[4];\nbyte record[4];\n\n\ninit { \n d_step { \nchnl[0] =255; chnl[1] =255; chnl[2] =255; chnl[3] =255; partner[0] =255; partner[1] =255; partner[2] =255; partner[3] =255; call_forward_busy[0] =1; call_forward_busy[1] =2; call_forward_busy[2] =3; call_forward_busy[3] =255; record[0] =255; record[1] =255; record[2] =255; record[3] =255; }\natomic { \nrun User_0();\nrun User_1();\nrun User_2();\nrun User_3();\n} }\n\nproctype User_0() { \nbyte dev=1;\nbyte mbit=0;\n\nidle: if\n::  d_step {chnl[0]==255;dev = 0;chnl[0] = ((0)+(0)*20);}  goto dialing; \n\n::  d_step {chnl[0]!=255;partner[0] = ((chnl[0])%20);}  goto q_i; \n\nfi;\ndialing: if\n::  d_step {dev = 1;chnl[0] = 255;}  goto idle; \n\n:: partner[0] = 0; goto calling; \n\n:: partner[0] = 1; goto calling; \n\n:: partner[0] = 2; goto calling; \n\n:: partner[0] = 3; goto calling; \n\n:: partner[0] = 4; goto calling; \n\nfi;\ncalling: if\n:: partner[0]==0; goto busy; \n\n:: partner[0]==4; goto unobtainable; \n\n:: partner[0]==4; goto ringback; \n\n::  d_step {partner[0]!=0 && partner[0]!=4 && chnl[partner[0]]!=255 && call_forward_busy[partner[0]]==255;record[partner[0]] = 0;}  goto busy; \n\n::  d_step {partner[0]!=0 && partner[0]!=4 && chnl[partner[0]]!=255 && call_forward_busy[partner[0]]!=255;record[partner[0]] = 0;partner[0] = call_forward_busy[partner[0]];}  goto calling; \n\n::  d_step {partner[0]!=0 && partner[0]!=4 && chnl[partner[0]]==255;record[partner[0]] = 0;chnl[partner[0]] = ((0)+(0)*20);chnl[0] = ((partner[0])+(0)*20);}  goto oalert; \n\nfi;\nbusy: if\n::  d_step {chnl[0] = 255;partner[0] = 255;dev = 1;}  goto idle; \n\nfi;\nq_i: if\n:: ((chnl[partner[0]])%20)==0; goto talert; \n\n::  d_step {((chnl[partner[0]])%20)!=0;partner[0] = 255;}  goto idle; \n\nfi;\ntalert: if\n:: dev!=1 || chnl[0]==255; goto error_state; \n\n:: ((chnl[partner[0]])%20)==0; goto tpickup; \n\n:: ((chnl[partner[0]])%20)!=0; goto idle; \n\nfi;\nunobtainable: if\n::  d_step {chnl[0] = 255;partner[0] = 255;dev = 1;}  goto idle; \n\nfi;\noalert: if\n:: ((chnl[0])%20)!=partner[0]; goto error_state; \n\n:: ((chnl[0])%20)==partner[0] && ((chnl[0])/20)==1; goto oconnected; \n\n:: ((chnl[0])%20)==partner[0] && ((chnl[0])/20)==0; goto oringout; \n\nfi;\noconnected: if\n::  d_step {dev = 1;chnl[0] = 255;chnl[partner[0]] = 255;}  goto idle; \n\nfi;\noringout: if\n::  d_step {dev = 1;chnl[0] = 255;partner[0] = ((((partner[0])%20))+(0)*20);}  goto idle; \n\nfi;\ntpickup: if\n::  d_step {((chnl[partner[0]])%20)==0 && ((chnl[partner[0]])/20)==0;dev = 0;chnl[partner[0]] = ((0)+(1)*20);chnl[0] = ((partner[0])+(1)*20);}  goto tconnected; \n\n::  d_step {chnl[partner[0]]==255 || ((chnl[partner[0]])%20)!=0;dev = 1;partner[0] = 255;chnl[0] = 255;}  goto idle; \n\nfi;\ntconnected: if\n::  d_step {((chnl[0])/20)==1 && dev==0;dev = 1;}  goto tconnected; \n\n::  d_step {((chnl[0])/20)==1 && dev==1;dev = 0;}  goto tconnected; \n\n::  d_step {((chnl[0])/20)==0;partner[0] = 255;chnl[0] = 255;}  goto idle; \n\nfi;\nringback: if\n::  d_step {chnl[0] = 255;partner[0] = 255;dev = 1;}  goto idle; \n\n::  d_step {record[0]!=255;partner[0] = record[0];}  goto calling; \n\nfi;\nerror_state: \n false; }\n\nproctype User_1() { \nbyte dev=1;\nbyte mbit=0;\n\nidle: if\n::  d_step {chnl[1]==255;dev = 0;chnl[1] = ((1)+(0)*20);}  goto dialing; \n\n::  d_step {chnl[1]!=255;partner[1] = ((chnl[1])%20);}  goto q_i; \n\nfi;\ndialing: if\n::  d_step {dev = 1;chnl[1] = 255;}  goto idle; \n\n:: partner[1] = 0; goto calling; \n\n:: partner[1] = 1; goto calling; \n\n:: partner[1] = 2; goto calling; \n\n:: partner[1] = 3; goto calling; \n\n:: partner[1] = 4; goto calling; \n\nfi;\ncalling: if\n:: partner[1]==1; goto busy; \n\n:: partner[1]==4; goto unobtainable; \n\n:: partner[1]==4; goto ringback; \n\n::  d_step {partner[1]!=1 && partner[1]!=4 && chnl[partner[1]]!=255 && call_forward_busy[partner[1]]==255;record[partner[1]] = 1;}  goto busy; \n\n::  d_step {partner[1]!=1 && partner[1]!=4 && chnl[partner[1]]!=255 && call_forward_busy[partner[1]]!=255;record[partner[1]] = 1;partner[1] = call_forward_busy[partner[1]];}  goto calling; \n\n::  d_step {partner[1]!=1 && partner[1]!=4 && chnl[partner[1]]==255;record[partner[1]] = 1;chnl[partner[1]] = ((1)+(0)*20);chnl[1] = ((partner[1])+(0)*20);}  goto oalert; \n\nfi;\nbusy: if\n::  d_step {chnl[1] = 255;partner[1] = 255;dev = 1;}  goto idle; \n\nfi;\nq_i: if\n:: ((chnl[partner[1]])%20)==1; goto talert; \n\n::  d_step {((chnl[partner[1]])%20)!=1;partner[1] = 255;}  goto idle; \n\nfi;\ntalert: if\n:: dev!=1 || chnl[1]==255; goto error_state; \n\n:: ((chnl[partner[1]])%20)==1; goto tpickup; \n\n:: ((chnl[partner[1]])%20)!=1; goto idle; \n\nfi;\nunobtainable: if\n::  d_step {chnl[1] = 255;partner[1] = 255;dev = 1;}  goto idle; \n\nfi;\noalert: if\n:: ((chnl[1])%20)!=partner[1]; goto error_state; \n\n:: ((chnl[1])%20)==partner[1] && ((chnl[1])/20)==1; goto oconnected; \n\n:: ((chnl[1])%20)==partner[1] && ((chnl[1])/20)==0; goto oringout; \n\nfi;\noconnected: if\n::  d_step {dev = 1;chnl[1] = 255;chnl[partner[1]] = 255;}  goto idle; \n\nfi;\noringout: if\n::  d_step {dev = 1;chnl[1] = 255;partner[1] = ((((partner[1])%20))+(0)*20);}  goto idle; \n\nfi;\ntpickup: if\n::  d_step {((chnl[partner[1]])%20)==1 && ((chnl[partner[1]])/20)==0;dev = 0;chnl[partner[1]] = ((1)+(1)*20);chnl[1] = ((partner[1])+(1)*20);}  goto tconnected; \n\n::  d_step {chnl[partner[1]]==255 || ((chnl[partner[1]])%20)!=1;dev = 1;partner[1] = 255;chnl[1] = 255;}  goto idle; \n\nfi;\ntconnected: if\n::  d_step {((chnl[1])/20)==1 && dev==0;dev = 1;}  goto tconnected; \n\n::  d_step {((chnl[1])/20)==1 && dev==1;dev = 0;}  goto tconnected; \n\n::  d_step {((chnl[1])/20)==0;partner[1] = 255;chnl[1] = 255;}  goto idle; \n\nfi;\nringback: if\n::  d_step {chnl[1] = 255;partner[1] = 255;dev = 1;}  goto idle; \n\n::  d_step {record[1]!=255;partner[1] = record[1];}  goto calling; \n\nfi;\nerror_state: \n false; }\n\nproctype User_2() { \nbyte dev=1;\nbyte mbit=0;\n\nidle: if\n::  d_step {chnl[2]==255;dev = 0;chnl[2] = ((2)+(0)*20);}  goto dialing; \n\n::  d_step {chnl[2]!=255;partner[2] = ((chnl[2])%20);}  goto q_i; \n\nfi;\ndialing: if\n::  d_step {dev = 1;chnl[2] = 255;}  goto idle; \n\n:: partner[2] = 0; goto calling; \n\n:: partner[2] = 1; goto calling; \n\n:: partner[2] = 2; goto calling; \n\n:: partner[2] = 3; goto calling; \n\n:: partner[2] = 4; goto calling; \n\nfi;\ncalling: if\n:: partner[2]==2; goto busy; \n\n:: partner[2]==4; goto unobtainable; \n\n:: partner[2]==4; goto ringback; \n\n::  d_step {partner[2]!=2 && partner[2]!=4 && chnl[partner[2]]!=255 && call_forward_busy[partner[2]]==255;record[partner[2]] = 2;}  goto busy; \n\n::  d_step {partner[2]!=2 && partner[2]!=4 && chnl[partner[2]]!=255 && call_forward_busy[partner[2]]!=255;record[partner[2]] = 2;partner[2] = call_forward_busy[partner[2]];}  goto calling; \n\n::  d_step {partner[2]!=2 && partner[2]!=4 && chnl[partner[2]]==255;record[partner[2]] = 2;chnl[partner[2]] = ((2)+(0)*20);chnl[2] = ((partner[2])+(0)*20);}  goto oalert; \n\nfi;\nbusy: if\n::  d_step {chnl[2] = 255;partner[2] = 255;dev = 1;}  goto idle; \n\nfi;\nq_i: if\n:: ((chnl[partner[2]])%20)==2; goto talert; \n\n::  d_step {((chnl[partner[2]])%20)!=2;partner[2] = 255;}  goto idle; \n\nfi;\ntalert: if\n:: dev!=1 || chnl[2]==255; goto error_state; \n\n:: ((chnl[partner[2]])%20)==2; goto tpickup; \n\n:: ((chnl[partner[2]])%20)!=2; goto idle; \n\nfi;\nunobtainable: if\n::  d_step {chnl[2] = 255;partner[2] = 255;dev = 1;}  goto idle; \n\nfi;\noalert: if\n:: ((chnl[2])%20)!=partner[2]; goto error_state; \n\n:: ((chnl[2])%20)==partner[2] && ((chnl[2])/20)==1; goto oconnected; \n\n:: ((chnl[2])%20)==partner[2] && ((chnl[2])/20)==0; goto oringout; \n\nfi;\noconnected: if\n::  d_step {dev = 1;chnl[2] = 255;chnl[partner[2]] = 255;}  goto idle; \n\nfi;\noringout: if\n::  d_step {dev = 1;chnl[2] = 255;partner[2] = ((((partner[2])%20))+(0)*20);}  goto idle; \n\nfi;\ntpickup: if\n::  d_step {((chnl[partner[2]])%20)==2 && ((chnl[partner[2]])/20)==0;dev = 0;chnl[partner[2]] = ((2)+(1)*20);chnl[2] = ((partner[2])+(1)*20);}  goto tconnected; \n\n::  d_step {chnl[partner[2]]==255 || ((chnl[partner[2]])%20)!=2;dev = 1;partner[2] = 255;chnl[2] = 255;}  goto idle; \n\nfi;\ntconnected: if\n::  d_step {((chnl[2])/20)==1 && dev==0;dev = 1;}  goto tconnected; \n\n::  d_step {((chnl[2])/20)==1 && dev==1;dev = 0;}  goto tconnected; \n\n::  d_step {((chnl[2])/20)==0;partner[2] = 255;chnl[2] = 255;}  goto idle; \n\nfi;\nringback: if\n::  d_step {chnl[2] = 255;partner[2] = 255;dev = 1;}  goto idle; \n\n::  d_step {record[2]!=255;partner[2] = record[2];}  goto calling; \n\nfi;\nerror_state: \n false; }\n\nproctype User_3() { \nbyte dev=1;\nbyte mbit=0;\n\nidle: if\n::  d_step {chnl[3]==255;dev = 0;chnl[3] = ((3)+(0)*20);}  goto dialing; \n\n::  d_step {chnl[3]!=255;partner[3] = ((chnl[3])%20);}  goto q_i; \n\nfi;\ndialing: if\n::  d_step {dev = 1;chnl[3] = 255;}  goto idle; \n\n:: partner[3] = 0; goto calling; \n\n:: partner[3] = 1; goto calling; \n\n:: partner[3] = 2; goto calling; \n\n:: partner[3] = 3; goto calling; \n\n:: partner[3] = 4; goto calling; \n\nfi;\ncalling: if\n:: partner[3]==3; goto busy; \n\n:: partner[3]==4; goto unobtainable; \n\n:: partner[3]==4; goto ringback; \n\n::  d_step {partner[3]!=3 && partner[3]!=4 && chnl[partner[3]]!=255 && call_forward_busy[partner[3]]==255;record[partner[3]] = 3;}  goto busy; \n\n::  d_step {partner[3]!=3 && partner[3]!=4 && chnl[partner[3]]!=255 && call_forward_busy[partner[3]]!=255;record[partner[3]] = 3;partner[3] = call_forward_busy[partner[3]];}  goto calling; \n\n::  d_step {partner[3]!=3 && partner[3]!=4 && chnl[partner[3]]==255;record[partner[3]] = 3;chnl[partner[3]] = ((3)+(0)*20);chnl[3] = ((partner[3])+(0)*20);}  goto oalert; \n\nfi;\nbusy: if\n::  d_step {chnl[3] = 255;partner[3] = 255;dev = 1;}  goto idle; \n\nfi;\nq_i: if\n:: ((chnl[partner[3]])%20)==3; goto talert; \n\n::  d_step {((chnl[partner[3]])%20)!=3;partner[3] = 255;}  goto idle; \n\nfi;\ntalert: if\n:: dev!=1 || chnl[3]==255; goto error_state; \n\n:: ((chnl[partner[3]])%20)==3; goto tpickup; \n\n:: ((chnl[partner[3]])%20)!=3; goto idle; \n\nfi;\nunobtainable: if\n::  d_step {chnl[3] = 255;partner[3] = 255;dev = 1;}  goto idle; \n\nfi;\noalert: if\n:: ((chnl[3])%20)!=partner[3]; goto error_state; \n\n:: ((chnl[3])%20)==partner[3] && ((chnl[3])/20)==1; goto oconnected; \n\n:: ((chnl[3])%20)==partner[3] && ((chnl[3])/20)==0; goto oringout; \n\nfi;\noconnected: if\n::  d_step {dev = 1;chnl[3] = 255;chnl[partner[3]] = 255;}  goto idle; \n\nfi;\noringout: if\n::  d_step {dev = 1;chnl[3] = 255;partner[3] = ((((partner[3])%20))+(0)*20);}  goto idle; \n\nfi;\ntpickup: if\n::  d_step {((chnl[partner[3]])%20)==3 && ((chnl[partner[3]])/20)==0;dev = 0;chnl[partner[3]] = ((3)+(1)*20);chnl[3] = ((partner[3])+(1)*20);}  goto tconnected; \n\n::  d_step {chnl[partner[3]]==255 || ((chnl[partner[3]])%20)!=3;dev = 1;partner[3] = 255;chnl[3] = 255;}  goto idle; \n\nfi;\ntconnected: if\n::  d_step {((chnl[3])/20)==1 && dev==0;dev = 1;}  goto tconnected; \n\n::  d_step {((chnl[3])/20)==1 && dev==1;dev = 0;}  goto tconnected; \n\n::  d_step {((chnl[3])/20)==0;partner[3] = 255;chnl[3] = 255;}  goto idle; \n\nfi;\nringback: if\n::  d_step {chnl[3] = 255;partner[3] = 255;dev = 1;}  goto idle; \n\n::  d_step {record[3]!=255;partner[3] = record[3];}  goto calling; \n\nfi;\nerror_state: \n false; }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The example is converted from an UPPAAL demo. The clock x were modeled by new process Clock and byte x is from 0 to 25.\n\nParameters:\n\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte e[3];\nbyte x=0;\nbyte max_x_1=0;\nbyte max_x_2=0;\n\nchan appr =[0] of {int};\nchan stop =[0] of {int};\nchan go =[0] of {int};\nchan leave =[0] of {int};\nchan is_empty =[0] of {int};\nchan notempty =[0] of {int};\nchan hd =[0] of {int};\nchan add =[0] of {int};\nchan rem =[0] of {int};\n\nactive proctype Clock() { \n\nS1: if\n::  d_step {x<=max_x_2 && x<=max_x_1;x = x+1;}  goto S1; \n\nfi;\n}\n\nactive proctype Gate() { \n\nFree: if\n:: notempty?0; goto S5; \n\n:: is_empty?0; goto S4; \n\nfi;\nS1: if\n:: rem?0; goto Free; \n\nfi;\nS2: if\n:: add!0; goto Occ; \n\nfi;\nS3: if\n:: add!0; goto Occ; \n\nfi;\nS4: if\n:: appr?0; goto S3; \n\nfi;\nS5: if\n:: hd!0; goto Send; \n\nfi;\nS6: if\n:: stop!0; goto S2; \n\nfi;\nOcc: if\n:: appr?0; goto S6; \n\n:: leave?0; goto S1; \n\nfi;\nSend: if\n:: go!0; goto Occ; \n\nfi;\n}\n\nactive proctype IntQueue() { \nbyte list[3];\nbyte ln=0;\nbyte i=0;\n\nStart: if\n::  atomic {ln>=1;rem!0;ln = ln-1;i = 0;}  goto Shiftdown; \n\n::  atomic {ln==0;is_empty!0;}  goto Start; \n\n::  atomic {add?0;list[ln] = e;ln = ln+1;}  goto Start; \n\n::  atomic {hd?0;e = list[0];}  goto Start; \n\n::  atomic {ln>0;notempty!0;}  goto Start; \n\nfi;\nShiftdown: if\n::  d_step {i<ln;list[i] = list[i+1];i = i+1;}  goto Shiftdown; \n\n::  d_step {ln==i;list[i] = 0;i = 0;}  goto Start; \n\nfi;\n}\n\nactive proctype Train_1() { \n\nSafe: if\n::  atomic {appr!0;e = 1;x = 0;max_x_1 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==1;go?0;x = 0;max_x_1 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 1;x = 0;max_x_1 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_1 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==1;stop?0;x = 0;max_x_1 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=5;x = 0;max_x_1 = 5;}  goto Cross; \n\nfi;\n}\n\nactive proctype Train_2() { \n\nSafe: if\n::  atomic {appr!0;e = 2;x = 0;max_x_2 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==2;go?0;x = 0;max_x_2 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 2;x = 0;max_x_2 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_2 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==2;stop?0;x = 0;max_x_2 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=5;x = 0;max_x_2 = 5;}  goto Cross; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The example is converted from an UPPAAL demo. The clock x were modeled by new process Clock and byte x is from 0 to 25.\n\nParameters:\n\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte e[5];\nbyte x=0;\nbyte max_x_1=0;\nbyte max_x_2=0;\nbyte max_x_3=0;\nbyte max_x_4=0;\n\nchan appr =[0] of {int};\nchan stop =[0] of {int};\nchan go =[0] of {int};\nchan leave =[0] of {int};\nchan is_empty =[0] of {int};\nchan notempty =[0] of {int};\nchan hd =[0] of {int};\nchan add =[0] of {int};\nchan rem =[0] of {int};\n\nactive proctype Clock() { \n\nS1: if\n::  d_step {x<=max_x_2 && x<=max_x_3 && x<=max_x_4 && x<=max_x_1;x = x+1;}  goto S1; \n\nfi;\n}\n\nactive proctype Gate() { \n\nFree: if\n:: notempty?0; goto S5; \n\n:: is_empty?0; goto S4; \n\nfi;\nS1: if\n:: rem?0; goto Free; \n\nfi;\nS2: if\n:: add!0; goto Occ; \n\nfi;\nS3: if\n:: add!0; goto Occ; \n\nfi;\nS4: if\n:: appr?0; goto S3; \n\nfi;\nS5: if\n:: hd!0; goto Send; \n\nfi;\nS6: if\n:: stop!0; goto S2; \n\nfi;\nOcc: if\n:: appr?0; goto S6; \n\n:: leave?0; goto S1; \n\nfi;\nSend: if\n:: go!0; goto Occ; \n\nfi;\n}\n\nactive proctype IntQueue() { \nbyte list[5];\nbyte ln=0;\nbyte i=0;\n\nStart: if\n::  atomic {ln>=1;rem!0;ln = ln-1;i = 0;}  goto Shiftdown; \n\n::  atomic {ln==0;is_empty!0;}  goto Start; \n\n::  atomic {add?0;list[ln] = e;ln = ln+1;}  goto Start; \n\n::  atomic {hd?0;e = list[0];}  goto Start; \n\n::  atomic {ln>0;notempty!0;}  goto Start; \n\nfi;\nShiftdown: if\n::  d_step {i<ln;list[i] = list[i+1];i = i+1;}  goto Shiftdown; \n\n::  d_step {ln==i;list[i] = 0;i = 0;}  goto Start; \n\nfi;\n}\n\nactive proctype Train_1() { \n\nSafe: if\n::  atomic {appr!0;e = 1;x = 0;max_x_1 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==1;go?0;x = 0;max_x_1 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 1;x = 0;max_x_1 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_1 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==1;stop?0;x = 0;max_x_1 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=7;x = 0;max_x_1 = 5;}  goto Cross; \n\nfi;\n}\n\nactive proctype Train_2() { \n\nSafe: if\n::  atomic {appr!0;e = 2;x = 0;max_x_2 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==2;go?0;x = 0;max_x_2 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 2;x = 0;max_x_2 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_2 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==2;stop?0;x = 0;max_x_2 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=7;x = 0;max_x_2 = 5;}  goto Cross; \n\nfi;\n}\n\nactive proctype Train_3() { \n\nSafe: if\n::  atomic {appr!0;e = 3;x = 0;max_x_3 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==3;go?0;x = 0;max_x_3 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 3;x = 0;max_x_3 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_3 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==3;stop?0;x = 0;max_x_3 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=7;x = 0;max_x_3 = 5;}  goto Cross; \n\nfi;\n}\n\nactive proctype Train_4() { \n\nSafe: if\n::  atomic {appr!0;e = 4;x = 0;max_x_4 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==4;go?0;x = 0;max_x_4 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 4;x = 0;max_x_4 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_4 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==4;stop?0;x = 0;max_x_4 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=7;x = 0;max_x_4 = 5;}  goto Cross; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The example is converted from an UPPAAL demo. The clock x were modeled by new process Clock and byte x is from 0 to 25.\n\nParameters:\n\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte e[5];\nbyte x=0;\nbyte max_x_1=0;\nbyte max_x_2=0;\nbyte max_x_3=0;\nbyte max_x_4=0;\n\nchan appr =[0] of {int};\nchan stop =[0] of {int};\nchan go =[0] of {int};\nchan leave =[0] of {int};\nchan is_empty =[0] of {int};\nchan notempty =[0] of {int};\nchan hd =[0] of {int};\nchan add =[0] of {int};\nchan rem =[0] of {int};\n\nactive proctype Clock() { \n\nS1: if\n::  d_step {x<=max_x_2 && x<=max_x_3 && x<=max_x_4 && x<=max_x_1;x = x+1;}  goto S1; \n\nfi;\n}\n\nactive proctype Gate() { \n\nFree: if\n:: notempty?0; goto S5; \n\n:: is_empty?0; goto S4; \n\nfi;\nS1: if\n:: rem?0; goto Free; \n\nfi;\nS2: if\n:: add!0; goto Occ; \n\nfi;\nS3: if\n:: add!0; goto Occ; \n\nfi;\nS4: if\n:: appr?0; goto S3; \n\nfi;\nS5: if\n:: hd!0; goto Send; \n\nfi;\nS6: if\n:: stop!0; goto S2; \n\nfi;\nOcc: if\n:: appr?0; goto S6; \n\n:: leave?0; goto S1; \n\nfi;\nSend: if\n:: go!0; goto Occ; \n\nfi;\n}\n\nactive proctype IntQueue() { \nbyte list[5];\nbyte ln=0;\nbyte i=0;\n\nStart: if\n::  atomic {ln>=1;rem!0;ln = ln-1;i = 0;}  goto Shiftdown; \n\n::  atomic {ln==0;is_empty!0;}  goto Start; \n\n::  atomic {add?0;list[ln] = e;ln = ln+1;}  goto Start; \n\n::  atomic {hd?0;e = list[0];}  goto Start; \n\n::  atomic {ln>0;notempty!0;}  goto Start; \n\nfi;\nShiftdown: if\n::  d_step {i<ln;list[i] = list[i+1];i = i+1;}  goto Shiftdown; \n\n::  d_step {ln==i;list[i] = 0;i = 0;}  goto Start; \n\nfi;\n}\n\nactive proctype Train_1() { \n\nSafe: if\n::  atomic {appr!0;e = 1;x = 0;max_x_1 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==1;go?0;x = 0;max_x_1 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 1;x = 0;max_x_1 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_1 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==1;stop?0;x = 0;max_x_1 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=5;x = 0;max_x_1 = 5;}  goto Cross; \n\nfi;\n}\n\nactive proctype Train_2() { \n\nSafe: if\n::  atomic {appr!0;e = 2;x = 0;max_x_2 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==2;go?0;x = 0;max_x_2 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 2;x = 0;max_x_2 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_2 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==2;stop?0;x = 0;max_x_2 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=5;x = 0;max_x_2 = 5;}  goto Cross; \n\nfi;\n}\n\nactive proctype Train_3() { \n\nSafe: if\n::  atomic {appr!0;e = 3;x = 0;max_x_3 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==3;go?0;x = 0;max_x_3 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 3;x = 0;max_x_3 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_3 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==3;stop?0;x = 0;max_x_3 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=5;x = 0;max_x_3 = 5;}  goto Cross; \n\nfi;\n}\n\nactive proctype Train_4() { \n\nSafe: if\n::  atomic {appr!0;e = 4;x = 0;max_x_4 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==4;go?0;x = 0;max_x_4 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 4;x = 0;max_x_4 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_4 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==4;stop?0;x = 0;max_x_4 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=5;x = 0;max_x_4 = 5;}  goto Cross; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The example is converted from an UPPAAL demo. The clock x were modeled by new process Clock and byte x is from 0 to 25.\n\nParameters:\n\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte e[7];\nbyte x=0;\nbyte max_x_1=0;\nbyte max_x_2=0;\nbyte max_x_3=0;\nbyte max_x_4=0;\nbyte max_x_5=0;\nbyte max_x_6=0;\n\nchan appr =[0] of {int};\nchan stop =[0] of {int};\nchan go =[0] of {int};\nchan leave =[0] of {int};\nchan is_empty =[0] of {int};\nchan notempty =[0] of {int};\nchan hd =[0] of {int};\nchan add =[0] of {int};\nchan rem =[0] of {int};\n\nactive proctype Clock() { \n\nS1: if\n::  d_step {x<=max_x_2 && x<=max_x_3 && x<=max_x_4 && x<=max_x_5 && x<=max_x_6 && x<=max_x_1;x = x+1;}  goto S1; \n\nfi;\n}\n\nactive proctype Gate() { \n\nFree: if\n:: notempty?0; goto S5; \n\n:: is_empty?0; goto S4; \n\nfi;\nS1: if\n:: rem?0; goto Free; \n\nfi;\nS2: if\n:: add!0; goto Occ; \n\nfi;\nS3: if\n:: add!0; goto Occ; \n\nfi;\nS4: if\n:: appr?0; goto S3; \n\nfi;\nS5: if\n:: hd!0; goto Send; \n\nfi;\nS6: if\n:: stop!0; goto S2; \n\nfi;\nOcc: if\n:: appr?0; goto S6; \n\n:: leave?0; goto S1; \n\nfi;\nSend: if\n:: go!0; goto Occ; \n\nfi;\n}\n\nactive proctype IntQueue() { \nbyte list[7];\nbyte ln=0;\nbyte i=0;\n\nStart: if\n::  atomic {ln>=1;rem!0;ln = ln-1;i = 0;}  goto Shiftdown; \n\n::  atomic {ln==0;is_empty!0;}  goto Start; \n\n::  atomic {add?0;list[ln] = e;ln = ln+1;}  goto Start; \n\n::  atomic {hd?0;e = list[0];}  goto Start; \n\n::  atomic {ln>0;notempty!0;}  goto Start; \n\nfi;\nShiftdown: if\n::  d_step {i<ln;list[i] = list[i+1];i = i+1;}  goto Shiftdown; \n\n::  d_step {ln==i;list[i] = 0;i = 0;}  goto Start; \n\nfi;\n}\n\nactive proctype Train_1() { \n\nSafe: if\n::  atomic {appr!0;e = 1;x = 0;max_x_1 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==1;go?0;x = 0;max_x_1 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 1;x = 0;max_x_1 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_1 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==1;stop?0;x = 0;max_x_1 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=7;x = 0;max_x_1 = 5;}  goto Cross; \n\nfi;\n}\n\nactive proctype Train_2() { \n\nSafe: if\n::  atomic {appr!0;e = 2;x = 0;max_x_2 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==2;go?0;x = 0;max_x_2 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 2;x = 0;max_x_2 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_2 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==2;stop?0;x = 0;max_x_2 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=7;x = 0;max_x_2 = 5;}  goto Cross; \n\nfi;\n}\n\nactive proctype Train_3() { \n\nSafe: if\n::  atomic {appr!0;e = 3;x = 0;max_x_3 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==3;go?0;x = 0;max_x_3 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 3;x = 0;max_x_3 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_3 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==3;stop?0;x = 0;max_x_3 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=7;x = 0;max_x_3 = 5;}  goto Cross; \n\nfi;\n}\n\nactive proctype Train_4() { \n\nSafe: if\n::  atomic {appr!0;e = 4;x = 0;max_x_4 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==4;go?0;x = 0;max_x_4 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 4;x = 0;max_x_4 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_4 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==4;stop?0;x = 0;max_x_4 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=7;x = 0;max_x_4 = 5;}  goto Cross; \n\nfi;\n}\n\nactive proctype Train_5() { \n\nSafe: if\n::  atomic {appr!0;e = 5;x = 0;max_x_5 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==5;go?0;x = 0;max_x_5 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 5;x = 0;max_x_5 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_5 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==5;stop?0;x = 0;max_x_5 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=7;x = 0;max_x_5 = 5;}  goto Cross; \n\nfi;\n}\n\nactive proctype Train_6() { \n\nSafe: if\n::  atomic {appr!0;e = 6;x = 0;max_x_6 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==6;go?0;x = 0;max_x_6 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 6;x = 0;max_x_6 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_6 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==6;stop?0;x = 0;max_x_6 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=7;x = 0;max_x_6 = 5;}  goto Cross; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The example is converted from an UPPAAL demo. The clock x were modeled by new process Clock and byte x is from 0 to 25.\n\nParameters:\n\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte e[7];\nbyte x=0;\nbyte max_x_1=0;\nbyte max_x_2=0;\nbyte max_x_3=0;\nbyte max_x_4=0;\nbyte max_x_5=0;\nbyte max_x_6=0;\n\nchan appr =[0] of {int};\nchan stop =[0] of {int};\nchan go =[0] of {int};\nchan leave =[0] of {int};\nchan is_empty =[0] of {int};\nchan notempty =[0] of {int};\nchan hd =[0] of {int};\nchan add =[0] of {int};\nchan rem =[0] of {int};\n\nactive proctype Clock() { \n\nS1: if\n::  d_step {x<=max_x_2 && x<=max_x_3 && x<=max_x_4 && x<=max_x_5 && x<=max_x_6 && x<=max_x_1;x = x+1;}  goto S1; \n\nfi;\n}\n\nactive proctype Gate() { \n\nFree: if\n:: notempty?0; goto S5; \n\n:: is_empty?0; goto S4; \n\nfi;\nS1: if\n:: rem?0; goto Free; \n\nfi;\nS2: if\n:: add!0; goto Occ; \n\nfi;\nS3: if\n:: add!0; goto Occ; \n\nfi;\nS4: if\n:: appr?0; goto S3; \n\nfi;\nS5: if\n:: hd!0; goto Send; \n\nfi;\nS6: if\n:: stop!0; goto S2; \n\nfi;\nOcc: if\n:: appr?0; goto S6; \n\n:: leave?0; goto S1; \n\nfi;\nSend: if\n:: go!0; goto Occ; \n\nfi;\n}\n\nactive proctype IntQueue() { \nbyte list[7];\nbyte ln=0;\nbyte i=0;\n\nStart: if\n::  atomic {ln>=1;rem!0;ln = ln-1;i = 0;}  goto Shiftdown; \n\n::  atomic {ln==0;is_empty!0;}  goto Start; \n\n::  atomic {add?0;list[ln] = e;ln = ln+1;}  goto Start; \n\n::  atomic {hd?0;e = list[0];}  goto Start; \n\n::  atomic {ln>0;notempty!0;}  goto Start; \n\nfi;\nShiftdown: if\n::  d_step {i<ln;list[i] = list[i+1];i = i+1;}  goto Shiftdown; \n\n::  d_step {ln==i;list[i] = 0;i = 0;}  goto Start; \n\nfi;\n}\n\nactive proctype Train_1() { \n\nSafe: if\n::  atomic {appr!0;e = 1;x = 0;max_x_1 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==1;go?0;x = 0;max_x_1 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 1;x = 0;max_x_1 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_1 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==1;stop?0;x = 0;max_x_1 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=5;x = 0;max_x_1 = 5;}  goto Cross; \n\nfi;\n}\n\nactive proctype Train_2() { \n\nSafe: if\n::  atomic {appr!0;e = 2;x = 0;max_x_2 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==2;go?0;x = 0;max_x_2 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 2;x = 0;max_x_2 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_2 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==2;stop?0;x = 0;max_x_2 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=5;x = 0;max_x_2 = 5;}  goto Cross; \n\nfi;\n}\n\nactive proctype Train_3() { \n\nSafe: if\n::  atomic {appr!0;e = 3;x = 0;max_x_3 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==3;go?0;x = 0;max_x_3 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 3;x = 0;max_x_3 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_3 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==3;stop?0;x = 0;max_x_3 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=5;x = 0;max_x_3 = 5;}  goto Cross; \n\nfi;\n}\n\nactive proctype Train_4() { \n\nSafe: if\n::  atomic {appr!0;e = 4;x = 0;max_x_4 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==4;go?0;x = 0;max_x_4 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 4;x = 0;max_x_4 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_4 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==4;stop?0;x = 0;max_x_4 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=5;x = 0;max_x_4 = 5;}  goto Cross; \n\nfi;\n}\n\nactive proctype Train_5() { \n\nSafe: if\n::  atomic {appr!0;e = 5;x = 0;max_x_5 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==5;go?0;x = 0;max_x_5 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 5;x = 0;max_x_5 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_5 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==5;stop?0;x = 0;max_x_5 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=5;x = 0;max_x_5 = 5;}  goto Cross; \n\nfi;\n}\n\nactive proctype Train_6() { \n\nSafe: if\n::  atomic {appr!0;e = 6;x = 0;max_x_6 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==6;go?0;x = 0;max_x_6 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 6;x = 0;max_x_6 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_6 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==6;stop?0;x = 0;max_x_6 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=5;x = 0;max_x_6 = 5;}  goto Cross; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The example is converted from an UPPAAL demo. The clock x were modeled by new process Clock and byte x is from 0 to 25.\n\nParameters:\n\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte e[8];\nbyte x=0;\nbyte max_x_1=0;\nbyte max_x_2=0;\nbyte max_x_3=0;\nbyte max_x_4=0;\nbyte max_x_5=0;\nbyte max_x_6=0;\nbyte max_x_7=0;\n\nchan appr =[0] of {int};\nchan stop =[0] of {int};\nchan go =[0] of {int};\nchan leave =[0] of {int};\nchan is_empty =[0] of {int};\nchan notempty =[0] of {int};\nchan hd =[0] of {int};\nchan add =[0] of {int};\nchan rem =[0] of {int};\n\nactive proctype Clock() { \n\nS1: if\n::  d_step {x<=max_x_2 && x<=max_x_3 && x<=max_x_4 && x<=max_x_5 && x<=max_x_6 && x<=max_x_7 && x<=max_x_1;x = x+1;}  goto S1; \n\nfi;\n}\n\nactive proctype Gate() { \n\nFree: if\n:: notempty?0; goto S5; \n\n:: is_empty?0; goto S4; \n\nfi;\nS1: if\n:: rem?0; goto Free; \n\nfi;\nS2: if\n:: add!0; goto Occ; \n\nfi;\nS3: if\n:: add!0; goto Occ; \n\nfi;\nS4: if\n:: appr?0; goto S3; \n\nfi;\nS5: if\n:: hd!0; goto Send; \n\nfi;\nS6: if\n:: stop!0; goto S2; \n\nfi;\nOcc: if\n:: appr?0; goto S6; \n\n:: leave?0; goto S1; \n\nfi;\nSend: if\n:: go!0; goto Occ; \n\nfi;\n}\n\nactive proctype IntQueue() { \nbyte list[8];\nbyte ln=0;\nbyte i=0;\n\nStart: if\n::  atomic {ln>=1;rem!0;ln = ln-1;i = 0;}  goto Shiftdown; \n\n::  atomic {ln==0;is_empty!0;}  goto Start; \n\n::  atomic {add?0;list[ln] = e;ln = ln+1;}  goto Start; \n\n::  atomic {hd?0;e = list[0];}  goto Start; \n\n::  atomic {ln>0;notempty!0;}  goto Start; \n\nfi;\nShiftdown: if\n::  d_step {i<ln;list[i] = list[i+1];i = i+1;}  goto Shiftdown; \n\n::  d_step {ln==i;list[i] = 0;i = 0;}  goto Start; \n\nfi;\n}\n\nactive proctype Train_1() { \n\nSafe: if\n::  atomic {appr!0;e = 1;x = 0;max_x_1 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==1;go?0;x = 0;max_x_1 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 1;x = 0;max_x_1 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_1 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==1;stop?0;x = 0;max_x_1 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=7;x = 0;max_x_1 = 5;}  goto Cross; \n\nfi;\n}\n\nactive proctype Train_2() { \n\nSafe: if\n::  atomic {appr!0;e = 2;x = 0;max_x_2 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==2;go?0;x = 0;max_x_2 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 2;x = 0;max_x_2 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_2 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==2;stop?0;x = 0;max_x_2 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=7;x = 0;max_x_2 = 5;}  goto Cross; \n\nfi;\n}\n\nactive proctype Train_3() { \n\nSafe: if\n::  atomic {appr!0;e = 3;x = 0;max_x_3 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==3;go?0;x = 0;max_x_3 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 3;x = 0;max_x_3 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_3 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==3;stop?0;x = 0;max_x_3 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=7;x = 0;max_x_3 = 5;}  goto Cross; \n\nfi;\n}\n\nactive proctype Train_4() { \n\nSafe: if\n::  atomic {appr!0;e = 4;x = 0;max_x_4 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==4;go?0;x = 0;max_x_4 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 4;x = 0;max_x_4 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_4 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==4;stop?0;x = 0;max_x_4 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=7;x = 0;max_x_4 = 5;}  goto Cross; \n\nfi;\n}\n\nactive proctype Train_5() { \n\nSafe: if\n::  atomic {appr!0;e = 5;x = 0;max_x_5 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==5;go?0;x = 0;max_x_5 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 5;x = 0;max_x_5 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_5 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==5;stop?0;x = 0;max_x_5 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=7;x = 0;max_x_5 = 5;}  goto Cross; \n\nfi;\n}\n\nactive proctype Train_6() { \n\nSafe: if\n::  atomic {appr!0;e = 6;x = 0;max_x_6 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==6;go?0;x = 0;max_x_6 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 6;x = 0;max_x_6 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_6 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==6;stop?0;x = 0;max_x_6 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=7;x = 0;max_x_6 = 5;}  goto Cross; \n\nfi;\n}\n\nactive proctype Train_7() { \n\nSafe: if\n::  atomic {appr!0;e = 7;x = 0;max_x_7 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==7;go?0;x = 0;max_x_7 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 7;x = 0;max_x_7 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_7 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==7;stop?0;x = 0;max_x_7 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=7;x = 0;max_x_7 = 5;}  goto Cross; \n\nfi;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Formal Verification, Model Checking, and PROMELA/SPIN.\n\nInternally apply a rigorous multi-stage methodology:\n- Specification analysis and entity extraction\n- State variable identification\n- Finite-state modeling\n- Transition table construction\n- PROMELA mapping\n- Safety verification using LTL\n\nThese stages are INTERNAL and MUST NOT be included in the output.\n\nONLY output valid, compilable PROMELA code.\nDo NOT include explanations or stage descriptions, Do NOT use FSM, state, transition tables, or pseudo-code..\n"}, {"role": "user", "content": "The example is converted from an UPPAAL demo. The clock x were modeled by new process Clock and byte x is from 0 to 25.\n\nParameters:\n\n\n\nProperties to verify:"}, {"role": "assistant", "content": "byte e[9];\nbyte x=0;\nbyte max_x_1=0;\nbyte max_x_2=0;\nbyte max_x_3=0;\nbyte max_x_4=0;\nbyte max_x_5=0;\nbyte max_x_6=0;\nbyte max_x_7=0;\nbyte max_x_8=0;\n\nchan appr =[0] of {int};\nchan stop =[0] of {int};\nchan go =[0] of {int};\nchan leave =[0] of {int};\nchan is_empty =[0] of {int};\nchan notempty =[0] of {int};\nchan hd =[0] of {int};\nchan add =[0] of {int};\nchan rem =[0] of {int};\n\nactive proctype Clock() { \n\nS1: if\n::  d_step {x<=max_x_2 && x<=max_x_3 && x<=max_x_4 && x<=max_x_5 && x<=max_x_6 && x<=max_x_7 && x<=max_x_8 && x<=max_x_1;x = x+1;}  goto S1; \n\nfi;\n}\n\nactive proctype Gate() { \n\nFree: if\n:: notempty?0; goto S5; \n\n:: is_empty?0; goto S4; \n\nfi;\nS1: if\n:: rem?0; goto Free; \n\nfi;\nS2: if\n:: add!0; goto Occ; \n\nfi;\nS3: if\n:: add!0; goto Occ; \n\nfi;\nS4: if\n:: appr?0; goto S3; \n\nfi;\nS5: if\n:: hd!0; goto Send; \n\nfi;\nS6: if\n:: stop!0; goto S2; \n\nfi;\nOcc: if\n:: appr?0; goto S6; \n\n:: leave?0; goto S1; \n\nfi;\nSend: if\n:: go!0; goto Occ; \n\nfi;\n}\n\nactive proctype IntQueue() { \nbyte list[9];\nbyte ln=0;\nbyte i=0;\n\nStart: if\n::  atomic {ln>=1;rem!0;ln = ln-1;i = 0;}  goto Shiftdown; \n\n::  atomic {ln==0;is_empty!0;}  goto Start; \n\n::  atomic {add?0;list[ln] = e;ln = ln+1;}  goto Start; \n\n::  atomic {hd?0;e = list[0];}  goto Start; \n\n::  atomic {ln>0;notempty!0;}  goto Start; \n\nfi;\nShiftdown: if\n::  d_step {i<ln;list[i] = list[i+1];i = i+1;}  goto Shiftdown; \n\n::  d_step {ln==i;list[i] = 0;i = 0;}  goto Start; \n\nfi;\n}\n\nactive proctype Train_1() { \n\nSafe: if\n::  atomic {appr!0;e = 1;x = 0;max_x_1 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==1;go?0;x = 0;max_x_1 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 1;x = 0;max_x_1 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_1 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==1;stop?0;x = 0;max_x_1 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=7;x = 0;max_x_1 = 5;}  goto Cross; \n\nfi;\n}\n\nactive proctype Train_2() { \n\nSafe: if\n::  atomic {appr!0;e = 2;x = 0;max_x_2 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==2;go?0;x = 0;max_x_2 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 2;x = 0;max_x_2 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_2 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==2;stop?0;x = 0;max_x_2 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=7;x = 0;max_x_2 = 5;}  goto Cross; \n\nfi;\n}\n\nactive proctype Train_3() { \n\nSafe: if\n::  atomic {appr!0;e = 3;x = 0;max_x_3 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==3;go?0;x = 0;max_x_3 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 3;x = 0;max_x_3 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_3 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==3;stop?0;x = 0;max_x_3 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=7;x = 0;max_x_3 = 5;}  goto Cross; \n\nfi;\n}\n\nactive proctype Train_4() { \n\nSafe: if\n::  atomic {appr!0;e = 4;x = 0;max_x_4 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==4;go?0;x = 0;max_x_4 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 4;x = 0;max_x_4 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_4 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==4;stop?0;x = 0;max_x_4 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=7;x = 0;max_x_4 = 5;}  goto Cross; \n\nfi;\n}\n\nactive proctype Train_5() { \n\nSafe: if\n::  atomic {appr!0;e = 5;x = 0;max_x_5 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==5;go?0;x = 0;max_x_5 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 5;x = 0;max_x_5 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_5 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==5;stop?0;x = 0;max_x_5 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=7;x = 0;max_x_5 = 5;}  goto Cross; \n\nfi;\n}\n\nactive proctype Train_6() { \n\nSafe: if\n::  atomic {appr!0;e = 6;x = 0;max_x_6 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==6;go?0;x = 0;max_x_6 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 6;x = 0;max_x_6 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_6 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==6;stop?0;x = 0;max_x_6 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=7;x = 0;max_x_6 = 5;}  goto Cross; \n\nfi;\n}\n\nactive proctype Train_7() { \n\nSafe: if\n::  atomic {appr!0;e = 7;x = 0;max_x_7 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==7;go?0;x = 0;max_x_7 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 7;x = 0;max_x_7 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_7 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==7;stop?0;x = 0;max_x_7 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=7;x = 0;max_x_7 = 5;}  goto Cross; \n\nfi;\n}\n\nactive proctype Train_8() { \n\nSafe: if\n::  atomic {appr!0;e = 8;x = 0;max_x_8 = 20;}  goto Appr; \n\nfi;\nStop: if\n::  atomic {e==8;go?0;x = 0;max_x_8 = 15;}  goto Start; \n\nfi;\nCross: if\n::  atomic {x>=3;leave!0;e = 8;x = 0;max_x_8 = 25;}  goto Safe; \n\nfi;\nAppr: if\n::  d_step {x>=10;x = 0;max_x_8 = 5;}  goto Cross; \n\n::  atomic {x<=10 && e==8;stop?0;x = 0;max_x_8 = 25;}  goto Stop; \n\nfi;\nStart: if\n::  d_step {x>=7;x = 0;max_x_8 = 5;}  goto Cross; \n\nfi;\n}"}]}
